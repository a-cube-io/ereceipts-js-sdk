{"version":3,"sources":["../node_modules/tsup/assets/esm_shims.js","../src/cli/types.ts","../src/cli/config/constants.ts","../src/cli/config/index.ts","../node_modules/eventemitter3/index.js","../node_modules/eventemitter3/index.mjs","../src/errors/index.ts","../src/http/circuit-breaker.ts","../src/http/retry.ts","../src/http/middleware.ts","../src/http/client.ts","../src/storage/adapters/optimized-react-native-storage.ts","../src/react-native/connectivity-manager.ts","../src/react-native/background-processor.ts","../src/react-native/performance-monitor.ts","../src/generated/endpoints.ts","../src/storage/queue/types.ts","../src/resources/base-openapi.ts","../src/resources/cashiers.ts","../src/resources/receipts.ts","../src/resources/point-of-sales.ts","../src/storage/unified-storage.ts","../src/storage/platform-detector.ts","../src/storage/adapters/indexeddb-adapter.ts","../src/storage/adapters/localstorage-adapter.ts","../src/security/encryption.ts","../src/storage/encryption-service.ts","../src/storage/storage-factory.ts","../src/security/mtls-certificate-manager.ts","../src/resources/cash-registers.ts","../src/resources/merchants.ts","../src/resources/pems.ts","../src/pwa/push-notifications.ts","../src/pwa/app-installer.ts","../src/pwa/pwa-manager.ts","../src/pwa/manifest-generator.ts","../src/sync/sync-engine.ts","../src/storage/queue/priority-queue.ts","../src/storage/queue/batch-processor.ts","../src/storage/queue/retry-manager.ts","../src/storage/queue/queue-analytics.ts","../src/storage/queue/queue-manager.ts","../src/auth/types.ts","../src/auth/auth-events.ts","../src/auth/token-manager.ts","../src/compliance/access-control.ts","../src/auth/auth-storage.ts","../src/auth/auth-performance.ts","../src/auth/auth-service.ts","../src/auth/auth-middleware.ts","../src/core/sdk.ts","../src/types/branded.ts","../src/types/events.ts","../src/storage/base/storage-adapter.ts","../src/storage/adapters/web-storage.ts","../src/storage/adapters/react-native-storage.ts","../src/storage/queue/conflict-resolver.ts","../node_modules/react/cjs/react.production.js","../node_modules/react/cjs/react.development.js","../node_modules/react/index.js","../src/storage/queue/enhanced-offline-hook.ts","../src/storage/queue/index.ts","../node_modules/react/cjs/react-jsx-runtime.production.js","../node_modules/react/cjs/react-jsx-runtime.development.js","../node_modules/react/jsx-runtime.js","../src/hooks/react/ACubeProvider.tsx","../src/hooks/react/useACubeQuery.ts","../src/hooks/react/useACubeMutation.ts","../src/hooks/react/useACubeSubscription.ts","../src/hooks/react/useACubeCache.ts","../src/hooks/react/useACubeOffline.ts","../src/hooks/react/auth-provider.tsx","../src/hooks/react/use-auth.ts","../src/hooks/react/auth-components.tsx","../src/hooks/react/index.ts","../src/compliance/gdpr-compliance.ts","../src/compliance/fiscal-audit.ts","../src/compliance/index.ts","../src/plugins/core/plugin-manager.ts","../src/plugins/core/base-plugin.ts","../src/plugins/core/index.ts","../src/plugins/builtin/analytics-plugin.ts","../src/plugins/builtin/audit-plugin.ts","../src/plugins/builtin/cache-plugin.ts","../src/plugins/builtin/debug-plugin.ts","../src/plugins/builtin/performance-plugin.ts","../src/plugins/builtin/index.ts","../src/plugins/index.ts","../src/quality/pre-commit.ts","../src/quality/ci-cd.ts","../src/quality/dependency-management.ts","../src/quality/index.ts","../src/pwa/background-sync.ts","../src/pwa/offline-integration.ts","../src/pwa/index.ts","../src/index.ts","../src/cli/utils/sdk.ts","../src/cli.ts","../src/cli/index.ts","../src/cli/commands/index.ts","../src/cli/commands/auth/index.ts","../src/cli/commands/auth/login.ts","../src/cli/commands/base/command.ts","../src/cli/utils/errors.ts","../src/cli/utils/process.ts","../src/cli/commands/auth/logout.ts","../src/cli/commands/auth/status.ts","../src/cli/commands/auth/refresh.ts","../src/cli/commands/config/index.ts","../src/cli/commands/config/setup.ts","../src/cli/commands/config/show.ts","../src/cli/commands/resources/index.ts","../src/cli/commands/resources/receipts.ts","../src/cli/commands/base/resource.ts","../src/cli/commands/resources/cashiers.ts","../src/cli/commands/resources/merchants.ts","../src/cli/commands/resources/point-of-sales.ts","../src/cli/commands/profile.ts","../src/cli/commands/interactive.ts","../src/cli/commands/version.ts"],"sourcesContent":["// Shim globals in esm bundle\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\n\nconst getFilename = () => fileURLToPath(import.meta.url)\nconst getDirname = () => path.dirname(getFilename())\n\nexport const __dirname = /* @__PURE__ */ getDirname()\nexport const __filename = /* @__PURE__ */ getFilename()\n","/**\n * CLI Types and Interfaces\n * Centralized type definitions for the CLI application\n */\n\nimport type { AuthUser } from '../auth/types.js';\n\n// Error tracing configuration\nexport interface TraceConfig {\n  enabled: boolean;\n  level: 'basic' | 'detailed' | 'verbose' | 'debug';\n  includeStack: boolean;\n  includeContext: boolean;\n  includeTimestamp: boolean;\n  outputFormat: 'json' | 'pretty' | 'compact';\n}\n\n// Configuration and state management\nexport interface CLIConfig {\n  environment: 'sandbox' | 'production' | 'development';\n  baseUrls?: {\n    api?: string;\n    auth?: string;\n  };\n  currentProfile?: string;\n  trace?: TraceConfig;\n}\n\nexport interface CLIAuthState {\n  accessToken?: string;\n  refreshToken?: string;\n  user?: AuthUser;\n  expiresAt?: number;\n}\n\n// Command execution context\nexport interface CommandContext {\n  config: CLIConfig;\n  auth?: CLIAuthState;\n  profile?: string;\n}\n\n// Command options\nexport interface BaseCommandOptions {\n  profile?: string;\n  trace?: boolean;\n  verbose?: boolean;\n}\n\nexport interface ResourceListOptions extends BaseCommandOptions {\n  limit?: number;\n  offset?: number;\n  format?: 'table' | 'json';\n}\n\nexport interface AuthCommandOptions extends BaseCommandOptions {\n  remember?: boolean;\n  force?: boolean;\n}\n\n// Process management\nexport type ProcessStatus = 'success' | 'error' | 'cancelled';\n\nexport interface ProcessResult {\n  status: ProcessStatus;\n  message?: string;\n  data?: any;\n  error?: Error;\n}\n\n// Custom error classes for better CLI error handling\nexport class AuthenticationRequiredError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'AuthenticationRequiredError';\n  }\n}","/**\n * CLI Configuration Constants\n */\n\nimport path from 'path';\nimport os from 'os';\nimport type { TraceConfig } from '../types.js';\n\n// File paths for CLI configuration\nexport const CONFIG_DIR = path.join(os.homedir(), '.acube');\nexport const CONFIG_FILE = path.join(CONFIG_DIR, 'config.json');\nexport const AUTH_FILE = path.join(CONFIG_DIR, 'auth.json');\nexport const PROFILES_DIR = path.join(CONFIG_DIR, 'profiles');\n\n// Default trace configuration\nexport const DEFAULT_TRACE_CONFIG: TraceConfig = {\n  enabled: false,\n  level: 'basic',\n  includeStack: false,\n  includeContext: true,\n  includeTimestamp: true,\n  outputFormat: 'pretty',\n};","/**\n * Configuration Management\n * Handles CLI configuration, authentication state, and profiles\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport type { CLIConfig, CLIAuthState } from '../types.js';\nimport { CONFIG_DIR, CONFIG_FILE, AUTH_FILE, PROFILES_DIR, DEFAULT_TRACE_CONFIG } from './constants.js';\n\n// Utility functions\nexport async function ensureConfigDir(): Promise<void> {\n  try {\n    await fs.mkdir(CONFIG_DIR, { recursive: true });\n    await fs.mkdir(PROFILES_DIR, { recursive: true });\n  } catch (error) {\n    // Directory might already exist, ignore error\n  }\n}\n\nexport async function loadConfig(): Promise<CLIConfig> {\n  try {\n    const data = await fs.readFile(CONFIG_FILE, 'utf-8');\n    const config = JSON.parse(data);\n    \n    // Ensure trace config has all required properties\n    if (config.trace) {\n      config.trace = { ...DEFAULT_TRACE_CONFIG, ...config.trace };\n    }\n    \n    return config;\n  } catch (error) {\n    // Return default config if file doesn't exist\n    return {\n      environment: 'sandbox',\n      trace: DEFAULT_TRACE_CONFIG,\n    };\n  }\n}\n\nexport async function saveConfig(config: CLIConfig): Promise<void> {\n  await ensureConfigDir();\n  await fs.writeFile(CONFIG_FILE, JSON.stringify(config, null, 2));\n}\n\nexport async function loadAuth(profile?: string): Promise<CLIAuthState | null> {\n  try {\n    const authFile = profile ? path.join(PROFILES_DIR, `${profile}.json`) : AUTH_FILE;\n    const data = await fs.readFile(authFile, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    return null;\n  }\n}\n\nexport async function saveAuth(auth: CLIAuthState, profile?: string): Promise<void> {\n  await ensureConfigDir();\n  const authFile = profile ? path.join(PROFILES_DIR, `${profile}.json`) : AUTH_FILE;\n  await fs.writeFile(authFile, JSON.stringify(auth, null, 2));\n}\n\nexport async function clearAuth(profile?: string): Promise<void> {\n  try {\n    const authFile = profile ? path.join(PROFILES_DIR, `${profile}.json`) : AUTH_FILE;\n    await fs.unlink(authFile);\n  } catch (error) {\n    // File might not exist, ignore error\n  }\n}\n\nexport async function listProfiles(): Promise<string[]> {\n  try {\n    const files = await fs.readdir(PROFILES_DIR);\n    return files\n      .filter(file => file.endsWith('.json'))\n      .map(file => path.basename(file, '.json'));\n  } catch (error) {\n    return [];\n  }\n}\n\nexport async function deleteProfile(name: string): Promise<void> {\n  const profileFile = path.join(PROFILES_DIR, `${name}.json`);\n  await fs.unlink(profileFile);\n}","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n","/**\n * Enterprise-grade error handling system\n * Hierarchical error types with retry logic and audit information\n */\n\n// Base error class with audit information\nexport abstract class ACubeSDKError extends Error {\n  public readonly timestamp: Date;\n  public readonly requestId: string;\n  public readonly operation: string;\n  public readonly retryable: boolean;\n  public readonly statusCode?: number;\n  public readonly auditInfo?: AuditInfo;\n  public override readonly cause?: Error;\n\n  constructor(\n    message: string,\n    public readonly code: string,\n    options: {\n      operation: string;\n      retryable?: boolean;\n      statusCode?: number;\n      requestId?: string;\n      auditInfo?: AuditInfo;\n      cause?: Error;\n    }\n  ) {\n    super(message);\n    if (options.cause) {\n      this.cause = options.cause;\n    }\n    this.name = this.constructor.name;\n    this.timestamp = new Date();\n    this.requestId = options.requestId ?? generateRequestId();\n    this.operation = options.operation;\n    this.retryable = options.retryable ?? false;\n    if (options.statusCode !== undefined) {\n      this.statusCode = options.statusCode;\n    }\n    if (options.auditInfo !== undefined) {\n      this.auditInfo = options.auditInfo;\n    }\n\n    // Ensure proper prototype chain\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n\n  toJSON(): Record<string, unknown> {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      operation: this.operation,\n      retryable: this.retryable,\n      statusCode: this.statusCode,\n      timestamp: this.timestamp.toISOString(),\n      requestId: this.requestId,\n      auditInfo: this.auditInfo,\n      stack: this.stack,\n    };\n  }\n}\n\n// Audit information for compliance\nexport interface AuditInfo {\n  userId?: string;\n  role?: 'provider' | 'merchant' | 'cashier';\n  fiscalId?: string;\n  receiptId?: string;\n  pemId?: string;\n  ipAddress?: string;\n  userAgent?: string;\n}\n\n// Network-related errors (usually retryable)\nexport class NetworkError extends ACubeSDKError {\n  constructor(\n    message: string,\n    operation: string,\n    options: {\n      statusCode?: number;\n      requestId?: string;\n      retryable?: boolean;\n      cause?: Error;\n    } = {}\n  ) {\n    super(message, 'NETWORK_ERROR', {\n      operation,\n      retryable: options.retryable ?? true,\n      ...(options.statusCode !== undefined && { statusCode: options.statusCode }),\n      ...(options.requestId !== undefined && { requestId: options.requestId }),\n      ...(options.cause !== undefined && { cause: options.cause }),\n    });\n  }\n}\n\n// Authentication/Authorization errors (not retryable)\nexport class AuthenticationError extends ACubeSDKError {\n  constructor(\n    message: string,\n    operation: string,\n    options: {\n      statusCode?: number;\n      requestId?: string;\n      auditInfo?: AuditInfo;\n    } = {}\n  ) {\n    super(message, 'AUTHENTICATION_ERROR', {\n      operation,\n      retryable: false,\n      statusCode: options.statusCode ?? 401,\n      ...(options.requestId !== undefined && { requestId: options.requestId }),\n      ...(options.auditInfo !== undefined && { auditInfo: options.auditInfo }),\n    });\n  }\n}\n\n// Authorization errors (not retryable)\nexport class AuthorizationError extends ACubeSDKError {\n  constructor(\n    message: string,\n    operation: string,\n    options: {\n      statusCode?: number;\n      requestId?: string;\n      auditInfo?: AuditInfo;\n    } = {}\n  ) {\n    super(message, 'AUTHORIZATION_ERROR', {\n      operation,\n      retryable: false,\n      statusCode: options.statusCode ?? 403,\n      ...(options.requestId !== undefined && { requestId: options.requestId }),\n      ...(options.auditInfo !== undefined && { auditInfo: options.auditInfo }),\n    });\n  }\n}\n\n// Validation errors (not retryable)\nexport class ValidationError extends ACubeSDKError {\n  public readonly violations: ValidationViolation[];\n\n  constructor(\n    message: string,\n    operation: string,\n    violations: ValidationViolation[],\n    options: {\n      requestId?: string;\n      auditInfo?: AuditInfo;\n    } = {}\n  ) {\n    super(message, 'VALIDATION_ERROR', {\n      operation,\n      retryable: false,\n      statusCode: 422,\n      ...(options.requestId !== undefined && { requestId: options.requestId }),\n      ...(options.auditInfo !== undefined && { auditInfo: options.auditInfo }),\n    });\n    this.violations = violations;\n  }\n\n  override toJSON(): Record<string, unknown> {\n    return {\n      ...super.toJSON(),\n      violations: this.violations,\n    };\n  }\n}\n\nexport interface ValidationViolation {\n  field: string;\n  message: string;\n  code: string;\n  value?: unknown;\n}\n\n// Fiscal/compliance specific errors (usually not retryable)\nexport class FiscalError extends ACubeSDKError {\n  public readonly fiscalCode?: string;\n  public readonly documentNumber?: string;\n\n  constructor(\n    message: string,\n    operation: string,\n    options: {\n      fiscalCode?: string;\n      documentNumber?: string;\n      statusCode?: number;\n      requestId?: string;\n      retryable?: boolean;\n      auditInfo?: AuditInfo;\n    } = {}\n  ) {\n    super(message, 'FISCAL_ERROR', {\n      operation,\n      retryable: options.retryable ?? false,\n      statusCode: options.statusCode ?? 400,\n      ...(options.requestId !== undefined && { requestId: options.requestId }),\n      ...(options.auditInfo !== undefined && { auditInfo: options.auditInfo }),\n    });\n    if (options.fiscalCode !== undefined) {\n      this.fiscalCode = options.fiscalCode;\n    }\n    if (options.documentNumber !== undefined) {\n      this.documentNumber = options.documentNumber;\n    }\n  }\n\n  override toJSON(): Record<string, unknown> {\n    return {\n      ...super.toJSON(),\n      fiscalCode: this.fiscalCode,\n      documentNumber: this.documentNumber,\n    };\n  }\n}\n\n// Rate limiting errors (retryable)\nexport class RateLimitError extends ACubeSDKError {\n  public readonly retryAfter?: number;\n\n  constructor(\n    message: string,\n    operation: string,\n    options: {\n      retryAfter?: number;\n      requestId?: string;\n    } = {}\n  ) {\n    super(message, 'RATE_LIMIT_ERROR', {\n      operation,\n      retryable: true,\n      statusCode: 429,\n      ...(options.requestId !== undefined && { requestId: options.requestId }),\n    });\n    if (options.retryAfter !== undefined) {\n      this.retryAfter = options.retryAfter;\n    }\n  }\n\n  override toJSON(): Record<string, unknown> {\n    return {\n      ...super.toJSON(),\n      retryAfter: this.retryAfter,\n    };\n  }\n}\n\n// Configuration errors (not retryable)\nexport class ConfigurationError extends ACubeSDKError {\n  constructor(\n    message: string,\n    operation: string,\n    options: {\n      requestId?: string;\n    } = {}\n  ) {\n    super(message, 'CONFIGURATION_ERROR', {\n      operation,\n      retryable: false,\n      ...(options.requestId !== undefined && { requestId: options.requestId }),\n    });\n  }\n}\n\n// Resource not found errors (not retryable)\nexport class NotFoundError extends ACubeSDKError {\n  public readonly resourceType: string;\n  public readonly resourceId: string;\n\n  constructor(\n    resourceType: string,\n    resourceId: string,\n    operation: string,\n    options: {\n      requestId?: string;\n      auditInfo?: AuditInfo;\n    } = {}\n  ) {\n    super(\n      `${resourceType} with id ${resourceId} not found`,\n      'NOT_FOUND_ERROR',\n      {\n        operation,\n        retryable: false,\n        statusCode: 404,\n        ...(options.requestId !== undefined && { requestId: options.requestId }),\n        ...(options.auditInfo !== undefined && { auditInfo: options.auditInfo }),\n      }\n    );\n    this.resourceType = resourceType;\n    this.resourceId = resourceId;\n  }\n\n  override toJSON(): Record<string, unknown> {\n    return {\n      ...super.toJSON(),\n      resourceType: this.resourceType,\n      resourceId: this.resourceId,\n    };\n  }\n}\n\n// Circuit breaker errors (retryable)\nexport class CircuitBreakerError extends ACubeSDKError {\n  public readonly state: 'OPEN' | 'HALF_OPEN';\n\n  constructor(\n    message: string,\n    operation: string,\n    state: 'OPEN' | 'HALF_OPEN',\n    options: {\n      requestId?: string;\n    } = {}\n  ) {\n    super(message, 'CIRCUIT_BREAKER_ERROR', {\n      operation,\n      retryable: true,\n      ...(options.requestId !== undefined && { requestId: options.requestId }),\n    });\n    this.state = state;\n  }\n\n  override toJSON(): Record<string, unknown> {\n    return {\n      ...super.toJSON(),\n      state: this.state,\n    };\n  }\n}\n\n// Utility functions\nfunction generateRequestId(): string {\n  return `req_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;\n}\n\n// Error factory for creating errors from HTTP responses\nexport function createErrorFromResponse(\n  response: {\n    status: number;\n    statusText: string;\n    data?: unknown;\n  },\n  operation: string,\n  requestId?: string\n): ACubeSDKError {\n  const message = getErrorMessage(response.data) || response.statusText;\n\n  switch (response.status) {\n    case 401:\n      return new AuthenticationError(message, operation, {\n        statusCode: response.status,\n        ...(requestId !== undefined && { requestId }),\n      });\n    case 403:\n      return new AuthorizationError(message, operation, {\n        statusCode: response.status,\n        ...(requestId !== undefined && { requestId }),\n      });\n    case 404:\n      // Try to extract resource info from error data\n      const resourceType = extractResourceType(response.data);\n      const resourceId = extractResourceId(response.data);\n      if (resourceType && resourceId) {\n        return new NotFoundError(resourceType, resourceId, operation, {\n          ...(requestId !== undefined && { requestId }),\n        });\n      }\n      // Create a concrete NotFoundError for generic 404s\n      return new NotFoundError('Resource', 'unknown', operation, {\n        ...(requestId !== undefined && { requestId }),\n      });\n    case 422:\n      const violations = extractValidationViolations(response.data);\n      return new ValidationError(message, operation, violations, {\n        ...(requestId !== undefined && { requestId }),\n      });\n    case 429:\n      const retryAfter = extractRetryAfter(response.data);\n      return new RateLimitError(message, operation, {\n        ...(retryAfter !== undefined && { retryAfter }),\n        ...(requestId !== undefined && { requestId }),\n      });\n    case 500:\n    case 502:\n    case 503:\n    case 504:\n      return new NetworkError(message, operation, {\n        statusCode: response.status,\n        ...(requestId !== undefined && { requestId }),\n        retryable: true,\n      });\n    default:\n      return new NetworkError(message, operation, {\n        statusCode: response.status,\n        ...(requestId !== undefined && { requestId }),\n        retryable: response.status >= 500,\n      });\n  }\n}\n\n// Helper functions for extracting error details\nfunction getErrorMessage(data: unknown): string | null {\n  if (typeof data === 'object' && data !== null) {\n    const obj = data as Record<string, unknown>;\n    return (obj.message as string) || (obj.detail as string) || null;\n  }\n  return null;\n}\n\nfunction extractResourceType(data: unknown): string | null {\n  if (typeof data === 'object' && data !== null) {\n    const obj = data as Record<string, unknown>;\n    return obj.resourceType as string || null;\n  }\n  return null;\n}\n\nfunction extractResourceId(data: unknown): string | null {\n  if (typeof data === 'object' && data !== null) {\n    const obj = data as Record<string, unknown>;\n    return obj.resourceId as string || null;\n  }\n  return null;\n}\n\nfunction extractValidationViolations(data: unknown): ValidationViolation[] {\n  if (typeof data === 'object' && data !== null) {\n    const obj = data as Record<string, unknown>;\n    if (Array.isArray(obj.violations)) {\n      return obj.violations.map((v: any) => ({\n        field: v.propertyPath || v.field || 'unknown',\n        message: v.message || 'Validation failed',\n        code: v.code || 'VALIDATION_FAILED',\n        value: v.value,\n      }));\n    }\n    if (Array.isArray(obj.detail)) {\n      return obj.detail.map((v: any) => ({\n        field: v.loc?.join('.') || 'unknown',\n        message: v.msg || 'Validation failed',\n        code: v.type || 'VALIDATION_FAILED',\n        value: v.input,\n      }));\n    }\n  }\n  return [];\n}\n\nfunction extractRetryAfter(data: unknown): number | undefined {\n  if (typeof data === 'object' && data !== null) {\n    const obj = data as Record<string, unknown>;\n    const retryAfter = obj.retryAfter || obj.retry_after;\n    return typeof retryAfter === 'number' ? retryAfter : undefined;\n  }\n  return undefined;\n}","/**\n * Circuit Breaker Pattern Implementation\n * Prevents cascading failures by monitoring service health\n */\n\nimport { CircuitBreakerError } from '../errors';\n\nexport type CircuitBreakerState = 'CLOSED' | 'OPEN' | 'HALF_OPEN';\n\nexport const CircuitBreakerState = {\n  CLOSED: 'CLOSED' as const,\n  OPEN: 'OPEN' as const,\n  HALF_OPEN: 'HALF_OPEN' as const,\n} as const;\n\nexport interface CircuitBreakerConfig {\n  failureThreshold: number;\n  successThreshold: number;\n  timeout: number;\n  resetTimeout: number;\n  healthCheckInterval?: number;\n  name?: string;\n}\n\nexport interface CircuitBreakerMetrics {\n  totalRequests: number;\n  successfulRequests: number;\n  failedRequests: number;\n  consecutiveFailures: number;\n  consecutiveSuccesses: number;\n  lastFailureTime: number | null;\n  lastSuccessTime: number | null;\n  stateChanges: Array<{\n    from: CircuitBreakerState;\n    to: CircuitBreakerState;\n    timestamp: number;\n    reason: string;\n  }>;\n}\n\nexport const DEFAULT_CIRCUIT_BREAKER_CONFIG: CircuitBreakerConfig = {\n  failureThreshold: 5,\n  successThreshold: 2,\n  timeout: 30000,\n  resetTimeout: 60000,\n  name: 'default-circuit-breaker',\n};\n\nexport class CircuitBreaker {\n  private state: CircuitBreakerState = 'CLOSED';\n  private metrics: CircuitBreakerMetrics = {\n    totalRequests: 0,\n    successfulRequests: 0,\n    failedRequests: 0,\n    consecutiveFailures: 0,\n    consecutiveSuccesses: 0,\n    lastFailureTime: null,\n    lastSuccessTime: null,\n    stateChanges: [],\n  };\n  private nextAttemptTime = 0;\n  private healthCheckTimer: NodeJS.Timeout | null = null;\n\n  constructor(private config: CircuitBreakerConfig) {\n    if (config.healthCheckInterval) {\n      this.startHealthCheck();\n    }\n  }\n\n  async execute<T>(\n    operation: () => Promise<T>,\n    operationName = 'unknown'\n  ): Promise<T> {\n    if (this.shouldRejectRequest()) {\n      throw new CircuitBreakerError(\n        `Circuit breaker is ${this.state} for operation: ${operationName}`,\n        operationName,\n        this.state as 'OPEN' | 'HALF_OPEN'\n      );\n    }\n\n    this.metrics.totalRequests++;\n\n    try {\n      const result = await this.executeWithTimeout(operation);\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  private async executeWithTimeout<T>(\n    operation: () => Promise<T>\n  ): Promise<T> {\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      setTimeout(() => {\n        reject(new Error(`Operation timeout after ${this.config.timeout}ms`));\n      }, this.config.timeout);\n    });\n\n    return Promise.race([operation(), timeoutPromise]);\n  }\n\n  private shouldRejectRequest(): boolean {\n    switch (this.state) {\n      case 'CLOSED':\n        return false;\n      case 'OPEN':\n        return Date.now() < this.nextAttemptTime;\n      case 'HALF_OPEN':\n        return false;\n      default:\n        return false;\n    }\n  }\n\n  private onSuccess(): void {\n    this.metrics.successfulRequests++;\n    this.metrics.consecutiveSuccesses++;\n    this.metrics.consecutiveFailures = 0;\n    this.metrics.lastSuccessTime = Date.now();\n\n    switch (this.state) {\n      case 'HALF_OPEN':\n        if (this.metrics.consecutiveSuccesses >= this.config.successThreshold) {\n          this.transitionTo('CLOSED', 'Success threshold reached');\n        }\n        break;\n      case 'OPEN':\n        this.transitionTo('HALF_OPEN', 'First success after opening');\n        break;\n    }\n  }\n\n  private onFailure(): void {\n    this.metrics.failedRequests++;\n    this.metrics.consecutiveFailures++;\n    this.metrics.consecutiveSuccesses = 0;\n    this.metrics.lastFailureTime = Date.now();\n\n    switch (this.state) {\n      case 'CLOSED':\n        if (this.metrics.consecutiveFailures >= this.config.failureThreshold) {\n          this.transitionTo('OPEN', 'Failure threshold reached');\n        }\n        break;\n      case 'HALF_OPEN':\n        this.transitionTo('OPEN', 'Failed during half-open state');\n        break;\n    }\n  }\n\n  private transitionTo(newState: CircuitBreakerState, reason: string): void {\n    const oldState = this.state;\n    this.state = newState;\n\n    this.metrics.stateChanges.push({\n      from: oldState,\n      to: newState,\n      timestamp: Date.now(),\n      reason,\n    });\n\n    // Keep only last 100 state changes\n    if (this.metrics.stateChanges.length > 100) {\n      this.metrics.stateChanges.shift();\n    }\n\n    if (newState === 'OPEN') {\n      this.nextAttemptTime = Date.now() + this.config.resetTimeout;\n    }\n\n    console.log(`Circuit breaker ${this.config.name || 'unnamed'} transitioned from ${oldState} to ${newState}: ${reason}`);\n  }\n\n  private startHealthCheck(): void {\n    if (this.config.healthCheckInterval) {\n      this.healthCheckTimer = setInterval(() => {\n        this.performHealthCheck();\n      }, this.config.healthCheckInterval) as unknown as NodeJS.Timeout;\n    }\n  }\n\n  private performHealthCheck(): void {\n    if (this.state === 'OPEN' && Date.now() >= this.nextAttemptTime) {\n      this.transitionTo('HALF_OPEN', 'Health check triggered state change');\n    }\n  }\n\n  public getState(): CircuitBreakerState {\n    return this.state;\n  }\n\n  public getMetrics(): Readonly<CircuitBreakerMetrics> {\n    return { ...this.metrics };\n  }\n\n  public reset(): void {\n    this.state = 'CLOSED';\n    this.metrics = {\n      totalRequests: 0,\n      successfulRequests: 0,\n      failedRequests: 0,\n      consecutiveFailures: 0,\n      consecutiveSuccesses: 0,\n      lastFailureTime: null,\n      lastSuccessTime: null,\n      stateChanges: [],\n    };\n    this.nextAttemptTime = 0;\n  }\n\n  public destroy(): void {\n    if (this.healthCheckTimer) {\n      clearInterval(this.healthCheckTimer);\n      this.healthCheckTimer = null;\n    }\n  }\n\n  public getHealthStatus(): {\n    isHealthy: boolean;\n    failureRate: number;\n    avgResponseTime?: number;\n    uptime: number;\n  } {\n    const now = Date.now();\n    const uptime = this.metrics.lastSuccessTime \n      ? now - this.metrics.lastSuccessTime \n      : 0;\n    \n    const failureRate = this.metrics.totalRequests > 0 \n      ? this.metrics.failedRequests / this.metrics.totalRequests \n      : 0;\n\n    return {\n      isHealthy: this.state === 'CLOSED' && failureRate < 0.5,\n      failureRate,\n      uptime,\n    };\n  }\n}","/**\n * Advanced Retry Logic with Exponential Backoff and Jitter\n * Prevents thundering herd problem and provides intelligent retry policies\n */\n\nimport { ACubeSDKError } from '../errors';\n\nexport interface RetryConfig {\n  maxAttempts: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffMultiplier: number;\n  jitterType: 'none' | 'full' | 'equal' | 'decorrelated';\n  retryableStatusCodes: number[];\n  retryableErrors: string[];\n  timeout?: number;\n}\n\nexport interface RetryAttempt {\n  attempt: number;\n  delay: number;\n  error: Error;\n  timestamp: number;\n}\n\nexport interface RetryMetrics {\n  totalAttempts: number;\n  successfulRetries: number;\n  failedRetries: number;\n  averageDelay: number;\n  attempts: RetryAttempt[];\n}\n\nexport class RetryHandler {\n  private metrics: RetryMetrics = {\n    totalAttempts: 0,\n    successfulRetries: 0,\n    failedRetries: 0,\n    averageDelay: 0,\n    attempts: [],\n  };\n\n  constructor(private config: RetryConfig) {}\n\n  async execute<T>(\n    operation: () => Promise<T>,\n    operationName = 'unknown'\n  ): Promise<T> {\n    let lastError: Error | null = null;\n    let nextDelay = this.config.baseDelay;\n\n    for (let attempt = 1; attempt <= this.config.maxAttempts; attempt++) {\n      this.metrics.totalAttempts++;\n\n      try {\n        const result = await this.executeWithTimeout(operation);\n        \n        if (attempt > 1) {\n          this.metrics.successfulRetries++;\n        }\n        \n        return result;\n      } catch (error) {\n        lastError = error as Error;\n        \n        const retryAttempt: RetryAttempt = {\n          attempt,\n          delay: nextDelay,\n          error: lastError,\n          timestamp: Date.now(),\n        };\n        \n        this.metrics.attempts.push(retryAttempt);\n        \n        // Keep only last 100 attempts\n        if (this.metrics.attempts.length > 100) {\n          this.metrics.attempts.shift();\n        }\n\n        // Check if we should retry\n        if (attempt === this.config.maxAttempts || !this.shouldRetry(lastError)) {\n          this.metrics.failedRetries++;\n          break;\n        }\n\n        // Calculate delay with jitter\n        const delay = this.calculateDelay(attempt, nextDelay);\n        \n        console.log(\n          `Retrying ${operationName} (attempt ${attempt}/${this.config.maxAttempts}) after ${delay}ms delay. Error: ${lastError.message}`\n        );\n\n        await this.sleep(delay);\n        \n        // Update delay for next iteration\n        nextDelay = Math.min(\n          nextDelay * this.config.backoffMultiplier,\n          this.config.maxDelay\n        );\n      }\n    }\n\n    // All retries exhausted\n    throw lastError || new Error('Unknown error during retry execution');\n  }\n\n  private async executeWithTimeout<T>(\n    operation: () => Promise<T>\n  ): Promise<T> {\n    if (!this.config.timeout) {\n      return operation();\n    }\n\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      setTimeout(() => {\n        reject(new Error(`Operation timeout after ${this.config.timeout}ms`));\n      }, this.config.timeout);\n    });\n\n    return Promise.race([operation(), timeoutPromise]);\n  }\n\n  private shouldRetry(error: Error): boolean {\n    // Check if error is explicitly marked as retryable\n    if (error instanceof ACubeSDKError) {\n      return error.retryable;\n    }\n\n    // Check HTTP status codes\n    const statusCode = this.extractStatusCode(error);\n    if (statusCode && this.config.retryableStatusCodes.includes(statusCode)) {\n      return true;\n    }\n\n    // Check error types/codes\n    const errorCode = this.extractErrorCode(error);\n    if (errorCode && this.config.retryableErrors.includes(errorCode)) {\n      return true;\n    }\n\n    // Network errors are generally retryable\n    if (this.isNetworkError(error)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private calculateDelay(_attempt: number, baseDelay: number): number {\n    switch (this.config.jitterType) {\n      case 'none':\n        return baseDelay;\n      \n      case 'full':\n        return Math.random() * baseDelay;\n      \n      case 'equal':\n        return baseDelay / 2 + Math.random() * (baseDelay / 2);\n      \n      case 'decorrelated':\n        // Decorrelated jitter: sleep = random_between(base_delay, previous_sleep * 3)\n        return Math.random() * (Math.min(this.config.maxDelay, baseDelay * 3) - this.config.baseDelay) + this.config.baseDelay;\n      \n      default:\n        return baseDelay;\n    }\n  }\n\n  private extractStatusCode(error: Error): number | null {\n    // Try different ways to extract status code\n    const err = error as any;\n    return err.statusCode || err.status || err.response?.status || null;\n  }\n\n  private extractErrorCode(error: Error): string | null {\n    const err = error as any;\n    return err.code || err.errno || error.name || null;\n  }\n\n  private isNetworkError(error: Error): boolean {\n    const networkErrorCodes = [\n      'ECONNRESET',\n      'ECONNREFUSED',\n      'ETIMEDOUT',\n      'ENOTFOUND',\n      'ENETUNREACH',\n      'EAI_AGAIN',\n      'ECONNABORTED',\n    ];\n\n    const errorCode = this.extractErrorCode(error);\n    return errorCode ? networkErrorCodes.includes(errorCode) : false;\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  public getMetrics(): Readonly<RetryMetrics> {\n    const totalDelay = this.metrics.attempts.reduce((sum, attempt) => sum + attempt.delay, 0);\n    \n    return {\n      ...this.metrics,\n      averageDelay: this.metrics.attempts.length > 0 ? totalDelay / this.metrics.attempts.length : 0,\n    };\n  }\n\n  public reset(): void {\n    this.metrics = {\n      totalAttempts: 0,\n      successfulRetries: 0,\n      failedRetries: 0,\n      averageDelay: 0,\n      attempts: [],\n    };\n  }\n}\n\n// Predefined retry configurations\nexport const DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxAttempts: 3,\n  baseDelay: 1000,\n  maxDelay: 30000,\n  backoffMultiplier: 2,\n  jitterType: 'equal',\n  retryableStatusCodes: [500, 502, 503, 504, 429],\n  retryableErrors: [\n    'ECONNRESET',\n    'ECONNREFUSED',\n    'ETIMEDOUT',\n    'ENOTFOUND',\n    'ENETUNREACH',\n    'NETWORK_ERROR',\n    'RATE_LIMIT_ERROR',\n  ],\n  timeout: 30000,\n};\n\nexport const AGGRESSIVE_RETRY_CONFIG: RetryConfig = {\n  maxAttempts: 5,\n  baseDelay: 500,\n  maxDelay: 60000,\n  backoffMultiplier: 2.5,\n  jitterType: 'decorrelated',\n  retryableStatusCodes: [500, 502, 503, 504, 429, 408],\n  retryableErrors: [\n    'ECONNRESET',\n    'ECONNREFUSED',\n    'ETIMEDOUT',\n    'ENOTFOUND',\n    'ENETUNREACH',\n    'NETWORK_ERROR',\n    'RATE_LIMIT_ERROR',\n    'CIRCUIT_BREAKER_ERROR',\n  ],\n  timeout: 45000,\n};\n\nexport const CONSERVATIVE_RETRY_CONFIG: RetryConfig = {\n  maxAttempts: 2,\n  baseDelay: 2000,\n  maxDelay: 10000,\n  backoffMultiplier: 1.5,\n  jitterType: 'full',\n  retryableStatusCodes: [500, 502, 503, 504],\n  retryableErrors: ['NETWORK_ERROR'],\n  timeout: 15000,\n};","/**\n * Middleware Stack for HTTP Client\n * Allows for request/response interception and modification\n */\n\nexport interface RequestContext {\n  url: string;\n  method: string;\n  headers: Record<string, string>;\n  body?: unknown;\n  metadata: Record<string, unknown>;\n  startTime: number;\n  requestId: string;\n}\n\nexport interface ResponseContext {\n  status: number;\n  statusText: string;\n  headers: Record<string, string>;\n  data: unknown;\n  metadata: Record<string, unknown>;\n  endTime: number;\n  duration: number;\n}\n\nexport interface Middleware {\n  name: string;\n  priority: number;\n  \n  beforeRequest?(context: RequestContext): Promise<RequestContext> | RequestContext;\n  afterResponse?(\n    context: RequestContext,\n    response: ResponseContext\n  ): Promise<ResponseContext> | ResponseContext;\n  onError?(\n    context: RequestContext,\n    error: Error\n  ): Promise<Error | void> | Error | void;\n}\n\nexport class MiddlewareStack {\n  private middlewares: Middleware[] = [];\n\n  add(middleware: Middleware): this {\n    this.middlewares.push(middleware);\n    // Sort by priority (higher priority first)\n    this.middlewares.sort((a, b) => b.priority - a.priority);\n    return this;\n  }\n\n  remove(name: string): this {\n    this.middlewares = this.middlewares.filter(m => m.name !== name);\n    return this;\n  }\n\n  async executeBeforeRequest(context: RequestContext): Promise<RequestContext> {\n    let currentContext = context;\n    \n    for (const middleware of this.middlewares) {\n      if (middleware.beforeRequest) {\n        try {\n          currentContext = await middleware.beforeRequest(currentContext);\n        } catch (error) {\n          console.warn(`Middleware ${middleware.name} failed in beforeRequest:`, error);\n          // Continue with other middlewares\n        }\n      }\n    }\n    \n    return currentContext;\n  }\n\n  async executeAfterResponse(\n    context: RequestContext,\n    response: ResponseContext\n  ): Promise<ResponseContext> {\n    let currentResponse = response;\n    \n    // Execute in reverse order for response middlewares\n    for (const middleware of [...this.middlewares].reverse()) {\n      if (middleware.afterResponse) {\n        try {\n          currentResponse = await middleware.afterResponse(context, currentResponse);\n        } catch (error) {\n          console.warn(`Middleware ${middleware.name} failed in afterResponse:`, error);\n          // Continue with other middlewares\n        }\n      }\n    }\n    \n    return currentResponse;\n  }\n\n  async executeOnError(\n    context: RequestContext,\n    error: Error\n  ): Promise<Error> {\n    let currentError = error;\n    \n    for (const middleware of this.middlewares) {\n      if (middleware.onError) {\n        try {\n          const result = await middleware.onError(context, currentError);\n          if (result instanceof Error) {\n            currentError = result;\n          }\n          // If void is returned, keep the current error\n        } catch (middlewareError) {\n          console.warn(`Middleware ${middleware.name} failed in onError:`, middlewareError);\n          // Continue with other middlewares\n        }\n      }\n    }\n    \n    return currentError;\n  }\n\n  getMiddlewares(): Readonly<Middleware[]> {\n    return [...this.middlewares];\n  }\n\n  clear(): this {\n    this.middlewares = [];\n    return this;\n  }\n}\n\n// Built-in middlewares\n\n// Authentication middleware\nexport class AuthenticationMiddleware implements Middleware {\n  name = 'authentication';\n  priority = 100;\n\n  constructor(private getToken: () => Promise<string | null>) {}\n\n  async beforeRequest(context: RequestContext): Promise<RequestContext> {\n    const token = await this.getToken();\n    if (token) {\n      context.headers.Authorization = `Bearer ${token}`;\n    }\n    return context;\n  }\n}\n\n// Request ID middleware\nexport class RequestIdMiddleware implements Middleware {\n  name = 'request-id';\n  priority = 90;\n\n  beforeRequest(context: RequestContext): RequestContext {\n    if (!context.headers['X-Request-ID']) {\n      context.headers['X-Request-ID'] = context.requestId;\n    }\n    return context;\n  }\n}\n\n// User Agent middleware\nexport class UserAgentMiddleware implements Middleware {\n  name = 'user-agent';\n  priority = 80;\n\n  constructor(private userAgent: string) {}\n\n  beforeRequest(context: RequestContext): RequestContext {\n    if (!context.headers['User-Agent']) {\n      context.headers['User-Agent'] = this.userAgent;\n    }\n    return context;\n  }\n}\n\n// Content Type middleware\nexport class ContentTypeMiddleware implements Middleware {\n  name = 'content-type';\n  priority = 70;\n\n  beforeRequest(context: RequestContext): RequestContext {\n    if (context.body && !context.headers['Content-Type']) {\n      context.headers['Content-Type'] = 'application/json';\n    }\n    return context;\n  }\n}\n\n// Request/Response logging middleware\nexport class LoggingMiddleware implements Middleware {\n  name = 'logging';\n  priority = 10;\n\n  constructor(\n    private logger: {\n      debug: (message: string, meta?: unknown) => void;\n      warn: (message: string, meta?: unknown) => void;\n      error: (message: string, meta?: unknown) => void;\n    },\n    private options: {\n      logRequests: boolean;\n      logResponses: boolean;\n      logHeaders: boolean;\n      logBody: boolean;\n      sanitizeHeaders?: string[];\n    } = {\n      logRequests: true,\n      logResponses: true,\n      logHeaders: false,\n      logBody: false,\n      sanitizeHeaders: ['authorization', 'cookie', 'x-api-key'],\n    }\n  ) {}\n\n  beforeRequest(context: RequestContext): RequestContext {\n    if (this.options.logRequests) {\n      const logData: Record<string, unknown> = {\n        requestId: context.requestId,\n        method: context.method,\n        url: context.url,\n      };\n\n      if (this.options.logHeaders) {\n        logData.headers = this.sanitizeHeaders(context.headers);\n      }\n\n      if (this.options.logBody && context.body) {\n        logData.body = this.sanitizeBody(context.body);\n      }\n\n      this.logger.debug('HTTP Request', logData);\n    }\n    return context;\n  }\n\n  afterResponse(\n    context: RequestContext,\n    response: ResponseContext\n  ): ResponseContext {\n    if (this.options.logResponses) {\n      const logData: Record<string, unknown> = {\n        requestId: context.requestId,\n        status: response.status,\n        statusText: response.statusText,\n        duration: response.duration,\n      };\n\n      if (this.options.logHeaders) {\n        logData.headers = this.sanitizeHeaders(response.headers);\n      }\n\n      if (this.options.logBody && response.data) {\n        logData.body = this.sanitizeBody(response.data);\n      }\n\n      const logLevel = response.status >= 400 ? 'error' : 'debug';\n      this.logger[logLevel]('HTTP Response', logData);\n    }\n    return response;\n  }\n\n  onError(context: RequestContext, error: Error): Error {\n    this.logger.error('HTTP Error', {\n      requestId: context.requestId,\n      method: context.method,\n      url: context.url,\n      error: error.message,\n      stack: error.stack,\n    });\n    return error;\n  }\n\n  private sanitizeHeaders(headers: Record<string, string>): Record<string, string> {\n    const sanitized = { ...headers };\n    \n    this.options.sanitizeHeaders?.forEach(header => {\n      const key = Object.keys(sanitized).find(k => \n        k.toLowerCase() === header.toLowerCase()\n      );\n      if (key) {\n        sanitized[key] = '[REDACTED]';\n      }\n    });\n    \n    return sanitized;\n  }\n\n  private sanitizeBody(body: unknown): unknown {\n    if (typeof body !== 'object' || body === null) {\n      return body;\n    }\n\n    const sensitiveFields = ['password', 'token', 'secret', 'key', 'auth'];\n    const sanitized = { ...body as Record<string, unknown> };\n    \n    Object.keys(sanitized).forEach(key => {\n      if (sensitiveFields.some(field => key.toLowerCase().includes(field))) {\n        sanitized[key] = '[REDACTED]';\n      }\n    });\n    \n    return sanitized;\n  }\n}\n\n// Rate limiting middleware\nexport class RateLimitingMiddleware implements Middleware {\n  name = 'rate-limiting';\n  priority = 50;\n\n  private requests: Map<string, number[]> = new Map();\n\n  constructor(\n    private config: {\n      requestsPerMinute: number;\n      keyGenerator?: (context: RequestContext) => string;\n    }\n  ) {}\n\n  async beforeRequest(context: RequestContext): Promise<RequestContext> {\n    const key = this.config.keyGenerator?.(context) || 'default';\n    const now = Date.now();\n    const windowStart = now - 60000; // 1 minute window\n\n    // Get existing requests for this key\n    const requests = this.requests.get(key) || [];\n    \n    // Remove requests outside the window\n    const recentRequests = requests.filter(time => time > windowStart);\n    \n    // Check if we're over the limit\n    if (recentRequests.length >= this.config.requestsPerMinute) {\n      throw new Error(`Rate limit exceeded: ${this.config.requestsPerMinute} requests per minute`);\n    }\n    \n    // Add current request\n    recentRequests.push(now);\n    this.requests.set(key, recentRequests);\n    \n    return context;\n  }\n}\n\n// Performance monitoring middleware\nexport class PerformanceMiddleware implements Middleware {\n  name = 'performance';\n  priority = 5;\n\n  private metrics: Map<string, {\n    count: number;\n    totalDuration: number;\n    minDuration: number;\n    maxDuration: number;\n  }> = new Map();\n\n  afterResponse(\n    context: RequestContext,\n    response: ResponseContext\n  ): ResponseContext {\n    const endpoint = `${context.method} ${context.url}`;\n    const duration = response.duration;\n    \n    const existing = this.metrics.get(endpoint) || {\n      count: 0,\n      totalDuration: 0,\n      minDuration: Infinity,\n      maxDuration: 0,\n    };\n    \n    this.metrics.set(endpoint, {\n      count: existing.count + 1,\n      totalDuration: existing.totalDuration + duration,\n      minDuration: Math.min(existing.minDuration, duration),\n      maxDuration: Math.max(existing.maxDuration, duration),\n    });\n    \n    return response;\n  }\n\n  getMetrics(): Record<string, {\n    count: number;\n    averageDuration: number;\n    minDuration: number;\n    maxDuration: number;\n  }> {\n    const result: Record<string, any> = {};\n    \n    this.metrics.forEach((value, key) => {\n      result[key] = {\n        count: value.count,\n        averageDuration: value.totalDuration / value.count,\n        minDuration: value.minDuration === Infinity ? 0 : value.minDuration,\n        maxDuration: value.maxDuration,\n      };\n    });\n    \n    return result;\n  }\n\n  reset(): void {\n    this.metrics.clear();\n  }\n}","/**\n * Enterprise HTTP Client with Advanced Features\n * Integrates circuit breaker, retry logic, middleware, and comprehensive error handling\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport { CircuitBreaker, type CircuitBreakerConfig } from './circuit-breaker';\nimport { RetryHandler, type RetryConfig, DEFAULT_RETRY_CONFIG } from './retry';\nimport { \n  MiddlewareStack, \n  type RequestContext, \n  type ResponseContext,\n  AuthenticationMiddleware,\n  RequestIdMiddleware,\n  UserAgentMiddleware,\n  ContentTypeMiddleware,\n  LoggingMiddleware,\n  type Middleware,\n} from './middleware.js';\nimport { createErrorFromResponse, ACubeSDKError } from '../errors/index.js';\n\nexport interface HttpClientConfig {\n  baseUrl: string;\n  timeout: number;\n  retryConfig: RetryConfig;\n  circuitBreakerConfig: CircuitBreakerConfig;\n  headers: Record<string, string>;\n  enableCircuitBreaker: boolean;\n  enableRetry: boolean;\n  enableLogging: boolean;\n  userAgent: string;\n  getAuthToken?: () => Promise<string | null>;\n}\n\nexport interface RequestOptions {\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n  url: string;\n  params?: Record<string, unknown>;\n  data?: unknown;\n  headers?: Record<string, string>;\n  timeout?: number;\n  metadata?: Record<string, unknown>;\n  skipRetry?: boolean;\n  skipCircuitBreaker?: boolean;\n}\n\nexport interface HttpResponse<T = unknown> {\n  data: T;\n  status: number;\n  statusText: string;\n  headers: Record<string, string>;\n  requestId: string;\n  duration: number;\n  config?: RequestOptions;\n  fromCache?: boolean;\n}\n\nexport class HttpClient extends EventEmitter {\n  private middlewareStack: MiddlewareStack;\n  private circuitBreaker: CircuitBreaker;\n  private retryHandler: RetryHandler;\n  private requestCounter = 0;\n\n  constructor(private config: HttpClientConfig) {\n    super();\n    \n    this.middlewareStack = new MiddlewareStack();\n    this.circuitBreaker = new CircuitBreaker(config.circuitBreakerConfig);\n    this.retryHandler = new RetryHandler(config.retryConfig);\n    \n    this.setupDefaultMiddlewares();\n  }\n\n  private setupDefaultMiddlewares(): void {\n    // Authentication middleware (if token provider available)\n    if (this.config.getAuthToken) {\n      this.middlewareStack.add(new AuthenticationMiddleware(this.config.getAuthToken));\n    }\n\n    // Request ID middleware\n    this.middlewareStack.add(new RequestIdMiddleware());\n\n    // User Agent middleware\n    this.middlewareStack.add(new UserAgentMiddleware(this.config.userAgent));\n\n    // Content Type middleware\n    this.middlewareStack.add(new ContentTypeMiddleware());\n\n    // Logging middleware (if enabled)\n    if (this.config.enableLogging) {\n      this.middlewareStack.add(new LoggingMiddleware(\n        {\n          debug: (msg, meta) => this.emit('debug', msg, meta),\n          warn: (msg, meta) => this.emit('warn', msg, meta),\n          error: (msg, meta) => this.emit('error', msg, meta),\n        },\n        {\n          logRequests: true,\n          logResponses: true,\n          logHeaders: false,\n          logBody: false,\n        }\n      ));\n    }\n  }\n\n  async request<T = unknown>(options: RequestOptions): Promise<HttpResponse<T>> {\n    const requestId = this.generateRequestId();\n    const startTime = Date.now();\n\n    // Create request context\n    const context: RequestContext = {\n      url: this.buildUrl(options.url, options.params),\n      method: options.method,\n      headers: {\n        ...this.config.headers,\n        ...options.headers,\n      },\n      body: options.data,\n      metadata: options.metadata || {},\n      startTime,\n      requestId,\n    };\n\n    const executeRequest = async (): Promise<HttpResponse<T>> => {\n      try {\n        // Execute before request middlewares\n        const processedContext = await this.middlewareStack.executeBeforeRequest(context);\n        \n        // Make the actual HTTP request\n        const response = await this.makeHttpRequest(processedContext, options.timeout);\n        \n        // Execute after response middlewares\n        const processedResponse = await this.middlewareStack.executeAfterResponse(\n          processedContext,\n          response\n        );\n        \n        return {\n          data: processedResponse.data as T,\n          status: processedResponse.status,\n          statusText: processedResponse.statusText,\n          headers: processedResponse.headers,\n          requestId,\n          duration: processedResponse.duration,\n        };\n      } catch (error) {\n        // Execute error middlewares\n        const processedError = await this.middlewareStack.executeOnError(\n          context,\n          error as Error\n        );\n        throw processedError;\n      }\n    };\n\n    try {\n      // Apply circuit breaker if enabled\n      if (this.config.enableCircuitBreaker && !options.skipCircuitBreaker) {\n        if (this.config.enableRetry && !options.skipRetry) {\n          // Both circuit breaker and retry\n          return await this.circuitBreaker.execute(\n            () => this.retryHandler.execute(() => executeRequest(), `${options.method} ${options.url}`),\n            `${options.method} ${options.url}`\n          );\n        } else {\n          // Circuit breaker only\n          return await this.circuitBreaker.execute(\n            executeRequest,\n            `${options.method} ${options.url}`\n          );\n        }\n      } else if (this.config.enableRetry && !options.skipRetry) {\n        // Retry only\n        return await this.retryHandler.execute(\n          executeRequest,\n          `${options.method} ${options.url}`\n        );\n      } else {\n        // No circuit breaker or retry\n        return await executeRequest();\n      }\n    } catch (error) {\n      // Emit error event for monitoring\n      this.emit('requestError', {\n        requestId,\n        method: options.method,\n        url: options.url,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        duration: Date.now() - startTime,\n      });\n      \n      throw error;\n    }\n  }\n\n  private async makeHttpRequest(\n    context: RequestContext,\n    timeoutOverride?: number\n  ): Promise<ResponseContext> {\n    const timeout = timeoutOverride || this.config.timeout;\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n      const fetchOptions: RequestInit = {\n        method: context.method,\n        headers: context.headers,\n        signal: controller.signal,\n      };\n\n      if (context.body && context.method !== 'GET') {\n        fetchOptions.body = typeof context.body === 'string' \n          ? context.body \n          : JSON.stringify(context.body);\n      }\n\n      const response = await fetch(context.url, fetchOptions);\n      clearTimeout(timeoutId);\n\n      const endTime = Date.now();\n      const duration = endTime - context.startTime;\n\n      // Parse response data\n      let data: unknown;\n      const contentType = response.headers.get('content-type') || '';\n      \n      if (contentType.includes('application/json')) {\n        data = await response.json();\n      } else if (contentType.includes('application/pdf')) {\n        data = await response.blob();\n      } else if (contentType.includes('text/')) {\n        data = await response.text();\n      } else {\n        data = await response.arrayBuffer();\n      }\n\n      // Convert headers to plain object\n      const headers: Record<string, string> = {};\n      response.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n\n      const responseContext: ResponseContext = {\n        status: response.status,\n        statusText: response.statusText,\n        headers,\n        data,\n        metadata: {},\n        endTime,\n        duration,\n      };\n\n      // Check for HTTP errors\n      if (!response.ok) {\n        const error = createErrorFromResponse(\n          {\n            status: response.status,\n            statusText: response.statusText,\n            data,\n          },\n          `${context.method} ${context.url}`,\n          context.requestId\n        );\n        throw error;\n      }\n\n      // Emit success event\n      this.emit('requestSuccess', {\n        requestId: context.requestId,\n        method: context.method,\n        url: context.url,\n        status: response.status,\n        duration,\n      });\n\n      return responseContext;\n    } catch (error) {\n      clearTimeout(timeoutId);\n      \n      if (error instanceof ACubeSDKError) {\n        throw error;\n      }\n\n      // Handle network/fetch errors\n      if (error instanceof Error) {\n        if (error.name === 'AbortError') {\n          throw createErrorFromResponse(\n            {\n              status: 408,\n              statusText: 'Request Timeout',\n              data: { message: 'Request timeout' },\n            },\n            `${context.method} ${context.url}`,\n            context.requestId\n          );\n        }\n        \n        throw createErrorFromResponse(\n          {\n            status: 0,\n            statusText: 'Network Error',\n            data: { message: error.message },\n          },\n          `${context.method} ${context.url}`,\n          context.requestId\n        );\n      }\n      \n      throw error;\n    }\n  }\n\n  private buildUrl(path: string, params?: Record<string, unknown>): string {\n    const url = new URL(path, this.config.baseUrl);\n    \n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n    \n    return url.toString();\n  }\n\n  private generateRequestId(): string {\n    return `req_${Date.now()}_${++this.requestCounter}_${Math.random().toString(36).substring(2, 8)}`;\n  }\n\n  // Convenience methods\n  async get<T = unknown>(\n    url: string, \n    options: Omit<RequestOptions, 'method' | 'url'> = {}\n  ): Promise<HttpResponse<T>> {\n    return this.request<T>({ ...options, method: 'GET', url });\n  }\n\n  async post<T = unknown>(\n    url: string,\n    data?: unknown,\n    options: Omit<RequestOptions, 'method' | 'url' | 'data'> = {}\n  ): Promise<HttpResponse<T>> {\n    return this.request<T>({ ...options, method: 'POST', url, data });\n  }\n\n  async put<T = unknown>(\n    url: string,\n    data?: unknown,\n    options: Omit<RequestOptions, 'method' | 'url' | 'data'> = {}\n  ): Promise<HttpResponse<T>> {\n    return this.request<T>({ ...options, method: 'PUT', url, data });\n  }\n\n  async delete<T = unknown>(\n    url: string,\n    options: Omit<RequestOptions, 'method' | 'url'> = {}\n  ): Promise<HttpResponse<T>> {\n    return this.request<T>({ ...options, method: 'DELETE', url });\n  }\n\n  async patch<T = unknown>(\n    url: string,\n    data?: unknown,\n    options: Omit<RequestOptions, 'method' | 'url' | 'data'> = {}\n  ): Promise<HttpResponse<T>> {\n    return this.request<T>({ ...options, method: 'PATCH', url, data });\n  }\n\n  // Middleware management\n  addMiddleware(middleware: Middleware): this {\n    this.middlewareStack.add(middleware);\n    return this;\n  }\n\n  removeMiddleware(name: string): this {\n    this.middlewareStack.remove(name);\n    return this;\n  }\n\n  // Health and metrics\n  getCircuitBreakerMetrics() {\n    return this.circuitBreaker.getMetrics();\n  }\n\n  getRetryMetrics() {\n    return this.retryHandler.getMetrics();\n  }\n\n  getMetrics() {\n    const circuitBreakerMetrics = this.circuitBreaker.getMetrics();\n    const retryMetrics = this.retryHandler.getMetrics();\n    \n    return {\n      requestCount: circuitBreakerMetrics.totalRequests,\n      successCount: circuitBreakerMetrics.successfulRequests,\n      errorCount: circuitBreakerMetrics.failedRequests,\n      totalDuration: 0, // Would need to track this separately\n      averageResponseTime: 0, // Would need to track this separately\n      retryCount: retryMetrics.totalAttempts || 0,\n    };\n  }\n\n  getHealth() {\n    const circuitBreakerHealth = this.circuitBreaker.getHealthStatus();\n    \n    return {\n      status: circuitBreakerHealth.isHealthy ? 'healthy' : 'unhealthy',\n      circuitBreakerState: this.circuitBreaker.getState(),\n      lastError: null, // Would need to track this\n      uptime: circuitBreakerHealth.uptime,\n    };\n  }\n\n  getHealthStatus() {\n    return {\n      circuitBreaker: this.circuitBreaker.getHealthStatus(),\n      retry: this.retryHandler.getMetrics(),\n    };\n  }\n\n  // Configuration updates\n  updateConfig(updates: Partial<HttpClientConfig>): void {\n    Object.assign(this.config, updates);\n  }\n\n  // Cleanup\n  destroy(): void {\n    this.circuitBreaker.destroy();\n    this.retryHandler.reset();\n    this.middlewareStack.clear();\n    this.removeAllListeners();\n  }\n}\n\n// Default configurations\nexport const DEFAULT_HTTP_CONFIG: HttpClientConfig = {\n  baseUrl: 'https://ereceipts-it-sandbox.acubeapi.com',\n  timeout: 30000,\n  retryConfig: DEFAULT_RETRY_CONFIG,\n  circuitBreakerConfig: {\n    failureThreshold: 5,\n    successThreshold: 2,\n    timeout: 30000,\n    resetTimeout: 60000,\n    name: 'acube-http-client',\n  },\n  headers: {\n    'Accept': 'application/json',\n    'Content-Type': 'application/json',\n  },\n  enableCircuitBreaker: true,\n  enableRetry: true,\n  enableLogging: true,\n  userAgent: 'ACube-SDK/2.0.0',\n};\n\nexport const AUTH_HTTP_CONFIG: HttpClientConfig = {\n  ...DEFAULT_HTTP_CONFIG,\n  baseUrl: 'https://common-sandbox.api.acubeapi.com',\n  circuitBreakerConfig: {\n    ...DEFAULT_HTTP_CONFIG.circuitBreakerConfig,\n    name: 'acube-auth-client',\n  },\n};","/**\n * Optimized React Native AsyncStorage Adapter\n * High-performance storage with memory caching, batching, and advanced optimizations\n * \n * Features:\n * - In-memory LRU cache for frequently accessed data\n * - Intelligent write batching and coalescing\n * - Compression for large values\n * - Background cleanup and defragmentation\n * - Performance monitoring and metrics\n * - Memory pressure handling\n * - Connection retry logic\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport type { \n  StorageAdapter, \n  StorageKey, \n  StorageValue, \n  StorageEntry, \n  StorageOptions,\n  QueryOptions,\n  StorageTransaction,\n  StorageStats\n} from '../unified-storage.js';\n\n// Platform detection\nconst isReactNative = typeof navigator !== 'undefined' && \n  ((navigator as any).product === 'ReactNative' || (global as any).__REACT_NATIVE__);\n\n/**\n * LRU Cache for in-memory storage optimization\n */\nclass LRUCache<T> {\n  private cache = new Map<string, { value: T; timestamp: number }>();\n  private maxSize: number;\n  private ttl: number;\n\n  constructor(maxSize: number = 1000, ttl: number = 5 * 60 * 1000) {\n    this.maxSize = maxSize;\n    this.ttl = ttl;\n  }\n\n  get(key: string): T | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    // Check TTL\n    if (Date.now() - entry.timestamp > this.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    // Move to end (most recently used)\n    this.cache.delete(key);\n    this.cache.set(key, entry);\n    return entry.value;\n  }\n\n  set(key: string, value: T): void {\n    // Remove if exists\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n    // Evict least recently used if at capacity\n    else if (this.cache.size >= this.maxSize) {\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey) {\n        this.cache.delete(firstKey);\n      }\n    }\n\n    this.cache.set(key, { value, timestamp: Date.now() });\n  }\n\n  delete(key: string): boolean {\n    return this.cache.delete(key);\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  size(): number {\n    return this.cache.size;\n  }\n\n  // Cleanup expired entries\n  cleanup(): number {\n    const now = Date.now();\n    let cleaned = 0;\n    \n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp > this.ttl) {\n        this.cache.delete(key);\n        cleaned++;\n      }\n    }\n    \n    return cleaned;\n  }\n}\n\n/**\n * Write batch manager for optimizing AsyncStorage operations\n */\nclass WriteBatchManager {\n  private pendingWrites = new Map<string, { value: string; timestamp: number; resolve: Function; reject: Function }>();\n  private batchTimer?: NodeJS.Timeout;\n  private batchDelay: number;\n  private maxBatchSize: number;\n\n  constructor(batchDelay: number = 50, maxBatchSize: number = 100) {\n    this.batchDelay = batchDelay;\n    this.maxBatchSize = maxBatchSize;\n  }\n\n  enqueue(key: string, value: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // Cancel existing entry if present\n      const existing = this.pendingWrites.get(key);\n      if (existing) {\n        existing.resolve(); // Resolve the old promise\n      }\n\n      this.pendingWrites.set(key, {\n        value,\n        timestamp: Date.now(),\n        resolve,\n        reject,\n      });\n\n      // Schedule batch processing\n      if (!this.batchTimer) {\n        this.batchTimer = setTimeout(() => this.processBatch(), this.batchDelay) as unknown as NodeJS.Timeout;\n      }\n\n      // Force batch if at capacity\n      if (this.pendingWrites.size >= this.maxBatchSize) {\n        this.processBatch();\n      }\n    });\n  }\n\n  async processBatch(): Promise<void> {\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n      this.batchTimer = undefined as any;\n    }\n\n    if (this.pendingWrites.size === 0) return;\n\n    const batch = Array.from(this.pendingWrites.entries());\n    this.pendingWrites.clear();\n\n    try {\n      // Import AsyncStorage dynamically\n      const AsyncStorageModule = await import('@react-native-async-storage/async-storage');\n      const AsyncStorage = AsyncStorageModule.default;\n\n      // Create multiSet array\n      const multiSetArray: [string, string][] = batch.map(([key, data]) => [key, data.value]);\n      \n      await AsyncStorage.multiSet(multiSetArray);\n      \n      // Resolve all promises\n      batch.forEach(([, data]) => data.resolve());\n    } catch (error) {\n      // Reject all promises\n      batch.forEach(([, data]) => data.reject(error));\n    }\n  }\n\n  async flush(): Promise<void> {\n    return this.processBatch();\n  }\n\n  clear(): void {\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n      this.batchTimer = undefined as any;\n    }\n    \n    // Reject all pending writes\n    for (const [, data] of this.pendingWrites) {\n      data.reject(new Error('Batch manager cleared'));\n    }\n    \n    this.pendingWrites.clear();\n  }\n}\n\n/**\n * Performance metrics tracking\n */\ninterface PerformanceMetrics {\n  cacheHits: number;\n  cacheMisses: number;\n  reads: number;\n  writes: number;\n  batches: number;\n  compressionSaved: number;\n  avgReadTime: number;\n  avgWriteTime: number;\n  memoryPressureEvents: number;\n  backgroundCleanups: number;\n}\n\n/**\n * Optimized React Native storage configuration\n */\nexport interface OptimizedReactNativeStorageConfig {\n  /** Key prefix for namespacing */\n  keyPrefix?: string;\n  \n  /** Enable in-memory LRU cache */\n  enableCache?: boolean;\n  \n  /** Cache size limit */\n  cacheSize?: number;\n  \n  /** Cache TTL in milliseconds */\n  cacheTTL?: number;\n  \n  /** Enable write batching */\n  enableBatching?: boolean;\n  \n  /** Batch delay in milliseconds */\n  batchDelay?: number;\n  \n  /** Maximum batch size */\n  maxBatchSize?: number;\n  \n  /** Enable compression for large values */\n  enableCompression?: boolean;\n  \n  /** Compression threshold in bytes */\n  compressionThreshold?: number;\n  \n  /** Enable background cleanup */\n  enableBackgroundCleanup?: boolean;\n  \n  /** Cleanup interval in milliseconds */\n  cleanupInterval?: number;\n  \n  /** Enable performance monitoring */\n  enableMetrics?: boolean;\n  \n  /** Enable memory pressure handling */\n  enableMemoryPressureHandling?: boolean;\n  \n  /** Maximum memory usage before pressure handling */\n  memoryPressureThreshold?: number;\n}\n\nconst DEFAULT_CONFIG: Required<OptimizedReactNativeStorageConfig> = {\n  keyPrefix: 'acube_optimized',\n  enableCache: true,\n  cacheSize: 1000,\n  cacheTTL: 5 * 60 * 1000, // 5 minutes\n  enableBatching: true,\n  batchDelay: 50, // 50ms\n  maxBatchSize: 100,\n  enableCompression: true,\n  compressionThreshold: 1024, // 1KB\n  enableBackgroundCleanup: true,\n  cleanupInterval: 10 * 60 * 1000, // 10 minutes\n  enableMetrics: true,\n  enableMemoryPressureHandling: true,\n  memoryPressureThreshold: 50 * 1024 * 1024, // 50MB\n};\n\n/**\n * Storage events\n */\ninterface StorageEvents {\n  'cache:hit': { key: string };\n  'cache:miss': { key: string };\n  'batch:processed': { size: number; duration: number };\n  'compression:applied': { key: string; originalSize: number; compressedSize: number };\n  'memory:pressure': { usage: number; threshold: number };\n  'background:cleanup': { cleaned: number; duration: number };\n  'performance:metrics': { metrics: PerformanceMetrics };\n}\n\n/**\n * Optimized React Native AsyncStorage Adapter\n */\nexport class OptimizedReactNativeStorageAdapter extends EventEmitter<StorageEvents> implements StorageAdapter {\n  readonly name = 'OptimizedReactNativeStorage';\n  readonly isAvailable = isReactNative;\n  readonly capabilities = {\n    supportsTransactions: false,\n    supportsIndexing: false,\n    maxKeyLength: 1000,\n    maxValueSize: 6 * 1024 * 1024, // 6MB (iOS limit)\n    supportsCompression: true,\n    supportsEncryption: false,\n    supportsTTL: true,\n  };\n\n  private config: Required<OptimizedReactNativeStorageConfig>;\n  private cache: LRUCache<StorageEntry>;\n  private writeBatch: WriteBatchManager;\n  private AsyncStorage: any;\n  private isInitialized = false;\n  private metrics: PerformanceMetrics;\n  private cleanupTimer?: NodeJS.Timeout;\n  private memoryUsage = 0;\n\n  constructor(config: OptimizedReactNativeStorageConfig = {}) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.cache = new LRUCache<StorageEntry>(this.config.cacheSize, this.config.cacheTTL);\n    this.writeBatch = new WriteBatchManager(this.config.batchDelay, this.config.maxBatchSize);\n    this.metrics = this.initializeMetrics();\n    \n    this.initialize();\n  }\n\n  private initializeMetrics(): PerformanceMetrics {\n    return {\n      cacheHits: 0,\n      cacheMisses: 0,\n      reads: 0,\n      writes: 0,\n      batches: 0,\n      compressionSaved: 0,\n      avgReadTime: 0,\n      avgWriteTime: 0,\n      memoryPressureEvents: 0,\n      backgroundCleanups: 0,\n    };\n  }\n\n  private async initialize(): Promise<void> {\n    if (this.isInitialized || !this.isAvailable) return;\n\n    try {\n      // Dynamically import AsyncStorage\n      const AsyncStorageModule = await import('@react-native-async-storage/async-storage');\n      this.AsyncStorage = AsyncStorageModule.default;\n\n      // Setup background cleanup\n      if (this.config.enableBackgroundCleanup) {\n        this.startBackgroundCleanup();\n      }\n\n      // Setup memory pressure handling\n      if (this.config.enableMemoryPressureHandling) {\n        this.setupMemoryPressureHandling();\n      }\n\n      this.isInitialized = true;\n    } catch (error) {\n      throw new Error(`Failed to initialize OptimizedReactNativeStorageAdapter: ${error}`);\n    }\n  }\n\n  private startBackgroundCleanup(): void {\n    this.cleanupTimer = setInterval(async () => {\n      const startTime = Date.now();\n      \n      try {\n        // Cleanup cache\n        const cacheCleanedCount = this.cache.cleanup();\n        \n        // Cleanup expired storage entries\n        const storageCleanedCount = await this.cleanupExpiredStorage();\n        \n        const duration = Date.now() - startTime;\n        const totalCleaned = cacheCleanedCount + storageCleanedCount;\n        \n        this.metrics.backgroundCleanups++;\n        this.emit('background:cleanup', { cleaned: totalCleaned, duration });\n        \n        // Emit metrics periodically\n        if (this.config.enableMetrics && this.metrics.backgroundCleanups % 10 === 0) {\n          this.emit('performance:metrics', { metrics: { ...this.metrics } });\n        }\n      } catch (error) {\n        console.warn('Background cleanup failed:', error);\n      }\n    }, this.config.cleanupInterval) as unknown as NodeJS.Timeout;\n  }\n\n  private setupMemoryPressureHandling(): void {\n    // Monitor memory usage and handle pressure\n    setInterval(() => {\n      if (this.memoryUsage > this.config.memoryPressureThreshold) {\n        this.handleMemoryPressure();\n      }\n    }, 30000); // Check every 30 seconds\n  }\n\n  private handleMemoryPressure(): void {\n    this.metrics.memoryPressureEvents++;\n    this.emit('memory:pressure', { \n      usage: this.memoryUsage, \n      threshold: this.config.memoryPressureThreshold \n    });\n\n    // Clear cache to free memory\n    this.cache.clear();\n    \n    // Force batch processing\n    this.writeBatch.flush();\n  }\n\n  async set<T extends StorageValue>(\n    key: StorageKey, \n    value: T, \n    options: StorageOptions = {}\n  ): Promise<void> {\n    await this.initialize();\n    \n    const startTime = Date.now();\n    \n    try {\n      const entry: StorageEntry<T> = {\n        data: value,\n        metadata: {\n          key,\n          createdAt: Date.now(),\n          updatedAt: Date.now(),\n          expiresAt: options.ttl ? Date.now() + options.ttl : undefined,\n          encrypted: false,\n          compressed: false,\n          version: options.version || '1.0.0',\n        } as any,\n      };\n\n      // Serialize and optionally compress\n      let serialized = JSON.stringify(entry);\n      const originalSize = new Blob([serialized]).size;\n      \n      if (this.config.enableCompression && originalSize > this.config.compressionThreshold) {\n        serialized = await this.compress(serialized);\n        (entry.metadata as any).compressed = true;\n        \n        const compressedSize = new Blob([serialized]).size;\n        const saved = originalSize - compressedSize;\n        \n        this.metrics.compressionSaved += saved;\n        this.emit('compression:applied', { \n          key: key as string, \n          originalSize, \n          compressedSize \n        });\n      }\n\n      const storageKey = this.getPrefixedKey(key);\n      \n      // Update cache\n      if (this.config.enableCache) {\n        this.cache.set(storageKey, entry);\n      }\n\n      // Write to storage (batched or immediate)\n      if (this.config.enableBatching) {\n        await this.writeBatch.enqueue(storageKey, serialized);\n      } else {\n        await this.AsyncStorage.setItem(storageKey, serialized);\n      }\n\n      // Update metrics\n      this.metrics.writes++;\n      const duration = Date.now() - startTime;\n      this.metrics.avgWriteTime = (this.metrics.avgWriteTime + duration) / 2;\n      this.memoryUsage += originalSize;\n      \n    } catch (error) {\n      throw new Error(`Failed to set ${key}: ${error}`);\n    }\n  }\n\n  async get<T extends StorageValue>(key: StorageKey): Promise<StorageEntry<T> | null> {\n    await this.initialize();\n    \n    const startTime = Date.now();\n    const storageKey = this.getPrefixedKey(key);\n    \n    try {\n      // Check cache first\n      if (this.config.enableCache) {\n        const cached = this.cache.get(storageKey);\n        if (cached) {\n          this.metrics.cacheHits++;\n          this.emit('cache:hit', { key: key as string });\n          \n          // Check expiration\n          if (this.isExpired(cached)) {\n            this.cache.delete(storageKey);\n            await this.delete(key);\n            return null;\n          }\n          \n          return cached as StorageEntry<T>;\n        } else {\n          this.metrics.cacheMisses++;\n          this.emit('cache:miss', { key: key as string });\n        }\n      }\n\n      // Read from storage\n      const serialized = await this.AsyncStorage.getItem(storageKey);\n      if (!serialized) return null;\n\n      // Deserialize and decompress if needed\n      let data = serialized;\n      try {\n        const entry: StorageEntry<T> = JSON.parse(data);\n        \n        // Handle compressed data\n        if (entry.metadata.compressed) {\n          const decompressed = await this.decompress(data);\n          const decompressedEntry: StorageEntry<T> = JSON.parse(decompressed);\n          data = JSON.stringify(decompressedEntry);\n        }\n        \n        const finalEntry: StorageEntry<T> = JSON.parse(data);\n        \n        // Check expiration\n        if (this.isExpired(finalEntry)) {\n          await this.delete(key);\n          return null;\n        }\n\n        // Update cache\n        if (this.config.enableCache) {\n          this.cache.set(storageKey, finalEntry);\n        }\n\n        // Update metrics\n        this.metrics.reads++;\n        const duration = Date.now() - startTime;\n        this.metrics.avgReadTime = (this.metrics.avgReadTime + duration) / 2;\n        \n        return finalEntry;\n      } catch (error) {\n        // Handle corrupted data\n        console.warn(`Corrupted data for key ${key}:`, error);\n        await this.delete(key);\n        return null;\n      }\n    } catch (error) {\n      console.warn(`Failed to get ${key}:`, error);\n      return null;\n    }\n  }\n\n  async delete(key: StorageKey): Promise<boolean> {\n    await this.initialize();\n    \n    const storageKey = this.getPrefixedKey(key);\n    \n    try {\n      // Remove from cache\n      if (this.config.enableCache) {\n        this.cache.delete(storageKey);\n      }\n\n      // Remove from storage\n      await this.AsyncStorage.removeItem(storageKey);\n      return true;\n    } catch (error) {\n      console.warn(`Failed to delete ${key}:`, error);\n      return false;\n    }\n  }\n\n  async exists(key: StorageKey): Promise<boolean> {\n    const entry = await this.get(key);\n    return entry !== null;\n  }\n\n  async clear(namespace?: string): Promise<void> {\n    await this.initialize();\n    \n    try {\n      if (namespace) {\n        // Clear specific namespace\n        const keys = await this.getAllKeys();\n        const namespacedKeys = keys.filter(k => k.startsWith(namespace));\n        await this.deleteMany(namespacedKeys as StorageKey[]);\n      } else {\n        // Clear all our keys\n        const keys = await this.getAllKeys();\n        const prefixedKeys = keys.map(k => this.getPrefixedKey(k as StorageKey));\n        await this.AsyncStorage.multiRemove(prefixedKeys);\n        \n        // Clear cache\n        if (this.config.enableCache) {\n          this.cache.clear();\n        }\n      }\n      \n      this.memoryUsage = 0;\n    } catch (error) {\n      throw new Error(`Failed to clear storage: ${error}`);\n    }\n  }\n\n  async setMany<T extends StorageValue>(\n    entries: Array<{ key: StorageKey; value: T; options?: StorageOptions }>\n  ): Promise<void> {\n    await this.initialize();\n    \n    if (this.config.enableBatching) {\n      // Use batching for better performance\n      for (const entry of entries) {\n        await this.set(entry.key, entry.value, entry.options);\n      }\n    } else {\n      // Use multiSet for non-batched writes\n      const serializedEntries: [string, string][] = [];\n      \n      for (const { key, value, options = {} } of entries) {\n        const entry: StorageEntry<T> = {\n          data: value,\n          metadata: {\n            key,\n            createdAt: Date.now(),\n            updatedAt: Date.now(),\n            expiresAt: options.ttl ? Date.now() + options.ttl : undefined,\n            encrypted: false,\n            compressed: false,\n            version: options.version || '1.0.0',\n          } as any,\n        };\n\n        const serialized = JSON.stringify(entry);\n        const storageKey = this.getPrefixedKey(key);\n        \n        serializedEntries.push([storageKey, serialized]);\n        \n        // Update cache\n        if (this.config.enableCache) {\n          this.cache.set(storageKey, entry);\n        }\n      }\n      \n      await this.AsyncStorage.multiSet(serializedEntries);\n      this.metrics.writes += entries.length;\n    }\n  }\n\n  async getMany<T extends StorageValue>(keys: StorageKey[]): Promise<Array<StorageEntry<T> | null>> {\n    await this.initialize();\n    \n    const results: Array<StorageEntry<T> | null> = [];\n    const uncachedKeys: StorageKey[] = [];\n    const keyMap = new Map<string, number>();\n    \n    // Check cache first\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (!key) {\n        results[i] = null;\n        continue;\n      }\n      \n      const storageKey = this.getPrefixedKey(key);\n      \n      if (this.config.enableCache) {\n        const cached = this.cache.get(storageKey);\n        if (cached) {\n          results[i] = this.isExpired(cached) ? null : (cached as StorageEntry<T>);\n          this.metrics.cacheHits++;\n          continue;\n        } else {\n          this.metrics.cacheMisses++;\n        }\n      }\n      \n      uncachedKeys.push(key);\n      keyMap.set(this.getPrefixedKey(key), i);\n    }\n    \n    // Fetch uncached keys\n    if (uncachedKeys.length > 0) {\n      const prefixedKeys = uncachedKeys.map(k => this.getPrefixedKey(k));\n      const storageResults = await this.AsyncStorage.multiGet(prefixedKeys);\n      \n      for (const [storageKey, serialized] of storageResults) {\n        const index = keyMap.get(storageKey);\n        if (index === undefined || index === null) continue;\n        \n        if (!serialized) {\n          results[index] = null;\n          continue;\n        }\n        \n        try {\n          const entry: StorageEntry<T> = JSON.parse(serialized);\n          \n          if (this.isExpired(entry)) {\n            results[index] = null;\n            const keyToDelete = keys[index];\n            if (keyToDelete) {\n              await this.delete(keyToDelete);\n            }\n          } else {\n            results[index] = entry;\n            \n            // Update cache\n            if (this.config.enableCache) {\n              this.cache.set(storageKey, entry);\n            }\n          }\n        } catch (error) {\n          const keyForLog = keys[index] || 'unknown';\n          console.warn(`Corrupted data for key ${keyForLog}:`, error);\n          results[index] = null;\n        }\n      }\n    }\n    \n    this.metrics.reads += keys.length;\n    return results;\n  }\n\n  async deleteMany(keys: StorageKey[]): Promise<number> {\n    await this.initialize();\n    \n    try {\n      const prefixedKeys = keys.map(k => this.getPrefixedKey(k));\n      \n      // Remove from cache\n      if (this.config.enableCache) {\n        for (const prefixedKey of prefixedKeys) {\n          this.cache.delete(prefixedKey);\n        }\n      }\n      \n      // Remove from storage\n      await this.AsyncStorage.multiRemove(prefixedKeys);\n      \n      return keys.length;\n    } catch (error) {\n      console.warn('Failed to delete multiple keys:', error);\n      return 0;\n    }\n  }\n\n  async query<T extends StorageValue>(options: QueryOptions = {}): Promise<Array<StorageEntry<T>>> {\n    await this.initialize();\n    \n    const keys = await this.getAllKeys();\n    let filteredKeys = keys;\n    \n    // Filter by prefix\n    if (options.prefix || options.keyPrefix) {\n      const prefix = options.prefix || options.keyPrefix!;\n      filteredKeys = keys.filter(k => k.startsWith(prefix));\n    }\n    \n    // Filter by namespace\n    if (options.namespace) {\n      filteredKeys = filteredKeys.filter(k => k.includes(options.namespace!));\n    }\n    \n    // Apply limit and offset\n    if (options.offset) {\n      filteredKeys = filteredKeys.slice(options.offset);\n    }\n    if (options.limit) {\n      filteredKeys = filteredKeys.slice(0, options.limit);\n    }\n    \n    // Get entries\n    const entries = await this.getMany<T>(filteredKeys as StorageKey[]);\n    const validEntries = entries.filter((entry): entry is StorageEntry<T> => {\n      if (!entry) return false;\n      if (!options.includeExpired && this.isExpired(entry)) return false;\n      return true;\n    });\n    \n    // Sort if requested\n    if (options.sortBy) {\n      validEntries.sort((a, b) => {\n        let aValue: number;\n        let bValue: number;\n        \n        switch (options.sortBy) {\n          case 'createdAt':\n            aValue = a.metadata.createdAt;\n            bValue = b.metadata.createdAt;\n            break;\n          case 'updatedAt':\n            aValue = a.metadata.updatedAt;\n            bValue = b.metadata.updatedAt;\n            break;\n          case 'key':\n          default:\n            aValue = a.metadata.key.localeCompare(b.metadata.key as string);\n            bValue = 0;\n            break;\n        }\n        \n        const result = aValue - bValue;\n        return options.sortOrder === 'desc' ? -result : result;\n      });\n    }\n    \n    return validEntries;\n  }\n\n  // StorageAdapter interface methods\n  async keys(options?: QueryOptions): Promise<StorageKey[]> {\n    await this.initialize();\n    \n    try {\n      const allKeys = await this.getAllKeys();\n      let filteredKeys = allKeys;\n      \n      // Apply filters\n      if (options?.prefix || options?.keyPrefix) {\n        const prefix = options.prefix || options.keyPrefix!;\n        filteredKeys = allKeys.filter(k => k.startsWith(prefix));\n      }\n      \n      if (options?.namespace) {\n        filteredKeys = filteredKeys.filter(k => k.includes(options.namespace!));\n      }\n      \n      // Apply pagination\n      if (options?.offset) {\n        filteredKeys = filteredKeys.slice(options.offset);\n      }\n      if (options?.limit) {\n        filteredKeys = filteredKeys.slice(0, options.limit);\n      }\n      \n      return filteredKeys.map(k => k as StorageKey);\n    } catch (error) {\n      console.warn('Failed to get keys:', error);\n      return [];\n    }\n  }\n\n  async values<T extends StorageValue>(options?: QueryOptions): Promise<Array<StorageEntry<T>>> {\n    const keys = await this.keys(options);\n    const entries = await this.getMany<T>(keys);\n    return entries.filter((entry): entry is StorageEntry<T> => entry !== null);\n  }\n\n  async entries<T extends StorageValue>(options?: QueryOptions): Promise<Array<StorageEntry<T>>> {\n    return this.values<T>(options);\n  }\n\n  async count(options?: QueryOptions): Promise<number> {\n    const keys = await this.keys(options);\n    return keys.length;\n  }\n\n  // Transaction support (basic implementation)\n  async beginTransaction(): Promise<StorageTransaction> {\n    throw new Error('Transactions not supported in AsyncStorage adapter');\n  }\n\n  // Lifecycle methods\n  async connect(): Promise<void> {\n    await this.initialize();\n  }\n\n  async disconnect(): Promise<void> {\n    this.destroy();\n  }\n\n  isConnected(): boolean {\n    return this.isInitialized;\n  }\n\n  // Maintenance methods\n  async optimize(): Promise<void> {\n    // Force cache cleanup and garbage collection\n    const cleaned = this.cache.cleanup();\n    \n    // Force write batch processing\n    await this.writeBatch.flush();\n    \n    console.log(`Storage optimized: cleaned ${cleaned} cache entries`);\n  }\n\n  async getStats(): Promise<StorageStats> {\n    const keys = await this.getAllKeys();\n    const entries = await this.getMany(keys as StorageKey[]);\n    const validEntries = entries.filter(entry => entry !== null);\n    \n    let totalSize = 0;\n    let encryptedCount = 0;\n    let compressedCount = 0;\n    let oldestTimestamp = Date.now();\n    let newestTimestamp = 0;\n    const namespaces = new Set<string>();\n    \n    for (const entry of validEntries) {\n      if (entry) {\n        // Estimate size (simplified)\n        totalSize += JSON.stringify(entry).length;\n        \n        if (entry.metadata.encrypted) encryptedCount++;\n        if (entry.metadata.compressed) compressedCount++;\n        \n        oldestTimestamp = Math.min(oldestTimestamp, entry.metadata.createdAt);\n        newestTimestamp = Math.max(newestTimestamp, entry.metadata.updatedAt);\n        \n        // Extract namespace from key\n        const keyStr = entry.metadata.key as string;\n        const namespace = keyStr.split(':')[0];\n        if (namespace) namespaces.add(namespace);\n      }\n    }\n    \n    return {\n      totalKeys: validEntries.length,\n      totalSize,\n      namespaces: Array.from(namespaces),\n      oldestEntry: oldestTimestamp,\n      newestEntry: newestTimestamp,\n      expiredEntries: 0, // Would need to check expiration\n      encryptedEntries: encryptedCount,\n      compressedEntries: compressedCount,\n    };\n  }\n\n  // Utility methods\n  private getPrefixedKey(key: StorageKey): string {\n    return `${this.config.keyPrefix}:${key}`;\n  }\n\n  private isExpired(entry: StorageEntry): boolean {\n    return entry.metadata.expiresAt ? Date.now() > entry.metadata.expiresAt : false;\n  }\n\n  private async getAllKeys(): Promise<string[]> {\n    const allKeys = await this.AsyncStorage.getAllKeys();\n    return allKeys\n      .filter((key: string) => key.startsWith(`${this.config.keyPrefix}:`))\n      .map((key: string) => key.substring(this.config.keyPrefix.length + 1));\n  }\n\n  private async cleanupExpiredStorage(): Promise<number> {\n    const keys = await this.getAllKeys();\n    const expiredKeys: StorageKey[] = [];\n    \n    for (const key of keys) {\n      const entry = await this.get(key as StorageKey);\n      if (!entry || this.isExpired(entry)) {\n        expiredKeys.push(key as StorageKey);\n      }\n    }\n    \n    if (expiredKeys.length > 0) {\n      await this.deleteMany(expiredKeys);\n    }\n    \n    return expiredKeys.length;\n  }\n\n  // Compression utilities (simplified for demo - in production use a proper compression library)\n  private async compress(data: string): Promise<string> {\n    // This is a placeholder - in production, use a proper compression library like pako\n    return data; // For now, return as-is\n  }\n\n  private async decompress(data: string): Promise<string> {\n    // This is a placeholder - in production, use a proper decompression library\n    return data; // For now, return as-is\n  }\n\n  /**\n   * Get performance metrics\n   */\n  getMetrics(): PerformanceMetrics {\n    return { ...this.metrics };\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats() {\n    return {\n      size: this.cache.size(),\n      maxSize: this.config.cacheSize,\n      hitRate: this.metrics.cacheHits / (this.metrics.cacheHits + this.metrics.cacheMisses) || 0,\n    };\n  }\n\n  /**\n   * Force cleanup\n   */\n  async cleanup(): Promise<number> {\n    const cleaned = await this.cleanupExpiredStorage();\n    this.cache.cleanup();\n    console.log(`Cleaned ${cleaned} expired entries`);\n    return cleaned;\n  }\n\n  /**\n   * Destroy adapter and cleanup resources\n   */\n  async destroy(): Promise<void> {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n    }\n    \n    this.writeBatch.clear();\n    this.cache.clear();\n    this.removeAllListeners();\n  }\n}","/**\n * React Native Connectivity Manager\n * Advanced network connectivity handling with intelligent retry, quality monitoring,\n * and adaptive behavior for mobile environments\n * \n * Features:\n * - Real-time network quality monitoring\n * - Intelligent retry strategies based on network conditions\n * - Adaptive timeouts and batch sizes\n * - Background/foreground app state handling\n * - Data usage optimization\n * - Connection pooling and reuse\n */\n\nimport { EventEmitter } from 'eventemitter3';\n\n// Platform detection\nconst isReactNative = typeof navigator !== 'undefined' && \n  ((navigator as any).product === 'ReactNative' || (global as any).__REACT_NATIVE__);\n\n/**\n * Network quality levels\n */\nexport type NetworkQuality = 'excellent' | 'good' | 'fair' | 'poor' | 'unknown';\n\n/**\n * Connection types\n */\nexport type ConnectionType = \n  | 'wifi' \n  | 'cellular' \n  | '2g' \n  | '3g' \n  | '4g' \n  | '5g' \n  | 'ethernet' \n  | 'bluetooth' \n  | 'unknown'\n  | 'none';\n\n/**\n * Network state information\n */\nexport interface NetworkState {\n  isConnected: boolean;\n  connectionType: ConnectionType;\n  quality: NetworkQuality;\n  effectiveType?: '2g' | '3g' | '4g' | 'slow-2g';\n  downlink?: number; // Mbps\n  rtt?: number; // Round trip time in ms\n  saveData?: boolean; // Data saver mode\n  isExpensive?: boolean; // Metered connection\n  strength?: number; // Signal strength 0-100\n  timestamp: number;\n}\n\n/**\n * Retry configuration based on network conditions\n */\nexport interface RetryConfig {\n  maxRetries: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffMultiplier: number;\n  jitter: boolean;\n}\n\n/**\n * Network quality thresholds\n */\ninterface QualityThresholds {\n  excellent: { minDownlink: number; maxRtt: number };\n  good: { minDownlink: number; maxRtt: number };\n  fair: { minDownlink: number; maxRtt: number };\n  poor: { minDownlink: number; maxRtt: number };\n}\n\n/**\n * Connectivity manager configuration\n */\nexport interface ConnectivityConfig {\n  /** Enable network quality monitoring */\n  enableQualityMonitoring?: boolean;\n  \n  /** Quality check interval in ms */\n  qualityCheckInterval?: number;\n  \n  /** Enable adaptive retry strategies */\n  enableAdaptiveRetry?: boolean;\n  \n  /** Enable data usage optimization */\n  enableDataOptimization?: boolean;\n  \n  /** Enable background/foreground optimization */\n  enableAppStateOptimization?: boolean;\n  \n  /** Custom quality thresholds */\n  qualityThresholds?: Partial<QualityThresholds>;\n  \n  /** Retry configurations by network quality */\n  retryConfigs?: Record<NetworkQuality, RetryConfig>;\n  \n  /** Timeout configurations by network quality (ms) */\n  timeoutConfigs?: Record<NetworkQuality, number>;\n  \n  /** Enable connection health monitoring */\n  enableHealthMonitoring?: boolean;\n  \n  /** Health check URL */\n  healthCheckUrl?: string;\n  \n  /** Health check interval in ms */\n  healthCheckInterval?: number;\n}\n\n/**\n * Connectivity events\n */\ninterface ConnectivityEvents {\n  'network:change': { current: NetworkState; previous: NetworkState };\n  'quality:change': { quality: NetworkQuality; previous: NetworkQuality };\n  'connection:lost': { lastState: NetworkState };\n  'connection:restored': { newState: NetworkState };\n  'health:check': { healthy: boolean; latency?: number };\n  'app:background': { networkState: NetworkState };\n  'app:foreground': { networkState: NetworkState };\n  'data:optimization': { enabled: boolean; reason: string };\n}\n\nconst DEFAULT_QUALITY_THRESHOLDS: QualityThresholds = {\n  excellent: { minDownlink: 10, maxRtt: 50 },\n  good: { minDownlink: 2, maxRtt: 150 },\n  fair: { minDownlink: 0.5, maxRtt: 300 },\n  poor: { minDownlink: 0, maxRtt: 1000 },\n};\n\nconst DEFAULT_RETRY_CONFIGS: Record<NetworkQuality, RetryConfig> = {\n  excellent: { maxRetries: 2, baseDelay: 500, maxDelay: 2000, backoffMultiplier: 1.5, jitter: true },\n  good: { maxRetries: 3, baseDelay: 1000, maxDelay: 5000, backoffMultiplier: 2, jitter: true },\n  fair: { maxRetries: 4, baseDelay: 2000, maxDelay: 10000, backoffMultiplier: 2, jitter: true },\n  poor: { maxRetries: 5, baseDelay: 3000, maxDelay: 15000, backoffMultiplier: 2.5, jitter: true },\n  unknown: { maxRetries: 3, baseDelay: 1500, maxDelay: 8000, backoffMultiplier: 2, jitter: true },\n};\n\nconst DEFAULT_TIMEOUT_CONFIGS: Record<NetworkQuality, number> = {\n  excellent: 5000,\n  good: 10000,\n  fair: 15000,\n  poor: 30000,\n  unknown: 15000,\n};\n\nconst DEFAULT_CONFIG: Required<ConnectivityConfig> = {\n  enableQualityMonitoring: true,\n  qualityCheckInterval: 30000, // 30 seconds\n  enableAdaptiveRetry: true,\n  enableDataOptimization: true,\n  enableAppStateOptimization: true,\n  qualityThresholds: DEFAULT_QUALITY_THRESHOLDS,\n  retryConfigs: DEFAULT_RETRY_CONFIGS,\n  timeoutConfigs: DEFAULT_TIMEOUT_CONFIGS,\n  enableHealthMonitoring: true,\n  healthCheckUrl: 'https://ereceipts-it.acubeapi.com/health',\n  healthCheckInterval: 60000, // 1 minute\n};\n\n/**\n * React Native Connectivity Manager\n */\nexport class ConnectivityManager extends EventEmitter<ConnectivityEvents> {\n  private config: Required<ConnectivityConfig>;\n  private currentState: NetworkState;\n  private previousState?: NetworkState;\n  private isInitialized = false;\n  \n  // React Native modules\n  private NetInfo: any;\n  private AppState: any;\n  \n  // Monitoring timers\n  private qualityTimer?: NodeJS.Timeout;\n  private healthTimer?: NodeJS.Timeout;\n  \n  // Connection health tracking\n  private healthHistory: boolean[] = [];\n  private currentAppState: 'active' | 'background' | 'inactive' = 'active';\n  \n  constructor(config: ConnectivityConfig = {}) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.currentState = this.getInitialState();\n    \n    this.initialize();\n  }\n\n  private getInitialState(): NetworkState {\n    return {\n      isConnected: false,\n      connectionType: 'unknown',\n      quality: 'unknown',\n      timestamp: Date.now(),\n    };\n  }\n\n  private async initialize(): Promise<void> {\n    if (this.isInitialized || !isReactNative) return;\n\n    try {\n      // Dynamically import React Native modules\n      const NetInfoModule = await import('@react-native-community/netinfo');\n      this.NetInfo = NetInfoModule.default;\n\n      const AppStateModule = await import('react-native');\n      this.AppState = AppStateModule.AppState;\n\n      // Setup listeners\n      this.setupNetworkListener();\n      this.setupAppStateListener();\n\n      // Start monitoring\n      if (this.config.enableQualityMonitoring) {\n        this.startQualityMonitoring();\n      }\n\n      if (this.config.enableHealthMonitoring) {\n        this.startHealthMonitoring();\n      }\n\n      // Get initial network state\n      await this.updateNetworkState();\n\n      this.isInitialized = true;\n    } catch (error) {\n      console.warn('Failed to initialize ConnectivityManager:', error);\n      // Fallback to basic connectivity detection\n      this.setupFallbackDetection();\n    }\n  }\n\n  private setupNetworkListener(): void {\n    if (!this.NetInfo) return;\n\n    this.NetInfo.addEventListener((state: any) => {\n      this.handleNetworkStateChange(state);\n    });\n  }\n\n  private setupAppStateListener(): void {\n    if (!this.AppState) return;\n\n    this.AppState.addEventListener('change', (nextAppState: string) => {\n      const previousAppState = this.currentAppState;\n      this.currentAppState = nextAppState as any;\n\n      if (previousAppState === 'background' && nextAppState === 'active') {\n        this.emit('app:foreground', { networkState: this.currentState });\n        // Refresh network state when coming back to foreground\n        this.updateNetworkState();\n      } else if (previousAppState === 'active' && nextAppState === 'background') {\n        this.emit('app:background', { networkState: this.currentState });\n      }\n    });\n  }\n\n  private setupFallbackDetection(): void {\n    // Basic online/offline detection\n    if (typeof window !== 'undefined') {\n      window.addEventListener('online', () => {\n        this.currentState = {\n          ...this.currentState,\n          isConnected: true,\n          timestamp: Date.now(),\n        };\n        this.emit('connection:restored', { newState: this.currentState });\n      });\n\n      window.addEventListener('offline', () => {\n        const lastState = { ...this.currentState };\n        this.currentState = {\n          ...this.currentState,\n          isConnected: false,\n          timestamp: Date.now(),\n        };\n        this.emit('connection:lost', { lastState });\n      });\n    }\n  }\n\n  private async handleNetworkStateChange(netInfoState: any): Promise<void> {\n    this.previousState = { ...this.currentState };\n    \n    const newState: NetworkState = {\n      isConnected: netInfoState.isConnected,\n      connectionType: this.mapConnectionType(netInfoState.type, netInfoState.details),\n      quality: this.calculateNetworkQuality(netInfoState),\n      effectiveType: netInfoState.details?.effectiveType,\n      downlink: netInfoState.details?.downlink,\n      rtt: netInfoState.details?.rtt,\n      saveData: netInfoState.details?.saveData,\n      isExpensive: netInfoState.details?.isConnectionExpensive,\n      strength: netInfoState.details?.strength,\n      timestamp: Date.now(),\n    };\n\n    this.currentState = newState;\n\n    // Emit events\n    this.emit('network:change', { current: newState, previous: this.previousState });\n\n    if (this.previousState.quality !== newState.quality) {\n      this.emit('quality:change', { \n        quality: newState.quality, \n        previous: this.previousState.quality \n      });\n    }\n\n    if (!this.previousState.isConnected && newState.isConnected) {\n      this.emit('connection:restored', { newState });\n    } else if (this.previousState.isConnected && !newState.isConnected) {\n      this.emit('connection:lost', { lastState: this.previousState });\n    }\n\n    // Handle data optimization\n    if (this.config.enableDataOptimization) {\n      this.handleDataOptimization(newState);\n    }\n  }\n\n  private mapConnectionType(type: string, details: any): ConnectionType {\n    if (!type || type === 'none') return 'none';\n    \n    switch (type.toLowerCase()) {\n      case 'wifi':\n        return 'wifi';\n      case 'cellular':\n        // Try to determine cellular generation\n        if (details?.cellularGeneration) {\n          switch (details.cellularGeneration) {\n            case '2g': return '2g';\n            case '3g': return '3g';\n            case '4g': return '4g';\n            case '5g': return '5g';\n            default: return 'cellular';\n          }\n        }\n        return 'cellular';\n      case 'ethernet':\n        return 'ethernet';\n      case 'bluetooth':\n        return 'bluetooth';\n      default:\n        return 'unknown';\n    }\n  }\n\n  private calculateNetworkQuality(netInfoState: any): NetworkQuality {\n    const { details } = netInfoState;\n    if (!details) return 'unknown';\n\n    const downlink = details.downlink || 0;\n    const rtt = details.rtt || 1000;\n    const qualityThresholds = {\n      ...DEFAULT_QUALITY_THRESHOLDS,\n      ...this.config.qualityThresholds,\n    };\n\n    if (downlink >= qualityThresholds.excellent.minDownlink && rtt <= qualityThresholds.excellent.maxRtt) {\n      return 'excellent';\n    } else if (downlink >= qualityThresholds.good.minDownlink && rtt <= qualityThresholds.good.maxRtt) {\n      return 'good';\n    } else if (downlink >= qualityThresholds.fair.minDownlink && rtt <= qualityThresholds.fair.maxRtt) {\n      return 'fair';\n    } else if (downlink >= qualityThresholds.poor.minDownlink && rtt <= qualityThresholds.poor.maxRtt) {\n      return 'poor';\n    }\n\n    return 'unknown';\n  }\n\n  private handleDataOptimization(networkState: NetworkState): void {\n    const shouldOptimize = \n      networkState.saveData || \n      networkState.isExpensive ||\n      networkState.quality === 'poor' ||\n      ['2g', '3g'].includes(networkState.connectionType);\n\n    if (shouldOptimize) {\n      const reason = networkState.saveData ? 'data_saver' :\n                   networkState.isExpensive ? 'expensive_connection' :\n                   networkState.quality === 'poor' ? 'poor_quality' :\n                   'slow_connection';\n\n      this.emit('data:optimization', { enabled: true, reason });\n    } else {\n      this.emit('data:optimization', { enabled: false, reason: 'good_connection' });\n    }\n  }\n\n  private startQualityMonitoring(): void {\n    this.qualityTimer = setInterval(async () => {\n      if (this.currentAppState === 'active') {\n        await this.updateNetworkState();\n      }\n    }, this.config.qualityCheckInterval) as unknown as NodeJS.Timeout;\n  }\n\n  private startHealthMonitoring(): void {\n    this.healthTimer = setInterval(async () => {\n      if (this.currentState.isConnected && this.currentAppState === 'active') {\n        await this.performHealthCheck();\n      }\n    }, this.config.healthCheckInterval) as unknown as NodeJS.Timeout;\n  }\n\n  private async updateNetworkState(): Promise<void> {\n    if (!this.NetInfo) return;\n\n    try {\n      const netInfoState = await this.NetInfo.fetch();\n      await this.handleNetworkStateChange(netInfoState);\n    } catch (error) {\n      console.warn('Failed to fetch network state:', error);\n    }\n  }\n\n  private async performHealthCheck(): Promise<void> {\n    try {\n      const startTime = Date.now();\n      const controller = new AbortController();\n      const timeout = setTimeout(() => controller.abort(), 5000);\n\n      const response = await fetch(this.config.healthCheckUrl, {\n        method: 'HEAD',\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeout);\n      const latency = Date.now() - startTime;\n      const healthy = response.ok;\n\n      // Update health history\n      this.healthHistory.push(healthy);\n      if (this.healthHistory.length > 10) {\n        this.healthHistory.shift();\n      }\n\n      this.emit('health:check', { healthy, latency });\n    } catch (error) {\n      this.healthHistory.push(false);\n      if (this.healthHistory.length > 10) {\n        this.healthHistory.shift();\n      }\n      \n      this.emit('health:check', { healthy: false });\n    }\n  }\n\n  /**\n   * Get current network state\n   */\n  getNetworkState(): NetworkState {\n    return { ...this.currentState };\n  }\n\n  /**\n   * Check if network is available\n   */\n  isConnected(): boolean {\n    return this.currentState.isConnected;\n  }\n\n  /**\n   * Get current network quality\n   */\n  getNetworkQuality(): NetworkQuality {\n    return this.currentState.quality;\n  }\n\n  /**\n   * Get retry configuration for current network conditions\n   */\n  getRetryConfig(): RetryConfig {\n    return this.config.retryConfigs[this.currentState.quality];\n  }\n\n  /**\n   * Get timeout for current network conditions\n   */\n  getTimeout(): number {\n    return this.config.timeoutConfigs[this.currentState.quality];\n  }\n\n  /**\n   * Check if data optimization should be enabled\n   */\n  shouldOptimizeData(): boolean {\n    return (\n      this.currentState.saveData ||\n      this.currentState.isExpensive ||\n      this.currentState.quality === 'poor' ||\n      ['2g', '3g'].includes(this.currentState.connectionType)\n    );\n  }\n\n  /**\n   * Get connection health score (0-1)\n   */\n  getHealthScore(): number {\n    if (this.healthHistory.length === 0) return 1;\n    \n    const successCount = this.healthHistory.filter(h => h).length;\n    return successCount / this.healthHistory.length;\n  }\n\n  /**\n   * Wait for network connection to be restored\n   */\n  async waitForConnection(timeout: number = 30000): Promise<boolean> {\n    if (this.currentState.isConnected) return true;\n\n    return new Promise((resolve) => {\n      const timer = setTimeout(() => {\n        this.off('connection:restored', onRestored);\n        resolve(false);\n      }, timeout);\n\n      const onRestored = () => {\n        clearTimeout(timer);\n        resolve(true);\n      };\n\n      this.once('connection:restored', onRestored);\n    });\n  }\n\n  /**\n   * Execute a network operation with intelligent retry\n   */\n  async executeWithRetry<T>(\n    operation: () => Promise<T>,\n    customRetryConfig?: Partial<RetryConfig>\n  ): Promise<T> {\n    const config = { ...this.getRetryConfig(), ...customRetryConfig };\n    let lastError: Error;\n\n    for (let attempt = 0; attempt <= config.maxRetries; attempt++) {\n      try {\n        // Wait for connection if not available\n        if (!this.currentState.isConnected) {\n          const connected = await this.waitForConnection(10000);\n          if (!connected) {\n            throw new Error('Network not available');\n          }\n        }\n\n        return await operation();\n      } catch (error) {\n        lastError = error as Error;\n\n        // Don't retry on the last attempt\n        if (attempt === config.maxRetries) break;\n\n        // Calculate delay with backoff and jitter\n        let delay = Math.min(\n          config.baseDelay * Math.pow(config.backoffMultiplier, attempt),\n          config.maxDelay\n        );\n\n        if (config.jitter) {\n          delay *= (0.5 + Math.random() * 0.5); // 50-100% of calculated delay\n        }\n\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n\n    throw lastError!;\n  }\n\n  /**\n   * Get adaptive batch size based on network conditions\n   */\n  getAdaptiveBatchSize(baseBatchSize: number = 50): number {\n    switch (this.currentState.quality) {\n      case 'excellent':\n        return Math.min(baseBatchSize * 2, 200);\n      case 'good':\n        return baseBatchSize;\n      case 'fair':\n        return Math.max(Math.floor(baseBatchSize * 0.7), 10);\n      case 'poor':\n        return Math.max(Math.floor(baseBatchSize * 0.3), 5);\n      default:\n        return Math.max(Math.floor(baseBatchSize * 0.5), 10);\n    }\n  }\n\n  /**\n   * Destroy the connectivity manager\n   */\n  destroy(): void {\n    if (this.qualityTimer) {\n      clearInterval(this.qualityTimer);\n    }\n\n    if (this.healthTimer) {\n      clearInterval(this.healthTimer);\n    }\n\n    this.removeAllListeners();\n  }\n}","/**\n * React Native Background Processor\n * Handles background tasks, sync operations, and app lifecycle management\n * with intelligent scheduling and resource management\n * \n * Features:\n * - Background task scheduling and execution\n * - App state-aware processing\n * - Battery and performance optimization\n * - Push notification triggers\n * - Sync queue management\n * - Resource usage monitoring\n */\n\nimport { EventEmitter } from 'eventemitter3';\n\n// Platform detection\nconst isReactNative = typeof navigator !== 'undefined' && \n  ((navigator as any).product === 'ReactNative' || (global as any).__REACT_NATIVE__);\n\n/**\n * Background task types\n */\nexport type BackgroundTaskType = \n  | 'sync' \n  | 'upload' \n  | 'cleanup' \n  | 'analytics' \n  | 'cache_warmup'\n  | 'notification'\n  | 'custom';\n\n/**\n * Task priority levels\n */\nexport type TaskPriority = 'critical' | 'high' | 'normal' | 'low';\n\n/**\n * Background task definition\n */\nexport interface BackgroundTask {\n  id: string;\n  type: BackgroundTaskType;\n  priority: TaskPriority;\n  data: any;\n  executionTime?: number; // Specific time to execute\n  delay?: number; // Delay from now in ms\n  interval?: number; // For recurring tasks\n  maxRetries?: number;\n  retryCount?: number;\n  createdAt: number;\n  maxExecutionTime?: number; // Max time allowed for execution\n  requiredNetworkType?: 'any' | 'wifi' | 'cellular';\n  requiresCharging?: boolean;\n  requiresDeviceIdle?: boolean;\n}\n\n/**\n * Task execution result\n */\nexport interface TaskResult {\n  success: boolean;\n  data?: any;\n  error?: Error;\n  executionTime: number;\n  retryAfter?: number; // Suggest retry delay in ms\n}\n\n/**\n * App state types\n */\nexport type AppState = 'active' | 'background' | 'inactive';\n\n/**\n * Battery state\n */\nexport interface BatteryState {\n  level: number; // 0-1\n  isCharging: boolean;\n  isLowPowerMode?: boolean;\n}\n\n/**\n * Background processor configuration\n */\nexport interface BackgroundProcessorConfig {\n  /** Maximum concurrent background tasks */\n  maxConcurrentTasks?: number;\n  \n  /** Default task timeout in ms */\n  defaultTaskTimeout?: number;\n  \n  /** Enable battery optimization */\n  enableBatteryOptimization?: boolean;\n  \n  /** Minimum battery level for non-critical tasks */\n  minBatteryLevel?: number;\n  \n  /** Enable app state management */\n  enableAppStateManagement?: boolean;\n  \n  /** Maximum background execution time in ms */\n  maxBackgroundTime?: number;\n  \n  /** Enable task persistence */\n  enableTaskPersistence?: boolean;\n  \n  /** Storage key for task persistence */\n  persistenceKey?: string;\n  \n  /** Enable resource monitoring */\n  enableResourceMonitoring?: boolean;\n  \n  /** CPU usage threshold for throttling */\n  cpuThrottleThreshold?: number;\n  \n  /** Memory usage threshold for throttling */\n  memoryThrottleThreshold?: number;\n}\n\n/**\n * Background processor events\n */\ninterface BackgroundProcessorEvents {\n  'task:scheduled': { task: BackgroundTask };\n  'task:started': { task: BackgroundTask };\n  'task:completed': { task: BackgroundTask; result: TaskResult };\n  'task:failed': { task: BackgroundTask; error: Error };\n  'task:retry': { task: BackgroundTask; attempt: number };\n  'queue:empty': {};\n  'queue:full': { queueSize: number };\n  'app:background': { remainingTime?: number };\n  'app:foreground': {};\n  'battery:low': { level: number };\n  'battery:charging': { isCharging: boolean };\n  'resource:throttle': { reason: 'cpu' | 'memory' | 'battery' };\n  'resource:resume': { reason: string };\n}\n\n/**\n * Task executor function type\n */\nexport type TaskExecutor = (task: BackgroundTask, signal: AbortSignal) => Promise<TaskResult>;\n\nconst DEFAULT_CONFIG: Required<BackgroundProcessorConfig> = {\n  maxConcurrentTasks: 3,\n  defaultTaskTimeout: 30000, // 30 seconds\n  enableBatteryOptimization: true,\n  minBatteryLevel: 0.15, // 15%\n  enableAppStateManagement: true,\n  maxBackgroundTime: 30000, // 30 seconds (iOS limit)\n  enableTaskPersistence: true,\n  persistenceKey: 'acube_background_tasks',\n  enableResourceMonitoring: true,\n  cpuThrottleThreshold: 80, // 80%\n  memoryThrottleThreshold: 80, // 80%\n};\n\n/**\n * React Native Background Processor\n */\nexport class BackgroundProcessor extends EventEmitter<BackgroundProcessorEvents> {\n  private config: Required<BackgroundProcessorConfig>;\n  private taskQueue: BackgroundTask[] = [];\n  private activeTasks = new Map<string, { task: BackgroundTask; controller: AbortController }>();\n  private taskExecutors = new Map<BackgroundTaskType, TaskExecutor>();\n  private isInitialized = false;\n  private isPaused = false;\n  \n  // React Native modules\n  private AppState: any;\n  private BackgroundTask: any;\n  private AsyncStorage: any;\n  \n  // State tracking\n  private currentAppState: AppState = 'active';\n  private batteryState: BatteryState = { level: 1, isCharging: false };\n  private backgroundTaskId: number | undefined;\n  private resourceMonitorTimer?: NodeJS.Timeout;\n  \n  // Performance tracking\n  private executionStats = {\n    totalTasks: 0,\n    successfulTasks: 0,\n    failedTasks: 0,\n    avgExecutionTime: 0,\n    totalExecutionTime: 0,\n  };\n\n  constructor(config: BackgroundProcessorConfig = {}) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    \n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    if (this.isInitialized || !isReactNative) return;\n\n    try {\n      // Import React Native modules\n      const RNModules = await import('react-native');\n      this.AppState = RNModules.AppState;\n      // BackgroundTask is not available in React Native\n      // this.BackgroundTask = RNModules.BackgroundTask;\n      // PushNotificationIOS deprecated\n      // this._PushNotificationIOS = RNModules.PushNotificationIOS;\n\n      const AsyncStorageModule = await import('@react-native-async-storage/async-storage');\n      this.AsyncStorage = AsyncStorageModule.default;\n\n      // Setup listeners\n      if (this.config.enableAppStateManagement) {\n        this.setupAppStateListener();\n      }\n\n      if (this.config.enableBatteryOptimization) {\n        this.setupBatteryMonitoring();\n      }\n\n      if (this.config.enableResourceMonitoring) {\n        this.startResourceMonitoring();\n      }\n\n      // Load persisted tasks\n      if (this.config.enableTaskPersistence) {\n        await this.loadPersistedTasks();\n      }\n\n      // Register default task executors\n      this.registerDefaultExecutors();\n\n      this.isInitialized = true;\n      console.log('BackgroundProcessor initialized');\n    } catch (error) {\n      console.warn('Failed to initialize BackgroundProcessor:', error);\n    }\n  }\n\n  private setupAppStateListener(): void {\n    if (!this.AppState) return;\n\n    this.AppState.addEventListener('change', (nextAppState: AppState) => {\n      const previousAppState = this.currentAppState;\n      this.currentAppState = nextAppState;\n\n      if (previousAppState === 'active' && nextAppState === 'background') {\n        this.handleAppBackground();\n      } else if (previousAppState === 'background' && nextAppState === 'active') {\n        this.handleAppForeground();\n      }\n    });\n  }\n\n  private async setupBatteryMonitoring(): Promise<void> {\n    try {\n      // Try to import battery monitoring\n      const DeviceInfo = await import('react-native-device-info');\n      \n      // Initial battery state\n      const batteryLevel = await DeviceInfo.default.getBatteryLevel();\n      const isCharging = (await DeviceInfo.default.getPowerState()).batteryState === 'charging';\n      const isPowerSaveMode = (await DeviceInfo.default.getPowerState()).lowPowerMode;\n      \n      this.batteryState = {\n        level: batteryLevel,\n        isCharging,\n        isLowPowerMode: !!isPowerSaveMode,\n      };\n\n      // Monitor battery changes\n      setInterval(async () => {\n        const newLevel = await DeviceInfo.default.getBatteryLevel();\n        const newCharging = (await DeviceInfo.default.getPowerState()).batteryState === 'charging';\n        const newPowerSave = (await DeviceInfo.default.getPowerState()).lowPowerMode;\n\n        const previousCharging = this.batteryState.isCharging;\n        const previousLevel = this.batteryState.level;\n\n        this.batteryState = {\n          level: newLevel,\n          isCharging: newCharging,\n          isLowPowerMode: !!newPowerSave,\n        };\n\n        // Emit events\n        if (newCharging !== previousCharging) {\n          this.emit('battery:charging', { isCharging: newCharging });\n        }\n\n        if (newLevel < this.config.minBatteryLevel && previousLevel >= this.config.minBatteryLevel) {\n          this.emit('battery:low', { level: newLevel });\n          this.pauseNonCriticalTasks();\n        }\n      }, 30000); // Check every 30 seconds\n    } catch (error) {\n      console.warn('Battery monitoring not available:', error);\n    }\n  }\n\n  private startResourceMonitoring(): void {\n    this.resourceMonitorTimer = setInterval(async () => {\n      try {\n        // Monitor memory usage (simplified)\n        const memoryInfo = await this.getMemoryInfo();\n        const cpuUsage = await this.getCPUUsage();\n\n        if (memoryInfo.usage > this.config.memoryThrottleThreshold) {\n          this.emit('resource:throttle', { reason: 'memory' });\n          this.throttleExecution();\n        } else if (cpuUsage > this.config.cpuThrottleThreshold) {\n          this.emit('resource:throttle', { reason: 'cpu' });\n          this.throttleExecution();\n        } else if (this.isPaused) {\n          this.emit('resource:resume', { reason: 'resources_available' });\n          this.resumeExecution();\n        }\n      } catch (error) {\n        console.warn('Resource monitoring failed:', error);\n      }\n    }, 10000) as unknown as NodeJS.Timeout; // Check every 10 seconds\n  }\n\n  private async getMemoryInfo(): Promise<{ usage: number; total: number }> {\n    // This would use a proper memory monitoring library in production\n    return { usage: 50, total: 100 }; // Placeholder\n  }\n\n  private async getCPUUsage(): Promise<number> {\n    // This would use a proper CPU monitoring library in production\n    return 30; // Placeholder\n  }\n\n  private handleAppBackground(): void {\n    console.log('App went to background');\n    \n    // Start background task to extend execution time\n    if (this.BackgroundTask && this.taskQueue.length > 0) {\n      this.backgroundTaskId = this.BackgroundTask.start({\n        taskName: 'ACubeBackgroundSync',\n        taskDescriptor: 'Syncing e-receipt data',\n      });\n\n      // Set a timer for when background time runs out\n      setTimeout(() => {\n        this.handleBackgroundTimeExpired();\n      }, this.config.maxBackgroundTime);\n    }\n\n    this.emit('app:background', { remainingTime: this.config.maxBackgroundTime });\n    \n    // Process critical tasks immediately\n    this.processCriticalTasks();\n  }\n\n  private handleAppForeground(): void {\n    console.log('App came to foreground');\n    \n    // End background task\n    if (this.backgroundTaskId && this.BackgroundTask) {\n      this.BackgroundTask.finish(this.backgroundTaskId);\n      this.backgroundTaskId = undefined;\n    }\n\n    this.emit('app:foreground', {});\n    \n    // Resume normal processing\n    this.resumeExecution();\n    this.processQueue();\n  }\n\n  private handleBackgroundTimeExpired(): void {\n    console.log('Background time expired, pausing non-critical tasks');\n    \n    // Cancel non-critical tasks\n    for (const [taskId, { task, controller }] of this.activeTasks) {\n      if (task.priority !== 'critical') {\n        controller.abort();\n        this.activeTasks.delete(taskId);\n      }\n    }\n\n    // End background task\n    if (this.backgroundTaskId && this.BackgroundTask) {\n      this.BackgroundTask.finish(this.backgroundTaskId);\n      this.backgroundTaskId = undefined;\n    }\n  }\n\n  private async processCriticalTasks(): Promise<void> {\n    const criticalTasks = this.taskQueue.filter(task => task.priority === 'critical');\n    \n    for (const task of criticalTasks) {\n      if (this.activeTasks.size < this.config.maxConcurrentTasks) {\n        await this.executeTask(task);\n      }\n    }\n  }\n\n  private pauseNonCriticalTasks(): void {\n    this.isPaused = true;\n    \n    // Cancel non-critical running tasks\n    for (const [taskId, { task, controller }] of this.activeTasks) {\n      if (task.priority !== 'critical') {\n        controller.abort();\n        this.activeTasks.delete(taskId);\n        // Re-queue the task\n        this.taskQueue.unshift(task);\n      }\n    }\n  }\n\n  private throttleExecution(): void {\n    this.isPaused = true;\n    console.log('Throttling background execution due to resource constraints');\n  }\n\n  private resumeExecution(): void {\n    if (this.isPaused) {\n      this.isPaused = false;\n      console.log('Resuming background execution');\n      this.processQueue();\n    }\n  }\n\n  private registerDefaultExecutors(): void {\n    // Sync task executor\n    this.registerExecutor('sync', async (_task: BackgroundTask, signal: AbortSignal) => {\n      const startTime = Date.now();\n      \n      try {\n        // Simulate sync operation\n        await new Promise((resolve, reject) => {\n          const timeout = setTimeout(resolve, Math.random() * 2000 + 1000);\n          \n          signal.addEventListener('abort', () => {\n            clearTimeout(timeout);\n            reject(new Error('Task aborted'));\n          });\n        });\n\n        return {\n          success: true,\n          data: { syncedItems: Math.floor(Math.random() * 10) + 1 },\n          executionTime: Date.now() - startTime,\n        };\n      } catch (error) {\n        return {\n          success: false,\n          error: error as Error,\n          executionTime: Date.now() - startTime,\n        };\n      }\n    });\n\n    // Cleanup task executor\n    this.registerExecutor('cleanup', async (_task: BackgroundTask, signal: AbortSignal) => {\n      const startTime = Date.now();\n      \n      try {\n        // Simulate cleanup operation\n        await new Promise((resolve, reject) => {\n          const timeout = setTimeout(resolve, 500);\n          \n          signal.addEventListener('abort', () => {\n            clearTimeout(timeout);\n            reject(new Error('Task aborted'));\n          });\n        });\n\n        return {\n          success: true,\n          data: { cleanedItems: Math.floor(Math.random() * 5) + 1 },\n          executionTime: Date.now() - startTime,\n        };\n      } catch (error) {\n        return {\n          success: false,\n          error: error as Error,\n          executionTime: Date.now() - startTime,\n        };\n      }\n    });\n  }\n\n  /**\n   * Register a task executor\n   */\n  registerExecutor(type: BackgroundTaskType, executor: TaskExecutor): void {\n    this.taskExecutors.set(type, executor);\n  }\n\n  /**\n   * Schedule a new background task\n   */\n  async scheduleTask(task: Omit<BackgroundTask, 'id' | 'createdAt' | 'retryCount'>): Promise<string> {\n    const fullTask: BackgroundTask = {\n      ...task,\n      id: this.generateTaskId(),\n      createdAt: Date.now(),\n      retryCount: 0,\n      maxRetries: task.maxRetries || 3,\n    };\n\n    this.taskQueue.push(fullTask);\n    this.sortTaskQueue();\n\n    this.emit('task:scheduled', { task: fullTask });\n\n    // Persist task if enabled\n    if (this.config.enableTaskPersistence) {\n      await this.persistTasks();\n    }\n\n    // Process queue if not paused\n    if (!this.isPaused) {\n      this.processQueue();\n    }\n\n    return fullTask.id;\n  }\n\n  /**\n   * Cancel a scheduled task\n   */\n  async cancelTask(taskId: string): Promise<boolean> {\n    // Remove from queue\n    const queueIndex = this.taskQueue.findIndex(task => task.id === taskId);\n    if (queueIndex >= 0) {\n      this.taskQueue.splice(queueIndex, 1);\n      await this.persistTasks();\n      return true;\n    }\n\n    // Cancel if running\n    const activeTask = this.activeTasks.get(taskId);\n    if (activeTask) {\n      activeTask.controller.abort();\n      this.activeTasks.delete(taskId);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Get task status\n   */\n  getTaskStatus(taskId: string): 'queued' | 'running' | 'completed' | 'not_found' {\n    if (this.taskQueue.some(task => task.id === taskId)) {\n      return 'queued';\n    }\n    \n    if (this.activeTasks.has(taskId)) {\n      return 'running';\n    }\n    \n    return 'not_found';\n  }\n\n  /**\n   * Get queue statistics\n   */\n  getQueueStats() {\n    return {\n      queued: this.taskQueue.length,\n      running: this.activeTasks.size,\n      isPaused: this.isPaused,\n      currentAppState: this.currentAppState,\n      batteryLevel: this.batteryState.level,\n      isCharging: this.batteryState.isCharging,\n      ...this.executionStats,\n    };\n  }\n\n  private sortTaskQueue(): void {\n    // Sort by priority, then by execution time/delay\n    this.taskQueue.sort((a, b) => {\n      const priorityOrder = { critical: 4, high: 3, normal: 2, low: 1 };\n      const aPriority = priorityOrder[a.priority];\n      const bPriority = priorityOrder[b.priority];\n      \n      if (aPriority !== bPriority) {\n        return bPriority - aPriority; // Higher priority first\n      }\n      \n      // If same priority, sort by execution time\n      const aTime = a.executionTime || (a.createdAt + (a.delay || 0));\n      const bTime = b.executionTime || (b.createdAt + (b.delay || 0));\n      \n      return aTime - bTime; // Earlier time first\n    });\n  }\n\n  private async processQueue(): Promise<void> {\n    if (this.isPaused || this.taskQueue.length === 0) return;\n\n    const now = Date.now();\n    \n    while (\n      this.taskQueue.length > 0 && \n      this.activeTasks.size < this.config.maxConcurrentTasks &&\n      !this.isPaused\n    ) {\n      const task = this.taskQueue[0];\n      if (!task) break;\n      \n      // Check if task is ready to execute\n      const executionTime = task.executionTime || (task.createdAt + (task.delay || 0));\n      if (executionTime > now) {\n        break; // Wait for the right time\n      }\n\n      // Check execution conditions\n      if (!this.canExecuteTask(task)) {\n        break;\n      }\n\n      // Remove from queue and execute\n      this.taskQueue.shift();\n      await this.executeTask(task);\n    }\n\n    // Schedule next processing if there are more tasks\n    if (this.taskQueue.length > 0) {\n      const nextTask = this.taskQueue[0];\n      if (nextTask) {\n        const nextExecutionTime = nextTask.executionTime || (nextTask.createdAt + (nextTask.delay || 0));\n        const delay = Math.max(0, nextExecutionTime - now);\n        \n        setTimeout(() => this.processQueue(), delay);\n      }\n    } else {\n      this.emit('queue:empty', {});\n    }\n  }\n\n  private canExecuteTask(task: BackgroundTask): boolean {\n    // Check battery level for non-critical tasks\n    if (\n      this.config.enableBatteryOptimization &&\n      task.priority !== 'critical' &&\n      this.batteryState.level < this.config.minBatteryLevel &&\n      !this.batteryState.isCharging\n    ) {\n      return false;\n    }\n\n    // Check network requirements (would need ConnectivityManager integration)\n    // This is a placeholder for network checks\n    \n    // Check if device should be idle (placeholder)\n    if (task.requiresDeviceIdle && this.currentAppState === 'active') {\n      return false;\n    }\n\n    return true;\n  }\n\n  private async executeTask(task: BackgroundTask): Promise<void> {\n    const executor = this.taskExecutors.get(task.type);\n    if (!executor) {\n      console.warn(`No executor found for task type: ${task.type}`);\n      return;\n    }\n\n    const controller = new AbortController();\n    this.activeTasks.set(task.id, { task, controller });\n\n    this.emit('task:started', { task });\n\n    // Set timeout\n    const timeout = setTimeout(() => {\n      controller.abort();\n    }, task.maxExecutionTime || this.config.defaultTaskTimeout);\n\n    try {\n      const result = await executor(task, controller.signal);\n      clearTimeout(timeout);\n\n      this.handleTaskResult(task, result);\n    } catch (error) {\n      clearTimeout(timeout);\n      this.handleTaskError(task, error as Error);\n    } finally {\n      this.activeTasks.delete(task.id);\n      await this.persistTasks();\n    }\n  }\n\n  private handleTaskResult(task: BackgroundTask, result: TaskResult): void {\n    this.executionStats.totalTasks++;\n    this.executionStats.totalExecutionTime += result.executionTime;\n    this.executionStats.avgExecutionTime = \n      this.executionStats.totalExecutionTime / this.executionStats.totalTasks;\n\n    if (result.success) {\n      this.executionStats.successfulTasks++;\n      this.emit('task:completed', { task, result });\n    } else {\n      this.handleTaskError(task, result.error || new Error('Task failed'));\n    }\n  }\n\n  private async handleTaskError(task: BackgroundTask, error: Error): Promise<void> {\n    this.executionStats.failedTasks++;\n\n    const retryCount = task.retryCount || 0;\n    if (retryCount < (task.maxRetries || 3)) {\n      // Retry the task\n      const retryTask: BackgroundTask = {\n        ...task,\n        retryCount: retryCount + 1,\n        delay: Math.pow(2, retryCount) * 1000, // Exponential backoff\n      };\n\n      this.taskQueue.unshift(retryTask);\n      this.emit('task:retry', { task: retryTask, attempt: retryCount + 1 });\n      \n      // Process queue after a delay\n      setTimeout(() => this.processQueue(), 1000);\n    } else {\n      // Task failed permanently\n      this.emit('task:failed', { task, error });\n    }\n  }\n\n  private generateTaskId(): string {\n    return `task_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;\n  }\n\n  private async persistTasks(): Promise<void> {\n    if (!this.AsyncStorage) return;\n\n    try {\n      const tasksToSave = this.taskQueue.filter(task => \n        // Only persist tasks that should survive app restarts\n        task.type === 'sync' || task.priority === 'critical'\n      );\n\n      await this.AsyncStorage.setItem(\n        this.config.persistenceKey,\n        JSON.stringify(tasksToSave)\n      );\n    } catch (error) {\n      console.warn('Failed to persist tasks:', error);\n    }\n  }\n\n  private async loadPersistedTasks(): Promise<void> {\n    if (!this.AsyncStorage) return;\n\n    try {\n      const persistedTasks = await this.AsyncStorage.getItem(this.config.persistenceKey);\n      if (persistedTasks) {\n        const tasks: BackgroundTask[] = JSON.parse(persistedTasks);\n        this.taskQueue.push(...tasks);\n        this.sortTaskQueue();\n        \n        // Clear persisted tasks\n        await this.AsyncStorage.removeItem(this.config.persistenceKey);\n      }\n    } catch (error) {\n      console.warn('Failed to load persisted tasks:', error);\n    }\n  }\n\n  /**\n   * Force process all critical tasks immediately\n   */\n  async processCriticalTasksImmediately(): Promise<void> {\n    const criticalTasks = this.taskQueue.filter(task => task.priority === 'critical');\n    \n    for (const task of criticalTasks) {\n      await this.executeTask(task);\n      this.taskQueue = this.taskQueue.filter(t => t.id !== task.id);\n    }\n    \n    await this.persistTasks();\n  }\n\n  /**\n   * Pause all background processing\n   */\n  pause(): void {\n    this.isPaused = true;\n  }\n\n  /**\n   * Resume background processing\n   */\n  resume(): void {\n    this.isPaused = false;\n    this.processQueue();\n  }\n\n  /**\n   * Clear all queued tasks\n   */\n  async clearQueue(): Promise<void> {\n    this.taskQueue = [];\n    await this.persistTasks();\n  }\n\n  /**\n   * Destroy the background processor\n   */\n  destroy(): void {\n    // Cancel all active tasks\n    for (const [, { controller }] of this.activeTasks) {\n      controller.abort();\n    }\n    this.activeTasks.clear();\n\n    // Clear timers\n    if (this.resourceMonitorTimer) {\n      clearInterval(this.resourceMonitorTimer);\n    }\n\n    // End background task if running\n    if (this.backgroundTaskId && this.BackgroundTask) {\n      this.BackgroundTask.finish(this.backgroundTaskId);\n    }\n\n    this.removeAllListeners();\n  }\n}","/**\n * React Native Performance Monitor\n * Comprehensive performance monitoring and optimization for mobile environments\n * \n * Features:\n * - App startup time monitoring\n * - Memory usage tracking\n * - CPU performance monitoring\n * - Network request performance\n * - Frame rate monitoring\n * - Bundle size analysis\n * - Battery usage tracking\n * - Crash and error reporting\n * - User experience metrics\n */\n\nimport { EventEmitter } from 'eventemitter3';\n\n// Platform detection\nconst isReactNative = typeof navigator !== 'undefined' && \n  ((navigator as any).product === 'ReactNative' || (global as any).__REACT_NATIVE__);\n\n/**\n * Performance metric types\n */\nexport interface PerformanceMetrics {\n  // App lifecycle metrics\n  appStartTime: number;\n  timeToInteractive: number;\n  firstContentfulPaint?: number;\n  \n  // Runtime performance\n  memoryUsage: MemoryMetrics;\n  cpuUsage: number;\n  frameRate: FrameRateMetrics;\n  \n  // Network metrics\n  networkPerformance: NetworkMetrics;\n  \n  // User experience metrics\n  userInteractions: InteractionMetrics;\n  \n  // Battery metrics\n  batteryImpact: BatteryMetrics;\n  \n  // Error metrics\n  errorRate: number;\n  crashCount: number;\n  \n  // Timestamp\n  timestamp: number;\n}\n\nexport interface MemoryMetrics {\n  used: number; // MB\n  total: number; // MB\n  peak: number; // MB\n  heapUsed?: number; // MB\n  heapTotal?: number; // MB\n  gcEvents: number;\n  memoryWarnings: number;\n}\n\nexport interface FrameRateMetrics {\n  current: number; // FPS\n  average: number; // FPS\n  drops: number; // Frame drops in last period\n  jankCount: number; // Janky frames\n}\n\nexport interface NetworkMetrics {\n  avgRequestTime: number; // ms\n  failureRate: number; // 0-1\n  bytesTransferred: number;\n  requestCount: number;\n  slowRequestCount: number; // > 3s\n}\n\nexport interface InteractionMetrics {\n  avgResponseTime: number; // ms\n  slowInteractions: number; // > 100ms\n  totalInteractions: number;\n  userSatisfactionScore: number; // 0-1\n}\n\nexport interface BatteryMetrics {\n  drainRate: number; // %/hour\n  networkDrain: number; // Attributed to network\n  cpuDrain: number; // Attributed to CPU\n  backgroundDrain: number; // Background usage\n}\n\n/**\n * Performance thresholds for alerting\n */\nexport interface PerformanceThresholds {\n  maxMemoryUsage: number; // MB\n  minFrameRate: number; // FPS\n  maxResponseTime: number; // ms\n  maxBatteryDrainRate: number; // %/hour\n  maxErrorRate: number; // 0-1\n  maxNetworkFailureRate: number; // 0-1\n}\n\n/**\n * Performance monitoring configuration\n */\nexport interface PerformanceMonitorConfig {\n  /** Enable monitoring */\n  enabled?: boolean;\n  \n  /** Monitoring interval in ms */\n  monitoringInterval?: number;\n  \n  /** Enable memory monitoring */\n  enableMemoryMonitoring?: boolean;\n  \n  /** Enable frame rate monitoring */\n  enableFrameRateMonitoring?: boolean;\n  \n  /** Enable network monitoring */\n  enableNetworkMonitoring?: boolean;\n  \n  /** Enable battery monitoring */\n  enableBatteryMonitoring?: boolean;\n  \n  /** Enable user interaction monitoring */\n  enableInteractionMonitoring?: boolean;\n  \n  /** Enable crash reporting */\n  enableCrashReporting?: boolean;\n  \n  /** Performance thresholds */\n  thresholds?: Partial<PerformanceThresholds>;\n  \n  /** Maximum history entries to keep */\n  maxHistorySize?: number;\n  \n  /** Enable performance profiling */\n  enableProfiling?: boolean;\n  \n  /** Sample rate for profiling (0-1) */\n  profilingSampleRate?: number;\n  \n  /** Enable automatic optimization */\n  enableAutoOptimization?: boolean;\n  \n  /** Report performance data to server */\n  enableRemoteReporting?: boolean;\n  \n  /** Remote reporting endpoint */\n  reportingEndpoint?: string;\n}\n\n/**\n * Performance events\n */\ninterface PerformanceEvents {\n  'metrics:updated': { metrics: PerformanceMetrics };\n  'threshold:exceeded': { metric: string; value: number; threshold: number };\n  'memory:warning': { usage: number; available: number };\n  'frame:drop': { droppedFrames: number; duration: number };\n  'network:slow': { url: string; duration: number };\n  'interaction:slow': { type: string; duration: number };\n  'battery:drain': { rate: number; cause: string };\n  'crash:detected': { error: Error; context: any };\n  'optimization:applied': { type: string; impact: string };\n  'report:sent': { success: boolean; data?: any };\n}\n\nconst DEFAULT_THRESHOLDS: PerformanceThresholds = {\n  maxMemoryUsage: 512, // 512MB\n  minFrameRate: 55, // 55 FPS\n  maxResponseTime: 100, // 100ms\n  maxBatteryDrainRate: 5, // 5%/hour\n  maxErrorRate: 0.01, // 1%\n  maxNetworkFailureRate: 0.05, // 5%\n};\n\nconst DEFAULT_CONFIG: Required<PerformanceMonitorConfig> = {\n  enabled: true,\n  monitoringInterval: 10000, // 10 seconds\n  enableMemoryMonitoring: true,\n  enableFrameRateMonitoring: true,\n  enableNetworkMonitoring: true,\n  enableBatteryMonitoring: true,\n  enableInteractionMonitoring: true,\n  enableCrashReporting: true,\n  thresholds: DEFAULT_THRESHOLDS,\n  maxHistorySize: 100,\n  enableProfiling: false,\n  profilingSampleRate: 0.1,\n  enableAutoOptimization: true,\n  enableRemoteReporting: false,\n  reportingEndpoint: '/api/performance',\n};\n\n/**\n * React Native Performance Monitor\n */\nexport class PerformanceMonitor extends EventEmitter<PerformanceEvents> {\n  private config: Required<PerformanceMonitorConfig>;\n  private isInitialized = false;\n  private isMonitoring = false;\n  \n  // React Native modules\n  private PerformanceObserver: any;\n  private AppState: any;\n  private DeviceInfo: any;\n  \n  // Monitoring state\n  private startTime: number;\n  private lastMetrics?: PerformanceMetrics;\n  private metricsHistory: PerformanceMetrics[] = [];\n  private monitoringTimer?: NodeJS.Timeout;\n  \n  // Performance tracking\n  private memoryPeakUsage = 0;\n  private frameDropCount = 0;\n  private networkRequests: Array<{ url: string; startTime: number; endTime?: number; success?: boolean }> = [];\n  private userInteractions: Array<{ type: string; startTime: number; endTime: number }> = [];\n  private errorCount = 0;\n  private crashCount = 0;\n  private gcEventCount = 0;\n  private memoryWarningCount = 0;\n  \n  // Battery tracking\n  private batteryHistory: Array<{ level: number; timestamp: number }> = [];\n\n  constructor(config: PerformanceMonitorConfig = {}) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.startTime = Date.now();\n    \n    if (this.config.enabled) {\n      this.initialize();\n    }\n  }\n\n  private async initialize(): Promise<void> {\n    if (this.isInitialized || !isReactNative) return;\n\n    try {\n      // Import React Native modules\n      const RNModules = await import('react-native');\n      this.AppState = RNModules.AppState;\n\n      // Try to import performance modules\n      try {\n        const PerformanceModule = await import('react-native-performance');\n        this.PerformanceObserver = PerformanceModule.PerformanceObserver;\n      } catch {\n        console.warn('Performance API not available');\n      }\n\n      try {\n        const DeviceInfoModule = await import('react-native-device-info');\n        this.DeviceInfo = DeviceInfoModule.default;\n      } catch {\n        console.warn('DeviceInfo not available');\n      }\n\n      // AsyncStorage not used currently\n      // const AsyncStorageModule = await import('@react-native-async-storage/async-storage');\n      // this._AsyncStorage = AsyncStorageModule.default;\n\n      // Setup monitoring\n      this.setupMemoryMonitoring();\n      this.setupFrameRateMonitoring();\n      this.setupNetworkMonitoring();\n      this.setupErrorMonitoring();\n      this.setupInteractionMonitoring();\n\n      if (this.config.enableBatteryMonitoring) {\n        this.setupBatteryMonitoring();\n      }\n\n      this.isInitialized = true;\n      this.startMonitoring();\n      \n      console.log('PerformanceMonitor initialized');\n    } catch (error) {\n      console.warn('Failed to initialize PerformanceMonitor:', error);\n    }\n  }\n\n  private setupMemoryMonitoring(): void {\n    if (!this.config.enableMemoryMonitoring) return;\n\n    // Monitor memory warnings\n    if (this.AppState) {\n      try {\n        const MemoryWarningHandler = require('react-native').DeviceEventEmitter;\n        MemoryWarningHandler.addListener('memoryWarning', () => {\n          this.memoryWarningCount++;\n          const currentMemory = this.getMemoryUsage();\n          \n          this.emit('memory:warning', { \n            usage: currentMemory.used, \n            available: currentMemory.total - currentMemory.used \n          });\n          \n          if (this.config.enableAutoOptimization) {\n            this.applyMemoryOptimization();\n          }\n        });\n      } catch (error) {\n        console.warn('Memory warning monitoring not available:', error);\n      }\n    }\n\n    // Monitor GC events (if available)\n    if (global.gc) {\n      const originalGC = global.gc;\n      global.gc = async () => {\n        this.gcEventCount++;\n        return originalGC();\n      };\n    }\n  }\n\n  private setupFrameRateMonitoring(): void {\n    if (!this.config.enableFrameRateMonitoring) return;\n\n    // Use performance observer if available\n    if (this.PerformanceObserver) {\n      try {\n        const observer = new this.PerformanceObserver((list: any) => {\n          const entries = list.getEntries();\n          \n          for (const entry of entries) {\n            if (entry.entryType === 'measure' && entry.name.includes('frame')) {\n              if (entry.duration > 16.67) { // 60 FPS = 16.67ms per frame\n                this.frameDropCount++;\n                \n                this.emit('frame:drop', { \n                  droppedFrames: 1, \n                  duration: entry.duration \n                });\n              }\n            }\n          }\n        });\n\n        observer.observe({ entryTypes: ['measure'] });\n      } catch (error) {\n        console.warn('Frame monitoring not available:', error);\n      }\n    }\n  }\n\n  private setupNetworkMonitoring(): void {\n    if (!this.config.enableNetworkMonitoring) return;\n\n    // Intercept fetch requests\n    const originalFetch = global.fetch;\n    global.fetch = async (input: RequestInfo | URL, init?: RequestInit) => {\n      const url = typeof input === 'string' ? input : (input instanceof URL ? input.href : input.url);\n      const startTime = Date.now();\n      \n      const requestInfo: { url: string; startTime: number; endTime?: number; success?: boolean } = { url, startTime };\n      this.networkRequests.push(requestInfo);\n      \n      try {\n        const response = await originalFetch(input, init);\n        const endTime = Date.now();\n        const duration = endTime - startTime;\n        \n        requestInfo.endTime = endTime;\n        requestInfo.success = response.ok;\n        \n        // Check for slow requests\n        if (duration > 3000) {\n          this.emit('network:slow', { url, duration });\n        }\n        \n        return response;\n      } catch (error) {\n        requestInfo.endTime = Date.now();\n        requestInfo.success = false;\n        throw error;\n      }\n    };\n  }\n\n  private setupErrorMonitoring(): void {\n    if (!this.config.enableCrashReporting) return;\n\n    // Monitor JavaScript errors\n    const originalErrorHandler = ErrorUtils?.getGlobalHandler?.();\n    \n    ErrorUtils?.setGlobalHandler?.((error: Error, isFatal?: boolean) => {\n      this.errorCount++;\n      \n      if (isFatal) {\n        this.crashCount++;\n        this.emit('crash:detected', { error, context: { isFatal } });\n      }\n      \n      // Call original handler\n      if (originalErrorHandler) {\n        originalErrorHandler(error, isFatal);\n      }\n    });\n\n    // Monitor unhandled promise rejections\n    const handleUnhandledRejection = (event: any) => {\n      this.errorCount++;\n      console.warn('Unhandled promise rejection:', event.reason);\n    };\n\n    if (typeof process !== 'undefined') {\n      process.on('unhandledRejection', handleUnhandledRejection);\n    }\n  }\n\n  private setupInteractionMonitoring(): void {\n    if (!this.config.enableInteractionMonitoring) return;\n\n    // This would integrate with React Native's touch system\n    // For now, provide a manual API\n  }\n\n  private setupBatteryMonitoring(): void {\n    // Monitor battery changes\n    setInterval(async () => {\n      if (this.DeviceInfo) {\n        try {\n          const batteryLevel = await this.DeviceInfo.getBatteryLevel();\n          const timestamp = Date.now();\n          \n          this.batteryHistory.push({ level: batteryLevel, timestamp });\n          \n          // Keep only last 24 hours of data\n          const oneDayAgo = timestamp - 24 * 60 * 60 * 1000;\n          this.batteryHistory = this.batteryHistory.filter(entry => entry.timestamp > oneDayAgo);\n          \n          // Calculate drain rate\n          if (this.batteryHistory.length >= 2) {\n            const drainRate = this.calculateBatteryDrainRate();\n            \n            if (drainRate > (this.config.thresholds.maxBatteryDrainRate || 5)) {\n              this.emit('battery:drain', { rate: drainRate, cause: 'unknown' });\n            }\n          }\n        } catch (error) {\n          console.warn('Battery monitoring failed:', error);\n        }\n      }\n    }, 60000); // Check every minute\n  }\n\n  private calculateBatteryDrainRate(): number {\n    if (this.batteryHistory.length < 2) return 0;\n    \n    // Calculate drain over last hour\n    const now = Date.now();\n    const oneHourAgo = now - 60 * 60 * 1000;\n    \n    const recentHistory = this.batteryHistory.filter(entry => entry.timestamp > oneHourAgo);\n    if (recentHistory.length < 2) return 0;\n    \n    const oldest = recentHistory[0];\n    const newest = recentHistory[recentHistory.length - 1];\n    \n    if (!oldest || !newest) return 0;\n    \n    const timeDiff = newest.timestamp - oldest.timestamp; // ms\n    const batteryDiff = oldest.level - newest.level; // battery used\n    \n    // Convert to %/hour\n    const hoursElapsed = timeDiff / (60 * 60 * 1000);\n    return hoursElapsed > 0 ? (batteryDiff / hoursElapsed) * 100 : 0;\n  }\n\n  private startMonitoring(): void {\n    if (this.isMonitoring) return;\n    \n    this.isMonitoring = true;\n    this.monitoringTimer = setInterval(() => {\n      this.collectMetrics();\n    }, this.config.monitoringInterval) as unknown as NodeJS.Timeout;\n    \n    console.log('Performance monitoring started');\n  }\n\n  private collectMetrics(): void {\n    try {\n      const metrics: PerformanceMetrics = {\n        appStartTime: this.startTime,\n        timeToInteractive: Date.now() - this.startTime,\n        \n        memoryUsage: this.getMemoryUsage(),\n        cpuUsage: this.getCPUUsage(),\n        frameRate: this.getFrameRateMetrics(),\n        \n        networkPerformance: this.getNetworkMetrics(),\n        userInteractions: this.getInteractionMetrics(),\n        batteryImpact: this.getBatteryMetrics(),\n        \n        errorRate: this.calculateErrorRate(),\n        crashCount: this.crashCount,\n        \n        timestamp: Date.now(),\n      };\n\n      this.lastMetrics = metrics;\n      this.metricsHistory.push(metrics);\n\n      // Trim history if needed\n      if (this.metricsHistory.length > this.config.maxHistorySize) {\n        this.metricsHistory.shift();\n      }\n\n      this.emit('metrics:updated', { metrics });\n      this.checkThresholds(metrics);\n\n      // Send to remote server if configured\n      if (this.config.enableRemoteReporting) {\n        this.sendMetricsToServer(metrics);\n      }\n\n    } catch (error) {\n      console.warn('Failed to collect metrics:', error);\n    }\n  }\n\n  private getMemoryUsage(): MemoryMetrics {\n    // Get JavaScript heap info if available\n    let heapUsed = 0;\n    let heapTotal = 0;\n    \n    if ((performance as any).memory) {\n      const memoryInfo = (performance as any).memory;\n      heapUsed = memoryInfo.usedJSHeapSize / (1024 * 1024);\n      heapTotal = memoryInfo.totalJSHeapSize / (1024 * 1024);\n    }\n\n    // Estimate total memory usage (simplified)\n    const estimated = heapUsed * 2; // Rough estimate including native memory\n    this.memoryPeakUsage = Math.max(this.memoryPeakUsage, estimated);\n\n    return {\n      used: estimated,\n      total: 1024, // Assume 1GB total (would get from device info)\n      peak: this.memoryPeakUsage,\n      heapUsed,\n      heapTotal,\n      gcEvents: this.gcEventCount,\n      memoryWarnings: this.memoryWarningCount,\n    };\n  }\n\n  private getCPUUsage(): number {\n    // CPU usage is hard to measure in RN, return estimated value\n    return Math.random() * 30 + 10; // 10-40% range for demo\n  }\n\n  private getFrameRateMetrics(): FrameRateMetrics {\n    // This would use actual frame rate measurement in production\n    const currentFPS = 60 - (this.frameDropCount * 0.1);\n    \n    return {\n      current: Math.max(currentFPS, 30),\n      average: 58, // Placeholder\n      drops: this.frameDropCount,\n      jankCount: Math.floor(this.frameDropCount * 0.3),\n    };\n  }\n\n  private getNetworkMetrics(): NetworkMetrics {\n    const recentRequests = this.networkRequests.slice(-100); // Last 100 requests\n    \n    if (recentRequests.length === 0) {\n      return {\n        avgRequestTime: 0,\n        failureRate: 0,\n        bytesTransferred: 0,\n        requestCount: 0,\n        slowRequestCount: 0,\n      };\n    }\n\n    const completedRequests = recentRequests.filter(req => req.endTime);\n    const failedRequests = completedRequests.filter(req => !req.success);\n    const slowRequests = completedRequests.filter(req => \n      req.endTime && (req.endTime - req.startTime) > 3000\n    );\n\n    const totalTime = completedRequests.reduce((sum, req) => \n      sum + (req.endTime! - req.startTime), 0\n    );\n\n    return {\n      avgRequestTime: completedRequests.length > 0 ? totalTime / completedRequests.length : 0,\n      failureRate: completedRequests.length > 0 ? failedRequests.length / completedRequests.length : 0,\n      bytesTransferred: 0, // Would need actual byte counting\n      requestCount: recentRequests.length,\n      slowRequestCount: slowRequests.length,\n    };\n  }\n\n  private getInteractionMetrics(): InteractionMetrics {\n    const recentInteractions = this.userInteractions.slice(-50); // Last 50 interactions\n    \n    if (recentInteractions.length === 0) {\n      return {\n        avgResponseTime: 0,\n        slowInteractions: 0,\n        totalInteractions: 0,\n        userSatisfactionScore: 1,\n      };\n    }\n\n    const totalTime = recentInteractions.reduce((sum, interaction) => \n      sum + (interaction.endTime - interaction.startTime), 0\n    );\n\n    const slowInteractions = recentInteractions.filter(interaction => \n      (interaction.endTime - interaction.startTime) > 100\n    );\n\n    const avgResponseTime = totalTime / recentInteractions.length;\n    const satisfactionScore = Math.max(0, 1 - (slowInteractions.length / recentInteractions.length));\n\n    return {\n      avgResponseTime,\n      slowInteractions: slowInteractions.length,\n      totalInteractions: recentInteractions.length,\n      userSatisfactionScore: satisfactionScore,\n    };\n  }\n\n  private getBatteryMetrics(): BatteryMetrics {\n    const drainRate = this.calculateBatteryDrainRate();\n    \n    return {\n      drainRate,\n      networkDrain: drainRate * 0.3, // Estimate 30% from network\n      cpuDrain: drainRate * 0.4, // Estimate 40% from CPU\n      backgroundDrain: drainRate * 0.2, // Estimate 20% from background\n    };\n  }\n\n  private calculateErrorRate(): number {\n    const timeWindow = 10 * 60 * 1000; // 10 minutes\n    const now = Date.now();\n    \n    // This is simplified - in production, track errors with timestamps\n    return this.errorCount / Math.max(1, (now - this.startTime) / timeWindow);\n  }\n\n  private checkThresholds(metrics: PerformanceMetrics): void {\n    const { thresholds } = this.config;\n\n    // Check memory threshold\n    const maxMemory = thresholds.maxMemoryUsage || 512;\n    if (metrics.memoryUsage.used > maxMemory) {\n      this.emit('threshold:exceeded', {\n        metric: 'memory',\n        value: metrics.memoryUsage.used,\n        threshold: maxMemory,\n      });\n    }\n\n    // Check frame rate threshold\n    const minFrameRate = thresholds.minFrameRate || 55;\n    if (metrics.frameRate.current < minFrameRate) {\n      this.emit('threshold:exceeded', {\n        metric: 'frameRate',\n        value: metrics.frameRate.current,\n        threshold: minFrameRate,\n      });\n    }\n\n    // Check response time threshold\n    const maxResponseTime = thresholds.maxResponseTime || 100;\n    if (metrics.userInteractions.avgResponseTime > maxResponseTime) {\n      this.emit('threshold:exceeded', {\n        metric: 'responseTime',\n        value: metrics.userInteractions.avgResponseTime,\n        threshold: maxResponseTime,\n      });\n    }\n\n    // Check battery drain threshold\n    const maxBatteryDrain = thresholds.maxBatteryDrainRate || 5;\n    if (metrics.batteryImpact.drainRate > maxBatteryDrain) {\n      this.emit('threshold:exceeded', {\n        metric: 'batteryDrain',\n        value: metrics.batteryImpact.drainRate,\n        threshold: maxBatteryDrain,\n      });\n    }\n\n    // Check error rate threshold\n    const maxErrorRate = thresholds.maxErrorRate || 0.01;\n    if (metrics.errorRate > maxErrorRate) {\n      this.emit('threshold:exceeded', {\n        metric: 'errorRate',\n        value: metrics.errorRate,\n        threshold: maxErrorRate,\n      });\n    }\n\n    // Check network failure rate threshold\n    const maxNetworkFailureRate = thresholds.maxNetworkFailureRate || 0.05;\n    if (metrics.networkPerformance.failureRate > maxNetworkFailureRate) {\n      this.emit('threshold:exceeded', {\n        metric: 'networkFailureRate',\n        value: metrics.networkPerformance.failureRate,\n        threshold: maxNetworkFailureRate,\n      });\n    }\n  }\n\n  private applyMemoryOptimization(): void {\n    // Force garbage collection if available\n    if (global.gc) {\n      global.gc();\n      this.emit('optimization:applied', { \n        type: 'garbage_collection', \n        impact: 'memory_freed' \n      });\n    }\n\n    // Other memory optimizations could go here\n    // - Clear caches\n    // - Reduce image quality\n    // - Limit concurrent operations\n  }\n\n  private async sendMetricsToServer(metrics: PerformanceMetrics): Promise<void> {\n    try {\n      const response = await fetch(this.config.reportingEndpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          metrics,\n          deviceInfo: await this.getDeviceInfo(),\n          timestamp: Date.now(),\n        }),\n      });\n\n      this.emit('report:sent', { \n        success: response.ok, \n        data: response.ok ? undefined : response.statusText \n      });\n    } catch (error) {\n      this.emit('report:sent', { success: false, data: error });\n    }\n  }\n\n  private async getDeviceInfo(): Promise<any> {\n    if (!this.DeviceInfo) return {};\n\n    try {\n      return {\n        model: await this.DeviceInfo.getModel(),\n        systemVersion: await this.DeviceInfo.getSystemVersion(),\n        brand: await this.DeviceInfo.getBrand(),\n        deviceId: await this.DeviceInfo.getUniqueId(),\n        totalMemory: await this.DeviceInfo.getTotalMemory(),\n        isEmulator: await this.DeviceInfo.isEmulator(),\n      };\n    } catch (error) {\n      return {};\n    }\n  }\n\n  /**\n   * Record a user interaction for monitoring\n   */\n  recordInteraction(type: string, startTime: number, endTime?: number): void {\n    if (!this.config.enableInteractionMonitoring) return;\n\n    const interaction = {\n      type,\n      startTime,\n      endTime: endTime || Date.now(),\n    };\n\n    this.userInteractions.push(interaction);\n\n    // Keep only recent interactions\n    if (this.userInteractions.length > 1000) {\n      this.userInteractions = this.userInteractions.slice(-500);\n    }\n\n    // Check for slow interaction\n    const duration = interaction.endTime - interaction.startTime;\n    if (duration > 100) {\n      this.emit('interaction:slow', { type, duration });\n    }\n  }\n\n  /**\n   * Get current performance metrics\n   */\n  getCurrentMetrics(): PerformanceMetrics | undefined {\n    return this.lastMetrics;\n  }\n\n  /**\n   * Get performance history\n   */\n  getMetricsHistory(): PerformanceMetrics[] {\n    return [...this.metricsHistory];\n  }\n\n  /**\n   * Get performance summary\n   */\n  getPerformanceSummary() {\n    const history = this.metricsHistory;\n    if (history.length === 0) return null;\n\n    const latest = history[history.length - 1];\n    const avgMemory = history.reduce((sum, m) => sum + m.memoryUsage.used, 0) / history.length;\n    const avgFrameRate = history.reduce((sum, m) => sum + m.frameRate.current, 0) / history.length;\n    const avgResponseTime = history.reduce((sum, m) => sum + m.userInteractions.avgResponseTime, 0) / history.length;\n\n    return {\n      current: latest,\n      averages: {\n        memoryUsage: avgMemory,\n        frameRate: avgFrameRate,\n        responseTime: avgResponseTime,\n      },\n      totals: {\n        errors: this.errorCount,\n        crashes: this.crashCount,\n        frameDrops: this.frameDropCount,\n        memoryWarnings: this.memoryWarningCount,\n      },\n    };\n  }\n\n  /**\n   * Force metrics collection\n   */\n  collectMetricsNow(): void {\n    this.collectMetrics();\n  }\n\n  /**\n   * Reset performance counters\n   */\n  resetCounters(): void {\n    this.errorCount = 0;\n    this.crashCount = 0;\n    this.frameDropCount = 0;\n    this.memoryWarningCount = 0;\n    this.gcEventCount = 0;\n    this.networkRequests = [];\n    this.userInteractions = [];\n    this.batteryHistory = [];\n  }\n\n  /**\n   * Stop monitoring\n   */\n  stopMonitoring(): void {\n    if (this.monitoringTimer) {\n      clearInterval(this.monitoringTimer);\n      this.monitoringTimer = undefined as any;\n    }\n    \n    this.isMonitoring = false;\n  }\n\n  /**\n   * Start monitoring\n   */\n  resumeMonitoring(): void {\n    if (!this.isMonitoring && this.isInitialized) {\n      this.startMonitoring();\n    }\n  }\n\n  /**\n   * Destroy the performance monitor\n   */\n  destroy(): void {\n    this.stopMonitoring();\n    this.removeAllListeners();\n  }\n}","/**\n * Generated Endpoint Definitions from OpenAPI Specification\n * Comprehensive endpoint configurations for all API resources\n * \n * This file is auto-generated based on openapi.yaml\n * Do not edit manually - use regeneration scripts instead\n */\n\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n\nexport interface EndpointDefinition {\n  path: string;\n  method: HttpMethod;\n  operationId: string;\n  summary?: string;\n  description?: string;\n  tags: string[];\n  security?: Array<Record<string, string[]>>;\n  parameters?: {\n    path?: Record<string, string>;\n    query?: Record<string, string>;\n    header?: Record<string, string>;\n  };\n  requestBody?: {\n    required: boolean;\n    contentType: string;\n    schema: string;\n  };\n  responses: {\n    [statusCode: string]: {\n      description: string;\n      contentType?: string;\n      schema?: string;\n    };\n  };\n  metadata?: {\n    resource: string;\n    operation: string;\n    authRequired: boolean;\n    retryable: boolean;\n  };\n}\n\n/**\n * Cashier Endpoints - User account management for cashiers\n */\nexport class CashierEndpoints {\n  static readonly LIST: EndpointDefinition = {\n    path: '/mf1/cashiers',\n    method: 'GET',\n    operationId: 'read_cashiers_mf1_cashiers_get',\n    summary: 'Read Cashiers',\n    description: 'Get a paginated list of cashiers',\n    tags: ['Cashier'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    parameters: {\n      query: {\n        page: 'integer',\n        size: 'integer'\n      }\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_Page__T_Customized_CashierOutput_'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '404': {\n        description: 'Not Found',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel404NotFound'\n      },\n      '422': {\n        description: 'Validation Error',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_HTTPValidationError'\n      }\n    },\n    metadata: {\n      resource: 'cashiers',\n      operation: 'list',\n      authRequired: true,\n      retryable: true\n    }\n  };\n\n  static readonly CREATE: EndpointDefinition = {\n    path: '/mf1/cashiers',\n    method: 'POST',\n    operationId: 'create_cashier_mf1_cashiers_post',\n    summary: 'Create Cashier',\n    description: 'Create a new cashier account',\n    tags: ['Cashier'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    requestBody: {\n      required: true,\n      contentType: 'application/json',\n      schema: 'E-Receipt_IT_API_CashierCreateInput'\n    },\n    responses: {\n      '201': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_CashierOutput'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '422': {\n        description: 'Validation Error',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_HTTPValidationError'\n      }\n    },\n    metadata: {\n      resource: 'cashiers',\n      operation: 'create',\n      authRequired: true,\n      retryable: false\n    }\n  };\n\n  static readonly ME: EndpointDefinition = {\n    path: '/mf1/cashiers/me',\n    method: 'GET',\n    operationId: 'read_cashier_me_mf1_cashiers_me_get',\n    summary: 'Read Cashier Me',\n    description: 'Read currently authenticated cashier\\'s information',\n    tags: ['Cashier'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_CashierOutput'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '404': {\n        description: 'Not Found',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel404NotFound'\n      }\n    },\n    metadata: {\n      resource: 'cashiers',\n      operation: 'me',\n      authRequired: true,\n      retryable: true\n    }\n  };\n\n  static readonly GET_BY_ID: EndpointDefinition = {\n    path: '/mf1/cashiers/{cashier_id}',\n    method: 'GET',\n    operationId: 'read_cashier_by_id_mf1_cashiers__cashier_id__get',\n    summary: 'Read Cashier By Id',\n    description: 'Get a specific user by id',\n    tags: ['Cashier'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    parameters: {\n      path: {\n        cashier_id: 'integer'\n      }\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_CashierOutput'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '404': {\n        description: 'Not Found',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel404NotFound'\n      },\n      '422': {\n        description: 'Validation Error',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_HTTPValidationError'\n      }\n    },\n    metadata: {\n      resource: 'cashiers',\n      operation: 'get',\n      authRequired: true,\n      retryable: true\n    }\n  };\n\n  static readonly DELETE: EndpointDefinition = {\n    path: '/mf1/cashiers/{cashier_id}',\n    method: 'DELETE',\n    operationId: 'delete_cashier_mf1_cashiers__cashier_id__delete',\n    summary: 'Delete Cashier',\n    description: 'Delete a cashier',\n    tags: ['Cashier'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    parameters: {\n      path: {\n        cashier_id: 'integer'\n      }\n    },\n    responses: {\n      '204': {\n        description: 'Successful Response'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '404': {\n        description: 'Not Found',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel404NotFound'\n      },\n      '422': {\n        description: 'Validation Error',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_HTTPValidationError'\n      }\n    },\n    metadata: {\n      resource: 'cashiers',\n      operation: 'delete',\n      authRequired: true,\n      retryable: false\n    }\n  };\n}\n\n/**\n * Point of Sales Endpoints - PEM device management\n */\nexport class PointOfSalesEndpoints {\n  static readonly LIST: EndpointDefinition = {\n    path: '/mf1/point-of-sales',\n    method: 'GET',\n    operationId: 'read_point_of_sales_mf1_point_of_sales_get',\n    summary: 'Read Point Of Sales',\n    description: 'Retrieve PEMs',\n    tags: ['Point of Sale'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_Page__T_Customized_PointOfSaleOutput_'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      }\n    },\n    metadata: {\n      resource: 'point-of-sales',\n      operation: 'list',\n      authRequired: true,\n      retryable: true\n    }\n  };\n\n  static readonly GET_BY_SERIAL: EndpointDefinition = {\n    path: '/mf1/point-of-sales/{serial_number}',\n    method: 'GET',\n    operationId: 'read_point_of_sale_mf1_point_of_sales__serial_number__get',\n    summary: 'Read Point Of Sale',\n    description: 'Get a specific Point of Sale by serial number',\n    tags: ['Point of Sale'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    parameters: {\n      path: {\n        serial_number: 'string'\n      }\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_PointOfSaleOutput'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '404': {\n        description: 'Not Found',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel404NotFound'\n      }\n    },\n    metadata: {\n      resource: 'point-of-sales',\n      operation: 'get',\n      authRequired: true,\n      retryable: true\n    }\n  };\n\n  static readonly CLOSE_JOURNAL: EndpointDefinition = {\n    path: '/mf1/point-of-sales/close',\n    method: 'POST',\n    operationId: 'close_journal_mf1_point_of_sales_close_post',\n    summary: 'Close Journal',\n    description: 'Close the daily journal for Point of Sales',\n    tags: ['Point of Sale'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    requestBody: {\n      required: true,\n      contentType: 'application/json',\n      schema: 'E-Receipt_IT_API_CloseJournalRequest'\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_CloseJournalOutput'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      }\n    },\n    metadata: {\n      resource: 'point-of-sales',\n      operation: 'close_journal',\n      authRequired: true,\n      retryable: false\n    }\n  };\n\n  static readonly ACTIVATION: EndpointDefinition = {\n    path: '/mf1/point-of-sales/{serial_number}/activation',\n    method: 'POST',\n    operationId: 'post_activation_mf1_point_of_sales__serial_number__activation_post',\n    summary: 'Post Activation',\n    description: 'Trigger the activation process of a Point of Sale by requesting a certificate to the Italian Tax Agency',\n    tags: ['Point of Sale'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    parameters: {\n      path: {\n        serial_number: 'string'\n      }\n    },\n    requestBody: {\n      required: true,\n      contentType: 'application/json',\n      schema: 'E-Receipt_IT_API_ActivationRequest'\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ActivationOutput'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      }\n    },\n    metadata: {\n      resource: 'point-of-sales',\n      operation: 'activation',\n      authRequired: true,\n      retryable: false\n    }\n  };\n\n  static readonly CREATE_INACTIVITY: EndpointDefinition = {\n    path: '/mf1/point-of-sales/{serial_number}/inactivity',\n    method: 'POST',\n    operationId: 'create_inactivity_period_mf1_point_of_sales__serial_number__inactivity_post',\n    summary: 'Create Inactivity Period',\n    description: 'Create a new inactivity period',\n    tags: ['Point of Sale'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    parameters: {\n      path: {\n        serial_number: 'string'\n      }\n    },\n    requestBody: {\n      required: true,\n      contentType: 'application/json',\n      schema: 'E-Receipt_IT_API_InactivityRequest'\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      }\n    },\n    metadata: {\n      resource: 'point-of-sales',\n      operation: 'create_inactivity',\n      authRequired: true,\n      retryable: false\n    }\n  };\n\n  static readonly SET_OFFLINE: EndpointDefinition = {\n    path: '/mf1/point-of-sales/{serial_number}/status/offline',\n    method: 'POST',\n    operationId: 'post_offline_mf1_point_of_sales__serial_number__status_offline_post',\n    summary: 'Post Offline',\n    description: 'Change the state of the Point of Sale to \\'offline\\'',\n    tags: ['Point of Sale'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    parameters: {\n      path: {\n        serial_number: 'string'\n      }\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      }\n    },\n    metadata: {\n      resource: 'point-of-sales',\n      operation: 'set_offline',\n      authRequired: true,\n      retryable: false\n    }\n  };\n}\n\n/**\n * Receipt Endpoints - Electronic receipt management\n */\nexport class ReceiptEndpoints {\n  static readonly LIST: EndpointDefinition = {\n    path: '/mf1/receipts',\n    method: 'GET',\n    operationId: 'get_receipts_mf1_receipts_get',\n    summary: 'Get Receipts',\n    description: 'Get a list of electronic receipts',\n    tags: ['Receipt'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    parameters: {\n      query: {\n        page: 'integer',\n        size: 'integer',\n        start_date: 'string',\n        end_date: 'string',\n        serial_number: 'string'\n      }\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_Page__T_Customized_ReceiptOutput_'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      }\n    },\n    metadata: {\n      resource: 'receipts',\n      operation: 'list',\n      authRequired: true,\n      retryable: true\n    }\n  };\n\n  static readonly CREATE: EndpointDefinition = {\n    path: '/mf1/receipts',\n    method: 'POST',\n    operationId: 'create_receipt_mf1_receipts_post',\n    summary: 'Create Receipt',\n    description: 'Create a new electronic receipt',\n    tags: ['Receipt'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    requestBody: {\n      required: true,\n      contentType: 'application/json',\n      schema: 'E-Receipt_IT_API_ReceiptInput'\n    },\n    responses: {\n      '201': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ReceiptOutput'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '422': {\n        description: 'Validation Error',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_HTTPValidationError'\n      }\n    },\n    metadata: {\n      resource: 'receipts',\n      operation: 'create',\n      authRequired: true,\n      retryable: false\n    }\n  };\n\n  static readonly VOID: EndpointDefinition = {\n    path: '/mf1/receipts',\n    method: 'DELETE',\n    operationId: 'void_receipt_mf1_receipts_delete',\n    summary: 'Void Receipt',\n    description: 'Void an electronic receipt',\n    tags: ['Receipt'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    requestBody: {\n      required: true,\n      contentType: 'application/json',\n      schema: 'E-Receipt_IT_API_VoidReceiptRequest'\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_VoidReceiptOutput'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      }\n    },\n    metadata: {\n      resource: 'receipts',\n      operation: 'void',\n      authRequired: true,\n      retryable: false\n    }\n  };\n\n  static readonly GET_BY_UUID: EndpointDefinition = {\n    path: '/mf1/receipts/{receipt_uuid}',\n    method: 'GET',\n    operationId: 'get_receipt_mf1_receipts__receipt_uuid__get',\n    summary: 'Get Receipt',\n    description: 'Get an electronic receipt',\n    tags: ['Receipt'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    parameters: {\n      path: {\n        receipt_uuid: 'string'\n      }\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ReceiptOutput'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '404': {\n        description: 'Not Found',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel404NotFound'\n      }\n    },\n    metadata: {\n      resource: 'receipts',\n      operation: 'get',\n      authRequired: true,\n      retryable: true\n    }\n  };\n\n  static readonly VOID_WITH_PROOF: EndpointDefinition = {\n    path: '/mf1/receipts/void-with-proof',\n    method: 'DELETE',\n    operationId: 'void_receipt_via_proof_mf1_receipts_void_with_proof_delete',\n    summary: 'Void Receipt Via Proof',\n    description: 'Void an electronic receipt identified by a proof of purchase',\n    tags: ['Receipt'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    requestBody: {\n      required: true,\n      contentType: 'application/json',\n      schema: 'E-Receipt_IT_API_VoidReceiptWithProofRequest'\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_VoidReceiptOutput'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      }\n    },\n    metadata: {\n      resource: 'receipts',\n      operation: 'void_with_proof',\n      authRequired: true,\n      retryable: false\n    }\n  };\n\n  static readonly GET_DETAILS: EndpointDefinition = {\n    path: '/mf1/receipts/{receipt_uuid}/details',\n    method: 'GET',\n    operationId: 'get_receipt_details_mf1_receipts__receipt_uuid__details_get',\n    summary: 'Get Receipt Details',\n    description: 'Get the details or the PDF of an electronic receipt',\n    tags: ['Receipt'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    parameters: {\n      path: {\n        receipt_uuid: 'string'\n      },\n      header: {\n        Accept: 'string'\n      }\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '404': {\n        description: 'Not Found',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel404NotFound'\n      }\n    },\n    metadata: {\n      resource: 'receipts',\n      operation: 'get_details',\n      authRequired: true,\n      retryable: true\n    }\n  };\n\n  static readonly RETURN_ITEMS: EndpointDefinition = {\n    path: '/mf1/receipts/return',\n    method: 'POST',\n    operationId: 'return_receipt_items_mf1_receipts_return_post',\n    summary: 'Return Receipt Items',\n    description: 'Return items from an electronic receipt (same PEM or other PEM)',\n    tags: ['Receipt'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    requestBody: {\n      required: true,\n      contentType: 'application/json',\n      schema: 'E-Receipt_IT_API_ReturnRequest'\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ReceiptOutput'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      }\n    },\n    metadata: {\n      resource: 'receipts',\n      operation: 'return_items',\n      authRequired: true,\n      retryable: false\n    }\n  };\n\n  static readonly RETURN_ITEMS_WITH_PROOF: EndpointDefinition = {\n    path: '/mf1/receipts/return-with-proof',\n    method: 'POST',\n    operationId: 'return_receipt_items_via_proof_mf1_receipts_return_with_proof_post',\n    summary: 'Return Receipt Items Via Proof',\n    description: 'Return items from an electronic receipt identified by a proof of purchase',\n    tags: ['Receipt'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    requestBody: {\n      required: true,\n      contentType: 'application/json',\n      schema: 'E-Receipt_IT_API_ReturnWithProofRequest'\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ReceiptOutput'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      }\n    },\n    metadata: {\n      resource: 'receipts',\n      operation: 'return_items_with_proof',\n      authRequired: true,\n      retryable: false\n    }\n  };\n}\n\n/**\n * Cash Register Endpoints - Cash register management\n */\nexport class CashRegisterEndpoints {\n  static readonly CREATE: EndpointDefinition = {\n    path: '/mf1/cash-register',\n    method: 'POST',\n    operationId: 'create_cash_register_mf1_cash_register_post',\n    summary: 'Create Cash Register',\n    description: 'Create a new cash register',\n    tags: ['Cash Register'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    requestBody: {\n      required: true,\n      contentType: 'application/json',\n      schema: 'E-Receipt_IT_API_CashRegisterInput'\n    },\n    responses: {\n      '201': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_CashRegisterOutput'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '422': {\n        description: 'Validation Error',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_HTTPValidationError'\n      }\n    },\n    metadata: {\n      resource: 'cash-registers',\n      operation: 'create',\n      authRequired: true,\n      retryable: false\n    }\n  };\n\n  static readonly LIST: EndpointDefinition = {\n    path: '/mf1/cash-register',\n    method: 'GET',\n    operationId: 'get_cash_registers_mf1_cash_register_get',\n    summary: 'Get Cash Registers',\n    description: 'Get a list of cash registers',\n    tags: ['Cash Register'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_Page__T_Customized_CashRegisterOutput_'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      }\n    },\n    metadata: {\n      resource: 'cash-registers',\n      operation: 'list',\n      authRequired: true,\n      retryable: true\n    }\n  };\n\n  static readonly GET_BY_ID: EndpointDefinition = {\n    path: '/mf1/cash-register/{id}',\n    method: 'GET',\n    operationId: 'get_cash_register_mf1_cash_register__id__get',\n    summary: 'Get Cash Register',\n    description: 'Get a specific cash register by ID',\n    tags: ['Cash Register'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    parameters: {\n      path: {\n        id: 'integer'\n      }\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_CashRegisterOutput'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '404': {\n        description: 'Not Found',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel404NotFound'\n      }\n    },\n    metadata: {\n      resource: 'cash-registers',\n      operation: 'get',\n      authRequired: true,\n      retryable: true\n    }\n  };\n}\n\n/**\n * Merchant Endpoints - Business entity management\n */\nexport class MerchantEndpoints {\n  static readonly LIST: EndpointDefinition = {\n    path: '/mf2/merchants',\n    method: 'GET',\n    operationId: 'api_merchants_get_collection',\n    summary: 'Get Merchants',\n    description: 'Get a list of merchants',\n    tags: ['Merchant'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      }\n    },\n    metadata: {\n      resource: 'merchants',\n      operation: 'list',\n      authRequired: true,\n      retryable: true\n    }\n  };\n\n  static readonly CREATE: EndpointDefinition = {\n    path: '/mf2/merchants',\n    method: 'POST',\n    operationId: 'api_merchants_post',\n    summary: 'Create Merchant',\n    description: 'Create a new merchant',\n    tags: ['Merchant'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    requestBody: {\n      required: true,\n      contentType: 'application/json',\n      schema: 'Merchant-create'\n    },\n    responses: {\n      '201': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'Merchant-read'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '422': {\n        description: 'Validation Error',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_HTTPValidationError'\n      }\n    },\n    metadata: {\n      resource: 'merchants',\n      operation: 'create',\n      authRequired: true,\n      retryable: false\n    }\n  };\n\n  static readonly GET_BY_UUID: EndpointDefinition = {\n    path: '/mf2/merchants/{uuid}',\n    method: 'GET',\n    operationId: 'api_merchants_uuid_get',\n    summary: 'Get Merchant',\n    description: 'Get a specific merchant by UUID',\n    tags: ['Merchant'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    parameters: {\n      path: {\n        uuid: 'string'\n      }\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'Merchant-read'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '404': {\n        description: 'Not Found',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel404NotFound'\n      }\n    },\n    metadata: {\n      resource: 'merchants',\n      operation: 'get',\n      authRequired: true,\n      retryable: true\n    }\n  };\n\n  static readonly UPDATE: EndpointDefinition = {\n    path: '/mf2/merchants/{uuid}',\n    method: 'PUT',\n    operationId: 'api_merchants_uuid_put',\n    summary: 'Update Merchant',\n    description: 'Update a merchant',\n    tags: ['Merchant'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    parameters: {\n      path: {\n        uuid: 'string'\n      }\n    },\n    requestBody: {\n      required: true,\n      contentType: 'application/json',\n      schema: 'Merchant-update'\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'Merchant-read'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '404': {\n        description: 'Not Found',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel404NotFound'\n      },\n      '422': {\n        description: 'Validation Error',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_HTTPValidationError'\n      }\n    },\n    metadata: {\n      resource: 'merchants',\n      operation: 'update',\n      authRequired: true,\n      retryable: false\n    }\n  };\n}\n\n/**\n * PEM Endpoints - Point of Sale Module certificate management\n */\nexport class PEMEndpoints {\n  static readonly CREATE_POS: EndpointDefinition = {\n    path: '/mf2/point-of-sales',\n    method: 'POST',\n    operationId: 'api_point-of-sales_post',\n    summary: 'Create Point of Sale',\n    description: 'Create a new Point of Sale',\n    tags: ['Pem'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    requestBody: {\n      required: true,\n      contentType: 'application/json',\n      schema: 'PointOfSale-create'\n    },\n    responses: {\n      '201': {\n        description: 'Successful Response',\n        contentType: 'application/json',\n        schema: 'PointOfSale-read'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '422': {\n        description: 'Validation Error',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_HTTPValidationError'\n      }\n    },\n    metadata: {\n      resource: 'pems',\n      operation: 'create_pos',\n      authRequired: true,\n      retryable: false\n    }\n  };\n\n  static readonly GET_CERTIFICATES: EndpointDefinition = {\n    path: '/mf2/point-of-sales/{id}/certificates',\n    method: 'GET',\n    operationId: 'api_point-of-sales_idcertificates_get',\n    summary: 'Get PEM Certificates',\n    description: 'Get certificates for a Point of Sale',\n    tags: ['Pem'],\n    security: [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }],\n    parameters: {\n      path: {\n        id: 'string'\n      }\n    },\n    responses: {\n      '200': {\n        description: 'Successful Response',\n        contentType: 'application/json'\n      },\n      '403': {\n        description: 'Forbidden',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel403Forbidden'\n      },\n      '404': {\n        description: 'Not Found',\n        contentType: 'application/json',\n        schema: 'E-Receipt_IT_API_ErrorModel404NotFound'\n      }\n    },\n    metadata: {\n      resource: 'pems',\n      operation: 'get_certificates',\n      authRequired: true,\n      retryable: true\n    }\n  };\n}\n\n/**\n * Utility class for endpoint operations\n */\nexport class EndpointUtils {\n  /**\n   * Get all endpoints for a specific resource\n   */\n  static getResourceEndpoints(resource: string): EndpointDefinition[] {\n    switch (resource.toLowerCase()) {\n      case 'cashiers':\n        return Object.values(CashierEndpoints);\n      case 'point-of-sales':\n        return Object.values(PointOfSalesEndpoints);\n      case 'receipts':\n        return Object.values(ReceiptEndpoints);\n      case 'cash-registers':\n        return Object.values(CashRegisterEndpoints);\n      case 'merchants':\n        return Object.values(MerchantEndpoints);\n      case 'pems':\n        return Object.values(PEMEndpoints);\n      default:\n        return [];\n    }\n  }\n\n  /**\n   * Find endpoint by operation ID\n   */\n  static findEndpointByOperationId(operationId: string): EndpointDefinition | null {\n    const allClasses = [\n      CashierEndpoints,\n      PointOfSalesEndpoints,\n      ReceiptEndpoints,\n      CashRegisterEndpoints,\n      MerchantEndpoints,\n      PEMEndpoints,\n    ];\n\n    for (const endpointClass of allClasses) {\n      for (const endpoint of Object.values(endpointClass)) {\n        if (endpoint.operationId === operationId) {\n          return endpoint;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Build URL with path parameters\n   */\n  static buildUrl(endpoint: EndpointDefinition, pathParams: Record<string, string | number> = {}): string {\n    let url = endpoint.path;\n    \n    for (const [key, value] of Object.entries(pathParams)) {\n      url = url.replace(`{${key}}`, String(value));\n    }\n    \n    return url;\n  }\n\n  /**\n   * Check if endpoint requires authentication\n   */\n  static requiresAuth(endpoint: EndpointDefinition): boolean {\n    return endpoint.metadata?.authRequired ?? false;\n  }\n\n  /**\n   * Check if endpoint operation is retryable\n   */\n  static isRetryable(endpoint: EndpointDefinition): boolean {\n    return endpoint.metadata?.retryable ?? false;\n  }\n\n  /**\n   * Get expected content type for request body\n   */\n  static getRequestContentType(endpoint: EndpointDefinition): string | null {\n    return endpoint.requestBody?.contentType ?? null;\n  }\n\n  /**\n   * Get expected response content type\n   */\n  static getResponseContentType(endpoint: EndpointDefinition, statusCode: string): string | null {\n    return endpoint.responses[statusCode]?.contentType ?? null;\n  }\n}","/**\n * Enterprise Queue Types and Interfaces\n * Type-safe queue operations with branded types\n */\n\n\n// Priority levels for queue operations\nexport type QueuePriority = 'critical' | 'high' | 'normal' | 'low';\n\n// Operation types for queue items\nexport type QueueOperationType = 'create' | 'update' | 'delete' | 'batch' | 'custom';\n\n// Conflict resolution strategies\nexport type ConflictResolutionStrategy = 'client-wins' | 'server-wins' | 'merge' | 'manual';\n\n// Retry strategies\nexport type RetryStrategy = 'exponential' | 'linear' | 'custom';\n\n// Queue item status\nexport type QueueItemStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'retry' | 'dead';\n\n// Resource types that can be queued\nexport type ResourceType = 'receipts' | 'cashiers' | 'merchants' | 'cash-registers' | 'point-of-sales' | 'pems';\n\n// Branded queue ID type\nexport type QueueItemId = string & { readonly __brand: 'QueueItemId' };\n\n// Base queue item interface\nexport interface QueueItem {\n  readonly id: QueueItemId;\n  readonly priority: QueuePriority;\n  readonly operation: QueueOperationType;\n  readonly resource: ResourceType;\n  readonly data: unknown;\n  readonly status: QueueItemStatus;\n  readonly createdAt: number;\n  readonly updatedAt: number;\n  readonly scheduledAt?: number;\n  readonly retryCount: number;\n  readonly maxRetries: number;\n  readonly retryStrategy: RetryStrategy;\n  readonly conflictResolution: ConflictResolutionStrategy;\n  readonly optimisticId?: string;\n  readonly batchId?: string;\n  readonly dependencies?: QueueItemId[];\n  readonly metadata?: Record<string, unknown>;\n  readonly errorHistory?: QueueError[];\n}\n\n// Queue error tracking\nexport interface QueueError {\n  readonly timestamp: number;\n  readonly error: string;\n  readonly code?: string;\n  readonly retryable: boolean;\n  readonly context?: Record<string, unknown>;\n}\n\n// Batch operation interface\nexport interface BatchOperation {\n  readonly id: string;\n  readonly items: QueueItem[];\n  readonly status: 'pending' | 'processing' | 'completed' | 'partial' | 'failed';\n  readonly createdAt: number;\n  readonly strategy: 'parallel' | 'sequential' | 'custom';\n  readonly maxConcurrency?: number;\n}\n\n// Queue statistics\nexport interface QueueStats {\n  readonly totalItems: number;\n  readonly pendingItems: number;\n  readonly processingItems: number;\n  readonly completedItems: number;\n  readonly failedItems: number;\n  readonly deadItems: number;\n  readonly averageProcessingTime: number;\n  readonly successRate: number;\n  readonly lastProcessedAt: number | null;\n  readonly throughputPerMinute: number;\n  readonly priorityDistribution: Record<QueuePriority, number>;\n  readonly resourceDistribution: Record<ResourceType, number>;\n}\n\n// Mutable version for internal metrics management\nexport interface InternalQueueStats {\n  totalItems: number;\n  pendingItems: number;\n  processingItems: number;\n  completedItems: number;\n  failedItems: number;\n  deadItems: number;\n  averageProcessingTime: number;\n  successRate: number;\n  lastProcessedAt: number | null;\n  throughputPerMinute: number;\n  priorityDistribution: Record<QueuePriority, number>;\n  resourceDistribution: Record<ResourceType, number>;\n}\n\n// Queue configuration\nexport interface QueueConfig {\n  readonly maxSize: number;\n  readonly maxRetries: number;\n  readonly defaultPriority: QueuePriority;\n  readonly defaultRetryStrategy: RetryStrategy;\n  readonly defaultConflictResolution: ConflictResolutionStrategy;\n  readonly batchingEnabled: boolean;\n  readonly batchSize: number;\n  readonly batchTimeout: number;\n  readonly deadLetterEnabled: boolean;\n  readonly analyticsEnabled: boolean;\n  readonly persistToDisk: boolean;\n  readonly circuitBreakerEnabled: boolean;\n  readonly circuitBreakerThreshold: number;\n  readonly deduplicationEnabled: boolean;\n  readonly deduplicationWindow: number;\n}\n\n// Queue event types\nexport interface QueueEvents {\n  'item:added': { item: QueueItem };\n  'item:processing': { item: QueueItem };\n  'item:completed': { item: QueueItem; result?: unknown };\n  'item:failed': { item: QueueItem; error: QueueError };\n  'item:retry': { item: QueueItem; attempt: number };\n  'item:dead': { item: QueueItem };\n  'item:max-retries-exceeded': { item: QueueItem };\n  'item:circuit-open': { item: QueueItem; resource: ResourceType };\n  'item:retry-scheduled': { item: QueueItem; attempt: number; delay: number };\n  'item:retry-cancelled': { item: QueueItem };\n  'item:retry-ready': { itemId: QueueItemId; attempt: number };\n  'batch:created': { batch: BatchOperation };\n  'batch:completed': { batch: BatchOperation };\n  'batch:failed': { batch: BatchOperation };\n  'queue:initialized': {};\n  'queue:drained': { stats: QueueStats };\n  'queue:backpressure': { queueSize: number; threshold: number };\n  'queue:paused': { reason?: string };\n  'queue:resumed': { reason?: string };\n  'circuit:opened': { resource: ResourceType; errorRate: number };\n  'circuit:closed': { resource: ResourceType };\n  'circuit:half-open': { resource: ResourceType };\n  'circuit:reset': { resource: ResourceType };\n  'retry:queue-full': { queueSize: number; maxSize: number };\n}\n\n// Retry policy configuration\nexport interface RetryPolicy {\n  readonly strategy: RetryStrategy;\n  readonly maxRetries: number;\n  readonly baseDelay: number;\n  readonly maxDelay: number;\n  readonly backoffFactor: number;\n  readonly jitterEnabled: boolean;\n  readonly retryableErrors?: string[];\n  readonly nonRetryableErrors?: string[];\n}\n\n// Circuit breaker state\nexport interface CircuitBreakerState {\n  readonly state: 'closed' | 'open' | 'half-open';\n  readonly failureCount: number;\n  readonly successCount: number;\n  readonly lastFailureTime: number | null;\n  readonly nextRetryTime: number | null;\n  readonly threshold: number;\n  readonly timeout: number;\n}\n\n// Deduplication key generator\nexport type DeduplicationKeyGenerator = (item: Omit<QueueItem, 'id' | 'createdAt' | 'updatedAt'>) => string;\n\n// Queue processor function type\nexport type QueueProcessor<T = unknown> = (item: QueueItem) => Promise<T>;\n\n// Conflict resolver function type\nexport type ConflictResolver<T = unknown> = (\n  localItem: QueueItem,\n  serverItem: T,\n  context: { resource: ResourceType; operation: QueueOperationType }\n) => Promise<T>;\n\n// Utility functions for creating branded types\nexport const createQueueItemId = (id: string): QueueItemId => id as QueueItemId;\n\n// Type guards\nexport const isQueueItemId = (value: unknown): value is QueueItemId =>\n  typeof value === 'string' && value.length > 0;\n\nexport const isValidPriority = (value: unknown): value is QueuePriority =>\n  typeof value === 'string' && ['critical', 'high', 'normal', 'low'].includes(value);\n\nexport const isValidOperation = (value: unknown): value is QueueOperationType =>\n  typeof value === 'string' && ['create', 'update', 'delete', 'batch', 'custom'].includes(value);\n\nexport const isValidResource = (value: unknown): value is ResourceType =>\n  typeof value === 'string' && \n  ['receipts', 'cashiers', 'merchants', 'cash-registers', 'point-of-sales', 'pems'].includes(value);","/**\n * Base OpenAPI Resource Class\n * Enterprise-grade foundation for all API resources with full type safety\n * \n * Features:\n * - Type-safe request execution based on OpenAPI specification\n * - Automatic parameter binding (path, query, body)\n * - Schema validation and error handling\n * - Audit trail and metadata tracking\n * - Integration with existing HTTP client and middleware\n */\n\nimport type { HttpClient, RequestOptions as HttpRequestOptions } from '@/http/client';\nimport type { EndpointDefinition, HttpMethod } from '@/generated/endpoints';\nimport { EndpointUtils } from '@/generated/endpoints';\nimport { ValidationError, type ACubeSDKError } from '@/errors/index';\nimport type { UnifiedStorage } from '@/storage/unified-storage';\nimport type { EnterpriseQueueManager, QueueItem } from '@/storage/queue/queue-manager';\nimport { createQueueItemId } from '@/storage/queue/types';\n\nexport interface BaseResourceConfig {\n  client: HttpClient;\n  endpoints: Record<string, EndpointDefinition>;\n  storage?: UnifiedStorage | undefined;\n  queueManager?: EnterpriseQueueManager | undefined;\n  offlineEnabled?: boolean;\n}\n\nexport interface OfflineRequestOptions {\n  preferOffline?: boolean;\n  queueIfOffline?: boolean;\n  skipCache?: boolean;\n  cacheTTL?: number; // seconds\n  optimistic?: boolean;\n}\n\nexport interface RequestOptions extends OfflineRequestOptions {\n  pathParams?: Record<string, string | number>;\n  queryParams?: Record<string, unknown>;\n  headers?: Record<string, string>;\n  metadata?: Record<string, unknown>;\n  skipRetry?: boolean;\n  skipCircuitBreaker?: boolean;\n  timeout?: number;\n}\n\nexport interface ValidationContext {\n  endpoint: EndpointDefinition;\n  operation: string;\n  data?: unknown;\n  pathParams?: Record<string, string | number>;\n  queryParams?: Record<string, unknown>;\n}\n\n/**\n * Abstract base class for all OpenAPI-based resources\n * Provides type-safe operations with comprehensive error handling and validation\n * Enhanced with offline-first capabilities\n */\nexport abstract class BaseOpenAPIResource {\n  protected readonly client: HttpClient;\n  protected readonly endpoints: Record<string, EndpointDefinition>;\n  protected readonly storage?: UnifiedStorage | undefined;\n  protected readonly queueManager?: EnterpriseQueueManager | undefined;\n  protected readonly offlineEnabled: boolean;\n\n  constructor(config: BaseResourceConfig) {\n    this.client = config.client;\n    this.endpoints = config.endpoints;\n    this.storage = config.storage || undefined;\n    this.queueManager = config.queueManager || undefined;\n    this.offlineEnabled = config.offlineEnabled ?? false;\n  }\n\n  /**\n   * Execute a type-safe API request based on OpenAPI endpoint definition\n   * Enhanced with offline-first capabilities\n   * \n   * @template TRequest - Type of request data\n   * @template TResponse - Type of response data\n   * @param endpointKey - Key to identify the endpoint in the endpoints map\n   * @param data - Request body data (for POST/PUT/PATCH requests)\n   * @param options - Additional request options including offline preferences\n   * @returns Promise resolving to typed response data\n   */\n  protected async executeRequest<TRequest = unknown, TResponse = unknown>(\n    endpointKey: string,\n    data?: TRequest,\n    options: RequestOptions = {}\n  ): Promise<TResponse> {\n    const endpoint = this.endpoints[endpointKey];\n    if (!endpoint) {\n      throw new ValidationError(\n        `Unknown endpoint: ${endpointKey}`,\n        'execute_request',\n        [{ field: 'endpointKey', message: `Endpoint '${endpointKey}' not found`, code: 'UNKNOWN_ENDPOINT' }]\n      );\n    }\n\n    // Validate the request before execution\n    this.validateRequest({ endpoint, operation: endpointKey, data, ...options });\n\n    // Offline-first execution logic\n    if (this.offlineEnabled && this.storage) {\n      return this.executeOfflineFirstRequest<TRequest, TResponse>(endpoint, endpointKey, data, options);\n    }\n\n    // Fallback to standard online execution\n    return this.executeOnlineRequest<TRequest, TResponse>(endpoint, endpointKey, data, options);\n  }\n\n  /**\n   * Execute offline-first request with intelligent fallback\n   */\n  private async executeOfflineFirstRequest<TRequest = unknown, TResponse = unknown>(\n    endpoint: EndpointDefinition,\n    endpointKey: string,\n    data?: TRequest,\n    options: RequestOptions = {}\n  ): Promise<TResponse> {\n    const cacheKey = this.buildCacheKey(endpoint, options.pathParams, options.queryParams);\n    const isReadOperation = endpoint.method === 'GET';\n    const isWriteOperation = ['POST', 'PUT', 'PATCH', 'DELETE'].includes(endpoint.method);\n\n    try {\n      // For read operations, try cache first unless explicitly skipped\n      if (isReadOperation && !options.skipCache && !options.preferOffline) {\n        const cachedResult = await this.getCachedResponse<TResponse>(cacheKey);\n        if (cachedResult) {\n          return cachedResult;\n        }\n      }\n\n      // If prefer offline is set, try offline storage first\n      if (options.preferOffline && isReadOperation) {\n        const offlineResult = await this.getOfflineData<TResponse>(cacheKey);\n        if (offlineResult) {\n          return offlineResult;\n        }\n      }\n\n      // Attempt online execution\n      const result = await this.executeOnlineRequest<TRequest, TResponse>(endpoint, endpointKey, data, options);\n      \n      // Cache successful read responses\n      if (isReadOperation && result) {\n        await this.cacheResponse(cacheKey, result, options.cacheTTL);\n      }\n\n      return result;\n\n    } catch (error) {\n      // Handle offline scenarios for write operations\n      if (isWriteOperation && options.queueIfOffline && this.queueManager) {\n        return this.queueWriteOperation<TRequest, TResponse>(endpoint, endpointKey, data, options, error as Error);\n      }\n\n      // For read operations, try offline data as fallback\n      if (isReadOperation) {\n        const offlineResult = await this.getOfflineData<TResponse>(cacheKey);\n        if (offlineResult) {\n          return offlineResult;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute standard online request (original implementation)\n   */\n  private async executeOnlineRequest<TRequest = unknown, TResponse = unknown>(\n    endpoint: EndpointDefinition,\n    endpointKey: string,\n    data?: TRequest,\n    options: RequestOptions = {}\n  ): Promise<TResponse> {\n\n    // Build the complete URL with path parameters\n    const url = this.buildRequestUrl(endpoint, options.pathParams);\n\n    // Prepare request options for HTTP client\n    const httpOptions: HttpRequestOptions = {\n      method: endpoint.method,\n      url,\n      data,\n      headers: {\n        ...this.getDefaultHeaders(endpoint),\n        ...options.headers,\n      },\n      metadata: {\n        operationId: endpoint.operationId,\n        resource: endpoint.metadata?.resource,\n        operation: endpoint.metadata?.operation,\n        ...options.metadata,\n      },\n      skipRetry: options.skipRetry ?? !EndpointUtils.isRetryable(endpoint),\n    };\n\n    // Add optional properties only if they have values\n    if (options.queryParams) {\n      httpOptions.params = options.queryParams;\n    }\n    if (options.timeout) {\n      httpOptions.timeout = options.timeout;\n    }\n    if (options.skipCircuitBreaker !== undefined) {\n      httpOptions.skipCircuitBreaker = options.skipCircuitBreaker;\n    }\n\n    try {\n      // Execute the HTTP request through the client\n      const response = await this.client.request<TResponse>(httpOptions);\n      \n      // Validate response if needed\n      this.validateResponse(endpoint, response.data);\n      \n      return response.data;\n    } catch (error) {\n      // Enhanced error handling with OpenAPI context\n      throw this.enhanceError(error as ACubeSDKError, endpoint, endpointKey, options);\n    }\n  }\n\n  /**\n   * Cache response data with TTL\n   */\n  private async cacheResponse<TResponse>(cacheKey: string, data: TResponse, ttl?: number): Promise<void> {\n    if (!this.storage) return;\n\n    try {\n      const ttlSeconds = ttl || 3600; // Default 1 hour\n      const expiresAt = new Date(Date.now() + ttlSeconds * 1000);\n      \n      await this.storage.set(cacheKey as any, {\n        data,\n        timestamp: new Date(),\n        expiresAt,\n      });\n    } catch (error) {\n      // Cache failures should not break the main operation\n      console.warn('Failed to cache response:', error);\n    }\n  }\n\n  /**\n   * Get cached response if valid\n   */\n  private async getCachedResponse<TResponse>(cacheKey: string): Promise<TResponse | null> {\n    if (!this.storage) return null;\n\n    try {\n      const cached = await this.storage.get<{\n        data: TResponse;\n        timestamp: Date;\n        expiresAt: Date;\n      }>(cacheKey as any);\n\n      if (cached && cached.data && 'expiresAt' in cached.data && new Date() < new Date(cached.data.expiresAt)) {\n        return cached.data.data;\n      }\n\n      // Remove expired cache entry\n      if (cached) {\n        await this.storage.delete(cacheKey as any);\n      }\n\n      return null;\n    } catch (error) {\n      console.warn('Failed to get cached response:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get offline data (persistent storage)\n   */\n  private async getOfflineData<TResponse>(cacheKey: string): Promise<TResponse | null> {\n    if (!this.storage) return null;\n\n    try {\n      const offlineKey = `offline:${cacheKey}`;\n      const offlineEntry = await this.storage.get(offlineKey as any);\n      return (offlineEntry?.data as TResponse) || null;\n    } catch (error) {\n      console.warn('Failed to get offline data:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Queue write operation for later execution\n   */\n  private async queueWriteOperation<TRequest = unknown, TResponse = unknown>(\n    endpoint: EndpointDefinition,\n    endpointKey: string,\n    data?: TRequest,\n    options: RequestOptions = {},\n    networkError?: Error\n  ): Promise<TResponse> {\n    if (!this.queueManager) {\n      throw networkError || new Error('Network unavailable and queue not configured');\n    }\n\n    // Create queue item\n    const queueItem: QueueItem = {\n      id: createQueueItemId(`${endpointKey}_${Date.now()}_${Math.random().toString(36).substring(2)}`),\n      operation: this.mapHttpMethodToQueueOperation(endpoint.method),\n      resource: 'receipts', // Default resource type - should be passed as parameter\n      data: {\n        endpoint: endpointKey,\n        requestData: data,\n        pathParams: options.pathParams,\n        queryParams: options.queryParams,\n        headers: options.headers,\n      },\n      priority: this.determinePriority(endpoint),\n      status: 'pending' as const,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n      retryCount: 0,\n      maxRetries: 3,\n      retryStrategy: 'exponential' as const,\n      conflictResolution: 'client-wins' as const,\n      ...(options.metadata && { metadata: options.metadata }),\n    };\n\n    // Add to queue\n    await this.queueManager.add(queueItem);\n\n    // For optimistic updates, return a placeholder response\n    if (options.optimistic) {\n      return this.createOptimisticResponse<TResponse>(endpoint, data, options);\n    }\n\n    // For non-optimistic updates, throw to indicate operation was queued\n    throw new ValidationError(\n      'Operation queued for later execution',\n      'queued_operation',\n      [{ field: 'network', message: 'Operation will be executed when network is available', code: 'QUEUED' }]\n    );\n  }\n\n  /**\n   * Build cache key for request\n   */\n  private buildCacheKey(\n    endpoint: EndpointDefinition,\n    pathParams?: Record<string, string | number>,\n    queryParams?: Record<string, unknown>\n  ): string {\n    let key = `${endpoint.method}:${endpoint.path}`;\n    \n    // Add path parameters to key\n    if (pathParams) {\n      const sortedParams = Object.keys(pathParams).sort();\n      const pathParamString = sortedParams.map(key => `${key}=${pathParams[key]}`).join('&');\n      key += `?path=${pathParamString}`;\n    }\n\n    // Add query parameters to key\n    if (queryParams) {\n      const sortedParams = Object.keys(queryParams).sort();\n      const queryParamString = sortedParams.map(key => `${key}=${queryParams[key]}`).join('&');\n      key += `&query=${queryParamString}`;\n    }\n\n    return `api_cache:${key}`;\n  }\n\n  /**\n   * Map HTTP method to queue operation type\n   */\n  private mapHttpMethodToQueueOperation(method: string): QueueItem['operation'] {\n    switch (method.toUpperCase()) {\n      case 'POST': return 'create';\n      case 'PUT': \n      case 'PATCH': return 'update';\n      case 'DELETE': return 'delete';\n      default: return 'custom'; // For GET and others\n    }\n  }\n\n  /**\n   * Determine queue priority based on endpoint\n   */\n  private determinePriority(endpoint: EndpointDefinition): QueueItem['priority'] {\n    // Higher priority for receipts and critical operations\n    if (endpoint.path.includes('/receipts') || endpoint.path.includes('/cashiers')) {\n      return 'high';\n    }\n    return 'normal';\n  }\n\n  /**\n   * Create optimistic response for write operations\n   */\n  private createOptimisticResponse<TResponse>(\n    endpoint: EndpointDefinition,\n    data: unknown,\n    _options: RequestOptions\n  ): TResponse {\n    // For POST operations, assume creation succeeded\n    if (endpoint.method === 'POST') {\n      return {\n        ...(data && typeof data === 'object' ? data : {}),\n        id: `temp_${Date.now()}`,\n        _optimistic: true,\n      } as TResponse;\n    }\n\n    // For PUT/PATCH, return the updated data\n    if (endpoint.method === 'PUT' || endpoint.method === 'PATCH') {\n      return {\n        ...(data && typeof data === 'object' ? data : {}),\n        _optimistic: true,\n      } as TResponse;\n    }\n\n    // For DELETE, return success indication\n    if (endpoint.method === 'DELETE') {\n      return {\n        success: true,\n        _optimistic: true,\n      } as TResponse;\n    }\n\n    // Default optimistic response\n    return {\n      success: true,\n      _optimistic: true,\n    } as TResponse;\n  }\n\n  /**\n   * Build complete request URL with path parameter substitution\n   */\n  private buildRequestUrl(endpoint: EndpointDefinition, pathParams: Record<string, string | number> = {}): string {\n    return EndpointUtils.buildUrl(endpoint, pathParams);\n  }\n\n  /**\n   * Get default headers based on endpoint requirements\n   */\n  private getDefaultHeaders(endpoint: EndpointDefinition): Record<string, string> {\n    const headers: Record<string, string> = {};\n\n    // Set content type for requests with body\n    if (endpoint.requestBody) {\n      headers['Content-Type'] = endpoint.requestBody.contentType;\n    }\n\n    // Set default accept header\n    const successResponse = endpoint.responses['200'] || endpoint.responses['201'];\n    if (successResponse?.contentType) {\n      headers['Accept'] = successResponse.contentType;\n    }\n\n    return headers;\n  }\n\n  /**\n   * Validate request data against OpenAPI specification\n   */\n  private validateRequest(context: ValidationContext): void {\n    const { endpoint, operation, data, pathParams, queryParams } = context;\n    const errors: Array<{ field: string; message: string; code: string }> = [];\n\n    // Validate required path parameters\n    if (endpoint.parameters?.path) {\n      for (const [paramName, paramType] of Object.entries(endpoint.parameters.path)) {\n        if (!pathParams || !(paramName in pathParams)) {\n          errors.push({\n            field: `path.${paramName}`,\n            message: `Required path parameter '${paramName}' is missing`,\n            code: 'MISSING_PATH_PARAM',\n          });\n        } else {\n          // Type validation for path parameters\n          const value = pathParams[paramName];\n          if (!this.validateParameterType(value, paramType)) {\n            errors.push({\n              field: `path.${paramName}`,\n              message: `Path parameter '${paramName}' must be of type ${paramType}`,\n              code: 'INVALID_PATH_PARAM_TYPE',\n            });\n          }\n        }\n      }\n    }\n\n    // Validate required request body\n    if (endpoint.requestBody?.required && !data) {\n      errors.push({\n        field: 'body',\n        message: 'Request body is required',\n        code: 'MISSING_BODY',\n      });\n    }\n\n    // Validate query parameters (basic type checking)\n    if (endpoint.parameters?.query && queryParams) {\n      for (const [paramName, paramType] of Object.entries(endpoint.parameters.query)) {\n        const value = queryParams[paramName];\n        if (value !== undefined && !this.validateParameterType(value, paramType)) {\n          errors.push({\n            field: `query.${paramName}`,\n            message: `Query parameter '${paramName}' must be of type ${paramType}`,\n            code: 'INVALID_QUERY_PARAM_TYPE',\n          });\n        }\n      }\n    }\n\n    if (errors.length > 0) {\n      throw new ValidationError(\n        `Request validation failed for operation '${operation}'`,\n        operation,\n        errors\n      );\n    }\n  }\n\n  /**\n   * Basic type validation for parameters\n   */\n  private validateParameterType(value: unknown, expectedType: string): boolean {\n    switch (expectedType) {\n      case 'string':\n        return typeof value === 'string';\n      case 'integer':\n      case 'number':\n        return typeof value === 'number' || (typeof value === 'string' && !isNaN(Number(value)));\n      case 'boolean':\n        return typeof value === 'boolean';\n      default:\n        return true; // Allow unknown types for now\n    }\n  }\n\n  /**\n   * Validate response data (can be extended for schema validation)\n   */\n  private validateResponse(endpoint: EndpointDefinition, data: unknown): void {\n    // Basic response validation - can be enhanced with JSON schema validation\n    if (data === null || data === undefined) {\n      // Check if null response is expected\n      const hasNullableResponse = Object.keys(endpoint.responses).some(code => \n        code === '204' || endpoint.responses[code]?.description?.toLowerCase().includes('no content')\n      );\n      \n      if (!hasNullableResponse) {\n        console.warn(`Received null/undefined response for ${endpoint.operationId}`);\n      }\n    }\n  }\n\n  /**\n   * Enhance errors with OpenAPI-specific context\n   */\n  private enhanceError(\n    error: ACubeSDKError,\n    endpoint: EndpointDefinition,\n    operation: string,\n    _options: RequestOptions\n  ): ACubeSDKError {\n    // Create enhanced error with additional context\n    const enhancedError = new (error.constructor as new (...args: any[]) => ACubeSDKError)(\n      error.message,\n      error.code,\n      {\n        operation: error.operation || endpoint.operationId,\n        retryable: error.retryable !== undefined ? error.retryable : EndpointUtils.isRetryable(endpoint),\n        statusCode: error.statusCode,\n        requestId: error.requestId,\n        auditInfo: {\n          ...error.auditInfo,\n          // Add OpenAPI-specific audit information\n          pemId: endpoint.metadata?.resource === 'point-of-sales' ? String(_options.pathParams?.serial_number || '') : error.auditInfo?.pemId,\n        },\n        cause: error.cause,\n      }\n    );\n\n    // Add a custom property for OpenAPI metadata (non-enumerable to avoid serialization issues)\n    Object.defineProperty(enhancedError, 'openapiMetadata', {\n      value: {\n        resource: endpoint.metadata?.resource,\n        endpointOperation: operation,\n        httpMethod: endpoint.method,\n        path: endpoint.path,\n      },\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n\n    return enhancedError;\n  }\n\n  /**\n   * Utility method to check if an operation is available\n   */\n  protected hasOperation(operationKey: string): boolean {\n    return operationKey in this.endpoints;\n  }\n\n  /**\n   * Get endpoint definition for an operation\n   */\n  protected getEndpoint(operationKey: string): EndpointDefinition | null {\n    return this.endpoints[operationKey] || null;\n  }\n\n  /**\n   * Get all available operations for this resource\n   */\n  protected getAvailableOperations(): string[] {\n    return Object.keys(this.endpoints);\n  }\n\n  /**\n   * Create a standardized error for missing operations\n   */\n  protected createUnsupportedOperationError(operation: string): ValidationError {\n    return new ValidationError(\n      `Operation '${operation}' is not supported by this resource`,\n      'unsupported_operation',\n      [{ \n        field: 'operation', \n        message: `Available operations: ${this.getAvailableOperations().join(', ')}`, \n        code: 'UNSUPPORTED_OPERATION' \n      }]\n    );\n  }\n\n  // Static utility methods for common patterns\n\n  /**\n   * Format validation errors for user-friendly display\n   */\n  static formatValidationErrors(errors: Array<{ field: string; message: string; code: string }>): string {\n    return errors.map(error => `${error.field}: ${error.message}`).join(', ');\n  }\n\n  /**\n   * Extract error details from API response\n   */\n  static extractErrorDetails(error: unknown): { message: string; details?: unknown } {\n    if (error instanceof ValidationError) {\n      return {\n        message: error.message,\n        details: error.violations,\n      };\n    }\n\n    if (error instanceof Error) {\n      return { message: error.message };\n    }\n\n    return { message: 'Unknown error occurred' };\n  }\n\n  /**\n   * Check if error indicates a temporary failure\n   */\n  static isTemporaryError(error: ACubeSDKError): boolean {\n    // Network errors are usually temporary\n    if (error.name === 'NetworkError') {\n      return true;\n    }\n\n    // Some HTTP status codes indicate temporary issues\n    if (error.statusCode) {\n      return [429, 500, 502, 503, 504].includes(error.statusCode);\n    }\n\n    return error.retryable ?? false;\n  }\n\n  /**\n   * Get retry delay for temporary errors\n   */\n  static getRetryDelay(_error: ACubeSDKError, attempt: number): number {\n    // Exponential backoff with jitter\n    const baseDelay = 1000; // 1 second\n    const maxDelay = 30000; // 30 seconds\n    \n    let delay = Math.min(baseDelay * Math.pow(2, attempt - 1), maxDelay);\n    \n    // Add jitter (25%)\n    const jitter = delay * 0.25;\n    delay += (Math.random() * 2 - 1) * jitter;\n    \n    return Math.floor(delay);\n  }\n\n  // Offline utility methods\n\n  /**\n   * Check if offline capabilities are enabled for this resource\n   */\n  protected isOfflineEnabled(): boolean {\n    return this.offlineEnabled && Boolean(this.storage);\n  }\n\n  /**\n   * Check if queue capabilities are enabled for this resource\n   */\n  protected isQueueEnabled(): boolean {\n    return this.offlineEnabled && Boolean(this.queueManager);\n  }\n\n  /**\n   * Store data for offline use (persistent across sessions)\n   */\n  protected async storeOfflineData(key: string, data: any): Promise<void> {\n    if (!this.storage) return;\n\n    try {\n      const offlineKey = `offline:${key}`;\n      await this.storage.set(offlineKey as any, data);\n    } catch (error) {\n      console.warn('Failed to store offline data:', error);\n    }\n  }\n\n  /**\n   * Clear cached data for a specific key pattern\n   */\n  protected async clearCache(keyPattern?: string): Promise<void> {\n    if (!this.storage) return;\n\n    try {\n      if (keyPattern) {\n        // Use query to find matching keys\n        const results = await this.storage.query({ keyPrefix: `api_cache:${keyPattern}` }) as Array<{ key: any; value: any }>;\n        for (const entry of results) {\n          await this.storage.delete(entry.key);\n        }\n      } else {\n        // Clear all cache entries for this resource\n        const results = await this.storage.query({ keyPrefix: 'api_cache:' }) as Array<{ key: any; value: any }>;\n        for (const entry of results) {\n          await this.storage.delete(entry.key);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to clear cache:', error);\n    }\n  }\n\n  /**\n   * Get offline queue statistics for this resource\n   */\n  protected async getOfflineStats(): Promise<{\n    queuedOperations: number;\n    cachedEntries: number;\n    offlineEntries: number;\n  }> {\n    const stats = {\n      queuedOperations: 0,\n      cachedEntries: 0,\n      offlineEntries: 0,\n    };\n\n    try {\n      if (this.queueManager) {\n        const queueStats = this.queueManager.getStats();\n        stats.queuedOperations = queueStats.totalItems;\n      }\n\n      if (this.storage) {\n        // Count cache entries\n        const cacheEntries = await this.storage.query({ keyPrefix: 'api_cache:' }) as Array<{ key: any; value: any }>;\n        stats.cachedEntries = cacheEntries.length;\n\n        // Count offline entries\n        const offlineEntries = await this.storage.query({ keyPrefix: 'offline:' }) as Array<{ key: any; value: any }>;\n        stats.offlineEntries = offlineEntries.length;\n      }\n    } catch (error) {\n      console.warn('Failed to get offline stats:', error);\n    }\n\n    return stats;\n  }\n\n  /**\n   * Force sync of queued operations for this resource\n   */\n  protected async syncQueuedOperations(): Promise<void> {\n    if (!this.queueManager) return;\n\n    try {\n      await this.queueManager.processAll();\n    } catch (error) {\n      console.warn('Failed to sync queued operations:', error);\n      throw error;\n    }\n  }\n}\n\n/**\n * Type-safe endpoint builder for dynamic endpoint creation\n */\nexport class EndpointBuilder {\n  private definition: Partial<EndpointDefinition> = {};\n\n  constructor(path: string, method: HttpMethod) {\n    this.definition = {\n      path,\n      method,\n      tags: [],\n      responses: {},\n    };\n  }\n\n  operationId(id: string): this {\n    this.definition.operationId = id;\n    return this;\n  }\n\n  summary(text: string): this {\n    this.definition.summary = text;\n    return this;\n  }\n\n  description(text: string): this {\n    this.definition.description = text;\n    return this;\n  }\n\n  tag(name: string): this {\n    this.definition.tags = [...(this.definition.tags || []), name];\n    return this;\n  }\n\n  requireAuth(): this {\n    this.definition.security = [{ 'E-Receipt_IT_API_OAuth2PasswordBearer': [] }];\n    return this;\n  }\n\n  pathParam(name: string, type: string): this {\n    if (!this.definition.parameters) {\n      this.definition.parameters = {};\n    }\n    if (!this.definition.parameters.path) {\n      this.definition.parameters.path = {};\n    }\n    this.definition.parameters.path[name] = type;\n    return this;\n  }\n\n  queryParam(name: string, type: string): this {\n    if (!this.definition.parameters) {\n      this.definition.parameters = {};\n    }\n    if (!this.definition.parameters.query) {\n      this.definition.parameters.query = {};\n    }\n    this.definition.parameters.query[name] = type;\n    return this;\n  }\n\n  requestBody(schema: string, required = true): this {\n    this.definition.requestBody = {\n      required,\n      contentType: 'application/json',\n      schema,\n    };\n    return this;\n  }\n\n  response(statusCode: string, description: string, schema?: string): this {\n    if (!this.definition.responses) {\n      this.definition.responses = {};\n    }\n    this.definition.responses[statusCode] = {\n      description,\n      ...(schema && { contentType: 'application/json', schema }),\n    };\n    return this;\n  }\n\n  metadata(resource: string, operation: string, authRequired = true, retryable = true): this {\n    this.definition.metadata = {\n      resource,\n      operation,\n      authRequired,\n      retryable,\n    };\n    return this;\n  }\n\n  build(): EndpointDefinition {\n    if (!this.definition.operationId) {\n      throw new Error('operationId is required');\n    }\n\n    return this.definition as EndpointDefinition;\n  }\n}","/**\n * Cashiers Resource - OpenAPI Implementation\n * Type-safe implementation based on OpenAPI specification\n * \n * Features:\n * - Full CRUD operations for cashier management\n * - Type-safe input/output with branded types\n * - Advanced validation and business logic\n * - Password security utilities\n * - Email management and formatting\n */\n\nimport { BaseOpenAPIResource, type RequestOptions } from '@/resources/base-openapi';\nimport { CashierEndpoints } from '@/generated/endpoints';\nimport type { HttpClient } from '@/http/client';\nimport type { CashierId } from '@/types/branded';\nimport type { components } from '@/types/generated';\nimport type { UnifiedStorage } from '@/storage/unified-storage';\nimport type { EnterpriseQueueManager } from '@/storage/queue/queue-manager';\nimport { ValidationError } from '@/errors/index';\n\n// Extract types from OpenAPI generated types\ntype CashierCreateInput = components['schemas']['E-Receipt_IT_API_CashierCreateInput'];\ntype CashierOutput = components['schemas']['E-Receipt_IT_API_CashierOutput'];\ntype CashierPage = components['schemas']['E-Receipt_IT_API_Page__T_Customized_CashierOutput_'];\n\nexport interface CashierListParams {\n  page?: number;\n  size?: number;\n}\n\nexport interface CashierValidationOptions {\n  enforceStrongPassword?: boolean;\n  allowedEmailDomains?: string[];\n  checkEmailUniqueness?: boolean;\n}\n\n/**\n * Cashiers Resource Class - OpenAPI Based\n * Manages cashier user accounts with full OpenAPI compliance\n * Enhanced with offline-first capabilities\n */\nexport class CashiersResource extends BaseOpenAPIResource {\n  constructor(client: HttpClient, storage?: UnifiedStorage | undefined, queueManager?: EnterpriseQueueManager | undefined) {\n    super({\n      client,\n      storage: storage || undefined,\n      queueManager: queueManager || undefined,\n      offlineEnabled: Boolean(storage || queueManager),\n      endpoints: {\n        list: CashierEndpoints.LIST,\n        create: CashierEndpoints.CREATE,\n        me: CashierEndpoints.ME,\n        getById: CashierEndpoints.GET_BY_ID,\n        delete: CashierEndpoints.DELETE,\n      }\n    });\n  }\n\n  /**\n   * Get a list of cashiers with pagination\n   * Enhanced with offline-first capabilities\n   * \n   * @param params - Pagination parameters\n   * @param options - Request options including offline preferences\n   * @returns Promise resolving to paginated cashier list\n   */\n  async list(params?: CashierListParams, options: Partial<RequestOptions> = {}): Promise<CashierPage> {\n    return this.executeRequest<void, CashierPage>('list', undefined, {\n      ...(params && { queryParams: params as Record<string, unknown> }),\n      cacheTTL: 600, // Cache for 10 minutes\n      queueIfOffline: false,\n      ...options,\n      metadata: {\n        operation: 'list_cashiers',\n        ...options.metadata,\n      }\n    });\n  }\n\n  /**\n   * Create a new cashier\n   * Enhanced with offline queuing and optimistic updates\n   * \n   * @param data - Cashier creation input data\n   * @param validationOptions - Validation options\n   * @param requestOptions - Request options including offline preferences\n   * @returns Promise resolving to created cashier\n   */\n  async create(\n    data: CashierCreateInput, \n    validationOptions: CashierValidationOptions = {},\n    requestOptions: Partial<RequestOptions> = {}\n  ): Promise<CashierOutput> {\n    // Validate input with custom business rules\n    await this.validateCashierInput(data, validationOptions);\n\n    return this.executeRequest<CashierCreateInput, CashierOutput>('create', data, {\n      queueIfOffline: true,\n      optimistic: true,\n      ...requestOptions,\n      metadata: {\n        operation: 'create_cashier',\n        email: data.email,\n        ...requestOptions.metadata,\n      }\n    });\n  }\n\n  /**\n   * Get current cashier information\n   * Enhanced with intelligent caching\n   * \n   * @param options - Request options including offline preferences\n   * @returns Promise resolving to current cashier details\n   */\n  async me(options: Partial<RequestOptions> = {}): Promise<CashierOutput> {\n    return this.executeRequest<void, CashierOutput>('me', undefined, {\n      cacheTTL: 300, // Cache for 5 minutes\n      queueIfOffline: false,\n      ...options,\n      metadata: {\n        operation: 'get_current_cashier',\n        ...options.metadata,\n      }\n    });\n  }\n\n  /**\n   * Get a specific cashier by ID\n   * \n   * @param cashierId - Cashier ID (branded or number)\n   * @returns Promise resolving to cashier details\n   */\n  async retrieve(cashierId: CashierId | number): Promise<CashierOutput> {\n    return this.executeRequest<void, CashierOutput>('getById', undefined, {\n      pathParams: { cashier_id: cashierId },\n      metadata: {\n        operation: 'get_cashier',\n        cashierId,\n      }\n    });\n  }\n\n  /**\n   * Delete a cashier\n   * \n   * @param cashierId - Cashier ID (branded or number)\n   * @returns Promise resolving when deletion is complete\n   */\n  async delete(cashierId: CashierId | number): Promise<void> {\n    return this.executeRequest<void, void>('delete', undefined, {\n      pathParams: { cashier_id: cashierId },\n      metadata: {\n        operation: 'delete_cashier',\n        cashierId,\n      }\n    });\n  }\n\n  /**\n   * Update a cashier's profile (future enhancement)\n   * Note: This endpoint is not yet available in the OpenAPI spec\n   */\n  async update(cashierId: CashierId | number, data: Partial<CashierCreateInput>): Promise<CashierOutput> {\n    if (!this.hasOperation('update')) {\n      throw this.createUnsupportedOperationError('update');\n    }\n    \n    return this.executeRequest<Partial<CashierCreateInput>, CashierOutput>('update', data, {\n      pathParams: { cashier_id: cashierId },\n      metadata: {\n        operation: 'update_cashier',\n        cashierId,\n      }\n    });\n  }\n\n  // Validation methods\n\n  /**\n   * Comprehensive cashier input validation\n   */\n  private async validateCashierInput(\n    data: CashierCreateInput, \n    options: CashierValidationOptions = {}\n  ): Promise<void> {\n    const errors: Array<{ field: string; message: string; code: string }> = [];\n\n    // Email validation\n    if (!data.email || !this.isValidEmail(data.email)) {\n      errors.push({\n        field: 'email',\n        message: 'Invalid email format',\n        code: 'INVALID_EMAIL'\n      });\n    } else {\n      // Domain validation if specified\n      if (options.allowedEmailDomains && options.allowedEmailDomains.length > 0) {\n        if (!CashiersResource.isAllowedEmailDomain(data.email, options.allowedEmailDomains)) {\n          errors.push({\n            field: 'email',\n            message: `Email domain not allowed. Allowed domains: ${options.allowedEmailDomains.join(', ')}`,\n            code: 'DOMAIN_NOT_ALLOWED'\n          });\n        }\n      }\n\n      // Email uniqueness check (if enabled and implemented)\n      if (options.checkEmailUniqueness) {\n        const isDuplicate = await this.checkEmailExists(data.email);\n        if (isDuplicate) {\n          errors.push({\n            field: 'email',\n            message: 'Email address is already in use',\n            code: 'EMAIL_EXISTS'\n          });\n        }\n      }\n    }\n\n    // Password validation\n    const passwordCheck = CashiersResource.checkPasswordStrength(data.password);\n    if (!passwordCheck.isValid) {\n      if (options.enforceStrongPassword) {\n        errors.push({\n          field: 'password',\n          message: passwordCheck.message || 'Password does not meet security requirements',\n          code: 'WEAK_PASSWORD'\n        });\n      } else {\n        // Just warn for weak passwords if not enforcing\n        console.warn(`Weak password detected for ${data.email}: ${passwordCheck.suggestions.join(', ')}`);\n      }\n    }\n\n    if (errors.length > 0) {\n      throw new ValidationError('Invalid cashier input', 'create_cashier', errors);\n    }\n  }\n\n  /**\n   * Check if email already exists (placeholder for future implementation)\n   */\n  private async checkEmailExists(email: string): Promise<boolean> {\n    // This would require a separate endpoint or database query\n    // For now, we'll return false as a placeholder\n    console.warn(`Email uniqueness check not implemented for: ${email}`);\n    return false;\n  }\n\n  /**\n   * Validate email format\n   */\n  private isValidEmail(email: string): boolean {\n    return CashiersResource.isValidEmail(email);\n  }\n\n  // Static utility methods\n\n  /**\n   * Validate email format (static utility)\n   */\n  static isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  /**\n   * Check password strength with detailed analysis\n   */\n  static checkPasswordStrength(password: string): {\n    isValid: boolean;\n    score: number;\n    message?: string;\n    suggestions: string[];\n  } {\n    const suggestions: string[] = [];\n    let score = 0;\n\n    // Length checks\n    if (password.length >= 8) score++;\n    if (password.length >= 12) score++;\n    if (password.length < 8) {\n      suggestions.push('Use at least 8 characters');\n    }\n\n    // Character variety checks\n    if (/[a-z]/.test(password)) score++;\n    else suggestions.push('Include lowercase letters');\n\n    if (/[A-Z]/.test(password)) score++;\n    else suggestions.push('Include uppercase letters');\n\n    if (/\\d/.test(password)) score++;\n    else suggestions.push('Include numbers');\n\n    if (/[^a-zA-Z0-9]/.test(password)) score++;\n    else suggestions.push('Include special characters');\n\n    // Common patterns to avoid\n    if (/(.)\\\\1{2,}/.test(password)) {\n      score--;\n      suggestions.push('Avoid repeating characters');\n    }\n\n    // Common passwords check\n    const commonPasswords = [\n      'password', 'password123', '12345678', 'qwerty', 'abc123', \n      'password1', '123456789', 'welcome', 'admin', 'letmein'\n    ];\n    \n    if (commonPasswords.some(common => password.toLowerCase().includes(common.toLowerCase()))) {\n      score = 0;\n      suggestions.push('Avoid common passwords');\n    }\n\n    // Dictionary word check (basic)\n    if (/^[a-zA-Z]+$/.test(password) && password.length < 12) {\n      score--;\n      suggestions.push('Avoid using only dictionary words');\n    }\n\n    const isValid = score >= 4 && password.length >= 8;\n    const message = isValid ? 'Strong password' : 'Password too weak';\n\n    return { isValid, score, message, suggestions };\n  }\n\n  /**\n   * Generate a secure password\n   */\n  static generateSecurePassword(length = 12): string {\n    const lowercase = 'abcdefghijklmnopqrstuvwxyz';\n    const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    const numbers = '0123456789';\n    const symbols = '!@#$%^&*()_+-=[]{}|;:,.<>?';\n    \n    const allChars = lowercase + uppercase + numbers + symbols;\n    \n    // Ensure at least one character from each category\n    let password = '';\n    password += lowercase[Math.floor(Math.random() * lowercase.length)];\n    password += uppercase[Math.floor(Math.random() * uppercase.length)];\n    password += numbers[Math.floor(Math.random() * numbers.length)];\n    password += symbols[Math.floor(Math.random() * symbols.length)];\n    \n    // Fill the rest randomly\n    for (let i = password.length; i < length; i++) {\n      password += allChars[Math.floor(Math.random() * allChars.length)];\n    }\n    \n    // Shuffle the password\n    return password.split('').sort(() => Math.random() - 0.5).join('');\n  }\n\n  /**\n   * Format email for display (partial masking for privacy)\n   */\n  static formatEmailForDisplay(email: string): string {\n    const [localPart, domain] = email.split('@');\n    if (!localPart || !domain) return email;\n\n    if (localPart.length <= 3) {\n      return `${localPart[0]}**@${domain}`;\n    }\n\n    const visibleChars = Math.min(3, Math.floor(localPart.length / 2));\n    const maskedPart = '*'.repeat(localPart.length - visibleChars);\n    \n    return `${localPart.substring(0, visibleChars)}${maskedPart}@${domain}`;\n  }\n\n  /**\n   * Extract domain from email\n   */\n  static getEmailDomain(email: string): string | null {\n    const parts = email.split('@');\n    return parts.length === 2 ? parts[1] || null : null;\n  }\n\n  /**\n   * Validate email domain against allowed domains\n   */\n  static isAllowedEmailDomain(email: string, allowedDomains: string[]): boolean {\n    const domain = this.getEmailDomain(email);\n    return domain ? allowedDomains.includes(domain.toLowerCase()) : false;\n  }\n\n  /**\n   * Generate username suggestion from email\n   */\n  static generateUsername(email: string): string {\n    const [localPart] = email.split('@');\n    if (!localPart) return 'user';\n    \n    // Clean up the local part for username\n    return localPart\n      .toLowerCase()\n      .replace(/[^a-z0-9]/g, '')\n      .substring(0, 20);\n  }\n\n  /**\n   * Validate cashier creation rate limits (placeholder for future implementation)\n   */\n  static checkCreationRateLimit(ipAddress: string): boolean {\n    // This would check against a rate limiting service\n    console.warn(`Rate limit check not implemented for IP: ${ipAddress}`);\n    return true; // Allow by default\n  }\n\n  /**\n   * Get cashier role permissions (placeholder for future implementation)\n   */\n  static getCashierPermissions(): string[] {\n    return [\n      'create_receipt',\n      'view_receipts',\n      'void_receipt',\n      'return_items',\n      'view_daily_summary',\n    ];\n  }\n\n  /**\n   * Format cashier for display in UI\n   */\n  static formatCashierForDisplay(cashier: CashierOutput): {\n    displayName: string;\n    maskedEmail: string;\n    status: string;\n    permissions: string[];\n  } {\n    return {\n      displayName: cashier.email.split('@')[0] || 'Unknown',\n      maskedEmail: this.formatEmailForDisplay(cashier.email),\n      status: 'active', // This would come from the API response\n      permissions: this.getCashierPermissions(),\n    };\n  }\n\n  /**\n   * Validate cashier session (placeholder for future implementation)\n   */\n  static validateCashierSession(cashierId: CashierId | number): Promise<boolean> {\n    // This would validate against the authentication service\n    console.warn(`Session validation not implemented for cashier: ${cashierId}`);\n    return Promise.resolve(true);\n  }\n}\n\n// Re-export for convenience\nexport { CashiersResource as Cashiers };\n\n// Export types for external use\nexport type {\n  CashierCreateInput,\n  CashierOutput,\n  CashierPage,\n};","/**\n * Receipts Resource - OpenAPI Implementation\n * Type-safe implementation for electronic receipt management\n * \n * Features:\n * - Complete electronic receipt lifecycle management\n * - Type-safe input/output with branded types\n * - Advanced validation for Italian fiscal requirements\n * - Receipt item calculations and VAT handling\n * - PDF generation and details retrieval\n * - Return and void operations\n */\n\nimport { BaseOpenAPIResource } from '@/resources/base-openapi';\nimport { ReceiptEndpoints } from '@/generated/endpoints';\nimport type { HttpClient } from '@/http/client';\nimport type { ReceiptId, Amount } from '@/types/branded';\nimport type { components } from '@/types/generated';\nimport type { UnifiedStorage } from '@/storage/unified-storage';\nimport type { EnterpriseQueueManager } from '@/storage/queue/queue-manager';\nimport type { RequestOptions } from '@/resources/base-openapi';\nimport { ValidationError } from '@/errors/index';\n\n// Extract types from OpenAPI generated types\ntype ReceiptInput = components['schemas']['E-Receipt_IT_API_ReceiptInput'];\ntype ReceiptOutput = components['schemas']['E-Receipt_IT_API_ReceiptOutput'];\ntype ReceiptPage = components['schemas']['E-Receipt_IT_API_Page__T_Customized_ReceiptOutput_'];\ntype VoidReceiptRequest = components['schemas']['E-Receipt_IT_API_ReceiptReturnOrVoidViaPEMInput'];\ntype VoidReceiptOutput = ReceiptOutput; // Returns standard receipt output\ntype VoidReceiptWithProofRequest = components['schemas']['E-Receipt_IT_API_ReceiptReturnOrVoidWithProofInput'];\ntype ReturnRequest = components['schemas']['E-Receipt_IT_API_ReceiptReturnOrVoidViaPEMInput'];\ntype ReturnWithProofRequest = components['schemas']['E-Receipt_IT_API_ReceiptReturnOrVoidWithProofInput'];\n\nexport interface ReceiptListParams {\n  page?: number | undefined;\n  size?: number | undefined;\n  start_date?: string | undefined;\n  end_date?: string | undefined;\n  serial_number?: string | undefined;\n}\n\nexport interface ReceiptValidationOptions {\n  validateVATRates?: boolean;\n  checkTotalCalculations?: boolean;\n  enforceItalianFiscalRules?: boolean;\n  maxReceiptItems?: number;\n}\n\nexport interface ReceiptCalculationResult {\n  subtotal: Amount;\n  vatAmount: Amount;\n  totalAmount: Amount;\n  discountAmount: Amount;\n  itemCount: number;\n  breakdown: {\n    vatRate: string;\n    netAmount: Amount;\n    vatAmount: Amount;\n    grossAmount: Amount;\n  }[];\n}\n\nexport type ReceiptItemType = 'good' | 'service' | 'mixed';\nexport type PaymentMethod = 'cash' | 'electronic' | 'ticket_restaurant' | 'mixed';\n\n/**\n * Receipts Resource Class - OpenAPI Based\n * Manages electronic receipts with full Italian fiscal compliance\n * Enhanced with offline-first capabilities\n */\nexport class ReceiptsResource extends BaseOpenAPIResource {\n  constructor(client: HttpClient, storage?: UnifiedStorage | undefined, queueManager?: EnterpriseQueueManager | undefined) {\n    super({\n      client,\n      storage: storage || undefined,\n      queueManager: queueManager || undefined,\n      offlineEnabled: Boolean(storage || queueManager),\n      endpoints: {\n        list: ReceiptEndpoints.LIST,\n        create: ReceiptEndpoints.CREATE,\n        void: ReceiptEndpoints.VOID,\n        getByUuid: ReceiptEndpoints.GET_BY_UUID,\n        voidWithProof: ReceiptEndpoints.VOID_WITH_PROOF,\n        getDetails: ReceiptEndpoints.GET_DETAILS,\n        returnItems: ReceiptEndpoints.RETURN_ITEMS,\n        returnItemsWithProof: ReceiptEndpoints.RETURN_ITEMS_WITH_PROOF,\n      }\n    });\n  }\n\n  /**\n   * Get a list of receipts with filtering and pagination\n   * Enhanced with offline-first capabilities\n   * \n   * @param params - List parameters including filters and pagination\n   * @param options - Request options including offline preferences\n   * @returns Promise resolving to paginated receipt list\n   */\n  async list(params?: ReceiptListParams, options: Partial<RequestOptions> = {}): Promise<ReceiptPage> {\n    return this.executeRequest<void, ReceiptPage>('list', undefined, {\n      ...(params && { queryParams: params as Record<string, unknown> }),\n      cacheTTL: 300, // Cache for 5 minutes\n      queueIfOffline: false, // Read operations don't need queuing\n      ...options,\n      metadata: {\n        operation: 'list_receipts',\n        dateRange: params?.start_date && params?.end_date ? `${params.start_date} to ${params.end_date}` : undefined,\n        ...options.metadata,\n      }\n    });\n  }\n\n  /**\n   * Create a new electronic receipt\n   * Enhanced with offline queuing and optimistic updates\n   * \n   * @param data - Receipt input data with items and payment information\n   * @param validationOptions - Validation options for fiscal compliance\n   * @param requestOptions - Request options including offline preferences\n   * @returns Promise resolving to created receipt\n   */\n  async create(\n    data: ReceiptInput, \n    validationOptions: ReceiptValidationOptions = {},\n    requestOptions: Partial<RequestOptions> = {}\n  ): Promise<ReceiptOutput> {\n    // Validate input with Italian fiscal rules\n    await this.validateReceiptInput(data, validationOptions);\n\n    return this.executeRequest<ReceiptInput, ReceiptOutput>('create', data, {\n      queueIfOffline: true, // Queue receipts when offline\n      optimistic: true, // Provide immediate feedback\n      ...requestOptions,\n      metadata: {\n        operation: 'create_receipt',\n        itemCount: data.items.length,\n        totalAmount: this.calculateTotalAmount(data).totalAmount,\n      }\n    });\n  }\n\n  /**\n   * Void an electronic receipt\n   * Enhanced with offline queuing for critical operations\n   * \n   * @param voidData - Void request data\n   * @param options - Request options including offline preferences\n   * @returns Promise resolving to void confirmation\n   */\n  async void(voidData: VoidReceiptRequest, options: Partial<RequestOptions> = {}): Promise<VoidReceiptOutput> {\n    return this.executeRequest<VoidReceiptRequest, VoidReceiptOutput>('void', voidData, {\n      queueIfOffline: true, // Critical operation - queue when offline\n      optimistic: false, // Don't provide optimistic response for fiscal operations\n      ...options,\n      metadata: {\n        operation: 'void_receipt',\n        ...options.metadata,\n      }\n    });\n  }\n\n  /**\n   * Get a specific receipt by UUID\n   * Enhanced with intelligent caching for frequent lookups\n   * \n   * @param receiptId - Receipt UUID\n   * @param options - Request options including offline preferences\n   * @returns Promise resolving to receipt details\n   */\n  async retrieve(receiptId: ReceiptId | string, options: Partial<RequestOptions> = {}): Promise<ReceiptOutput> {\n    return this.executeRequest<void, ReceiptOutput>('getByUuid', undefined, {\n      pathParams: { receipt_uuid: receiptId },\n      cacheTTL: 600, // Cache individual receipts for 10 minutes\n      queueIfOffline: false, // Read operations don't need queuing\n      ...options,\n      metadata: {\n        operation: 'get_receipt',\n        receiptId,\n        ...options.metadata,\n      }\n    });\n  }\n\n  /**\n   * Void a receipt using proof of purchase\n   * \n   * @param voidData - Void request with proof data\n   * @returns Promise resolving to void confirmation\n   */\n  async voidWithProof(voidData: VoidReceiptWithProofRequest): Promise<VoidReceiptOutput> {\n    return this.executeRequest<VoidReceiptWithProofRequest, VoidReceiptOutput>('voidWithProof', voidData, {\n      metadata: {\n        operation: 'void_receipt_with_proof',\n      }\n    });\n  }\n\n  /**\n   * Get receipt details or PDF\n   * \n   * @param receiptId - Receipt UUID\n   * @param format - Response format ('json' or 'pdf')\n   * @returns Promise resolving to receipt details or PDF blob\n   */\n  async getDetails(receiptId: ReceiptId | string, format: 'json' | 'pdf' = 'json'): Promise<components['schemas']['E-Receipt_IT_API_ReceiptDetailsOutput'] | Blob> {\n    const acceptHeader = format === 'pdf' ? 'application/pdf' : 'application/json';\n    \n    return this.executeRequest<void, components['schemas']['E-Receipt_IT_API_ReceiptDetailsOutput'] | Blob>('getDetails', undefined, {\n      pathParams: { receipt_uuid: receiptId },\n      headers: { Accept: acceptHeader },\n      metadata: {\n        operation: 'get_receipt_details',\n        receiptId,\n        format,\n      }\n    });\n  }\n\n  /**\n   * Return items from a receipt\n   * \n   * @param returnData - Return request data\n   * @returns Promise resolving to return receipt\n   */\n  async returnItems(returnData: ReturnRequest): Promise<ReceiptOutput> {\n    return this.executeRequest<ReturnRequest, ReceiptOutput>('returnItems', returnData, {\n      metadata: {\n        operation: 'return_receipt_items',\n      }\n    });\n  }\n\n  /**\n   * Return items from a receipt using proof of purchase\n   * \n   * @param returnData - Return request with proof data\n   * @returns Promise resolving to return receipt\n   */\n  async returnItemsWithProof(returnData: ReturnWithProofRequest): Promise<ReceiptOutput> {\n    return this.executeRequest<ReturnWithProofRequest, ReceiptOutput>('returnItemsWithProof', returnData, {\n      metadata: {\n        operation: 'return_receipt_items_with_proof',\n      }\n    });\n  }\n\n  /**\n   * Update an existing receipt\n   * \n   * @param receiptId - The receipt ID to update\n   * @param updateData - Update data for the receipt\n   * @returns Promise resolving to updated receipt\n   */\n  async update(receiptId: ReceiptId | string, updateData: Partial<ReceiptInput>): Promise<ReceiptOutput> {\n    if (!this.hasOperation('updateReceipt')) {\n      throw this.createUnsupportedOperationError('updateReceipt');\n    }\n    return this.executeRequest<{id: string} & Partial<ReceiptInput>, ReceiptOutput>('updateReceipt', {\n      id: String(receiptId),\n      ...updateData\n    }, {\n      metadata: {\n        operation: 'update_receipt',\n        receiptId: String(receiptId),\n      }\n    });\n  }\n\n  /**\n   * Delete a receipt\n   * \n   * @param receiptId - The receipt ID to delete\n   * @returns Promise resolving to deletion confirmation\n   */\n  async delete(receiptId: ReceiptId | string): Promise<{ success: boolean; message?: string }> {\n    if (!this.hasOperation('deleteReceipt')) {\n      throw this.createUnsupportedOperationError('deleteReceipt');\n    }\n    return this.executeRequest<{id: string}, { success: boolean; message?: string }>('deleteReceipt', {\n      id: String(receiptId)\n    }, {\n      metadata: {\n        operation: 'delete_receipt',\n        receiptId: String(receiptId),\n      }\n    });\n  }\n\n  // Validation methods\n\n  /**\n   * Comprehensive receipt input validation\n   */\n  private async validateReceiptInput(\n    data: ReceiptInput, \n    options: ReceiptValidationOptions = {}\n  ): Promise<void> {\n    const errors: Array<{ field: string; message: string; code: string }> = [];\n\n    // Basic validation\n    if (!data.items || data.items.length === 0) {\n      errors.push({\n        field: 'items',\n        message: 'Receipt must contain at least one item',\n        code: 'NO_ITEMS'\n      });\n    }\n\n    // Item count validation\n    if (options.maxReceiptItems && data.items.length > options.maxReceiptItems) {\n      errors.push({\n        field: 'items',\n        message: `Receipt cannot contain more than ${options.maxReceiptItems} items`,\n        code: 'TOO_MANY_ITEMS'\n      });\n    }\n\n    // Validate each item\n    for (let i = 0; i < data.items.length; i++) {\n      const item = data.items[i];\n      if (!item) continue;\n      const itemErrors = this.validateReceiptItem(item, i, options);\n      errors.push(...itemErrors);\n    }\n\n    // Payment validation\n    const paymentErrors = this.validatePaymentAmounts(data);\n    errors.push(...paymentErrors);\n\n    // Total calculation validation\n    if (options.checkTotalCalculations) {\n      const calculationErrors = this.validateCalculations(data);\n      errors.push(...calculationErrors);\n    }\n\n    // Italian fiscal rules validation\n    if (options.enforceItalianFiscalRules) {\n      const fiscalErrors = this.validateItalianFiscalRules(data);\n      errors.push(...fiscalErrors);\n    }\n\n    if (errors.length > 0) {\n      throw new ValidationError('Invalid receipt input', 'create_receipt', errors);\n    }\n  }\n\n  /**\n   * Validate individual receipt item\n   */\n  private validateReceiptItem(\n    item: components['schemas']['E-Receipt_IT_API_ReceiptItem'], \n    index: number, \n    options: ReceiptValidationOptions\n  ): Array<{ field: string; message: string; code: string }> {\n    const errors: Array<{ field: string; message: string; code: string }> = [];\n    const prefix = `items[${index}]`;\n\n    // Required fields\n    if (!item.description || item.description.trim().length === 0) {\n      errors.push({\n        field: `${prefix}.description`,\n        message: 'Item description is required',\n        code: 'REQUIRED'\n      });\n    }\n\n    if (!item.quantity || parseFloat(item.quantity) <= 0) {\n      errors.push({\n        field: `${prefix}.quantity`,\n        message: 'Item quantity must be greater than 0',\n        code: 'INVALID_QUANTITY'\n      });\n    }\n\n    if (!item.unit_price || parseFloat(item.unit_price) < 0) {\n      errors.push({\n        field: `${prefix}.unit_price`,\n        message: 'Item unit price cannot be negative',\n        code: 'INVALID_PRICE'\n      });\n    }\n\n    // VAT rate validation\n    if (options.validateVATRates && item.vat_rate_code) {\n      const validVATRates = ['0', '4', '5', '10', '22']; // Italian VAT rates\n      if (!validVATRates.includes(item.vat_rate_code)) {\n        errors.push({\n          field: `${prefix}.vat_rate_code`,\n          message: `Invalid VAT rate. Valid rates: ${validVATRates.join(', ')}`,\n          code: 'INVALID_VAT_RATE'\n        });\n      }\n    }\n\n    // Description length validation\n    if (item.description && item.description.length > 200) {\n      errors.push({\n        field: `${prefix}.description`,\n        message: 'Item description cannot exceed 200 characters',\n        code: 'DESCRIPTION_TOO_LONG'\n      });\n    }\n\n    return errors;\n  }\n\n  /**\n   * Validate payment amounts\n   */\n  private validatePaymentAmounts(data: ReceiptInput): Array<{ field: string; message: string; code: string }> {\n    const errors: Array<{ field: string; message: string; code: string }> = [];\n\n    const cashAmount = parseFloat(data.cash_payment_amount || '0');\n    const electronicAmount = parseFloat(data.electronic_payment_amount || '0');\n    const ticketAmount = parseFloat(data.ticket_restaurant_payment_amount || '0');\n\n    // At least one payment method must be used\n    if (cashAmount <= 0 && electronicAmount <= 0 && ticketAmount <= 0) {\n      errors.push({\n        field: 'payment',\n        message: 'At least one payment method must have a positive amount',\n        code: 'NO_PAYMENT'\n      });\n    }\n\n    // Negative amounts validation\n    if (cashAmount < 0) {\n      errors.push({\n        field: 'cash_payment_amount',\n        message: 'Cash payment amount cannot be negative',\n        code: 'NEGATIVE_AMOUNT'\n      });\n    }\n\n    if (electronicAmount < 0) {\n      errors.push({\n        field: 'electronic_payment_amount',\n        message: 'Electronic payment amount cannot be negative',\n        code: 'NEGATIVE_AMOUNT'\n      });\n    }\n\n    if (ticketAmount < 0) {\n      errors.push({\n        field: 'ticket_restaurant_payment_amount',\n        message: 'Ticket restaurant payment amount cannot be negative',\n        code: 'NEGATIVE_AMOUNT'\n      });\n    }\n\n    return errors;\n  }\n\n  /**\n   * Validate calculation accuracy\n   */\n  private validateCalculations(data: ReceiptInput): Array<{ field: string; message: string; code: string }> {\n    const errors: Array<{ field: string; message: string; code: string }> = [];\n\n    try {\n      const calculated = this.calculateTotalAmount(data);\n      const totalPayments = parseFloat(data.cash_payment_amount || '0') + \n                           parseFloat(data.electronic_payment_amount || '0') + \n                           parseFloat(data.ticket_restaurant_payment_amount || '0');\n\n      // Check if total payments match calculated total (with small tolerance for rounding)\n      const tolerance = 0.01;\n      if (Math.abs(totalPayments - parseFloat(calculated.totalAmount)) > tolerance) {\n        errors.push({\n          field: 'payment_total',\n          message: `Payment total (${totalPayments.toFixed(2)}) does not match calculated total (${calculated.totalAmount})`,\n          code: 'PAYMENT_MISMATCH'\n        });\n      }\n    } catch (error) {\n      errors.push({\n        field: 'calculation',\n        message: 'Failed to validate receipt calculations',\n        code: 'CALCULATION_ERROR'\n      });\n    }\n\n    return errors;\n  }\n\n  /**\n   * Validate Italian fiscal compliance rules\n   */\n  private validateItalianFiscalRules(data: ReceiptInput): Array<{ field: string; message: string; code: string }> {\n    const errors: Array<{ field: string; message: string; code: string }> = [];\n\n    // Check for fiscal compliance requirements\n    const totalAmount = parseFloat(this.calculateTotalAmount(data).totalAmount);\n\n    // High-value transaction reporting (example threshold)\n    if (totalAmount > 3000) {\n      const cashAmount = parseFloat(data.cash_payment_amount || '0');\n      if (cashAmount > 1000) {\n        errors.push({\n          field: 'cash_payment_amount',\n          message: 'Cash payments over 1000 require additional documentation for transactions above 3000',\n          code: 'HIGH_VALUE_CASH_LIMIT'\n        });\n      }\n    }\n\n    // Validate lottery code if provided (simplified check)\n    if (data.customer_lottery_code && !/^[A-Z0-9]{16}$/.test(data.customer_lottery_code)) {\n      errors.push({\n        field: 'customer_lottery_code',\n        message: 'Lottery code must be 16 alphanumeric characters',\n        code: 'INVALID_LOTTERY_CODE'\n      });\n    }\n\n    return errors;\n  }\n\n  // Calculation methods\n\n  /**\n   * Calculate total receipt amount with VAT breakdown\n   */\n  public calculateTotalAmount(data: ReceiptInput): ReceiptCalculationResult {\n    let subtotal = 0;\n    let totalVAT = 0;\n    let totalDiscount = parseFloat(data.discount || '0');\n    \n    const vatBreakdown = new Map<string, { net: number; vat: number; gross: number }>();\n\n    // Calculate item totals\n    for (const item of data.items) {\n      const quantity = parseFloat(item.quantity);\n      const unitPrice = parseFloat(item.unit_price);\n      const itemDiscount = parseFloat(item.discount || '0');\n      const vatRate = parseFloat(item.vat_rate_code || '0') / 100;\n\n      // Calculate item total before VAT\n      const itemNetTotal = (quantity * unitPrice) - itemDiscount;\n      const itemVAT = itemNetTotal * vatRate;\n      const itemGrossTotal = itemNetTotal + itemVAT;\n\n      subtotal += itemNetTotal;\n      totalVAT += itemVAT;\n\n      // Track VAT breakdown\n      const vatKey = item.vat_rate_code || '0';\n      if (!vatBreakdown.has(vatKey)) {\n        vatBreakdown.set(vatKey, { net: 0, vat: 0, gross: 0 });\n      }\n      const breakdown = vatBreakdown.get(vatKey)!;\n      breakdown.net += itemNetTotal;\n      breakdown.vat += itemVAT;\n      breakdown.gross += itemGrossTotal;\n    }\n\n    // Apply global discount\n    const finalSubtotal = subtotal - totalDiscount;\n    const finalTotal = finalSubtotal + totalVAT;\n\n    return {\n      subtotal: finalSubtotal.toFixed(2) as Amount,\n      vatAmount: totalVAT.toFixed(2) as Amount,\n      totalAmount: finalTotal.toFixed(2) as Amount,\n      discountAmount: (totalDiscount + data.items.reduce((sum, item) => sum + parseFloat(item.discount || '0'), 0)).toFixed(2) as Amount,\n      itemCount: data.items.length,\n      breakdown: Array.from(vatBreakdown.entries()).map(([vatRate, amounts]) => ({\n        vatRate,\n        netAmount: amounts.net.toFixed(2) as Amount,\n        vatAmount: amounts.vat.toFixed(2) as Amount,\n        grossAmount: amounts.gross.toFixed(2) as Amount,\n      })),\n    };\n  }\n\n  // Static utility methods\n\n  /**\n   * Format receipt for display\n   */\n  static formatReceiptForDisplay(receipt: ReceiptOutput): {\n    receiptNumber: string;\n    date: string;\n    time: string;\n    formattedTotal: string;\n    paymentMethod: PaymentMethod;\n    itemSummary: string;\n  } {\n    const date = new Date(receipt.created_at);\n    \n    return {\n      receiptNumber: receipt.uuid.split('-')[0]?.toUpperCase() || 'UNKNOWN',\n      date: date.toLocaleDateString('it-IT'),\n      time: date.toLocaleTimeString('it-IT'),\n      formattedTotal: ` ${receipt.total_amount}`,\n      paymentMethod: this.determinePaymentMethod(receipt),\n      itemSummary: `0 items`, // items field not available in OpenAPI schema\n    };\n  }\n\n  /**\n   * Determine primary payment method\n   */\n  private static determinePaymentMethod(_receipt: ReceiptOutput): PaymentMethod {\n    // Note: payment amount fields not available in OpenAPI schema\n    // Using default payment method\n    return 'cash'; // Default\n  }\n\n  /**\n   * Generate receipt summary for reports\n   */\n  static generateReceiptSummary(receipts: ReceiptOutput[]): {\n    totalCount: number;\n    totalAmount: Amount;\n    vatAmount: Amount;\n    averageAmount: Amount;\n    paymentMethodBreakdown: Record<PaymentMethod, { count: number; amount: Amount }>;\n    dateRange: { from: string; to: string };\n  } {\n    const summary = {\n      totalCount: receipts.length,\n      totalAmount: '0.00' as Amount,\n      vatAmount: '0.00' as Amount,\n      averageAmount: '0.00' as Amount,\n      paymentMethodBreakdown: {\n        cash: { count: 0, amount: '0.00' as Amount },\n        electronic: { count: 0, amount: '0.00' as Amount },\n        ticket_restaurant: { count: 0, amount: '0.00' as Amount },\n        mixed: { count: 0, amount: '0.00' as Amount },\n      } as Record<PaymentMethod, { count: number; amount: Amount }>,\n      dateRange: { from: '', to: '' },\n    };\n\n    if (receipts.length === 0) return summary;\n\n    let totalAmount = 0;\n    let totalVAT = 0;\n    const dates = receipts.map(r => new Date(r.created_at)).sort((a, b) => a.getTime() - b.getTime());\n\n    for (const receipt of receipts) {\n      const amount = parseFloat(receipt.total_amount);\n      totalAmount += amount;\n      \n      // Estimate VAT (simplified calculation)\n      totalVAT += amount * 0.15; // Rough estimate\n\n      const paymentMethod = this.determinePaymentMethod(receipt);\n      summary.paymentMethodBreakdown[paymentMethod].count++;\n      summary.paymentMethodBreakdown[paymentMethod].amount = \n        (parseFloat(summary.paymentMethodBreakdown[paymentMethod].amount) + amount).toFixed(2) as Amount;\n    }\n\n    summary.totalAmount = totalAmount.toFixed(2) as Amount;\n    summary.vatAmount = totalVAT.toFixed(2) as Amount;\n    summary.averageAmount = (totalAmount / receipts.length).toFixed(2) as Amount;\n    summary.dateRange.from = dates[0]?.toISOString().split('T')[0] || '';\n    summary.dateRange.to = dates[dates.length - 1]?.toISOString().split('T')[0] || '';\n\n    return summary;\n  }\n\n  /**\n   * Validate receipt return eligibility\n   */\n  static validateReturnEligibility(receipt: ReceiptOutput, returnDate: Date = new Date()): {\n    eligible: boolean;\n    reason?: string;\n    daysRemaining?: number;\n  } {\n    const receiptDate = new Date(receipt.created_at);\n    const daysSinceReceipt = Math.floor((returnDate.getTime() - receiptDate.getTime()) / (1000 * 60 * 60 * 24));\n    const returnPeriodDays = 30; // Example return period\n\n    if (daysSinceReceipt > returnPeriodDays) {\n      return {\n        eligible: false,\n        reason: `Return period expired. Returns allowed within ${returnPeriodDays} days.`,\n      };\n    }\n\n    if (receipt.document_number && receipt.document_number.includes('VOID')) {\n      return {\n        eligible: false,\n        reason: 'Receipt has already been voided',\n      };\n    }\n\n    return {\n      eligible: true,\n      daysRemaining: returnPeriodDays - daysSinceReceipt,\n    };\n  }\n\n  /**\n   * Generate fiscal code for lottery participation\n   */\n  static generateLotteryCode(): string {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    let result = '';\n    for (let i = 0; i < 16; i++) {\n      result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return result;\n  }\n\n  // Offline-specific convenience methods\n\n  /**\n   * Get offline receipt statistics\n   */\n  async getOfflineReceiptStats() {\n    const baseStats = await this.getOfflineStats();\n    return {\n      ...baseStats,\n      resourceType: 'receipts',\n      capabilities: {\n        canCreateOffline: this.isQueueEnabled(),\n        canReadOffline: this.isOfflineEnabled(),\n        canCacheReceipts: this.isOfflineEnabled(),\n      }\n    };\n  }\n\n  /**\n   * Sync all queued receipt operations\n   */\n  async syncQueuedReceipts(): Promise<void> {\n    if (!this.isQueueEnabled()) {\n      throw new ValidationError('Queue not enabled', 'sync_error', [\n        { field: 'queue', message: 'Offline queue is not configured', code: 'QUEUE_NOT_ENABLED' }\n      ]);\n    }\n\n    await this.syncQueuedOperations();\n  }\n\n  /**\n   * Clear receipt cache (useful for data refresh)\n   */\n  async clearReceiptCache(): Promise<void> {\n    await this.clearCache('receipts');\n  }\n\n  /**\n   * Store receipt for offline access\n   */\n  async storeReceiptOffline(receiptId: string, receipt: ReceiptOutput): Promise<void> {\n    const cacheKey = `GET:/receipts/{receipt_uuid}?path=receipt_uuid=${receiptId}`;\n    await this.storeOfflineData(cacheKey, receipt);\n  }\n}\n\n// Re-export for convenience\nexport { ReceiptsResource as Receipts };\n\n// Export types for external use\nexport type {\n  ReceiptInput,\n  ReceiptOutput,\n  ReceiptPage,\n  VoidReceiptRequest,\n  VoidReceiptOutput,\n  ReturnRequest,\n};","/**\n * Point of Sales Resource - OpenAPI Implementation\n * Type-safe implementation for PEM device management\n * \n * Features:\n * - Complete PEM device lifecycle management\n * - Activation and certificate management\n * - Status monitoring and control\n * - Journal closing operations\n * - Inactivity period management\n */\n\nimport { BaseOpenAPIResource } from '@/resources/base-openapi';\nimport { PointOfSalesEndpoints } from '@/generated/endpoints';\nimport type { HttpClient } from '@/http/client';\nimport type { SerialNumber } from '@/types/branded';\nimport type { components } from '@/types/generated';\nimport { ValidationError } from '@/errors/index';\n\n// Extract types from OpenAPI generated types\ntype PointOfSaleOutput = components['schemas']['E-Receipt_IT_API_PointOfSaleOutput'];\ntype PointOfSalePage = components['schemas']['E-Receipt_IT_API_Page__T_Customized_PointOfSaleOutput_'];\ntype ActivationRequest = components['schemas']['E-Receipt_IT_API_ActivationRequest'];\ntype InactivityRequest = components['schemas']['E-Receipt_IT_API_PEMStatusOfflineRequest'];\n// These endpoints return empty objects/have no request body per OpenAPI spec\ntype ActivationOutput = Record<string, never>; // Activation endpoint returns empty object\ntype CloseJournalRequest = void; // Close journal has no request body\ntype CloseJournalOutput = Record<string, never>; // Close journal returns empty object\n\nexport interface PointOfSaleValidationOptions {\n  validateSerialNumber?: boolean;\n  checkActivationStatus?: boolean;\n  enforceStatusTransitions?: boolean;\n}\n\nexport interface DeviceStatus {\n  serialNumber: SerialNumber;\n  status: PEMStatus;\n  lastSeen: string;\n  certificateExpiry?: string | undefined;\n  firmwareVersion?: string | undefined;\n  batteryLevel?: number | undefined;\n  connectivity: ConnectivityStatus;\n}\n\nexport interface JournalSummary {\n  date: string;\n  transactionCount: number;\n  totalAmount: string;\n  vatAmount: string;\n  firstTransaction?: string;\n  lastTransaction?: string;\n  status: 'open' | 'closed' | 'pending';\n}\n\n// Use actual OpenAPI types where available\nexport type PEMStatus = components['schemas']['E-Receipt_IT_API_PEMStatus'];\nexport type ConnectivityStatus = 'online' | 'offline' | 'intermittent' | 'unknown';\nexport type ActivationStatus = 'pending' | 'in_progress' | 'completed' | 'failed' | 'expired';\n\n/**\n * Point of Sales Resource Class - OpenAPI Based\n * Manages PEM devices with full Italian fiscal compliance\n */\nexport class PointOfSalesResource extends BaseOpenAPIResource {\n  constructor(client: HttpClient) {\n    super({\n      client,\n      endpoints: {\n        list: PointOfSalesEndpoints.LIST,\n        getBySerial: PointOfSalesEndpoints.GET_BY_SERIAL,\n        closeJournal: PointOfSalesEndpoints.CLOSE_JOURNAL,\n        activation: PointOfSalesEndpoints.ACTIVATION,\n        createInactivity: PointOfSalesEndpoints.CREATE_INACTIVITY,\n        setOffline: PointOfSalesEndpoints.SET_OFFLINE,\n      }\n    });\n  }\n\n  /**\n   * Get a list of Point of Sales devices\n   * \n   * @returns Promise resolving to paginated PEM list\n   */\n  async list(): Promise<PointOfSalePage> {\n    return this.executeRequest<void, PointOfSalePage>('list', undefined, {\n      metadata: {\n        operation: 'list_point_of_sales',\n      }\n    });\n  }\n\n  /**\n   * Get a specific Point of Sale by serial number\n   * \n   * @param serialNumber - Device serial number\n   * @returns Promise resolving to PEM details\n   */\n  async retrieve(serialNumber: SerialNumber | string): Promise<PointOfSaleOutput> {\n    return this.executeRequest<void, PointOfSaleOutput>('getBySerial', undefined, {\n      pathParams: { serial_number: serialNumber },\n      metadata: {\n        operation: 'get_point_of_sale',\n        serialNumber,\n      }\n    });\n  }\n\n  /**\n   * Close the daily journal for a Point of Sale\n   * \n   * @returns Promise resolving to close confirmation\n   */\n  async closeJournal(): Promise<CloseJournalOutput> {\n    return this.executeRequest<void, CloseJournalOutput>('closeJournal', undefined, {\n      metadata: {\n        operation: 'close_journal',\n      }\n    });\n  }\n\n  /**\n   * Trigger activation process for a Point of Sale\n   * \n   * @param serialNumber - Device serial number\n   * @param activationData - Activation request data\n   * @param options - Validation options\n   * @returns Promise resolving to activation status\n   */\n  async activate(\n    serialNumber: SerialNumber | string,\n    activationData: ActivationRequest,\n    options: PointOfSaleValidationOptions = {}\n  ): Promise<ActivationOutput> {\n    // Validate activation request\n    await this.validateActivationRequest(serialNumber, activationData, options);\n\n    return this.executeRequest<ActivationRequest, ActivationOutput>('activation', activationData, {\n      pathParams: { serial_number: serialNumber },\n      metadata: {\n        operation: 'activate_point_of_sale',\n        serialNumber,\n        registrationKey: activationData.registration_key,\n      }\n    });\n  }\n\n  /**\n   * Create an inactivity period for a Point of Sale\n   * \n   * @param serialNumber - Device serial number\n   * @param inactivityData - Inactivity period request data\n   * @returns Promise resolving when inactivity period is created\n   */\n  async createInactivityPeriod(\n    serialNumber: SerialNumber | string,\n    inactivityData: InactivityRequest\n  ): Promise<void> {\n    return this.executeRequest<InactivityRequest, void>('createInactivity', inactivityData, {\n      pathParams: { serial_number: serialNumber },\n      metadata: {\n        operation: 'create_inactivity_period',\n        serialNumber,\n      }\n    });\n  }\n\n  /**\n   * Set Point of Sale status to offline\n   * \n   * @param serialNumber - Device serial number\n   * @returns Promise resolving when status is updated\n   */\n  async setOffline(serialNumber: SerialNumber | string): Promise<void> {\n    return this.executeRequest<void, void>('setOffline', undefined, {\n      pathParams: { serial_number: serialNumber },\n      metadata: {\n        operation: 'set_point_of_sale_offline',\n        serialNumber,\n      }\n    });\n  }\n\n  /**\n   * Get device status summary\n   * \n   * @param serialNumber - Device serial number\n   * @returns Promise resolving to device status\n   */\n  async getDeviceStatus(serialNumber: SerialNumber | string): Promise<DeviceStatus> {\n    const device = await this.retrieve(serialNumber);\n    return PointOfSalesResource.analyzeDeviceStatus(device);\n  }\n\n  /**\n   * Get journal summary for a specific date\n   * \n   * @param serialNumber - Device serial number\n   * @param date - Date in YYYY-MM-DD format\n   * @returns Promise resolving to journal summary\n   */\n  async getJournalSummary(\n    _serialNumber: SerialNumber | string, \n    date: string = new Date().toISOString().split('T')[0]!\n  ): Promise<JournalSummary> {\n    // This would typically require additional API endpoints\n    // For now, return a mock summary\n    return {\n      date,\n      transactionCount: 0,\n      totalAmount: '0.00',\n      vatAmount: '0.00',\n      status: 'open',\n    };\n  }\n\n  // Validation methods\n\n  /**\n   * Validate activation request\n   */\n  private async validateActivationRequest(\n    serialNumber: SerialNumber | string,\n    activationData: ActivationRequest,\n    options: PointOfSaleValidationOptions = {}\n  ): Promise<void> {\n    const errors: Array<{ field: string; message: string; code: string }> = [];\n\n    // Serial number validation\n    if (options.validateSerialNumber) {\n      const serialValidation = PointOfSalesResource.validateSerialNumber(serialNumber);\n      if (!serialValidation.isValid) {\n        errors.push({\n          field: 'serial_number',\n          message: serialValidation.error || 'Invalid serial number format',\n          code: 'INVALID_SERIAL_NUMBER'\n        });\n      }\n    }\n\n    // Registration key validation\n    if (!activationData.registration_key || activationData.registration_key.length === 0) {\n      errors.push({\n        field: 'registration_key',\n        message: 'Registration key is required',\n        code: 'REQUIRED'\n      });\n    } else {\n      const keyValidation = this.validateRegistrationKey(activationData.registration_key);\n      if (!keyValidation.isValid) {\n        errors.push({\n          field: 'registration_key',\n          message: keyValidation.error || 'Invalid registration key format',\n          code: 'INVALID_REGISTRATION_KEY'\n        });\n      }\n    }\n\n    // Check activation status if required\n    if (options.checkActivationStatus) {\n      try {\n        const device = await this.retrieve(serialNumber);\n        if (device.status === 'ACTIVE') {\n          errors.push({\n            field: 'status',\n            message: 'Device is already activated',\n            code: 'ALREADY_ACTIVATED'\n          });\n        }\n      } catch (error) {\n        // Device not found is acceptable for new activations\n        if (error instanceof Error && !error.message.includes('404')) {\n          errors.push({\n            field: 'device',\n            message: 'Unable to verify device status',\n            code: 'STATUS_CHECK_FAILED'\n          });\n        }\n      }\n    }\n\n    if (errors.length > 0) {\n      throw new ValidationError('Invalid activation request', 'activate_point_of_sale', errors);\n    }\n  }\n\n  /**\n   * Validate registration key format\n   */\n  private validateRegistrationKey(key: string): { isValid: boolean; error?: string } {\n    // Basic format validation (this would depend on the actual key format)\n    if (key.length < 16) {\n      return { isValid: false, error: 'Registration key must be at least 16 characters' };\n    }\n\n    if (!/^[A-Z0-9-]+$/.test(key)) {\n      return { isValid: false, error: 'Registration key contains invalid characters' };\n    }\n\n    return { isValid: true };\n  }\n\n  // Static utility methods\n\n  /**\n   * Validate serial number format\n   */\n  static validateSerialNumber(serialNumber: SerialNumber | string): { isValid: boolean; error?: string } {\n    const serialStr = String(serialNumber);\n\n    // Basic serial number validation\n    if (serialStr.length < 8 || serialStr.length > 20) {\n      return { isValid: false, error: 'Serial number must be between 8 and 20 characters' };\n    }\n\n    if (!/^[A-Z0-9]+$/.test(serialStr)) {\n      return { isValid: false, error: 'Serial number must contain only uppercase letters and numbers' };\n    }\n\n    return { isValid: true };\n  }\n\n  /**\n   * Analyze device status from device data\n   */\n  static analyzeDeviceStatus(device: PointOfSaleOutput): DeviceStatus {\n    return {\n      serialNumber: device.serial_number as SerialNumber,\n      status: device.status as PEMStatus,\n      lastSeen: new Date().toISOString(), // last_seen field not available in OpenAPI schema\n      certificateExpiry: undefined, // certificate_expiry field not available in OpenAPI schema\n      firmwareVersion: undefined, // firmware_version field not available in OpenAPI schema\n      batteryLevel: undefined, // battery_level field not available in OpenAPI schema\n      connectivity: this.determineConnectivityStatus(device),\n    };\n  }\n\n  /**\n   * Determine connectivity status from device data\n   */\n  private static determineConnectivityStatus(_device: PointOfSaleOutput): ConnectivityStatus {\n    // last_seen field not available in OpenAPI schema, using mock connectivity\n    const lastSeenTime = new Date().getTime();\n    const now = Date.now();\n    const minutesSinceLastSeen = (now - lastSeenTime) / (1000 * 60);\n\n    if (minutesSinceLastSeen <= 5) return 'online';\n    if (minutesSinceLastSeen <= 30) return 'intermittent';\n    return 'offline';\n  }\n\n  /**\n   * Format device for display\n   */\n  static formatDeviceForDisplay(device: PointOfSaleOutput): {\n    displayName: string;\n    statusBadge: string;\n    location: string;\n    lastActivity: string;\n    certificateStatus: string;\n  } {\n    const status = device.status || 'unknown';\n    // last_seen field not available in OpenAPI schema, using current time\n    const lastSeen = new Date();\n\n    return {\n      displayName: `PEM ${device.serial_number}`,\n      statusBadge: status.toUpperCase(),\n      location: device.address?.city || 'Unknown Location',\n      lastActivity: lastSeen.toLocaleString(),\n      certificateStatus: 'Not Available', // certificate_expiry field not available in OpenAPI schema\n    };\n  }\n\n  /**\n   * Calculate device uptime\n   */\n  static calculateUptime(_device: PointOfSaleOutput): {\n    uptimeHours: number;\n    uptimePercentage: number;\n    availabilityStatus: 'excellent' | 'good' | 'poor' | 'critical';\n  } {\n    // This would typically use historical data\n    // For now, return mock calculations based on last seen\n    // last_seen field not available in OpenAPI schema, using current time\n    const lastSeenTime = Date.now();\n    const now = Date.now();\n    const hoursSinceLastSeen = (now - lastSeenTime) / (1000 * 60 * 60);\n\n    // Mock uptime calculation\n    const uptimeHours = Math.max(0, 24 - hoursSinceLastSeen);\n    const uptimePercentage = Math.round((uptimeHours / 24) * 100);\n\n    let availabilityStatus: 'excellent' | 'good' | 'poor' | 'critical' = 'excellent';\n    if (uptimePercentage < 95) availabilityStatus = 'good';\n    if (uptimePercentage < 85) availabilityStatus = 'poor';\n    if (uptimePercentage < 70) availabilityStatus = 'critical';\n\n    return {\n      uptimeHours: Math.round(uptimeHours * 100) / 100,\n      uptimePercentage,\n      availabilityStatus,\n    };\n  }\n\n  /**\n   * Generate device health report\n   */\n  static generateHealthReport(devices: PointOfSaleOutput[]): {\n    totalDevices: number;\n    activeDevices: number;\n    offlineDevices: number;\n    devicesRequiringAttention: number;\n    avgUptimePercentage: number;\n    certificateExpiringCount: number;\n    statusBreakdown: Record<PEMStatus, number>;\n  } {\n    const report = {\n      totalDevices: devices.length,\n      activeDevices: 0,\n      offlineDevices: 0,\n      devicesRequiringAttention: 0,\n      avgUptimePercentage: 0,\n      certificateExpiringCount: 0,\n      statusBreakdown: {} as Record<PEMStatus, number>,\n    };\n\n    let totalUptime = 0;\n    // const now = new Date();\n    // Note: certificate_expiry field not available in OpenAPI schema\n\n    for (const device of devices) {\n      const status = device.status as PEMStatus;\n      \n      // Update status breakdown\n      report.statusBreakdown[status] = (report.statusBreakdown[status] || 0) + 1;\n\n      // Count active/offline devices\n      if (status === 'ACTIVE') {\n        report.activeDevices++;\n      } else if (status === 'OFFLINE') {\n        report.offlineDevices++;\n      }\n\n      // Check for devices requiring attention\n      if (['DISCARDED'].includes(status)) {\n        report.devicesRequiringAttention++;\n      }\n\n      // Note: certificate_expiry field not available in OpenAPI schema\n      // Using mock certificate validation\n\n      // Calculate uptime\n      const uptime = this.calculateUptime(device);\n      totalUptime += uptime.uptimePercentage;\n    }\n\n    report.avgUptimePercentage = devices.length > 0 ? \n      Math.round(totalUptime / devices.length) : 0;\n\n    return report;\n  }\n\n  /**\n   * Validate journal closing eligibility\n   */\n  static validateJournalClosingEligibility(device: PointOfSaleOutput, _date: string): {\n    canClose: boolean;\n    reasons: string[];\n    requirements: string[];\n  } {\n    const reasons: string[] = [];\n    const requirements: string[] = [];\n\n    // Check device status\n    if (device.status !== 'ACTIVE') {\n      reasons.push('Device must be in active status');\n    }\n\n    // Note: last_journal_close and pending_transactions fields not available in OpenAPI schema\n    // Using mock validation logic\n\n    // Requirements for closing\n    requirements.push('All transactions must be transmitted to tax authority');\n    requirements.push('Device must be connected to network');\n    requirements.push('No active receipt printing operations');\n\n    return {\n      canClose: reasons.length === 0,\n      reasons,\n      requirements,\n    };\n  }\n\n  /**\n   * Get recommended maintenance schedule\n   */\n  static getMaintenanceSchedule(_device: PointOfSaleOutput): {\n    nextMaintenance: string;\n    maintenanceType: 'routine' | 'certificate' | 'firmware' | 'urgent';\n    priority: 'low' | 'medium' | 'high' | 'critical';\n    description: string;\n    estimatedDuration: string;\n  } {\n    const now = new Date();\n    \n    // Note: certificate_expiry and firmware_version fields not available in OpenAPI schema\n    // Using default maintenance schedule\n\n    // Default routine maintenance\n    return {\n      nextMaintenance: new Date(now.getTime() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]!,\n      maintenanceType: 'routine',\n      priority: 'low',\n      description: 'Routine maintenance and inspection',\n      estimatedDuration: '30-60 minutes',\n    };\n  }\n\n  /**\n   * Check if firmware version is outdated\n   * @deprecated This method is not used since firmware_version is not available in OpenAPI schema\n   */\n  // private static isOutdatedFirmware(version: string): boolean {\n  //   // Simple version comparison (in reality, this would be more sophisticated)\n  //   const currentVersion = '2.1.0'; // Mock current version\n  //   return version < currentVersion;\n  // }\n\n  /**\n   * Generate activation code for new devices\n   */\n  static generateActivationCode(): string {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    let result = '';\n    \n    // Generate in format: XXXX-XXXX-XXXX-XXXX\n    for (let group = 0; group < 4; group++) {\n      if (group > 0) result += '-';\n      for (let i = 0; i < 4; i++) {\n        result += chars.charAt(Math.floor(Math.random() * chars.length));\n      }\n    }\n    \n    return result;\n  }\n}\n\n// Re-export for convenience\nexport { PointOfSalesResource as PointOfSales };\n\n// Export types for external use\nexport type {\n  PointOfSaleOutput,\n  PointOfSalePage,\n  ActivationRequest,\n  ActivationOutput,\n  CloseJournalRequest,\n  CloseJournalOutput,\n  InactivityRequest,\n};","/**\n * Unified Storage Interface for A-Cube SDK\n * Provides cross-platform storage abstraction with type safety and encryption support\n */\n\nimport type { \n  ReceiptId, \n  CashierId, \n  PEMId, \n  MerchantId, \n  CashRegisterId,\n \n} from '../types/branded';\n\n// Storage Key Types (branded for type safety)\ndeclare const __storageKeyBrand: unique symbol;\nexport type StorageKey = string & { [__storageKeyBrand]: 'StorageKey' };\nexport const createStorageKey = (key: string): StorageKey => key as StorageKey;\n\n// Storage Value Types\nexport type StorageValue = \n  | string \n  | number \n  | boolean \n  | object \n  | Array<any> \n  | null\n  | undefined;\n\n// Serializable data with metadata\nexport interface StorageEntry<T = StorageValue> {\n  readonly data: T;\n  readonly metadata: {\n    readonly key: StorageKey;\n    readonly createdAt: number;\n    readonly updatedAt: number;\n    readonly expiresAt?: number;\n    readonly encrypted: boolean;\n    readonly compressed: boolean;\n    readonly version: string;\n    readonly checksum?: string;\n  };\n}\n\n// Storage operation options\nexport interface StorageOptions {\n  readonly encrypt?: boolean;\n  readonly compress?: boolean;\n  readonly ttl?: number; // Time to live in milliseconds\n  readonly namespace?: string;\n  readonly version?: string;\n}\n\n// Query options for bulk operations\nexport interface QueryOptions {\n  readonly keyPrefix?: string; // Added for compatibility with existing code\n  readonly prefix?: string;\n  readonly namespace?: string;\n  readonly limit?: number;\n  readonly offset?: number;\n  readonly includeExpired?: boolean;\n  readonly sortBy?: 'key' | 'createdAt' | 'updatedAt';\n  readonly sortOrder?: 'asc' | 'desc';\n}\n\n// Storage transaction for atomic operations\nexport interface StorageTransaction {\n  readonly id: string;\n  set<T extends StorageValue>(key: StorageKey, value: T, options?: StorageOptions): Promise<void>;\n  get<T extends StorageValue>(key: StorageKey): Promise<StorageEntry<T> | null>;\n  delete(key: StorageKey): Promise<boolean>;\n  commit(): Promise<void>;\n  rollback(): Promise<void>;\n  readonly isActive: boolean;\n}\n\n// Storage adapter interface that all implementations must follow\nexport interface StorageAdapter {\n  readonly name: string;\n  readonly isAvailable: boolean;\n  readonly capabilities: {\n    readonly supportsTransactions: boolean;\n    readonly supportsIndexing: boolean;\n    readonly maxKeyLength: number;\n    readonly maxValueSize: number;\n    readonly supportsCompression: boolean;\n    readonly supportsEncryption: boolean;\n    readonly supportsTTL: boolean;\n  };\n\n  // Core operations\n  set<T extends StorageValue>(key: StorageKey, value: T, options?: StorageOptions): Promise<void>;\n  get<T extends StorageValue>(key: StorageKey): Promise<StorageEntry<T> | null>;\n  delete(key: StorageKey): Promise<boolean>;\n  exists(key: StorageKey): Promise<boolean>;\n  clear(namespace?: string): Promise<void>;\n\n  // Bulk operations\n  setMany<T extends StorageValue>(entries: Array<{ key: StorageKey; value: T; options?: StorageOptions }>): Promise<void>;\n  getMany<T extends StorageValue>(keys: StorageKey[]): Promise<Array<StorageEntry<T> | null>>;\n  deleteMany(keys: StorageKey[]): Promise<number>;\n\n  // Query operations\n  keys(options?: QueryOptions): Promise<StorageKey[]>;\n  values<T extends StorageValue>(options?: QueryOptions): Promise<Array<StorageEntry<T>>>;\n  entries<T extends StorageValue>(options?: QueryOptions): Promise<Array<StorageEntry<T>>>;\n  count(options?: QueryOptions): Promise<number>;\n\n  // Transaction support\n  beginTransaction(): Promise<StorageTransaction>;\n\n  // Lifecycle\n  connect(): Promise<void>;\n  disconnect(): Promise<void>;\n  isConnected(): boolean;\n\n  // Maintenance\n  cleanup(): Promise<number>; // Returns number of cleaned entries\n  optimize(): Promise<void>;\n  getStats(): Promise<StorageStats>;\n}\n\n// Storage statistics\nexport interface StorageStats {\n  readonly totalKeys: number;\n  readonly totalSize: number; // In bytes\n  readonly namespaces: string[];\n  readonly oldestEntry: number; // Timestamp\n  readonly newestEntry: number; // Timestamp\n  readonly expiredEntries: number;\n  readonly encryptedEntries: number;\n  readonly compressedEntries: number;\n}\n\n// Mutable version for internal storage adapter use\nexport interface InternalStorageStats {\n  totalKeys: number;\n  totalSize: number; // In bytes\n  namespaces: string[];\n  oldestEntry: number; // Timestamp\n  newestEntry: number; // Timestamp\n  expiredEntries: number;\n  encryptedEntries: number;\n  compressedEntries: number;\n}\n\n// Unified storage interface with high-level operations\nexport interface UnifiedStorage extends StorageAdapter {\n  // Specialized methods for e-receipt entities\n  setReceipt(id: ReceiptId, receipt: any, options?: StorageOptions): Promise<void>;\n  getReceipt(id: ReceiptId): Promise<any | null>;\n  deleteReceipt(id: ReceiptId): Promise<boolean>;\n\n  setCashier(id: CashierId, cashier: any, options?: StorageOptions): Promise<void>;\n  getCashier(id: CashierId): Promise<any | null>;\n  deleteCashier(id: CashierId): Promise<boolean>;\n\n  setMerchant(id: MerchantId, merchant: any, options?: StorageOptions): Promise<void>;\n  getMerchant(id: MerchantId): Promise<any | null>;\n  deleteMerchant(id: MerchantId): Promise<boolean>;\n\n  setPEM(id: PEMId, pem: any, options?: StorageOptions): Promise<void>;\n  getPEM(id: PEMId): Promise<any | null>;\n  deletePEM(id: PEMId): Promise<boolean>;\n\n  setCashRegister(id: CashRegisterId, cashRegister: any, options?: StorageOptions): Promise<void>;\n  getCashRegister(id: CashRegisterId): Promise<any | null>;\n  deleteCashRegister(id: CashRegisterId): Promise<boolean>;\n\n  // Cache operations with TTL support\n  setCache<T extends StorageValue>(key: string, value: T, ttl?: number): Promise<void>;\n  getCache<T extends StorageValue>(key: string): Promise<T | null>;\n  invalidateCache(pattern?: string): Promise<number>;\n\n  // Session storage (auto-expires when app closes)\n  setSession<T extends StorageValue>(key: string, value: T): Promise<void>;\n  getSession<T extends StorageValue>(key: string): Promise<T | null>;\n  clearSession(): Promise<void>;\n\n  // Secure storage for sensitive data (always encrypted)\n  setSecure<T extends StorageValue>(key: string, value: T): Promise<void>;\n  getSecure<T extends StorageValue>(key: string): Promise<T | null>;\n  deleteSecure(key: string): Promise<boolean>;\n  \n  // Configuration storage\n  setConfig<T extends StorageValue>(key: string, value: T): Promise<void>;\n  getConfig<T extends StorageValue>(key: string): Promise<T | null>;\n  deleteConfig(key: string): Promise<boolean>;\n\n  // Backup and restore\n  exportData(namespace?: string): Promise<string>; // Returns JSON string\n  importData(data: string): Promise<number>; // Returns number of imported entries\n  \n  // Query operations with keyPrefix support\n  query<T extends StorageValue>(options: QueryOptions): Promise<Array<{ key: StorageKey; value: T }>>;\n  \n  // Initialization and cleanup\n  initialize(): Promise<void>;\n  destroy(): Promise<void>;\n  \n  // Event listeners\n  on(event: 'set' | 'get' | 'delete' | 'clear' | 'error', listener: (...args: any[]) => void): void;\n  off(event: 'set' | 'get' | 'delete' | 'clear' | 'error', listener: (...args: any[]) => void): void;\n  emit(event: string, ...args: any[]): void;\n}\n\n// Error types for storage operations\nexport class StorageError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly operation: string,\n    public readonly key?: StorageKey,\n    public override readonly cause?: Error\n  ) {\n    super(message);\n    this.name = 'StorageError';\n  }\n}\n\nexport class StorageConnectionError extends StorageError {\n  constructor(adapter: string, cause?: Error) {\n    super(\n      `Failed to connect to storage adapter: ${adapter}`,\n      'STORAGE_CONNECTION_ERROR',\n      'connect',\n      undefined,\n      cause\n    );\n  }\n}\n\nexport class StorageCapacityError extends StorageError {\n  constructor(key: StorageKey, size: number, maxSize: number) {\n    super(\n      `Storage capacity exceeded for key ${key}: ${size} > ${maxSize}`,\n      'STORAGE_CAPACITY_ERROR',\n      'set',\n      key\n    );\n  }\n}\n\nexport class StorageEncryptionError extends StorageError {\n  constructor(key: StorageKey, operation: string, cause?: Error) {\n    super(\n      `Encryption/decryption failed for key ${key}`,\n      'STORAGE_ENCRYPTION_ERROR',\n      operation,\n      key,\n      cause\n    );\n  }\n}\n\nexport class StorageTransactionError extends StorageError {\n  constructor(transactionId: string, operation: string, cause?: Error) {\n    super(\n      `Transaction ${transactionId} failed during ${operation}`,\n      'STORAGE_TRANSACTION_ERROR',\n      operation,\n      undefined,\n      cause\n    );\n  }\n}\n\n// Storage events\nexport interface StorageEventMap {\n  set: [key: StorageKey, value: StorageValue, options?: StorageOptions];\n  get: [key: StorageKey, value: StorageValue | null];\n  delete: [key: StorageKey, success: boolean];\n  clear: [namespace?: string];\n  error: [error: StorageError];\n}\n\n// Default storage options\nexport const DEFAULT_STORAGE_OPTIONS: Required<StorageOptions> = {\n  encrypt: false,\n  compress: false,\n  ttl: 0, // No expiration\n  namespace: 'default',\n  version: '1.0.0',\n} as const;\n\n// Predefined namespaces for different data types\nexport const STORAGE_NAMESPACES = {\n  RECEIPTS: 'receipts',\n  CASHIERS: 'cashiers',\n  MERCHANTS: 'merchants',\n  PEMS: 'pems',\n  CASH_REGISTERS: 'cash_registers',\n  CACHE: 'cache',\n  SESSION: 'session',\n  SECURE: 'secure',\n  CONFIG: 'config',\n  OFFLINE_QUEUE: 'offline_queue',\n  ANALYTICS: 'analytics',\n  AUDIT: 'audit',\n} as const;\n\n// Type-safe storage key generators\nexport const createReceiptKey = (id: ReceiptId): StorageKey => \n  createStorageKey(`${STORAGE_NAMESPACES.RECEIPTS}:${id}`);\n\nexport const createCashierKey = (id: CashierId): StorageKey => \n  createStorageKey(`${STORAGE_NAMESPACES.CASHIERS}:${id}`);\n\nexport const createMerchantKey = (id: MerchantId): StorageKey => \n  createStorageKey(`${STORAGE_NAMESPACES.MERCHANTS}:${id}`);\n\nexport const createPEMKey = (id: PEMId): StorageKey => \n  createStorageKey(`${STORAGE_NAMESPACES.PEMS}:${id}`);\n\nexport const createCashRegisterKey = (id: CashRegisterId): StorageKey => \n  createStorageKey(`${STORAGE_NAMESPACES.CASH_REGISTERS}:${id}`);\n\nexport const createCacheKey = (key: string): StorageKey => \n  createStorageKey(`${STORAGE_NAMESPACES.CACHE}:${key}`);\n\nexport const createSessionKey = (key: string): StorageKey => \n  createStorageKey(`${STORAGE_NAMESPACES.SESSION}:${key}`);\n\nexport const createSecureKey = (key: string): StorageKey => \n  createStorageKey(`${STORAGE_NAMESPACES.SECURE}:${key}`);\n\nexport const createConfigKey = (key: string): StorageKey => \n  createStorageKey(`${STORAGE_NAMESPACES.CONFIG}:${key}`);","/**\n * Platform Detection Utility for A-Cube SDK\n * Detects the current runtime environment to enable platform-specific optimizations\n */\n\n// Platform types\nexport type PlatformType = 'web' | 'react-native' | 'node' | 'unknown';\n\n// Storage capabilities by platform\nexport interface PlatformCapabilities {\n  readonly platform: PlatformType;\n  readonly hasIndexedDB: boolean;\n  readonly hasLocalStorage: boolean;\n  readonly hasAsyncStorage: boolean;\n  readonly hasFileSystem: boolean;\n  readonly hasWebCrypto: boolean;\n  readonly hasCompressionStreams: boolean;\n  readonly supportsWorkers: boolean;\n  readonly supportsNotifications: boolean;\n  readonly isSecureContext: boolean;\n  readonly maxStorageSize: number; // In bytes, 0 means unlimited\n}\n\n// Environment detection results\nexport interface EnvironmentInfo extends PlatformCapabilities {\n  readonly userAgent?: string;\n  readonly nodeVersion?: string;\n  readonly reactNativeVersion?: string;\n  readonly browserName?: string;\n  readonly browserVersion?: string;\n  readonly osName?: string;\n  readonly osVersion?: string;\n  readonly deviceType: 'mobile' | 'tablet' | 'desktop' | 'server' | 'unknown';\n  readonly connectionType?: 'wifi' | 'cellular' | 'ethernet' | 'unknown';\n  readonly isOnline: boolean;\n  readonly language: string;\n  readonly timezone: string;\n}\n\n/**\n * Platform detector with comprehensive environment analysis\n */\nexport class PlatformDetector {\n  private static instance: PlatformDetector | null = null;\n  private cachedInfo: EnvironmentInfo | null = null;\n\n  private constructor() {}\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(): PlatformDetector {\n    if (!PlatformDetector.instance) {\n      PlatformDetector.instance = new PlatformDetector();\n    }\n    return PlatformDetector.instance;\n  }\n\n  /**\n   * Detect current platform type\n   */\n  detectPlatform(): PlatformType {\n    // Check for Node.js environment\n    if (typeof process !== 'undefined' && \n        process.versions && \n        process.versions.node &&\n        typeof window === 'undefined') {\n      return 'node';\n    }\n\n    // Check for React Native environment\n    if (typeof navigator !== 'undefined' && \n        navigator.product === 'ReactNative') {\n      return 'react-native';\n    }\n\n    // Check for web browser environment\n    if (typeof window !== 'undefined' && \n        typeof document !== 'undefined') {\n      return 'web';\n    }\n\n    return 'unknown';\n  }\n\n  /**\n   * Get comprehensive environment information\n   */\n  getEnvironmentInfo(): EnvironmentInfo {\n    if (this.cachedInfo) {\n      return this.cachedInfo;\n    }\n\n    const platform = this.detectPlatform();\n    \n    this.cachedInfo = {\n      ...this.detectCapabilities(platform),\n      ...this.detectDeviceInfo(platform),\n      ...this.detectNetworkInfo(),\n      ...this.detectLocaleInfo(),\n    };\n\n    return this.cachedInfo;\n  }\n\n  /**\n   * Detect storage and API capabilities\n   */\n  private detectCapabilities(platform: PlatformType): PlatformCapabilities {\n    const baseCapabilities: PlatformCapabilities = {\n      platform,\n      hasIndexedDB: false,\n      hasLocalStorage: false,\n      hasAsyncStorage: false,\n      hasFileSystem: false,\n      hasWebCrypto: false,\n      hasCompressionStreams: false,\n      supportsWorkers: false,\n      supportsNotifications: false,\n      isSecureContext: false,\n      maxStorageSize: 0,\n    };\n\n    switch (platform) {\n      case 'web':\n        return {\n          ...baseCapabilities,\n          hasIndexedDB: this.checkIndexedDBSupport(),\n          hasLocalStorage: this.checkLocalStorageSupport(),\n          hasWebCrypto: this.checkWebCryptoSupport(),\n          hasCompressionStreams: this.checkCompressionStreamsSupport(),\n          supportsWorkers: this.checkWebWorkersSupport(),\n          supportsNotifications: this.checkNotificationSupport(),\n          isSecureContext: this.checkSecureContext(),\n          maxStorageSize: this.estimateWebStorageQuota(),\n        };\n\n      case 'react-native':\n        return {\n          ...baseCapabilities,\n          hasAsyncStorage: this.checkAsyncStorageSupport(),\n          hasFileSystem: this.checkFileSystemSupport(),\n          hasWebCrypto: this.checkWebCryptoSupport(),\n          supportsNotifications: this.checkNotificationSupport(),\n          isSecureContext: true, // React Native is always secure\n          maxStorageSize: 0, // Unlimited for mobile\n        };\n\n      case 'node':\n        return {\n          ...baseCapabilities,\n          hasFileSystem: true,\n          hasWebCrypto: this.checkNodeCryptoSupport(),\n          hasCompressionStreams: this.checkNodeCompressionSupport(),\n          supportsWorkers: this.checkWorkerThreadsSupport(),\n          isSecureContext: true,\n          maxStorageSize: 0, // Unlimited for server\n        };\n\n      default:\n        return baseCapabilities;\n    }\n  }\n\n  /**\n   * Detect device and browser information\n   */\n  private detectDeviceInfo(platform: PlatformType): Pick<EnvironmentInfo, 'userAgent' | 'nodeVersion' | 'reactNativeVersion' | 'browserName' | 'browserVersion' | 'osName' | 'osVersion' | 'deviceType'> {\n    const info: any = {\n      deviceType: 'unknown' as const,\n    };\n\n    if (platform === 'node') {\n      info.nodeVersion = process.version;\n      info.osName = process.platform;\n      info.deviceType = 'server';\n    } else if (platform === 'react-native') {\n      info.reactNativeVersion = this.getReactNativeVersion();\n      info.deviceType = this.detectMobileDeviceType();\n      info.osName = this.getReactNativeOS();\n    } else if (platform === 'web') {\n      info.userAgent = navigator.userAgent;\n      const browserInfo = this.parseBrowserInfo(navigator.userAgent);\n      info.browserName = browserInfo.name;\n      info.browserVersion = browserInfo.version;\n      info.osName = this.parseOSInfo(navigator.userAgent);\n      info.deviceType = this.detectWebDeviceType();\n    }\n\n    return info;\n  }\n\n  /**\n   * Detect network information\n   */\n  private detectNetworkInfo(): Pick<EnvironmentInfo, 'connectionType' | 'isOnline'> {\n    let isOnline = true;\n    let connectionType: EnvironmentInfo['connectionType'] = 'unknown';\n\n    if (typeof navigator !== 'undefined') {\n      isOnline = navigator.onLine;\n      \n      // Network Information API (experimental)\n      const connection = (navigator as any).connection || \n                        (navigator as any).mozConnection || \n                        (navigator as any).webkitConnection;\n      \n      if (connection) {\n        const effectiveType = connection.effectiveType;\n        if (effectiveType === 'slow-2g' || effectiveType === '2g' || \n            effectiveType === '3g' || effectiveType === '4g') {\n          connectionType = 'cellular';\n        } else {\n          connectionType = 'wifi';\n        }\n      }\n    }\n\n    return { isOnline, connectionType };\n  }\n\n  /**\n   * Detect locale information\n   */\n  private detectLocaleInfo(): Pick<EnvironmentInfo, 'language' | 'timezone'> {\n    let language = 'en-US';\n    let timezone = 'UTC';\n\n    if (typeof navigator !== 'undefined') {\n      language = navigator.language || 'en-US';\n    }\n\n    if (typeof Intl !== 'undefined') {\n      timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n    }\n\n    return { language, timezone };\n  }\n\n  // Capability detection methods\n  private checkIndexedDBSupport(): boolean {\n    try {\n      return typeof window !== 'undefined' && \n             'indexedDB' in window && \n             window.indexedDB !== null;\n    } catch {\n      return false;\n    }\n  }\n\n  private checkLocalStorageSupport(): boolean {\n    try {\n      if (typeof window === 'undefined' || !window.localStorage) {\n        return false;\n      }\n      const testKey = '__localStorage_test__';\n      window.localStorage.setItem(testKey, 'test');\n      window.localStorage.removeItem(testKey);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private checkAsyncStorageSupport(): boolean {\n    try {\n      // Check if AsyncStorage is available (React Native)\n      return typeof require !== 'undefined' && \n             require('@react-native-async-storage/async-storage') !== null;\n    } catch {\n      return false;\n    }\n  }\n\n  private checkFileSystemSupport(): boolean {\n    try {\n      return typeof require !== 'undefined' && \n             (require('fs') !== null || require('react-native-fs') !== null);\n    } catch {\n      return false;\n    }\n  }\n\n  private checkWebCryptoSupport(): boolean {\n    try {\n      if (typeof crypto !== 'undefined' && crypto.subtle) {\n        return true;\n      }\n      // Node.js crypto module\n      if (typeof require !== 'undefined') {\n        const nodeCrypto = require('crypto');\n        return nodeCrypto && nodeCrypto.webcrypto;\n      }\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  private checkCompressionStreamsSupport(): boolean {\n    try {\n      return typeof CompressionStream !== 'undefined' && \n             typeof DecompressionStream !== 'undefined';\n    } catch {\n      return false;\n    }\n  }\n\n  private checkNodeCompressionSupport(): boolean {\n    try {\n      return typeof require !== 'undefined' && \n             require('zlib') !== null;\n    } catch {\n      return false;\n    }\n  }\n\n  private checkWebWorkersSupport(): boolean {\n    try {\n      return typeof Worker !== 'undefined';\n    } catch {\n      return false;\n    }\n  }\n\n  private checkWorkerThreadsSupport(): boolean {\n    try {\n      return typeof require !== 'undefined' && \n             require('worker_threads') !== null;\n    } catch {\n      return false;\n    }\n  }\n\n  private checkNotificationSupport(): boolean {\n    try {\n      return typeof Notification !== 'undefined' || \n             (typeof require !== 'undefined' && \n              require('react-native-push-notification') !== null);\n    } catch {\n      return false;\n    }\n  }\n\n  private checkSecureContext(): boolean {\n    if (typeof window !== 'undefined') {\n      return window.isSecureContext || location.protocol === 'https:';\n    }\n    return true; // Node.js and React Native are considered secure\n  }\n\n  private checkNodeCryptoSupport(): boolean {\n    try {\n      const crypto = require('crypto');\n      return crypto && (crypto.webcrypto || crypto.subtle);\n    } catch {\n      return false;\n    }\n  }\n\n  private estimateWebStorageQuota(): number {\n    if (typeof navigator !== 'undefined' && 'storage' in navigator && 'estimate' in navigator.storage) {\n      // This will be resolved asynchronously, but we return 0 for now\n      navigator.storage.estimate().then(estimate => {\n        return estimate.quota || 0;\n      });\n    }\n    \n    // Fallback estimates based on browser\n    const userAgent = navigator?.userAgent || '';\n    if (userAgent.includes('Chrome')) {\n      return 1024 * 1024 * 1024; // ~1GB for Chrome\n    } else if (userAgent.includes('Firefox')) {\n      return 2 * 1024 * 1024 * 1024; // ~2GB for Firefox\n    } else if (userAgent.includes('Safari')) {\n      return 1024 * 1024 * 1024; // ~1GB for Safari\n    }\n    \n    return 50 * 1024 * 1024; // 50MB default\n  }\n\n  private getReactNativeVersion(): string {\n    try {\n      const Platform = require('react-native').Platform;\n      return Platform.constants?.reactNativeVersion?.string || 'unknown';\n    } catch {\n      return 'unknown';\n    }\n  }\n\n  private getReactNativeOS(): string {\n    try {\n      const Platform = require('react-native').Platform;\n      return Platform.OS;\n    } catch {\n      return 'unknown';\n    }\n  }\n\n  private detectMobileDeviceType(): 'mobile' | 'tablet' {\n    try {\n      const Dimensions = require('react-native').Dimensions;\n      const { width, height } = Dimensions.get('window');\n      const aspectRatio = Math.max(width, height) / Math.min(width, height);\n      \n      // Simple heuristic: tablets typically have lower aspect ratios\n      return aspectRatio < 1.6 ? 'tablet' : 'mobile';\n    } catch {\n      return 'mobile';\n    }\n  }\n\n  private detectWebDeviceType(): 'mobile' | 'tablet' | 'desktop' {\n    if (typeof window === 'undefined') return 'desktop';\n    \n    const userAgent = navigator.userAgent;\n    \n    if (/iPad|Android(?!.*Mobile)/i.test(userAgent)) {\n      return 'tablet';\n    } else if (/iPhone|iPod|Android.*Mobile|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {\n      return 'mobile';\n    } else {\n      return 'desktop';\n    }\n  }\n\n  private parseBrowserInfo(userAgent: string): { name: string; version: string } {\n    const browsers = [\n      { name: 'Chrome', regex: /Chrome\\/(\\d+\\.\\d+)/ },\n      { name: 'Firefox', regex: /Firefox\\/(\\d+\\.\\d+)/ },\n      { name: 'Safari', regex: /Safari\\/(\\d+\\.\\d+)/ },\n      { name: 'Edge', regex: /Edge\\/(\\d+\\.\\d+)/ },\n      { name: 'Opera', regex: /Opera\\/(\\d+\\.\\d+)/ },\n    ];\n\n    for (const browser of browsers) {\n      const match = userAgent.match(browser.regex);\n      if (match) {\n        return { name: browser.name, version: match[1] || '0.0' };\n      }\n    }\n\n    return { name: 'Unknown', version: '0.0' };\n  }\n\n  private parseOSInfo(userAgent: string): string {\n    if (userAgent.includes('Windows')) return 'Windows';\n    if (userAgent.includes('Mac OS')) return 'macOS';\n    if (userAgent.includes('Linux')) return 'Linux';\n    if (userAgent.includes('Android')) return 'Android';\n    if (userAgent.includes('iOS')) return 'iOS';\n    return 'Unknown';\n  }\n\n  /**\n   * Clear cached information (useful for testing)\n   */\n  clearCache(): void {\n    this.cachedInfo = null;\n  }\n\n  /**\n   * Check if specific capability is available\n   */\n  hasCapability(capability: keyof PlatformCapabilities): boolean {\n    const info = this.getEnvironmentInfo();\n    return info[capability] as boolean;\n  }\n\n  /**\n   * Get optimal storage adapter for current platform\n   */\n  getRecommendedStorageAdapter(): 'indexeddb' | 'localstorage' | 'asyncstorage' | 'filesystem' | 'memory' {\n    const capabilities = this.getEnvironmentInfo();\n    \n    if (capabilities.hasIndexedDB) {\n      return 'indexeddb';\n    } else if (capabilities.hasAsyncStorage) {\n      return 'asyncstorage';\n    } else if (capabilities.hasLocalStorage) {\n      return 'localstorage';\n    } else if (capabilities.hasFileSystem) {\n      return 'filesystem';\n    } else {\n      return 'memory';\n    }\n  }\n\n  /**\n   * Get performance tier based on platform capabilities\n   */\n  getPerformanceTier(): 'high' | 'medium' | 'low' {\n    const info = this.getEnvironmentInfo();\n    \n    if (info.platform === 'node' || \n        (info.platform === 'web' && info.deviceType === 'desktop')) {\n      return 'high';\n    } else if (info.platform === 'react-native' && info.deviceType === 'tablet') {\n      return 'medium';\n    } else {\n      return 'low';\n    }\n  }\n}\n\n// Export singleton instance\nexport const platformDetector = PlatformDetector.getInstance();\n\n// Convenience functions\nexport const getPlatform = (): PlatformType => platformDetector.detectPlatform();\nexport const getEnvironmentInfo = (): EnvironmentInfo => platformDetector.getEnvironmentInfo();\nexport const hasCapability = (capability: keyof PlatformCapabilities): boolean => \n  platformDetector.hasCapability(capability);\nexport const getRecommendedStorageAdapter = () => platformDetector.getRecommendedStorageAdapter();\nexport const getPerformanceTier = () => platformDetector.getPerformanceTier();","/**\n * IndexedDB Storage Adapter for A-Cube SDK\n * Provides robust, high-performance storage with schema management and migrations\n */\n\nimport { \n  StorageAdapter, \n  StorageKey, \n  StorageValue, \n  StorageEntry, \n  StorageOptions, \n  QueryOptions, \n  StorageTransaction, \n  StorageStats,\n  InternalStorageStats,\n  StorageError,\n  StorageConnectionError,\n  // StorageCapacityError,\n  StorageTransactionError,\n  DEFAULT_STORAGE_OPTIONS \n} from '../unified-storage';\n\n// IndexedDB specific types\ninterface IndexedDBSchema {\n  readonly version: number;\n  readonly stores: {\n    readonly [storeName: string]: {\n      readonly keyPath?: string;\n      readonly autoIncrement?: boolean;\n      readonly indexes?: {\n        readonly [indexName: string]: {\n          readonly keyPath: string | string[];\n          readonly unique?: boolean;\n          readonly multiEntry?: boolean;\n        };\n      };\n    };\n  };\n}\n\ninterface IndexedDBMigration {\n  readonly version: number;\n  readonly up: (db: IDBDatabase, transaction: IDBTransaction) => void | Promise<void>;\n  readonly down?: (db: IDBDatabase, transaction: IDBTransaction) => void | Promise<void>;\n}\n\ninterface IndexedDBConfig {\n  readonly databaseName: string;\n  readonly version: number;\n  readonly schema: IndexedDBSchema;\n  readonly migrations: IndexedDBMigration[];\n  readonly timeout?: number;\n  readonly maxRetries?: number;\n}\n\n// Transaction implementation\nclass IndexedDBTransaction implements StorageTransaction {\n  public readonly id: string;\n  public isActive: boolean = true;\n  \n  private operations: Array<() => Promise<void>> = [];\n  private rollbackOperations: Array<() => Promise<void>> = [];\n\n  constructor(\n    private adapter: IndexedDBAdapter,\n    private idbTransaction: IDBTransaction\n  ) {\n    this.id = `txn_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n    \n    // Handle transaction abort\n    this.idbTransaction.addEventListener('abort', () => {\n      this.isActive = false;\n    });\n    \n    this.idbTransaction.addEventListener('complete', () => {\n      this.isActive = false;\n    });\n\n    this.idbTransaction.addEventListener('error', () => {\n      this.isActive = false;\n    });\n  }\n\n  async set<T extends StorageValue>(key: StorageKey, value: T, options?: StorageOptions): Promise<void> {\n    if (!this.isActive) {\n      throw new StorageTransactionError(this.id, 'set', new Error('Transaction not active'));\n    }\n\n    const operation = async () => {\n      await this.adapter.setWithTransaction(key, value, options, this.idbTransaction);\n    };\n\n    const rollback = async () => {\n      await this.adapter.deleteWithTransaction(key, this.idbTransaction);\n    };\n\n    this.operations.push(operation);\n    this.rollbackOperations.unshift(rollback);\n  }\n\n  async get<T extends StorageValue>(key: StorageKey): Promise<StorageEntry<T> | null> {\n    if (!this.isActive) {\n      throw new StorageTransactionError(this.id, 'get', new Error('Transaction not active'));\n    }\n\n    return this.adapter.getWithTransaction<T>(key, this.idbTransaction);\n  }\n\n  async delete(key: StorageKey): Promise<boolean> {\n    if (!this.isActive) {\n      throw new StorageTransactionError(this.id, 'delete', new Error('Transaction not active'));\n    }\n\n    const originalValue = await this.get(key);\n    \n    const operation = async () => {\n      await this.adapter.deleteWithTransaction(key, this.idbTransaction);\n    };\n\n    const rollback = async () => {\n      if (originalValue) {\n        await this.adapter.setWithTransaction(key, originalValue.data, undefined, this.idbTransaction);\n      }\n    };\n\n    this.operations.push(operation);\n    this.rollbackOperations.unshift(rollback);\n    \n    return true;\n  }\n\n  async commit(): Promise<void> {\n    if (!this.isActive) {\n      throw new StorageTransactionError(this.id, 'commit', new Error('Transaction not active'));\n    }\n\n    try {\n      // Execute all operations\n      for (const operation of this.operations) {\n        await operation();\n      }\n      \n      // Transaction will auto-commit when it goes out of scope\n      this.isActive = false;\n    } catch (error) {\n      await this.rollback();\n      throw new StorageTransactionError(this.id, 'commit', error as Error);\n    }\n  }\n\n  async rollback(): Promise<void> {\n    if (!this.isActive) {\n      return; // Already rolled back\n    }\n\n    try {\n      // Execute rollback operations in reverse order\n      for (const rollback of this.rollbackOperations) {\n        await rollback();\n      }\n    } catch (error) {\n      console.warn(`Failed to rollback transaction ${this.id}:`, error);\n    } finally {\n      this.idbTransaction.abort();\n      this.isActive = false;\n    }\n  }\n}\n\n/**\n * IndexedDB Storage Adapter\n * High-performance storage with advanced features\n */\nexport class IndexedDBAdapter implements StorageAdapter {\n  public readonly name = 'IndexedDB';\n  private db: IDBDatabase | null = null;\n  private config: IndexedDBConfig;\n  private connectionPromise: Promise<IDBDatabase> | null = null;\n\n  public readonly capabilities = {\n    supportsTransactions: true,\n    supportsIndexing: true,\n    maxKeyLength: 1024,\n    maxValueSize: 256 * 1024 * 1024, // 256MB\n    supportsCompression: true,\n    supportsEncryption: true,\n    supportsTTL: true,\n  } as const;\n\n  constructor(config: Partial<IndexedDBConfig> = {}) {\n    this.config = {\n      databaseName: config.databaseName || 'acube-sdk-storage',\n      version: config.version || 1,\n      schema: config.schema || this.getDefaultSchema(),\n      migrations: config.migrations || [],\n      timeout: config.timeout || 30000,\n      maxRetries: config.maxRetries || 3,\n    };\n  }\n\n  get isAvailable(): boolean {\n    return typeof indexedDB !== 'undefined' && indexedDB !== null;\n  }\n\n  isConnected(): boolean {\n    return this.db !== null && this.db.objectStoreNames.length > 0;\n  }\n\n  async connect(): Promise<void> {\n    if (this.db) {\n      return; // Already connected\n    }\n\n    if (this.connectionPromise) {\n      await this.connectionPromise;\n      return;\n    }\n\n    this.connectionPromise = this.establishConnection();\n    \n    try {\n      this.db = await this.connectionPromise;\n    } finally {\n      this.connectionPromise = null;\n    }\n  }\n\n  private async establishConnection(): Promise<IDBDatabase> {\n    if (!this.isAvailable) {\n      throw new StorageConnectionError('IndexedDB not available');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new StorageConnectionError('IndexedDB connection timeout'));\n      }, this.config.timeout);\n\n      const request = indexedDB.open(this.config.databaseName, this.config.version);\n\n      request.onerror = () => {\n        clearTimeout(timeout);\n        reject(new StorageConnectionError('IndexedDB', request.error || undefined));\n      };\n\n      request.onsuccess = () => {\n        clearTimeout(timeout);\n        resolve(request.result);\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = request.result;\n        this.handleUpgrade(db, event.oldVersion, event.newVersion || this.config.version);\n      };\n\n      request.onblocked = () => {\n        console.warn('IndexedDB upgrade blocked. Close other tabs using this database.');\n      };\n    });\n  }\n\n  private handleUpgrade(db: IDBDatabase, oldVersion: number, newVersion: number): void {\n    // Create stores according to schema\n    for (const [storeName, storeConfig] of Object.entries(this.config.schema.stores)) {\n      if (!db.objectStoreNames.contains(storeName)) {\n        const store = db.createObjectStore(storeName, {\n          ...(storeConfig.keyPath && { keyPath: storeConfig.keyPath }),\n          ...(storeConfig.autoIncrement && { autoIncrement: storeConfig.autoIncrement }),\n        });\n\n        // Create indexes\n        if (storeConfig.indexes) {\n          for (const [indexName, indexConfig] of Object.entries(storeConfig.indexes)) {\n            store.createIndex(indexName, indexConfig.keyPath, {\n              ...(indexConfig.unique !== undefined && { unique: indexConfig.unique }),\n              ...(indexConfig.multiEntry !== undefined && { multiEntry: indexConfig.multiEntry }),\n            });\n          }\n        }\n      }\n    }\n\n    // Run migrations\n    const relevantMigrations = this.config.migrations.filter(\n      migration => migration.version > oldVersion && migration.version <= newVersion\n    );\n\n    for (const migration of relevantMigrations.sort((a, b) => a.version - b.version)) {\n      try {\n        migration.up(db, db.transaction(Array.from(db.objectStoreNames), 'readwrite'));\n      } catch (error) {\n        console.error(`Migration ${migration.version} failed:`, error);\n        throw error;\n      }\n    }\n  }\n\n  private getDefaultSchema(): IndexedDBSchema {\n    return {\n      version: 1,\n      stores: {\n        storage: {\n          keyPath: 'key',\n          indexes: {\n            namespace: { keyPath: 'namespace' },\n            createdAt: { keyPath: 'createdAt' },\n            expiresAt: { keyPath: 'expiresAt' },\n          },\n        },\n      },\n    };\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.db) {\n      this.db.close();\n      this.db = null;\n    }\n  }\n\n  async set<T extends StorageValue>(key: StorageKey, value: T, options?: StorageOptions): Promise<void> {\n    await this.connect();\n    \n    const mergedOptions = { ...DEFAULT_STORAGE_OPTIONS, ...options };\n    const entry = this.createStorageEntry(key, value, mergedOptions);\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction(['storage'], 'readwrite');\n      const store = transaction.objectStore('storage');\n      \n      const request = store.put({\n        key: key,\n        ...entry,\n        namespace: mergedOptions.namespace,\n      });\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new StorageError(\n        `Failed to set key: ${key}`,\n        'STORAGE_SET_ERROR',\n        'set',\n        key,\n        request.error || undefined\n      ));\n    });\n  }\n\n  async setWithTransaction<T extends StorageValue>(\n    key: StorageKey, \n    value: T, \n    options: StorageOptions = {}, \n    transaction: IDBTransaction\n  ): Promise<void> {\n    const mergedOptions = { ...DEFAULT_STORAGE_OPTIONS, ...options };\n    const entry = this.createStorageEntry(key, value, mergedOptions);\n    \n    return new Promise((resolve, reject) => {\n      const store = transaction.objectStore('storage');\n      const request = store.put({\n        key: key,\n        ...entry,\n        namespace: mergedOptions.namespace,\n      });\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new StorageError(\n        `Failed to set key in transaction: ${key}`,\n        'STORAGE_TRANSACTION_SET_ERROR',\n        'set',\n        key,\n        request.error || undefined\n      ));\n    });\n  }\n\n  async get<T extends StorageValue>(key: StorageKey): Promise<StorageEntry<T> | null> {\n    await this.connect();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction(['storage'], 'readonly');\n      const store = transaction.objectStore('storage');\n      \n      const request = store.get(key);\n\n      request.onsuccess = () => {\n        const result = request.result;\n        if (!result) {\n          resolve(null);\n          return;\n        }\n\n        // Check expiration\n        if (result.metadata.expiresAt && result.metadata.expiresAt < Date.now()) {\n          // Async cleanup of expired entry\n          this.delete(key).catch(console.warn);\n          resolve(null);\n          return;\n        }\n\n        resolve(result as StorageEntry<T>);\n      };\n\n      request.onerror = () => reject(new StorageError(\n        `Failed to get key: ${key}`,\n        'STORAGE_GET_ERROR',\n        'get',\n        key,\n        request.error || undefined\n      ));\n    });\n  }\n\n  async getWithTransaction<T extends StorageValue>(\n    key: StorageKey, \n    transaction: IDBTransaction\n  ): Promise<StorageEntry<T> | null> {\n    return new Promise((resolve, reject) => {\n      const store = transaction.objectStore('storage');\n      const request = store.get(key);\n\n      request.onsuccess = () => {\n        const result = request.result;\n        if (!result) {\n          resolve(null);\n          return;\n        }\n\n        // Check expiration\n        if (result.metadata.expiresAt && result.metadata.expiresAt < Date.now()) {\n          resolve(null);\n          return;\n        }\n\n        resolve(result as StorageEntry<T>);\n      };\n\n      request.onerror = () => reject(new StorageError(\n        `Failed to get key in transaction: ${key}`,\n        'STORAGE_TRANSACTION_GET_ERROR',\n        'get',\n        key,\n        request.error || undefined\n      ));\n    });\n  }\n\n  async delete(key: StorageKey): Promise<boolean> {\n    await this.connect();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction(['storage'], 'readwrite');\n      const store = transaction.objectStore('storage');\n      \n      const request = store.delete(key);\n\n      request.onsuccess = () => resolve(true);\n      request.onerror = () => reject(new StorageError(\n        `Failed to delete key: ${key}`,\n        'STORAGE_DELETE_ERROR',\n        'delete',\n        key,\n        request.error || undefined\n      ));\n    });\n  }\n\n  async deleteWithTransaction(key: StorageKey, transaction: IDBTransaction): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      const store = transaction.objectStore('storage');\n      const request = store.delete(key);\n\n      request.onsuccess = () => resolve(true);\n      request.onerror = () => reject(new StorageError(\n        `Failed to delete key in transaction: ${key}`,\n        'STORAGE_TRANSACTION_DELETE_ERROR',\n        'delete',\n        key,\n        request.error || undefined\n      ));\n    });\n  }\n\n  async exists(key: StorageKey): Promise<boolean> {\n    const entry = await this.get(key);\n    return entry !== null;\n  }\n\n  async clear(namespace?: string): Promise<void> {\n    await this.connect();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction(['storage'], 'readwrite');\n      const store = transaction.objectStore('storage');\n      \n      if (namespace) {\n        // Clear only specific namespace using index\n        const index = store.index('namespace');\n        const request = index.openCursor(IDBKeyRange.only(namespace));\n        \n        request.onsuccess = (event) => {\n          const cursor = (event.target as IDBRequest).result;\n          if (cursor) {\n            cursor.delete();\n            cursor.continue();\n          } else {\n            resolve();\n          }\n        };\n\n        request.onerror = () => reject(new StorageError(\n          `Failed to clear namespace: ${namespace}`,\n          'STORAGE_CLEAR_ERROR',\n          'clear',\n          undefined,\n          request.error || undefined\n        ));\n      } else {\n        // Clear entire store\n        const request = store.clear();\n        \n        request.onsuccess = () => resolve();\n        request.onerror = () => reject(new StorageError(\n          'Failed to clear storage',\n          'STORAGE_CLEAR_ERROR',\n          'clear',\n          undefined,\n          request.error || undefined\n        ));\n      }\n    });\n  }\n\n  async setMany<T extends StorageValue>(entries: Array<{ key: StorageKey; value: T; options?: StorageOptions }>): Promise<void> {\n    await this.connect();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction(['storage'], 'readwrite');\n      const store = transaction.objectStore('storage');\n      let completed = 0;\n      \n      for (const entry of entries) {\n        const mergedOptions = { ...DEFAULT_STORAGE_OPTIONS, ...entry.options };\n        const storageEntry = this.createStorageEntry(entry.key, entry.value, mergedOptions);\n        \n        const request = store.put({\n          key: entry.key,\n          ...storageEntry,\n          namespace: mergedOptions.namespace,\n        });\n\n        request.onsuccess = () => {\n          completed++;\n          if (completed === entries.length) {\n            resolve();\n          }\n        };\n\n        request.onerror = () => reject(new StorageError(\n          `Failed to set key in batch: ${entry.key}`,\n          'STORAGE_BATCH_SET_ERROR',\n          'setMany',\n          entry.key,\n          request.error || undefined\n        ));\n      }\n    });\n  }\n\n  async getMany<T extends StorageValue>(keys: StorageKey[]): Promise<Array<StorageEntry<T> | null>> {\n    await this.connect();\n    \n    const results: Array<StorageEntry<T> | null> = [];\n    \n    for (const key of keys) {\n      results.push(await this.get<T>(key));\n    }\n    \n    return results;\n  }\n\n  async deleteMany(keys: StorageKey[]): Promise<number> {\n    await this.connect();\n    \n    let deletedCount = 0;\n    \n    for (const key of keys) {\n      const deleted = await this.delete(key);\n      if (deleted) deletedCount++;\n    }\n    \n    return deletedCount;\n  }\n\n  async keys(options: QueryOptions = {}): Promise<StorageKey[]> {\n    await this.connect();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction(['storage'], 'readonly');\n      const store = transaction.objectStore('storage');\n      const keys: StorageKey[] = [];\n      \n      const request = store.openCursor();\n      \n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor) {\n          const entry = cursor.value;\n          \n          // Apply filters\n          if (this.matchesQuery(entry, options)) {\n            keys.push(entry.key as StorageKey);\n          }\n          \n          cursor.continue();\n        } else {\n          resolve(this.applySortingAndPaging(keys, options));\n        }\n      };\n\n      request.onerror = () => reject(new StorageError(\n        'Failed to get keys',\n        'STORAGE_KEYS_ERROR',\n        'keys',\n        undefined,\n        request.error || undefined\n      ));\n    });\n  }\n\n  async values<T extends StorageValue>(options: QueryOptions = {}): Promise<Array<StorageEntry<T>>> {\n    await this.connect();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction(['storage'], 'readonly');\n      const store = transaction.objectStore('storage');\n      const values: Array<StorageEntry<T>> = [];\n      \n      const request = store.openCursor();\n      \n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor) {\n          const entry = cursor.value;\n          \n          // Apply filters\n          if (this.matchesQuery(entry, options)) {\n            values.push(entry as StorageEntry<T>);\n          }\n          \n          cursor.continue();\n        } else {\n          resolve(this.applySortingAndPaging(values, options));\n        }\n      };\n\n      request.onerror = () => reject(new StorageError(\n        'Failed to get values',\n        'STORAGE_VALUES_ERROR',\n        'values',\n        undefined,\n        request.error || undefined\n      ));\n    });\n  }\n\n  async entries<T extends StorageValue>(options: QueryOptions = {}): Promise<Array<StorageEntry<T>>> {\n    return this.values<T>(options);\n  }\n\n  async count(options: QueryOptions = {}): Promise<number> {\n    await this.connect();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction(['storage'], 'readonly');\n      const store = transaction.objectStore('storage');\n      let count = 0;\n      \n      const request = store.openCursor();\n      \n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor) {\n          const entry = cursor.value;\n          \n          if (this.matchesQuery(entry, options)) {\n            count++;\n          }\n          \n          cursor.continue();\n        } else {\n          resolve(count);\n        }\n      };\n\n      request.onerror = () => reject(new StorageError(\n        'Failed to count entries',\n        'STORAGE_COUNT_ERROR',\n        'count',\n        undefined,\n        request.error || undefined\n      ));\n    });\n  }\n\n  async beginTransaction(): Promise<StorageTransaction> {\n    await this.connect();\n    \n    const idbTransaction = this.db!.transaction(['storage'], 'readwrite');\n    return new IndexedDBTransaction(this, idbTransaction);\n  }\n\n  async cleanup(): Promise<number> {\n    await this.connect();\n    \n    const now = Date.now();\n    let cleanedCount = 0;\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction(['storage'], 'readwrite');\n      const store = transaction.objectStore('storage');\n      const request = store.openCursor();\n      \n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor) {\n          const entry = cursor.value;\n          \n          // Check if entry is expired\n          if (entry.metadata.expiresAt && entry.metadata.expiresAt < now) {\n            cursor.delete();\n            cleanedCount++;\n          }\n          \n          cursor.continue();\n        } else {\n          resolve(cleanedCount);\n        }\n      };\n\n      request.onerror = () => reject(new StorageError(\n        'Failed to cleanup expired entries',\n        'STORAGE_CLEANUP_ERROR',\n        'cleanup',\n        undefined,\n        request.error || undefined\n      ));\n    });\n  }\n\n  async optimize(): Promise<void> {\n    // IndexedDB doesn't require manual optimization\n    // But we can run cleanup to remove expired entries\n    await this.cleanup();\n  }\n\n  async getStats(): Promise<StorageStats> {\n    await this.connect();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction(['storage'], 'readonly');\n      const store = transaction.objectStore('storage');\n      const request = store.openCursor();\n      \n      const stats: InternalStorageStats = {\n        totalKeys: 0,\n        totalSize: 0,\n        namespaces: [],\n        oldestEntry: Date.now(),\n        newestEntry: 0,\n        expiredEntries: 0,\n        encryptedEntries: 0,\n        compressedEntries: 0,\n      };\n      \n      const namespaceSet = new Set<string>();\n      \n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor) {\n          const entry = cursor.value;\n          \n          stats.totalKeys++;\n          stats.totalSize += this.estimateEntrySize(entry);\n          \n          namespaceSet.add(entry.namespace);\n          \n          if (entry.metadata.createdAt < stats.oldestEntry) {\n            stats.oldestEntry = entry.metadata.createdAt;\n          }\n          if (entry.metadata.createdAt > stats.newestEntry) {\n            stats.newestEntry = entry.metadata.createdAt;\n          }\n          \n          if (entry.metadata.expiresAt && entry.metadata.expiresAt < Date.now()) {\n            stats.expiredEntries++;\n          }\n          \n          if (entry.metadata.encrypted) {\n            stats.encryptedEntries++;\n          }\n          \n          if (entry.metadata.compressed) {\n            stats.compressedEntries++;\n          }\n          \n          cursor.continue();\n        } else {\n          stats.namespaces = Array.from(namespaceSet);\n          resolve(stats);\n        }\n      };\n\n      request.onerror = () => reject(new StorageError(\n        'Failed to get storage stats',\n        'STORAGE_STATS_ERROR',\n        'getStats',\n        undefined,\n        request.error || undefined\n      ));\n    });\n  }\n\n  private createStorageEntry<T extends StorageValue>(\n    key: StorageKey, \n    value: T, \n    options: Required<StorageOptions>\n  ): StorageEntry<T> {\n    const now = Date.now();\n    \n    return {\n      data: value,\n      metadata: {\n        key,\n        createdAt: now,\n        updatedAt: now,\n        ...(options.ttl > 0 && { expiresAt: now + options.ttl }),\n        encrypted: options.encrypt,\n        compressed: options.compress,\n        version: options.version,\n      },\n    };\n  }\n\n  private matchesQuery(entry: any, options: QueryOptions): boolean {\n    const now = Date.now();\n    \n    // Check expiration\n    if (!options.includeExpired && entry.metadata.expiresAt && entry.metadata.expiresAt < now) {\n      return false;\n    }\n    \n    // Check namespace\n    if (options.namespace && entry.namespace !== options.namespace) {\n      return false;\n    }\n    \n    // Check prefix\n    if (options.prefix && !entry.key.startsWith(options.prefix)) {\n      return false;\n    }\n    \n    return true;\n  }\n\n  private applySortingAndPaging<T>(items: T[], options: QueryOptions): T[] {\n    let result = [...items];\n    \n    // Apply sorting (simplified for this implementation)\n    if (options.sortBy) {\n      result.sort((a: any, b: any) => {\n        const sortBy = options.sortBy;\n        if (!sortBy) return 0;\n        \n        const aVal = sortBy === 'key' ? a.key || a : a.metadata?.[sortBy] || 0;\n        const bVal = sortBy === 'key' ? b.key || b : b.metadata?.[sortBy] || 0;\n        \n        const comparison = aVal < bVal ? -1 : aVal > bVal ? 1 : 0;\n        return options.sortOrder === 'desc' ? -comparison : comparison;\n      });\n    }\n    \n    // Apply paging\n    const offset = options.offset || 0;\n    const limit = options.limit;\n    \n    if (limit) {\n      result = result.slice(offset, offset + limit);\n    } else if (offset) {\n      result = result.slice(offset);\n    }\n    \n    return result;\n  }\n\n  private estimateEntrySize(entry: any): number {\n    // Rough estimation of entry size in bytes\n    const jsonString = JSON.stringify(entry);\n    return new Blob([jsonString]).size;\n  }\n}","/**\n * LocalStorage Storage Adapter for A-Cube SDK\n * Provides fallback storage for environments without IndexedDB\n */\n\nimport { \n  StorageAdapter, \n  StorageKey, \n  StorageValue, \n  StorageEntry, \n  StorageOptions, \n  QueryOptions, \n  StorageTransaction, \n  StorageStats,\n  InternalStorageStats,\n  StorageError,\n  StorageConnectionError,\n  StorageCapacityError,\n  StorageTransactionError,\n  DEFAULT_STORAGE_OPTIONS \n} from '../unified-storage';\n\n// LocalStorage specific types\n// interface LocalStorageData {\n//   readonly [key: string]: string;\n// }\n\ninterface LocalStorageTransaction extends StorageTransaction {\n  readonly pendingOperations: Map<StorageKey, { action: 'set' | 'delete'; value?: any; options?: StorageOptions }>;\n  readonly originalValues: Map<StorageKey, string | null>;\n}\n\n/**\n * Simple transaction implementation for localStorage\n * Uses in-memory operations with commit/rollback support\n */\nclass LocalStorageTransactionImpl implements LocalStorageTransaction {\n  public readonly id: string;\n  public isActive: boolean = true;\n  public readonly pendingOperations = new Map<StorageKey, { action: 'set' | 'delete'; value?: any; options?: StorageOptions }>();\n  public readonly originalValues = new Map<StorageKey, string | null>();\n\n  constructor(private adapter: LocalStorageAdapter) {\n    this.id = `txn_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  async set<T extends StorageValue>(key: StorageKey, value: T, options?: StorageOptions): Promise<void> {\n    if (!this.isActive) {\n      throw new StorageTransactionError(this.id, 'set', new Error('Transaction not active'));\n    }\n\n    // Store original value if not already stored\n    if (!this.originalValues.has(key)) {\n      try {\n        const originalValue = localStorage.getItem(this.adapter.getStorageKey(key));\n        this.originalValues.set(key, originalValue);\n      } catch {\n        this.originalValues.set(key, null);\n      }\n    }\n\n    this.pendingOperations.set(key, { action: 'set', value, ...(options && { options }) });\n  }\n\n  async get<T extends StorageValue>(key: StorageKey): Promise<StorageEntry<T> | null> {\n    if (!this.isActive) {\n      throw new StorageTransactionError(this.id, 'get', new Error('Transaction not active'));\n    }\n\n    // Check pending operations first\n    const pending = this.pendingOperations.get(key);\n    if (pending) {\n      if (pending.action === 'delete') {\n        return null;\n      } else if (pending.action === 'set') {\n        const mergedOptions = { ...DEFAULT_STORAGE_OPTIONS, ...pending.options };\n        return this.adapter.createStorageEntry(key, pending.value, mergedOptions);\n      }\n    }\n\n    // Fallback to adapter\n    return this.adapter.get<T>(key);\n  }\n\n  async delete(key: StorageKey): Promise<boolean> {\n    if (!this.isActive) {\n      throw new StorageTransactionError(this.id, 'delete', new Error('Transaction not active'));\n    }\n\n    // Store original value if not already stored\n    if (!this.originalValues.has(key)) {\n      try {\n        const originalValue = localStorage.getItem(this.adapter.getStorageKey(key));\n        this.originalValues.set(key, originalValue);\n      } catch {\n        this.originalValues.set(key, null);\n      }\n    }\n\n    this.pendingOperations.set(key, { action: 'delete' });\n    return true;\n  }\n\n  async commit(): Promise<void> {\n    if (!this.isActive) {\n      throw new StorageTransactionError(this.id, 'commit', new Error('Transaction not active'));\n    }\n\n    try {\n      // Apply all pending operations\n      for (const [key, operation] of this.pendingOperations) {\n        if (operation.action === 'set') {\n          await this.adapter.set(key, operation.value, operation.options);\n        } else if (operation.action === 'delete') {\n          await this.adapter.delete(key);\n        }\n      }\n      \n      this.isActive = false;\n    } catch (error) {\n      await this.rollback();\n      throw new StorageTransactionError(this.id, 'commit', error as Error);\n    }\n  }\n\n  async rollback(): Promise<void> {\n    if (!this.isActive) {\n      return; // Already rolled back\n    }\n\n    try {\n      // Restore original values\n      for (const [key, originalValue] of this.originalValues) {\n        const storageKey = this.adapter.getStorageKey(key);\n        if (originalValue === null) {\n          localStorage.removeItem(storageKey);\n        } else {\n          localStorage.setItem(storageKey, originalValue);\n        }\n      }\n    } catch (error) {\n      console.warn(`Failed to rollback transaction ${this.id}:`, error);\n    } finally {\n      this.isActive = false;\n    }\n  }\n}\n\n/**\n * LocalStorage Storage Adapter\n * Fallback storage implementation for environments without IndexedDB\n */\nexport class LocalStorageAdapter implements StorageAdapter {\n  public readonly name = 'LocalStorage';\n  private keyPrefix: string;\n\n  public readonly capabilities = {\n    supportsTransactions: true, // Simulated transactions\n    supportsIndexing: false,\n    maxKeyLength: 256,\n    maxValueSize: 5 * 1024 * 1024, // 5MB typical localStorage limit\n    supportsCompression: true,\n    supportsEncryption: true,\n    supportsTTL: true,\n  } as const;\n\n  constructor(keyPrefix: string = 'acube_sdk_') {\n    this.keyPrefix = keyPrefix;\n  }\n\n  get isAvailable(): boolean {\n    try {\n      if (typeof Storage === 'undefined' || typeof localStorage === 'undefined') {\n        return false;\n      }\n      \n      // Test localStorage availability\n      const testKey = '__localStorage_test__';\n      localStorage.setItem(testKey, 'test');\n      localStorage.removeItem(testKey);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  isConnected(): boolean {\n    return this.isAvailable;\n  }\n\n  async connect(): Promise<void> {\n    if (!this.isAvailable) {\n      throw new StorageConnectionError('LocalStorage not available');\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    // LocalStorage doesn't require explicit disconnection\n  }\n\n  getStorageKey(key: StorageKey): string {\n    return `${this.keyPrefix}${key}`;\n  }\n\n  createStorageEntry<T extends StorageValue>(\n    key: StorageKey, \n    value: T, \n    options: Required<StorageOptions>\n  ): StorageEntry<T> {\n    const now = Date.now();\n    \n    return {\n      data: value,\n      metadata: {\n        key,\n        createdAt: now,\n        updatedAt: now,\n        ...(options.ttl > 0 && { expiresAt: now + options.ttl }),\n        encrypted: options.encrypt,\n        compressed: options.compress,\n        version: options.version,\n      },\n    };\n  }\n\n  async set<T extends StorageValue>(key: StorageKey, value: T, options?: StorageOptions): Promise<void> {\n    await this.connect();\n    \n    const mergedOptions = { ...DEFAULT_STORAGE_OPTIONS, ...options };\n    const entry = this.createStorageEntry(key, value, mergedOptions);\n    const storageKey = this.getStorageKey(key);\n    \n    let serialized = '';\n    try {\n      serialized = JSON.stringify(entry);\n      \n      // Check size constraints\n      if (serialized.length > this.capabilities.maxValueSize) {\n        throw new StorageCapacityError(key, serialized.length, this.capabilities.maxValueSize);\n      }\n      \n      localStorage.setItem(storageKey, serialized);\n    } catch (error) {\n      if (error instanceof StorageCapacityError) {\n        throw error;\n      }\n      \n      // Handle quota exceeded error\n      if (error instanceof DOMException && (\n        error.code === 22 || // QUOTA_EXCEEDED_ERR\n        error.code === 1014 || // NS_ERROR_DOM_QUOTA_REACHED\n        error.name === 'QuotaExceededError'\n      )) {\n        const size = serialized ? serialized.length : 0;\n        throw new StorageCapacityError(key, size, this.getAvailableSpace());\n      }\n      \n      throw new StorageError(\n        `Failed to set key: ${key}`,\n        'STORAGE_SET_ERROR',\n        'set',\n        key,\n        error as Error\n      );\n    }\n  }\n\n  async get<T extends StorageValue>(key: StorageKey): Promise<StorageEntry<T> | null> {\n    await this.connect();\n    \n    const storageKey = this.getStorageKey(key);\n    \n    try {\n      const serialized = localStorage.getItem(storageKey);\n      if (!serialized) {\n        return null;\n      }\n      \n      const entry: StorageEntry<T> = JSON.parse(serialized);\n      \n      // Check expiration\n      if (entry.metadata.expiresAt && entry.metadata.expiresAt < Date.now()) {\n        // Async cleanup of expired entry\n        this.delete(key).catch(console.warn);\n        return null;\n      }\n      \n      return entry;\n    } catch (error) {\n      throw new StorageError(\n        `Failed to get key: ${key}`,\n        'STORAGE_GET_ERROR',\n        'get',\n        key,\n        error as Error\n      );\n    }\n  }\n\n  async delete(key: StorageKey): Promise<boolean> {\n    await this.connect();\n    \n    const storageKey = this.getStorageKey(key);\n    \n    try {\n      const existed = localStorage.getItem(storageKey) !== null;\n      localStorage.removeItem(storageKey);\n      return existed;\n    } catch (error) {\n      throw new StorageError(\n        `Failed to delete key: ${key}`,\n        'STORAGE_DELETE_ERROR',\n        'delete',\n        key,\n        error as Error\n      );\n    }\n  }\n\n  async exists(key: StorageKey): Promise<boolean> {\n    await this.connect();\n    \n    const storageKey = this.getStorageKey(key);\n    return localStorage.getItem(storageKey) !== null;\n  }\n\n  async clear(namespace?: string): Promise<void> {\n    await this.connect();\n    \n    try {\n      if (namespace) {\n        // Clear only specific namespace\n        const namespacePrefix = `${this.keyPrefix}${namespace}:`;\n        const keysToRemove: string[] = [];\n        \n        for (let i = 0; i < localStorage.length; i++) {\n          const key = localStorage.key(i);\n          if (key && key.startsWith(namespacePrefix)) {\n            keysToRemove.push(key);\n          }\n        }\n        \n        for (const key of keysToRemove) {\n          localStorage.removeItem(key);\n        }\n      } else {\n        // Clear all keys with our prefix\n        const keysToRemove: string[] = [];\n        \n        for (let i = 0; i < localStorage.length; i++) {\n          const key = localStorage.key(i);\n          if (key && key.startsWith(this.keyPrefix)) {\n            keysToRemove.push(key);\n          }\n        }\n        \n        for (const key of keysToRemove) {\n          localStorage.removeItem(key);\n        }\n      }\n    } catch (error) {\n      throw new StorageError(\n        `Failed to clear storage${namespace ? ` for namespace: ${namespace}` : ''}`,\n        'STORAGE_CLEAR_ERROR',\n        'clear',\n        undefined,\n        error as Error\n      );\n    }\n  }\n\n  async setMany<T extends StorageValue>(entries: Array<{ key: StorageKey; value: T; options?: StorageOptions }>): Promise<void> {\n    // Execute individually (no atomic batch support in localStorage)\n    for (const entry of entries) {\n      await this.set(entry.key, entry.value, entry.options);\n    }\n  }\n\n  async getMany<T extends StorageValue>(keys: StorageKey[]): Promise<Array<StorageEntry<T> | null>> {\n    const results: Array<StorageEntry<T> | null> = [];\n    \n    for (const key of keys) {\n      results.push(await this.get<T>(key));\n    }\n    \n    return results;\n  }\n\n  async deleteMany(keys: StorageKey[]): Promise<number> {\n    let deletedCount = 0;\n    \n    for (const key of keys) {\n      const deleted = await this.delete(key);\n      if (deleted) deletedCount++;\n    }\n    \n    return deletedCount;\n  }\n\n  async keys(options: QueryOptions = {}): Promise<StorageKey[]> {\n    await this.connect();\n    \n    const keys: StorageKey[] = [];\n    const now = Date.now();\n    \n    for (let i = 0; i < localStorage.length; i++) {\n      const storageKey = localStorage.key(i);\n      if (!storageKey || !storageKey.startsWith(this.keyPrefix)) {\n        continue;\n      }\n      \n      try {\n        const originalKey = storageKey.substring(this.keyPrefix.length) as StorageKey;\n        const entry = await this.get(originalKey);\n        \n        if (entry && this.matchesQuery(entry, options, now)) {\n          keys.push(originalKey);\n        }\n      } catch {\n        // Skip invalid entries\n        continue;\n      }\n    }\n    \n    return this.applySortingAndPaging(keys, options);\n  }\n\n  async values<T extends StorageValue>(options: QueryOptions = {}): Promise<Array<StorageEntry<T>>> {\n    await this.connect();\n    \n    const values: Array<StorageEntry<T>> = [];\n    const now = Date.now();\n    \n    for (let i = 0; i < localStorage.length; i++) {\n      const storageKey = localStorage.key(i);\n      if (!storageKey || !storageKey.startsWith(this.keyPrefix)) {\n        continue;\n      }\n      \n      try {\n        const originalKey = storageKey.substring(this.keyPrefix.length) as StorageKey;\n        const entry = await this.get<T>(originalKey);\n        \n        if (entry && this.matchesQuery(entry, options, now)) {\n          values.push(entry);\n        }\n      } catch {\n        // Skip invalid entries\n        continue;\n      }\n    }\n    \n    return this.applySortingAndPaging(values, options);\n  }\n\n  async entries<T extends StorageValue>(options: QueryOptions = {}): Promise<Array<StorageEntry<T>>> {\n    return this.values<T>(options);\n  }\n\n  async count(options: QueryOptions = {}): Promise<number> {\n    const keys = await this.keys(options);\n    return keys.length;\n  }\n\n  async beginTransaction(): Promise<StorageTransaction> {\n    await this.connect();\n    return new LocalStorageTransactionImpl(this);\n  }\n\n  async cleanup(): Promise<number> {\n    await this.connect();\n    \n    const now = Date.now();\n    let cleanedCount = 0;\n    const keysToRemove: string[] = [];\n    \n    for (let i = 0; i < localStorage.length; i++) {\n      const storageKey = localStorage.key(i);\n      if (!storageKey || !storageKey.startsWith(this.keyPrefix)) {\n        continue;\n      }\n      \n      try {\n        const serialized = localStorage.getItem(storageKey);\n        if (serialized) {\n          const entry: StorageEntry<any> = JSON.parse(serialized);\n          \n          // Check if entry is expired\n          if (entry.metadata.expiresAt && entry.metadata.expiresAt < now) {\n            keysToRemove.push(storageKey);\n            cleanedCount++;\n          }\n        }\n      } catch {\n        // Remove corrupted entries\n        keysToRemove.push(storageKey);\n        cleanedCount++;\n      }\n    }\n    \n    // Remove expired entries\n    for (const key of keysToRemove) {\n      localStorage.removeItem(key);\n    }\n    \n    return cleanedCount;\n  }\n\n  async optimize(): Promise<void> {\n    // Run cleanup to remove expired entries\n    await this.cleanup();\n  }\n\n  async getStats(): Promise<StorageStats> {\n    await this.connect();\n    \n    const stats: InternalStorageStats = {\n      totalKeys: 0,\n      totalSize: 0,\n      namespaces: [],\n      oldestEntry: Date.now(),\n      newestEntry: 0,\n      expiredEntries: 0,\n      encryptedEntries: 0,\n      compressedEntries: 0,\n    };\n    \n    const namespaceSet = new Set<string>();\n    const now = Date.now();\n    \n    for (let i = 0; i < localStorage.length; i++) {\n      const storageKey = localStorage.key(i);\n      if (!storageKey || !storageKey.startsWith(this.keyPrefix)) {\n        continue;\n      }\n      \n      try {\n        const serialized = localStorage.getItem(storageKey);\n        if (serialized) {\n          const entry: StorageEntry<any> = JSON.parse(serialized);\n          \n          stats.totalKeys++;\n          stats.totalSize += serialized.length;\n          \n          // Extract namespace from key\n          const originalKey = storageKey.substring(this.keyPrefix.length);\n          const namespacePart = originalKey.split(':')[0];\n          if (namespacePart) {\n            namespaceSet.add(namespacePart);\n          }\n          \n          if (entry.metadata.createdAt < stats.oldestEntry) {\n            stats.oldestEntry = entry.metadata.createdAt;\n          }\n          if (entry.metadata.createdAt > stats.newestEntry) {\n            stats.newestEntry = entry.metadata.createdAt;\n          }\n          \n          if (entry.metadata.expiresAt && entry.metadata.expiresAt < now) {\n            stats.expiredEntries++;\n          }\n          \n          if (entry.metadata.encrypted) {\n            stats.encryptedEntries++;\n          }\n          \n          if (entry.metadata.compressed) {\n            stats.compressedEntries++;\n          }\n        }\n      } catch {\n        // Skip invalid entries\n        continue;\n      }\n    }\n    \n    stats.namespaces = Array.from(namespaceSet);\n    return stats;\n  }\n\n  private matchesQuery(entry: StorageEntry<any>, options: QueryOptions, now: number): boolean {\n    // Check expiration\n    if (!options.includeExpired && entry.metadata.expiresAt && entry.metadata.expiresAt < now) {\n      return false;\n    }\n    \n    // Extract namespace from key\n    const key = entry.metadata.key;\n    const namespacePart = key.split(':')[0];\n    \n    // Check namespace\n    if (options.namespace && namespacePart !== options.namespace) {\n      return false;\n    }\n    \n    // Check prefix\n    if (options.prefix && !key.startsWith(options.prefix)) {\n      return false;\n    }\n    \n    return true;\n  }\n\n  private applySortingAndPaging<T>(items: T[], options: QueryOptions): T[] {\n    let result = [...items];\n    \n    // Apply sorting (simplified for this implementation)\n    if (options.sortBy) {\n      result.sort((a: any, b: any) => {\n        const sortBy = options.sortBy;\n        if (!sortBy) return 0;\n        \n        const aVal = sortBy === 'key' ? a.key || a : a.metadata?.[sortBy] || 0;\n        const bVal = sortBy === 'key' ? b.key || b : b.metadata?.[sortBy] || 0;\n        \n        const comparison = aVal < bVal ? -1 : aVal > bVal ? 1 : 0;\n        return options.sortOrder === 'desc' ? -comparison : comparison;\n      });\n    }\n    \n    // Apply paging\n    const offset = options.offset || 0;\n    const limit = options.limit;\n    \n    if (limit) {\n      result = result.slice(offset, offset + limit);\n    } else if (offset) {\n      result = result.slice(offset);\n    }\n    \n    return result;\n  }\n\n  private getAvailableSpace(): number {\n    try {\n      // Try to estimate available space\n      let testSize = 1024 * 1024; // Start with 1MB\n      const testKey = '__space_test__';\n      \n      while (testSize > 1024) {\n        try {\n          const testData = 'x'.repeat(testSize);\n          localStorage.setItem(testKey, testData);\n          localStorage.removeItem(testKey);\n          return testSize;\n        } catch {\n          testSize = Math.floor(testSize / 2);\n        }\n      }\n      \n      return testSize;\n    } catch {\n      return this.capabilities.maxValueSize;\n    }\n  }\n}","/**\n * Advanced Encryption Layer for A-Cube SDK\n * Provides comprehensive encryption, decryption, and key management\n */\n\n// Web Crypto API types are declared in signatures.ts\n\nexport interface EncryptionConfig {\n  algorithm: 'AES-GCM' | 'AES-CBC' | 'RSA-OAEP';\n  keyLength: 128 | 192 | 256 | 2048 | 4096;\n  keyDerivation: {\n    algorithm: 'PBKDF2' | 'scrypt' | 'Argon2';\n    iterations: number;\n    salt: Uint8Array;\n  };\n  compression: boolean;\n  metadata: {\n    version: string;\n    timestamp: number;\n    keyId: string;\n  };\n}\n\nexport interface EncryptedData {\n  data: Uint8Array;\n  iv: Uint8Array;\n  authTag?: Uint8Array;\n  metadata: EncryptionConfig['metadata'];\n  algorithm: string;\n}\n\nexport interface CryptoKeyPair {\n  publicKey: CryptoKey;\n  privateKey: CryptoKey;\n  keyId: string;\n  algorithm: string;\n  extractable: boolean;\n  usages: KeyUsage[];\n}\n\nexport class AdvancedEncryption {\n  private keys = new Map<string, CryptoKey>();\n  private keyPairs = new Map<string, CryptoKeyPair>();\n  private config: EncryptionConfig;\n  private initialized = false;\n\n  constructor(config?: Partial<EncryptionConfig>) {\n    this.config = {\n      algorithm: 'AES-GCM',\n      keyLength: 256,\n      keyDerivation: {\n        algorithm: 'PBKDF2',\n        iterations: 100000,\n        salt: crypto.getRandomValues(new Uint8Array(16)),\n      },\n      compression: true,\n      metadata: {\n        version: '1.0.0',\n        timestamp: Date.now(),\n        keyId: this.generateKeyId(),\n      },\n      ...config,\n    };\n  }\n\n  /**\n   * Generate a new symmetric encryption key\n   */\n  async generateSymmetricKey(keyId?: string): Promise<string> {\n    const id = keyId || this.generateKeyId();\n    \n    const key = await crypto.subtle.generateKey(\n      {\n        name: this.config.algorithm,\n        length: this.config.keyLength,\n      },\n      true, // extractable\n      ['encrypt', 'decrypt']\n    );\n\n    this.keys.set(id, key);\n    return id;\n  }\n\n  /**\n   * Generate a new asymmetric key pair\n   */\n  async generateKeyPair(algorithm: 'RSA-OAEP' | 'ECDSA' = 'RSA-OAEP', keyId?: string): Promise<string> {\n    const id = keyId || this.generateKeyId();\n    \n    let keyGenParams: RsaHashedKeyGenParams | EcKeyGenParams;\n    let usages: KeyUsage[];\n\n    if (algorithm === 'RSA-OAEP') {\n      keyGenParams = {\n        name: 'RSA-OAEP',\n        modulusLength: this.config.keyLength as 2048 | 4096,\n        publicExponent: new Uint8Array([1, 0, 1]),\n        hash: 'SHA-256',\n      };\n      usages = ['encrypt', 'decrypt'];\n    } else {\n      keyGenParams = {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n      };\n      usages = ['sign', 'verify'];\n    }\n\n    const keyPair = await crypto.subtle.generateKey(\n      keyGenParams,\n      true, // extractable\n      usages\n    );\n\n    const cryptoKeyPair: CryptoKeyPair = {\n      publicKey: keyPair.publicKey,\n      privateKey: keyPair.privateKey,\n      keyId: id,\n      algorithm,\n      extractable: true,\n      usages,\n    };\n\n    this.keyPairs.set(id, cryptoKeyPair);\n    return id;\n  }\n\n  /**\n   * Derive key from password using PBKDF2\n   */\n  async deriveKeyFromPassword(password: string, salt?: Uint8Array): Promise<string> {\n    const keyId = this.generateKeyId();\n    const usedSalt = salt || crypto.getRandomValues(new Uint8Array(16));\n    \n    const encoder = new TextEncoder();\n    const passwordBuffer = encoder.encode(password);\n\n    // Import password as key material\n    const keyMaterial = await crypto.subtle.importKey(\n      'raw',\n      passwordBuffer,\n      { name: 'PBKDF2' },\n      false,\n      ['deriveKey']\n    );\n\n    // Derive the actual encryption key\n    const derivedKey = await crypto.subtle.deriveKey(\n      {\n        name: 'PBKDF2',\n        salt: usedSalt,\n        iterations: this.config.keyDerivation.iterations,\n        hash: 'SHA-256',\n      },\n      keyMaterial,\n      {\n        name: this.config.algorithm,\n        length: this.config.keyLength,\n      },\n      true,\n      ['encrypt', 'decrypt']\n    );\n\n    this.keys.set(keyId, derivedKey);\n    \n    // Update salt in config for later use\n    this.config.keyDerivation.salt = usedSalt;\n    \n    return keyId;\n  }\n\n  /**\n   * Encrypt data with symmetric key\n   */\n  async encryptSymmetric(data: string | Uint8Array, keyId: string): Promise<EncryptedData> {\n    const key = this.keys.get(keyId);\n    if (!key) {\n      throw new Error(`Encryption key not found: ${keyId}`);\n    }\n\n    // Convert string to Uint8Array if needed\n    let dataBuffer: Uint8Array;\n    if (typeof data === 'string') {\n      dataBuffer = new TextEncoder().encode(data);\n    } else {\n      dataBuffer = data;\n    }\n\n    // Optionally compress data\n    if (this.config.compression) {\n      dataBuffer = await this.compressData(dataBuffer);\n    }\n\n    // Generate random IV\n    const iv = crypto.getRandomValues(new Uint8Array(12)); // 96 bits for GCM\n\n    // Encrypt the data\n    const encryptedBuffer = await crypto.subtle.encrypt(\n      {\n        name: this.config.algorithm,\n        iv: iv,\n      },\n      key,\n      dataBuffer\n    );\n\n    const encryptedArray = new Uint8Array(encryptedBuffer);\n    \n    // For GCM, the auth tag is included in the encrypted data\n    const authTag = this.config.algorithm === 'AES-GCM' \n      ? encryptedArray.slice(-16) // Last 16 bytes\n      : undefined;\n    \n    const ciphertext = this.config.algorithm === 'AES-GCM'\n      ? encryptedArray.slice(0, -16) // All but last 16 bytes\n      : encryptedArray;\n\n    return {\n      data: ciphertext,\n      iv,\n      metadata: {\n        ...this.config.metadata,\n        keyId,\n      },\n      algorithm: this.config.algorithm,\n      ...(authTag ? { authTag } : {}),\n    };\n  }\n\n  /**\n   * Decrypt data with symmetric key\n   */\n  async decryptSymmetric(encryptedData: EncryptedData): Promise<Uint8Array> {\n    const key = this.keys.get(encryptedData.metadata.keyId);\n    if (!key) {\n      throw new Error(`Decryption key not found: ${encryptedData.metadata.keyId}`);\n    }\n\n    // Reconstruct full encrypted buffer for GCM\n    let fullEncryptedBuffer: Uint8Array;\n    if (encryptedData.algorithm === 'AES-GCM' && encryptedData.authTag) {\n      fullEncryptedBuffer = new Uint8Array(encryptedData.data.length + encryptedData.authTag.length);\n      fullEncryptedBuffer.set(encryptedData.data);\n      fullEncryptedBuffer.set(encryptedData.authTag, encryptedData.data.length);\n    } else {\n      fullEncryptedBuffer = encryptedData.data;\n    }\n\n    // Decrypt the data\n    const decryptedBuffer = await crypto.subtle.decrypt(\n      {\n        name: encryptedData.algorithm,\n        iv: encryptedData.iv,\n      },\n      key,\n      fullEncryptedBuffer\n    );\n\n    let result = new Uint8Array(decryptedBuffer);\n\n    // Decompress if compression was used\n    if (this.config.compression) {\n      result = new Uint8Array(await this.decompressData(result));\n    }\n\n    return result;\n  }\n\n  /**\n   * Encrypt data with asymmetric key (RSA-OAEP)\n   */\n  async encryptAsymmetric(data: string | Uint8Array, keyId: string): Promise<EncryptedData> {\n    const keyPair = this.keyPairs.get(keyId);\n    if (!keyPair || keyPair.algorithm !== 'RSA-OAEP') {\n      throw new Error(`RSA encryption key not found: ${keyId}`);\n    }\n\n    // Convert string to Uint8Array if needed\n    let dataBuffer: Uint8Array;\n    if (typeof data === 'string') {\n      dataBuffer = new TextEncoder().encode(data);\n    } else {\n      dataBuffer = data;\n    }\n\n    // RSA-OAEP has size limitations, so we might need to chunk large data\n    const maxChunkSize = Math.floor((this.config.keyLength as number) / 8) - 42; // OAEP padding overhead\n    \n    if (dataBuffer.length > maxChunkSize) {\n      throw new Error(`Data too large for RSA encryption. Max size: ${maxChunkSize} bytes`);\n    }\n\n    // Encrypt with public key\n    const encryptedBuffer = await crypto.subtle.encrypt(\n      {\n        name: 'RSA-OAEP',\n      },\n      keyPair.publicKey,\n      dataBuffer\n    );\n\n    return {\n      data: new Uint8Array(encryptedBuffer),\n      iv: new Uint8Array(0), // Not used in RSA\n      metadata: {\n        ...this.config.metadata,\n        keyId,\n      },\n      algorithm: 'RSA-OAEP',\n    };\n  }\n\n  /**\n   * Decrypt data with asymmetric key (RSA-OAEP)\n   */\n  async decryptAsymmetric(encryptedData: EncryptedData): Promise<Uint8Array> {\n    const keyPair = this.keyPairs.get(encryptedData.metadata.keyId);\n    if (!keyPair || keyPair.algorithm !== 'RSA-OAEP') {\n      throw new Error(`RSA decryption key not found: ${encryptedData.metadata.keyId}`);\n    }\n\n    // Decrypt with private key\n    const decryptedBuffer = await crypto.subtle.decrypt(\n      {\n        name: 'RSA-OAEP',\n      },\n      keyPair.privateKey,\n      encryptedData.data\n    );\n\n    return new Uint8Array(decryptedBuffer);\n  }\n\n  /**\n   * Export key for storage or transmission\n   */\n  async exportKey(keyId: string, format: 'raw' | 'pkcs8' | 'spki' | 'jwk' = 'jwk'): Promise<JsonWebKey | ArrayBuffer> {\n    const symmetricKey = this.keys.get(keyId);\n    if (symmetricKey) {\n      if (format === 'jwk') {\n        return await crypto.subtle.exportKey('jwk', symmetricKey) as JsonWebKey;\n      } else {\n        return await crypto.subtle.exportKey(format as 'raw', symmetricKey) as ArrayBuffer;\n      }\n    }\n\n    const keyPair = this.keyPairs.get(keyId);\n    if (keyPair) {\n      // Export public key by default, private key requires special handling\n      if (format === 'jwk') {\n        return await crypto.subtle.exportKey('jwk', keyPair.publicKey) as JsonWebKey;\n      } else {\n        return await crypto.subtle.exportKey(format as 'spki', keyPair.publicKey) as ArrayBuffer;\n      }\n    }\n\n    throw new Error(`Key not found: ${keyId}`);\n  }\n\n  /**\n   * Import key from external source\n   */\n  async importKey(\n    keyData: JsonWebKey | ArrayBuffer,\n    algorithm: string,\n    keyId?: string,\n    usages: KeyUsage[] = ['encrypt', 'decrypt']\n  ): Promise<string> {\n    const id = keyId || this.generateKeyId();\n\n    let algorithmParams: any;\n    let format: 'raw' | 'pkcs8' | 'spki' | 'jwk';\n\n    if (algorithm === 'AES-GCM') {\n      algorithmParams = { name: 'AES-GCM' };\n      format = keyData instanceof ArrayBuffer ? 'raw' : 'jwk';\n    } else if (algorithm === 'RSA-OAEP') {\n      algorithmParams = {\n        name: 'RSA-OAEP',\n        hash: 'SHA-256',\n      };\n      format = keyData instanceof ArrayBuffer ? 'spki' : 'jwk';\n    } else {\n      throw new Error(`Unsupported algorithm: ${algorithm}`);\n    }\n\n    const importedKey = await (format === 'jwk'\n      ? crypto.subtle.importKey('jwk', keyData as JsonWebKey, algorithmParams, true, usages)\n      : crypto.subtle.importKey(format as 'raw' | 'spki', keyData as ArrayBuffer, algorithmParams, true, usages));\n\n    if (algorithm === 'AES-GCM') {\n      this.keys.set(id, importedKey);\n    } else {\n      // For asymmetric keys, we need both public and private keys\n      // This is a simplified version - in practice, you'd handle key pairs properly\n      throw new Error('Asymmetric key import not fully implemented');\n    }\n\n    return id;\n  }\n\n  /**\n   * Rotate encryption keys\n   */\n  async rotateKey(oldKeyId: string): Promise<string> {\n    const oldKey = this.keys.get(oldKeyId);\n    const oldKeyPair = this.keyPairs.get(oldKeyId);\n\n    if (!oldKey && !oldKeyPair) {\n      throw new Error(`Key not found for rotation: ${oldKeyId}`);\n    }\n\n    // Generate new key\n    let newKeyId: string;\n    if (oldKey) {\n      newKeyId = await this.generateSymmetricKey();\n    } else {\n      const algorithm = oldKeyPair!.algorithm as 'RSA-OAEP' | 'ECDSA';\n      newKeyId = await this.generateKeyPair(algorithm);\n    }\n\n    // Keep old key for a transition period (implementation detail)\n    // In practice, you'd have a more sophisticated key rotation strategy\n\n    return newKeyId;\n  }\n\n  /**\n   * Get key information\n   */\n  getKeyInfo(keyId: string): { algorithm: string; usages: string[]; extractable: boolean } | null {\n    const symmetricKey = this.keys.get(keyId);\n    if (symmetricKey) {\n      return {\n        algorithm: symmetricKey.algorithm.name,\n        usages: Array.from(symmetricKey.usages),\n        extractable: symmetricKey.extractable,\n      };\n    }\n\n    const keyPair = this.keyPairs.get(keyId);\n    if (keyPair) {\n      return {\n        algorithm: keyPair.algorithm,\n        usages: keyPair.usages,\n        extractable: keyPair.extractable,\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * List all available keys\n   */\n  listKeys(): Array<{ keyId: string; type: 'symmetric' | 'asymmetric'; algorithm: string }> {\n    const keys: Array<{ keyId: string; type: 'symmetric' | 'asymmetric'; algorithm: string }> = [];\n\n    for (const [keyId, key] of this.keys.entries()) {\n      keys.push({\n        keyId,\n        type: 'symmetric',\n        algorithm: key.algorithm.name,\n      });\n    }\n\n    for (const [keyId, keyPair] of this.keyPairs.entries()) {\n      keys.push({\n        keyId,\n        type: 'asymmetric',\n        algorithm: keyPair.algorithm,\n      });\n    }\n\n    return keys;\n  }\n\n  /**\n   * Clear all keys from memory\n   */\n  clearKeys(): void {\n    this.keys.clear();\n    this.keyPairs.clear();\n  }\n\n  /**\n   * Utility: Convert Uint8Array to base64\n   */\n  static arrayBufferToBase64(buffer: Uint8Array): string {\n    const binary = String.fromCharCode.apply(null, Array.from(buffer));\n    return btoa(binary);\n  }\n\n  /**\n   * Utility: Convert base64 to Uint8Array\n   */\n  static base64ToArrayBuffer(base64: string): Uint8Array {\n    const binary = atob(base64);\n    const buffer = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n      buffer[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n  }\n\n  /**\n   * Utility: Convert encrypted data to JSON\n   */\n  static encryptedDataToJSON(encryptedData: EncryptedData): string {\n    return JSON.stringify({\n      data: this.arrayBufferToBase64(encryptedData.data),\n      iv: this.arrayBufferToBase64(encryptedData.iv),\n      authTag: encryptedData.authTag ? this.arrayBufferToBase64(encryptedData.authTag) : undefined,\n      metadata: encryptedData.metadata,\n      algorithm: encryptedData.algorithm,\n    });\n  }\n\n  /**\n   * Utility: Convert JSON to encrypted data\n   */\n  static encryptedDataFromJSON(json: string): EncryptedData {\n    const obj = JSON.parse(json);\n    return {\n      data: this.base64ToArrayBuffer(obj.data),\n      iv: this.base64ToArrayBuffer(obj.iv),\n      metadata: obj.metadata,\n      algorithm: obj.algorithm,\n      ...(obj.authTag ? { authTag: this.base64ToArrayBuffer(obj.authTag) } : {}),\n    };\n  }\n\n  private generateKeyId(): string {\n    return `key_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private async compressData(data: Uint8Array): Promise<Uint8Array> {\n    // Simple compression using CompressionStream if available\n    if (typeof CompressionStream !== 'undefined') {\n      const stream = new CompressionStream('gzip');\n      const writer = stream.writable.getWriter();\n      const reader = stream.readable.getReader();\n\n      writer.write(data);\n      writer.close();\n\n      const chunks: Uint8Array[] = [];\n      let result;\n      while (!(result = await reader.read()).done) {\n        chunks.push(result.value);\n      }\n\n      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n      const compressed = new Uint8Array(totalLength);\n      let offset = 0;\n      for (const chunk of chunks) {\n        compressed.set(chunk, offset);\n        offset += chunk.length;\n      }\n\n      return compressed;\n    }\n\n    // Fallback: return original data\n    return data;\n  }\n\n  private async decompressData(data: Uint8Array): Promise<Uint8Array> {\n    // Simple decompression using DecompressionStream if available\n    if (typeof DecompressionStream !== 'undefined') {\n      const stream = new DecompressionStream('gzip');\n      const writer = stream.writable.getWriter();\n      const reader = stream.readable.getReader();\n\n      writer.write(data);\n      writer.close();\n\n      const chunks: Uint8Array[] = [];\n      let result;\n      while (!(result = await reader.read()).done) {\n        chunks.push(result.value);\n      }\n\n      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n      const decompressed = new Uint8Array(totalLength);\n      let offset = 0;\n      for (const chunk of chunks) {\n        decompressed.set(chunk, offset);\n        offset += chunk.length;\n      }\n\n      return decompressed;\n    }\n\n    // Fallback: return original data\n    return data;\n  }\n\n  /**\n   * Initialize the encryption system\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n    \n    // Generate a default key for certificate encryption\n    await this.generateSymmetricKey('default');\n    this.initialized = true;\n  }\n\n  /**\n   * Simple encrypt method (uses symmetric encryption)\n   */\n  async encrypt(data: string | Uint8Array, keyId: string = 'default'): Promise<EncryptedData> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n    return this.encryptSymmetric(data, keyId);\n  }\n\n  /**\n   * Simple decrypt method (uses symmetric decryption)\n   */\n  async decrypt(encryptedData: EncryptedData): Promise<Uint8Array> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n    return this.decryptSymmetric(encryptedData);\n  }\n}","/**\n * Storage Encryption Service for A-Cube SDK\n * Provides seamless encryption/decryption integration with storage adapters\n */\n\nimport { AdvancedEncryption } from '../security/encryption';\nimport { \n  StorageValue, \n  StorageEntry, \n  // StorageError, \n  StorageEncryptionError,\n  StorageKey \n} from './unified-storage';\n\n// Encryption configuration for storage\nexport interface StorageEncryptionConfig {\n  readonly enabled: boolean;\n  readonly algorithm: 'AES-GCM' | 'AES-CBC';\n  readonly keyLength: 128 | 192 | 256;\n  readonly keyDerivation: {\n    readonly algorithm: 'PBKDF2' | 'scrypt';\n    readonly iterations: number;\n  };\n  readonly compression: boolean;\n  readonly keyRotationInterval?: number; // in milliseconds\n  readonly masterPassword?: string;\n  readonly keyId?: string;\n}\n\n// Encryption metadata attached to storage entries\nexport interface EncryptionMetadata {\n  readonly encrypted: boolean;\n  readonly algorithm?: string;\n  readonly keyId?: string;\n  readonly version: string;\n  readonly checksum?: string;\n}\n\n// Key management interface\nexport interface EncryptionKeyManager {\n  getCurrentKeyId(): Promise<string>;\n  deriveKey(password: string, keyId?: string): Promise<string>;\n  rotateKey(): Promise<string>;\n  getKeyInfo(keyId: string): Promise<{ algorithm: string; created: number; expires?: number } | null>;\n  cleanup(): Promise<number>; // Returns number of old keys removed\n}\n\n/**\n * Default key manager implementation\n */\nclass DefaultKeyManager implements EncryptionKeyManager {\n  private currentKeyId: string | null = null;\n  private keyCache = new Map<string, { keyId: string; created: number; expires?: number }>();\n\n  constructor(\n    private encryption: AdvancedEncryption,\n    private config: StorageEncryptionConfig\n  ) {}\n\n  async getCurrentKeyId(): Promise<string> {\n    if (this.currentKeyId) {\n      // Check if key needs rotation\n      const keyInfo = this.keyCache.get(this.currentKeyId);\n      if (keyInfo && this.config.keyRotationInterval) {\n        const age = Date.now() - keyInfo.created;\n        if (age > this.config.keyRotationInterval) {\n          this.currentKeyId = await this.rotateKey();\n        }\n      }\n      return this.currentKeyId;\n    }\n\n    // Generate or derive initial key\n    if (this.config.masterPassword) {\n      this.currentKeyId = await this.deriveKey(this.config.masterPassword, this.config.keyId);\n    } else {\n      this.currentKeyId = await this.encryption.generateSymmetricKey(this.config.keyId);\n    }\n\n    // Cache key info\n    const keyInfo: any = {\n      keyId: this.currentKeyId,\n      created: Date.now(),\n    };\n    if (this.config.keyRotationInterval) {\n      keyInfo.expires = Date.now() + this.config.keyRotationInterval;\n    }\n    this.keyCache.set(this.currentKeyId, keyInfo);\n\n    return this.currentKeyId;\n  }\n\n  async deriveKey(password: string, keyId?: string): Promise<string> {\n    const derivedKeyId = await this.encryption.deriveKeyFromPassword(password);\n    \n    const finalKeyId = keyId || derivedKeyId;\n    const keyInfo2: any = {\n      keyId: finalKeyId,\n      created: Date.now(),\n    };\n    if (this.config.keyRotationInterval) {\n      keyInfo2.expires = Date.now() + this.config.keyRotationInterval;\n    }\n    this.keyCache.set(finalKeyId, keyInfo2);\n\n    return finalKeyId;\n  }\n\n  async rotateKey(): Promise<string> {\n    const oldKeyId = this.currentKeyId;\n    \n    // Generate new key\n    const newKeyId = await this.encryption.generateSymmetricKey();\n    \n    // Update current key\n    this.currentKeyId = newKeyId;\n    \n    // Cache new key info\n    const keyInfo3: any = {\n      keyId: newKeyId,\n      created: Date.now(),\n    };\n    if (this.config.keyRotationInterval) {\n      keyInfo3.expires = Date.now() + this.config.keyRotationInterval;\n    }\n    this.keyCache.set(newKeyId, keyInfo3);\n\n    // Mark old key for eventual cleanup (but keep it for decryption)\n    if (oldKeyId) {\n      const oldKeyInfo = this.keyCache.get(oldKeyId);\n      if (oldKeyInfo) {\n        this.keyCache.set(oldKeyId, {\n          ...oldKeyInfo,\n          expires: Date.now() + (24 * 60 * 60 * 1000), // Keep old key for 24 hours\n        });\n      }\n    }\n\n    return newKeyId;\n  }\n\n  async getKeyInfo(keyId: string): Promise<{ algorithm: string; created: number; expires?: number } | null> {\n    const cached = this.keyCache.get(keyId);\n    if (cached) {\n      const info = this.encryption.getKeyInfo(keyId);\n      if (info) {\n        const result: any = {\n          algorithm: info.algorithm,\n          created: cached.created,\n        };\n        if (cached.expires !== undefined) {\n          result.expires = cached.expires;\n        }\n        return result;\n      }\n    }\n    return null;\n  }\n\n  async cleanup(): Promise<number> {\n    const now = Date.now();\n    let cleanedCount = 0;\n    \n    const expiredKeys = Array.from(this.keyCache.entries())\n      .filter(([_, info]) => info.expires && info.expires < now)\n      .map(([keyId]) => keyId);\n\n    for (const keyId of expiredKeys) {\n      this.keyCache.delete(keyId);\n      cleanedCount++;\n    }\n\n    return cleanedCount;\n  }\n}\n\n/**\n * Storage Encryption Service\n * Handles encryption/decryption for storage adapters\n */\nexport class StorageEncryptionService {\n  private encryption: AdvancedEncryption;\n  private keyManager: EncryptionKeyManager;\n  private config: StorageEncryptionConfig;\n\n  constructor(config: Partial<StorageEncryptionConfig> = {}) {\n    this.config = {\n      enabled: true,\n      algorithm: 'AES-GCM',\n      keyLength: 256,\n      keyDerivation: {\n        algorithm: 'PBKDF2',\n        iterations: 100000,\n      },\n      compression: true,\n      keyRotationInterval: 7 * 24 * 60 * 60 * 1000, // 7 days\n      ...config,\n    };\n\n    this.encryption = new AdvancedEncryption({\n      algorithm: this.config.algorithm,\n      keyLength: this.config.keyLength,\n      keyDerivation: {\n        algorithm: this.config.keyDerivation.algorithm,\n        iterations: this.config.keyDerivation.iterations,\n        salt: crypto.getRandomValues(new Uint8Array(16)),\n      },\n      compression: this.config.compression,\n      metadata: {\n        version: '2.0.0',\n        timestamp: Date.now(),\n        keyId: this.config.keyId || this.generateKeyId(),\n      },\n    });\n\n    this.keyManager = new DefaultKeyManager(this.encryption, this.config);\n  }\n\n  /**\n   * Encrypt storage value if encryption is enabled\n   */\n  async encryptValue<T extends StorageValue>(\n    value: T, \n    key: StorageKey, \n    forceEncrypt: boolean = false\n  ): Promise<{ data: T | string; metadata: EncryptionMetadata }> {\n    if (!this.config.enabled && !forceEncrypt) {\n      return {\n        data: value,\n        metadata: {\n          encrypted: false,\n          version: '2.0.0',\n        },\n      };\n    }\n\n    try {\n      // Serialize value for encryption\n      const serialized = JSON.stringify(value);\n      const keyId = await this.keyManager.getCurrentKeyId();\n      \n      // Encrypt the serialized data\n      const encryptedData = await this.encryption.encryptSymmetric(serialized, keyId);\n      \n      // Convert to base64 for storage\n      const encryptedString = AdvancedEncryption.encryptedDataToJSON(encryptedData);\n      \n      // Generate checksum for integrity verification\n      const checksum = await this.generateChecksum(serialized);\n\n      return {\n        data: encryptedString,\n        metadata: {\n          encrypted: true,\n          algorithm: this.config.algorithm,\n          keyId,\n          version: '2.0.0',\n          checksum,\n        },\n      };\n    } catch (error) {\n      throw new StorageEncryptionError(key, 'encrypt', error as Error);\n    }\n  }\n\n  /**\n   * Decrypt storage value if it was encrypted\n   */\n  async decryptValue<T extends StorageValue>(\n    data: T | string, \n    metadata: EncryptionMetadata, \n    key: StorageKey\n  ): Promise<T> {\n    if (!metadata.encrypted) {\n      return data as T;\n    }\n\n    try {\n      // Parse encrypted data from JSON\n      const encryptedData = AdvancedEncryption.encryptedDataFromJSON(data as string);\n      \n      // Decrypt the data\n      const decryptedBuffer = await this.encryption.decryptSymmetric(encryptedData);\n      const decryptedString = new TextDecoder().decode(decryptedBuffer);\n      \n      // Verify checksum if available\n      if (metadata.checksum) {\n        const actualChecksum = await this.generateChecksum(decryptedString);\n        if (actualChecksum !== metadata.checksum) {\n          throw new Error('Checksum verification failed - data may be corrupted');\n        }\n      }\n      \n      // Deserialize the decrypted data\n      return JSON.parse(decryptedString) as T;\n    } catch (error) {\n      throw new StorageEncryptionError(key, 'decrypt', error as Error);\n    }\n  }\n\n  /**\n   * Process storage entry for encryption\n   */\n  async encryptStorageEntry<T extends StorageValue>(\n    entry: StorageEntry<T>, \n    forceEncrypt: boolean = false\n  ): Promise<StorageEntry<T | string>> {\n    const { data, metadata: encryptionMetadata } = await this.encryptValue(\n      entry.data, \n      entry.metadata.key, \n      forceEncrypt\n    );\n\n    const resultMetadata: any = {\n      ...entry.metadata,\n      encrypted: encryptionMetadata.encrypted,\n    };\n    \n    if (encryptionMetadata.checksum !== undefined) {\n      resultMetadata.checksum = encryptionMetadata.checksum;\n    }\n    \n    return {\n      data,\n      metadata: resultMetadata,\n    };\n  }\n\n  /**\n   * Process storage entry for decryption\n   */\n  async decryptStorageEntry<T extends StorageValue>(\n    entry: StorageEntry<T | string>\n  ): Promise<StorageEntry<T>> {\n    const encryptionMetadata: any = {\n      encrypted: entry.metadata.encrypted,\n      algorithm: this.config.algorithm,\n      version: entry.metadata.version,\n    };\n    \n    if (this.config.keyId) {\n      encryptionMetadata.keyId = this.config.keyId;\n    }\n    \n    if (entry.metadata.checksum !== undefined) {\n      encryptionMetadata.checksum = entry.metadata.checksum;\n    }\n\n    const decryptedData = await this.decryptValue(\n      entry.data, \n      encryptionMetadata, \n      entry.metadata.key\n    );\n\n    return {\n      data: decryptedData,\n      metadata: {\n        ...entry.metadata,\n        encrypted: false, // Mark as decrypted for consumers\n      },\n    };\n  }\n\n  /**\n   * Check if encryption is enabled\n   */\n  isEncryptionEnabled(): boolean {\n    return this.config.enabled;\n  }\n\n  /**\n   * Get current encryption configuration\n   */\n  getConfig(): Readonly<StorageEncryptionConfig> {\n    return { ...this.config };\n  }\n\n  /**\n   * Update encryption configuration\n   */\n  async updateConfig(newConfig: Partial<StorageEncryptionConfig>): Promise<void> {\n    const oldConfig = this.config;\n    this.config = { ...this.config, ...newConfig };\n\n    // If key configuration changed, regenerate encryption instance\n    if (newConfig.algorithm !== oldConfig.algorithm ||\n        newConfig.keyLength !== oldConfig.keyLength ||\n        newConfig.keyDerivation !== oldConfig.keyDerivation) {\n      \n      this.encryption = new AdvancedEncryption({\n        algorithm: this.config.algorithm,\n        keyLength: this.config.keyLength,\n        keyDerivation: {\n          algorithm: this.config.keyDerivation.algorithm,\n          iterations: this.config.keyDerivation.iterations,\n          salt: crypto.getRandomValues(new Uint8Array(16)),\n        },\n        compression: this.config.compression,\n        metadata: {\n          version: '2.0.0',\n          timestamp: Date.now(),\n          keyId: this.config.keyId || this.generateKeyId(),\n        },\n      });\n\n      // Force key rotation with new configuration\n      await this.keyManager.rotateKey();\n    }\n  }\n\n  /**\n   * Rotate encryption keys\n   */\n  async rotateKeys(): Promise<string> {\n    return this.keyManager.rotateKey();\n  }\n\n  /**\n   * Get encryption statistics\n   */\n  async getEncryptionStats(): Promise<{\n    enabled: boolean;\n    algorithm: string;\n    keyLength: number;\n    currentKeyId: string;\n    keyAge: number;\n    nextRotation?: number;\n  }> {\n    const currentKeyId = await this.keyManager.getCurrentKeyId();\n    const keyInfo = await this.keyManager.getKeyInfo(currentKeyId);\n    \n    const result: any = {\n      enabled: this.config.enabled,\n      algorithm: this.config.algorithm,\n      keyLength: this.config.keyLength,\n      currentKeyId,\n      keyAge: keyInfo ? Date.now() - keyInfo.created : 0,\n    };\n    \n    if (keyInfo?.expires !== undefined) {\n      result.nextRotation = keyInfo.expires;\n    }\n    \n    return result;\n  }\n\n  /**\n   * Cleanup expired keys\n   */\n  async cleanup(): Promise<number> {\n    return this.keyManager.cleanup();\n  }\n\n  /**\n   * Test encryption/decryption with sample data\n   */\n  async testEncryption(): Promise<boolean> {\n    try {\n      const testData = { test: 'encryption_test', timestamp: Date.now() };\n      const testKey = 'test:encryption' as StorageKey;\n      \n      // Test encryption\n      const { data: encrypted, metadata } = await this.encryptValue(testData, testKey, true);\n      \n      // Test decryption\n      const decrypted = await this.decryptValue(encrypted, metadata, testKey);\n      \n      // Verify data integrity\n      return JSON.stringify(testData) === JSON.stringify(decrypted);\n    } catch (error) {\n      console.error('Encryption test failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Generate integrity checksum\n   */\n  private async generateChecksum(data: string): Promise<string> {\n    if (typeof crypto !== 'undefined' && crypto.subtle) {\n      const encoder = new TextEncoder();\n      const dataBuffer = encoder.encode(data);\n      const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\n      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n    } else {\n      // Fallback for environments without Web Crypto API\n      return this.simpleHash(data);\n    }\n  }\n\n  /**\n   * Simple hash fallback for environments without crypto.subtle\n   */\n  private simpleHash(data: string): string {\n    let hash = 0;\n    for (let i = 0; i < data.length; i++) {\n      const char = data.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(16);\n  }\n\n  /**\n   * Generate unique key ID\n   */\n  private generateKeyId(): string {\n    return `storage_key_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n}\n\n// Export convenience functions\nexport const createEncryptionService = (config?: Partial<StorageEncryptionConfig>): StorageEncryptionService => {\n  return new StorageEncryptionService(config);\n};\n\nexport const createSecureEncryptionService = (masterPassword: string): StorageEncryptionService => {\n  return new StorageEncryptionService({\n    enabled: true,\n    masterPassword,\n    keyRotationInterval: 7 * 24 * 60 * 60 * 1000, // 7 days\n    compression: true,\n  });\n};\n\nexport const createMinimalEncryptionService = (): StorageEncryptionService => {\n  const config: any = {\n    enabled: true,\n    algorithm: 'AES-GCM',\n    keyLength: 256,\n    compression: false,\n  };\n  // keyRotationInterval omitted for no automatic rotation\n  \n  return new StorageEncryptionService(config);\n};","/**\n * Storage Factory for A-Cube SDK\n * Automatic platform detection and optimal storage adapter selection\n */\n\nimport { EventEmitter } from 'events';\nimport { \n  UnifiedStorage, \n  StorageAdapter, \n  StorageKey, \n  StorageValue, \n  StorageEntry, \n  StorageOptions, \n  QueryOptions, \n  StorageTransaction, \n  StorageStats,\n  StorageError,\n  DEFAULT_STORAGE_OPTIONS,\n  createReceiptKey,\n  createCashierKey,\n  createMerchantKey,\n  createPEMKey,\n  createCashRegisterKey,\n  createCacheKey,\n  createSessionKey,\n  createSecureKey,\n  createConfigKey,\n} from './unified-storage';\nimport { \n  ReceiptId, \n  CashierId, \n  PEMId, \n  MerchantId, \n  CashRegisterId \n} from '../types/branded';\nimport { platformDetector, PlatformType, EnvironmentInfo } from './platform-detector';\nimport { IndexedDBAdapter } from './adapters/indexeddb-adapter';\nimport { LocalStorageAdapter } from './adapters/localstorage-adapter';\nimport { \n  StorageEncryptionService, \n  StorageEncryptionConfig,\n  createEncryptionService,\n} from './encryption-service';\n\n// Factory configuration\nexport interface StorageFactoryConfig {\n  readonly preferredAdapter?: 'indexeddb' | 'localstorage' | 'memory' | 'auto';\n  readonly encryption?: Partial<StorageEncryptionConfig>;\n  readonly keyPrefix?: string;\n  readonly enableCompression?: boolean;\n  readonly enableCaching?: boolean;\n  readonly performanceMode?: 'high' | 'balanced' | 'conservative';\n  readonly debug?: boolean;\n  readonly maxRetries?: number;\n  readonly connectionTimeout?: number;\n}\n\n// Memory-based adapter for fallback scenarios\nclass MemoryStorageAdapter implements StorageAdapter {\n  public readonly name = 'Memory';\n  private store = new Map<string, any>();\n\n  public readonly capabilities = {\n    supportsTransactions: false,\n    supportsIndexing: false,\n    maxKeyLength: Infinity,\n    maxValueSize: Infinity,\n    supportsCompression: false,\n    supportsEncryption: false,\n    supportsTTL: true,\n  } as const;\n\n  get isAvailable(): boolean { return true; }\n  isConnected(): boolean { return true; }\n  async connect(): Promise<void> {}\n  async disconnect(): Promise<void> { this.store.clear(); }\n\n  async set<T extends StorageValue>(key: StorageKey, value: T, options?: StorageOptions): Promise<void> {\n    const mergedOptions = { ...DEFAULT_STORAGE_OPTIONS, ...options };\n    const entry = this.createStorageEntry(key, value, mergedOptions);\n    this.store.set(key, entry);\n  }\n\n  async get<T extends StorageValue>(key: StorageKey): Promise<StorageEntry<T> | null> {\n    const entry = this.store.get(key);\n    if (!entry) return null;\n    \n    // Check expiration\n    if (entry.metadata.expiresAt && entry.metadata.expiresAt < Date.now()) {\n      this.store.delete(key);\n      return null;\n    }\n    \n    return entry;\n  }\n\n  async delete(key: StorageKey): Promise<boolean> {\n    return this.store.delete(key);\n  }\n\n  async exists(key: StorageKey): Promise<boolean> {\n    return this.store.has(key);\n  }\n\n  async clear(): Promise<void> {\n    this.store.clear();\n  }\n\n  async setMany<T extends StorageValue>(entries: Array<{ key: StorageKey; value: T; options?: StorageOptions }>): Promise<void> {\n    for (const entry of entries) {\n      await this.set(entry.key, entry.value, entry.options);\n    }\n  }\n\n  async getMany<T extends StorageValue>(keys: StorageKey[]): Promise<Array<StorageEntry<T> | null>> {\n    return Promise.all(keys.map(key => this.get<T>(key)));\n  }\n\n  async deleteMany(keys: StorageKey[]): Promise<number> {\n    let count = 0;\n    for (const key of keys) {\n      if (await this.delete(key)) count++;\n    }\n    return count;\n  }\n\n  async keys(): Promise<StorageKey[]> {\n    return Array.from(this.store.keys()) as StorageKey[];\n  }\n\n  async values<T extends StorageValue>(): Promise<Array<StorageEntry<T>>> {\n    return Array.from(this.store.values());\n  }\n\n  async entries<T extends StorageValue>(): Promise<Array<StorageEntry<T>>> {\n    return this.values<T>();\n  }\n\n  async count(): Promise<number> {\n    return this.store.size;\n  }\n\n  async beginTransaction(): Promise<StorageTransaction> {\n    throw new StorageError('Transactions not supported', 'TRANSACTION_NOT_SUPPORTED', 'beginTransaction');\n  }\n\n  async cleanup(): Promise<number> {\n    const now = Date.now();\n    let cleaned = 0;\n    for (const [key, entry] of this.store.entries()) {\n      if (entry.metadata.expiresAt && entry.metadata.expiresAt < now) {\n        this.store.delete(key);\n        cleaned++;\n      }\n    }\n    return cleaned;\n  }\n\n  async optimize(): Promise<void> {\n    await this.cleanup();\n  }\n\n  async getStats(): Promise<StorageStats> {\n    const entries = Array.from(this.store.values());\n    const now = Date.now();\n    \n    return {\n      totalKeys: entries.length,\n      totalSize: entries.reduce((size, entry) => size + JSON.stringify(entry).length, 0),\n      namespaces: [...new Set(entries.map(e => e.metadata.key.split(':')[0]))],\n      oldestEntry: Math.min(...entries.map(e => e.metadata.createdAt)),\n      newestEntry: Math.max(...entries.map(e => e.metadata.createdAt)),\n      expiredEntries: entries.filter(e => e.metadata.expiresAt && e.metadata.expiresAt < now).length,\n      encryptedEntries: entries.filter(e => e.metadata.encrypted).length,\n      compressedEntries: entries.filter(e => e.metadata.compressed).length,\n    };\n  }\n\n  private createStorageEntry<T extends StorageValue>(key: StorageKey, value: T, options: Required<StorageOptions>): StorageEntry<T> {\n    const now = Date.now();\n    return {\n      data: value,\n      metadata: {\n        key,\n        createdAt: now,\n        updatedAt: now,\n        ...(options.ttl > 0 && { expiresAt: now + options.ttl }),\n        encrypted: options.encrypt,\n        compressed: options.compress,\n        version: options.version,\n      },\n    };\n  }\n}\n\n/**\n * Unified Storage Implementation\n * Brings together adapter, encryption, and high-level operations\n */\nclass UnifiedStorageImpl extends EventEmitter implements UnifiedStorage {\n  public readonly name: string;\n  public readonly capabilities;\n  public readonly isAvailable: boolean;\n\n  constructor(\n    private adapter: StorageAdapter,\n    private encryptionService: StorageEncryptionService,\n    // @ts-ignore - Config parameter reserved for future use\n    private _config: StorageFactoryConfig\n  ) {\n    super();\n    this.name = `Unified-${adapter.name}`;\n    this.capabilities = adapter.capabilities;\n    this.isAvailable = adapter.isAvailable;\n  }\n\n  // Delegate core methods to adapter\n  isConnected(): boolean { return this.adapter.isConnected(); }\n  async connect(): Promise<void> { return this.adapter.connect(); }\n  async disconnect(): Promise<void> { return this.adapter.disconnect(); }\n\n  async set<T extends StorageValue>(key: StorageKey, value: T, options?: StorageOptions): Promise<void> {\n    const mergedOptions = { ...DEFAULT_STORAGE_OPTIONS, ...options };\n    \n    try {\n      // Apply encryption if needed\n      let finalValue: T | string = value;\n      if (mergedOptions.encrypt || (mergedOptions.namespace === 'secure')) {\n        const encrypted = await this.encryptionService.encryptValue(value, key, true);\n        finalValue = encrypted.data;\n        mergedOptions.encrypt = true;\n      }\n\n      await this.adapter.set(key, finalValue, mergedOptions);\n      this.emit('set', key, value, options);\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  async get<T extends StorageValue>(key: StorageKey): Promise<StorageEntry<T> | null> {\n    try {\n      const entry = await this.adapter.get<T | string>(key);\n      if (!entry) {\n        this.emit('get', key, null);\n        return null;\n      }\n\n      // Apply decryption if needed\n      if (entry.metadata.encrypted) {\n        const decrypted = await this.encryptionService.decryptStorageEntry(entry);\n        this.emit('get', key, decrypted.data);\n        return decrypted as StorageEntry<T>;\n      }\n\n      this.emit('get', key, entry.data);\n      return entry as StorageEntry<T>;\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  async delete(key: StorageKey): Promise<boolean> {\n    try {\n      const result = await this.adapter.delete(key);\n      this.emit('delete', key, result);\n      return result;\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  async exists(key: StorageKey): Promise<boolean> {\n    return this.adapter.exists(key);\n  }\n\n  async clear(namespace?: string): Promise<void> {\n    try {\n      await this.adapter.clear(namespace);\n      this.emit('clear', namespace);\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  // High-level entity methods\n  async setReceipt(id: ReceiptId, receipt: any, options?: StorageOptions): Promise<void> {\n    const key = createReceiptKey(id);\n    return this.set(key, receipt, { ...options, namespace: 'receipts' });\n  }\n\n  async getReceipt(id: ReceiptId): Promise<any | null> {\n    const key = createReceiptKey(id);\n    const entry = await this.get(key);\n    return entry?.data || null;\n  }\n\n  async deleteReceipt(id: ReceiptId): Promise<boolean> {\n    const key = createReceiptKey(id);\n    return this.delete(key);\n  }\n\n  async setCashier(id: CashierId, cashier: any, options?: StorageOptions): Promise<void> {\n    const key = createCashierKey(id);\n    return this.set(key, cashier, { ...options, namespace: 'cashiers' });\n  }\n\n  async getCashier(id: CashierId): Promise<any | null> {\n    const key = createCashierKey(id);\n    const entry = await this.get(key);\n    return entry?.data || null;\n  }\n\n  async deleteCashier(id: CashierId): Promise<boolean> {\n    const key = createCashierKey(id);\n    return this.delete(key);\n  }\n\n  async setMerchant(id: MerchantId, merchant: any, options?: StorageOptions): Promise<void> {\n    const key = createMerchantKey(id);\n    return this.set(key, merchant, { ...options, namespace: 'merchants' });\n  }\n\n  async getMerchant(id: MerchantId): Promise<any | null> {\n    const key = createMerchantKey(id);\n    const entry = await this.get(key);\n    return entry?.data || null;\n  }\n\n  async deleteMerchant(id: MerchantId): Promise<boolean> {\n    const key = createMerchantKey(id);\n    return this.delete(key);\n  }\n\n  async setPEM(id: PEMId, pem: any, options?: StorageOptions): Promise<void> {\n    const key = createPEMKey(id);\n    return this.set(key, pem, { ...options, namespace: 'pems' });\n  }\n\n  async getPEM(id: PEMId): Promise<any | null> {\n    const key = createPEMKey(id);\n    const entry = await this.get(key);\n    return entry?.data || null;\n  }\n\n  async deletePEM(id: PEMId): Promise<boolean> {\n    const key = createPEMKey(id);\n    return this.delete(key);\n  }\n\n  async setCashRegister(id: CashRegisterId, cashRegister: any, options?: StorageOptions): Promise<void> {\n    const key = createCashRegisterKey(id);\n    return this.set(key, cashRegister, { ...options, namespace: 'cash_registers' });\n  }\n\n  async getCashRegister(id: CashRegisterId): Promise<any | null> {\n    const key = createCashRegisterKey(id);\n    const entry = await this.get(key);\n    return entry?.data || null;\n  }\n\n  async deleteCashRegister(id: CashRegisterId): Promise<boolean> {\n    const key = createCashRegisterKey(id);\n    return this.delete(key);\n  }\n\n  // Cache operations\n  async setCache<T extends StorageValue>(key: string, value: T, ttl?: number): Promise<void> {\n    const cacheKey = createCacheKey(key);\n    return this.set(cacheKey, value, { namespace: 'cache', ...(ttl && { ttl }) });\n  }\n\n  async getCache<T extends StorageValue>(key: string): Promise<T | null> {\n    const cacheKey = createCacheKey(key);\n    const entry = await this.get<T>(cacheKey);\n    return entry?.data || null;\n  }\n\n  async invalidateCache(pattern?: string): Promise<number> {\n    const keys = await this.keys({ namespace: 'cache', ...(pattern && { prefix: pattern }) });\n    return this.deleteMany(keys);\n  }\n\n  // Session storage\n  async setSession<T extends StorageValue>(key: string, value: T): Promise<void> {\n    const sessionKey = createSessionKey(key);\n    return this.set(sessionKey, value, { namespace: 'session' });\n  }\n\n  async getSession<T extends StorageValue>(key: string): Promise<T | null> {\n    const sessionKey = createSessionKey(key);\n    const entry = await this.get<T>(sessionKey);\n    return entry?.data || null;\n  }\n\n  async clearSession(): Promise<void> {\n    return this.clear('session');\n  }\n\n  // Secure storage (always encrypted)\n  async setSecure<T extends StorageValue>(key: string, value: T): Promise<void> {\n    const secureKey = createSecureKey(key);\n    return this.set(secureKey, value, { namespace: 'secure', encrypt: true });\n  }\n\n  async getSecure<T extends StorageValue>(key: string): Promise<T | null> {\n    const secureKey = createSecureKey(key);\n    const entry = await this.get<T>(secureKey);\n    return entry?.data || null;\n  }\n\n  async deleteSecure(key: string): Promise<boolean> {\n    const secureKey = createSecureKey(key);\n    return this.delete(secureKey);\n  }\n\n  // Configuration storage\n  async setConfig<T extends StorageValue>(key: string, value: T): Promise<void> {\n    const configKey = createConfigKey(key);\n    return this.set(configKey, value, { namespace: 'config' });\n  }\n\n  async getConfig<T extends StorageValue>(key: string): Promise<T | null> {\n    const configKey = createConfigKey(key);\n    const entry = await this.get<T>(configKey);\n    return entry?.data || null;\n  }\n\n  async deleteConfig(key: string): Promise<boolean> {\n    const configKey = createConfigKey(key);\n    return this.delete(configKey);\n  }\n\n  // Backup and restore\n  async exportData(namespace?: string): Promise<string> {\n    const entries = await this.entries({ ...(namespace && { namespace }) });\n    return JSON.stringify(entries, null, 2);\n  }\n\n  async importData(data: string): Promise<number> {\n    const entries = JSON.parse(data) as StorageEntry<any>[];\n    let imported = 0;\n    \n    for (const entry of entries) {\n      try {\n        await this.set(entry.metadata.key, entry.data);\n        imported++;\n      } catch (error) {\n        console.warn(`Failed to import entry ${entry.metadata.key}:`, error);\n      }\n    }\n    \n    return imported;\n  }\n\n  // Delegate remaining methods to adapter\n  async setMany<T extends StorageValue>(entries: Array<{ key: StorageKey; value: T; options?: StorageOptions }>): Promise<void> {\n    return this.adapter.setMany(entries);\n  }\n\n  async getMany<T extends StorageValue>(keys: StorageKey[]): Promise<Array<StorageEntry<T> | null>> {\n    return this.adapter.getMany(keys);\n  }\n\n  async deleteMany(keys: StorageKey[]): Promise<number> {\n    return this.adapter.deleteMany(keys);\n  }\n\n  async keys(options?: QueryOptions): Promise<StorageKey[]> {\n    return this.adapter.keys(options);\n  }\n\n  async values<T extends StorageValue>(options?: QueryOptions): Promise<Array<StorageEntry<T>>> {\n    return this.adapter.values(options);\n  }\n\n  async entries<T extends StorageValue>(options?: QueryOptions): Promise<Array<StorageEntry<T>>> {\n    return this.adapter.entries(options);\n  }\n\n  async count(options?: QueryOptions): Promise<number> {\n    return this.adapter.count(options);\n  }\n\n  async beginTransaction(): Promise<StorageTransaction> {\n    return this.adapter.beginTransaction();\n  }\n\n  async cleanup(): Promise<number> {\n    return this.adapter.cleanup();\n  }\n\n  async optimize(): Promise<void> {\n    return this.adapter.optimize();\n  }\n\n  async getStats(): Promise<StorageStats> {\n    return this.adapter.getStats();\n  }\n\n  // Missing interface methods\n  async query<T extends StorageValue>(options: QueryOptions): Promise<Array<{ key: StorageKey; value: T }>> {\n    const keys = await this.keys(options);\n    const results: Array<{ key: StorageKey; value: T }> = [];\n    \n    for (const key of keys) {\n      try {\n        const entry = await this.get<T>(key);\n        if (entry?.data) {\n          results.push({ key, value: entry.data });\n        }\n      } catch (error) {\n        console.warn(`Failed to query key ${key}:`, error);\n      }\n    }\n    \n    return results;\n  }\n\n  async initialize(): Promise<void> {\n    await this.connect();\n  }\n\n  async destroy(): Promise<void> {\n    await this.disconnect();\n    this.removeAllListeners();\n  }\n}\n\n/**\n * Storage Factory\n * Main entry point for creating storage instances\n */\nexport class StorageFactory {\n  private static instance: StorageFactory | null = null;\n  private storageInstances = new Map<string, UnifiedStorage>();\n\n  private constructor() {}\n\n  static getInstance(): StorageFactory {\n    if (!StorageFactory.instance) {\n      StorageFactory.instance = new StorageFactory();\n    }\n    return StorageFactory.instance;\n  }\n\n  /**\n   * Create storage instance with automatic adapter selection\n   */\n  async createStorage(config: StorageFactoryConfig = {}): Promise<UnifiedStorage> {\n    const instanceKey = this.generateInstanceKey(config);\n    \n    if (this.storageInstances.has(instanceKey)) {\n      return this.storageInstances.get(instanceKey)!;\n    }\n\n    try {\n      // Detect platform and select adapter\n      const environmentInfo = platformDetector.getEnvironmentInfo();\n      const adapter = await this.selectOptimalAdapter(config, environmentInfo);\n      \n      // Create encryption service\n      const encryptionService = createEncryptionService(config.encryption);\n      \n      // Create unified storage instance\n      const storage = new UnifiedStorageImpl(adapter, encryptionService, config);\n      \n      // Connect to storage\n      await storage.connect();\n      \n      // Cache instance\n      this.storageInstances.set(instanceKey, storage);\n      \n      if (config.debug) {\n        console.log(`Storage created: ${storage.name} for platform: ${environmentInfo.platform}`);\n      }\n      \n      return storage;\n    } catch (error) {\n      throw new StorageError(\n        'Failed to create storage instance',\n        'STORAGE_FACTORY_ERROR',\n        'createStorage',\n        undefined,\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get environment information\n   */\n  getEnvironmentInfo(): EnvironmentInfo {\n    return platformDetector.getEnvironmentInfo();\n  }\n\n  /**\n   * Test storage compatibility\n   */\n  async testCompatibility(): Promise<{\n    platform: PlatformType;\n    availableAdapters: string[];\n    recommendedAdapter: string;\n    encryptionSupported: boolean;\n    compressionSupported: boolean;\n  }> {\n    const environmentInfo = platformDetector.getEnvironmentInfo();\n    const availableAdapters: string[] = [];\n    \n    // Test IndexedDB\n    if (environmentInfo.hasIndexedDB) {\n      try {\n        const adapter = new IndexedDBAdapter();\n        if (adapter.isAvailable) {\n          availableAdapters.push('indexeddb');\n        }\n      } catch {\n        // IndexedDB not working\n      }\n    }\n    \n    // Test LocalStorage\n    if (environmentInfo.hasLocalStorage) {\n      try {\n        const adapter = new LocalStorageAdapter();\n        if (adapter.isAvailable) {\n          availableAdapters.push('localstorage');\n        }\n      } catch {\n        // LocalStorage not working\n      }\n    }\n    \n    // Memory is always available\n    availableAdapters.push('memory');\n    \n    return {\n      platform: environmentInfo.platform,\n      availableAdapters,\n      recommendedAdapter: platformDetector.getRecommendedStorageAdapter(),\n      encryptionSupported: environmentInfo.hasWebCrypto,\n      compressionSupported: environmentInfo.hasCompressionStreams,\n    };\n  }\n\n  /**\n   * Clear all cached instances\n   */\n  clearInstances(): void {\n    this.storageInstances.clear();\n  }\n\n  private async selectOptimalAdapter(\n    config: StorageFactoryConfig, \n    environmentInfo: EnvironmentInfo\n  ): Promise<StorageAdapter> {\n    const preferredAdapter = config.preferredAdapter || 'auto';\n    \n    if (preferredAdapter !== 'auto') {\n      return this.createSpecificAdapter(preferredAdapter as 'indexeddb' | 'localstorage' | 'memory', config);\n    }\n\n    // Auto-selection based on platform capabilities\n    if (environmentInfo.hasIndexedDB) {\n      try {\n        const adapter = new IndexedDBAdapter();\n        await adapter.connect();\n        return adapter;\n      } catch (error) {\n        console.warn('IndexedDB failed, falling back to localStorage:', error);\n      }\n    }\n\n    if (environmentInfo.hasLocalStorage) {\n      try {\n        const adapter = new LocalStorageAdapter(config.keyPrefix);\n        await adapter.connect();\n        return adapter;\n      } catch (error) {\n        console.warn('LocalStorage failed, falling back to memory:', error);\n      }\n    }\n\n    // Final fallback to memory (suppress warning for CLI usage)\n    const isCLI = typeof window === 'undefined' && typeof process !== 'undefined' && process.env.NODE_ENV !== 'test';\n    if (!isCLI) {\n      console.warn('Using memory storage as fallback - data will not persist');\n    }\n    return new MemoryStorageAdapter();\n  }\n\n  private createSpecificAdapter(\n    adapterType: 'indexeddb' | 'localstorage' | 'memory', \n    config: StorageFactoryConfig\n  ): StorageAdapter {\n    switch (adapterType) {\n      case 'indexeddb':\n        return new IndexedDBAdapter();\n      case 'localstorage':\n        return new LocalStorageAdapter(config.keyPrefix);\n      case 'memory':\n        return new MemoryStorageAdapter();\n      default:\n        throw new StorageError(\n          `Unknown adapter type: ${adapterType}`,\n          'UNKNOWN_ADAPTER',\n          'createSpecificAdapter'\n        );\n    }\n  }\n\n  private generateInstanceKey(config: StorageFactoryConfig): string {\n    const keyParts = [\n      config.preferredAdapter || 'auto',\n      config.keyPrefix || 'default',\n      config.enableCompression ? 'compressed' : 'uncompressed',\n      config.encryption?.enabled ? 'encrypted' : 'unencrypted',\n    ];\n    return keyParts.join('_');\n  }\n}\n\n// Export singleton instance and convenience functions\nexport const storageFactory = StorageFactory.getInstance();\n\nexport const createStorage = (config?: StorageFactoryConfig): Promise<UnifiedStorage> => {\n  return storageFactory.createStorage(config);\n};\n\nexport const createSecureStorage = (masterPassword: string): Promise<UnifiedStorage> => {\n  return storageFactory.createStorage({\n    encryption: {\n      enabled: true,\n      masterPassword,\n    },\n  });\n};\n\nexport const createHighPerformanceStorage = (): Promise<UnifiedStorage> => {\n  return storageFactory.createStorage({\n    preferredAdapter: 'indexeddb',\n    performanceMode: 'high',\n    enableCompression: true,\n  });\n};\n\nexport const createCompatibilityStorage = (): Promise<UnifiedStorage> => {\n  return storageFactory.createStorage({\n    preferredAdapter: 'localstorage',\n    performanceMode: 'conservative',\n    enableCompression: false,\n  });\n};","/**\n * mTLS Certificate Manager\n * Secure storage and management of mTLS certificates for POS devices\n * \n * Features:\n * - Secure storage of certificates received from server\n * - Cross-platform certificate management\n * - Certificate validation and lifecycle management\n * - Integration with cash register endpoints\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport type { UnifiedStorage } from '@/storage/unified-storage';\nimport { createStorageKey } from '@/storage/unified-storage';\nimport { createStorage } from '@/storage/storage-factory';\nimport { AdvancedEncryption, type EncryptedData } from '@/security/encryption';\nimport type { CashRegisterId, SerialNumber } from '@/types/branded';\n\n/**\n * mTLS Certificate data structure\n */\nexport interface MTLSCertificate {\n  /** Unique identifier for the cash register */\n  cashRegisterId: CashRegisterId;\n  \n  /** PEM serial number from the device */\n  pemSerialNumber: SerialNumber;\n  \n  /** Human-readable name for the cash register */\n  name: string;\n  \n  /** The actual mTLS certificate in PEM format */\n  certificate: string;\n  \n  /** Certificate metadata */\n  metadata: {\n    /** When the certificate was issued */\n    issuedAt: Date;\n    \n    /** When the certificate expires (if available) */\n    expiresAt?: Date;\n    \n    /** Certificate authority information */\n    issuer?: string;\n    \n    /** Certificate subject information */\n    subject?: string;\n    \n    /** Certificate fingerprint for validation */\n    fingerprint?: string;\n  };\n  \n  /** When this certificate was stored locally */\n  storedAt: Date;\n  \n  /** Certificate status */\n  status: 'active' | 'expired' | 'revoked' | 'pending';\n}\n\n/**\n * Certificate storage data structure\n */\ninterface StoredCertificateData {\n  certificates: Record<string, MTLSCertificate>;\n  version: '1.0';\n  encryptedAt: number;\n}\n\n/**\n * Certificate manager configuration\n */\nexport interface MTLSCertificateManagerConfig {\n  /** Storage key for certificates */\n  storageKey?: string;\n  \n  /** Enable encryption for stored certificates */\n  enableEncryption?: boolean;\n  \n  /** Storage adapter type */\n  storageAdapter?: 'memory' | 'localStorage' | 'indexedDB' | 'reactNative';\n  \n  /** Certificate validation options */\n  validation?: {\n    /** Validate certificate format */\n    validateFormat?: boolean;\n    \n    /** Check certificate expiration */\n    checkExpiration?: boolean;\n    \n    /** Validate certificate chain */\n    validateChain?: boolean;\n  };\n}\n\n/**\n * Certificate management events\n */\nexport interface CertificateEvents {\n  'certificate:stored': { certificate: MTLSCertificate };\n  'certificate:retrieved': { certificateId: string; certificate: MTLSCertificate };\n  'certificate:expired': { certificateId: string; certificate: MTLSCertificate };\n  'certificate:error': { error: Error; operation: string };\n  'storage:error': { error: Error };\n}\n\nconst DEFAULT_CONFIG: Required<MTLSCertificateManagerConfig> = {\n  storageKey: 'acube_mtls_certificates',\n  enableEncryption: true,\n  storageAdapter: 'memory',\n  validation: {\n    validateFormat: true,\n    checkExpiration: true,\n    validateChain: false,\n  },\n};\n\n/**\n * Secure mTLS Certificate Manager\n * Handles storage, retrieval, and management of mTLS certificates\n */\nexport class MTLSCertificateManager extends EventEmitter<CertificateEvents> {\n  private config: Required<MTLSCertificateManagerConfig>;\n  private storage: UnifiedStorage | null = null;\n  private encryption: AdvancedEncryption | null = null;\n  private initialized = false;\n\n  constructor(config: MTLSCertificateManagerConfig = {}) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  /**\n   * Initialize the certificate manager\n   */\n  async initialize(): Promise<void> {\n    try {\n      // Initialize storage\n      const adapterMapping: Record<string, 'indexeddb' | 'localstorage' | 'auto'> = {\n        'memory': 'localstorage',\n        'localStorage': 'localstorage', \n        'indexedDB': 'indexeddb',\n        'reactNative': 'localstorage',\n      };\n      \n      this.storage = await createStorage({\n        preferredAdapter: adapterMapping[this.config.storageAdapter] || 'auto',\n        encryption: this.config.enableEncryption ? { enabled: true } : { enabled: false },\n      });\n\n      // Initialize encryption if enabled\n      if (this.config.enableEncryption) {\n        this.encryption = new AdvancedEncryption();\n        await this.encryption.initialize();\n      }\n\n      this.initialized = true;\n    } catch (error) {\n      const certificateError = new Error(`Failed to initialize certificate manager: ${error}`);\n      this.emit('certificate:error', { error: certificateError, operation: 'initialize' });\n      throw certificateError;\n    }\n  }\n\n  /**\n   * Store a new mTLS certificate securely\n   */\n  async storeCertificate(\n    cashRegisterId: CashRegisterId,\n    pemSerialNumber: SerialNumber,\n    name: string,\n    certificate: string\n  ): Promise<MTLSCertificate> {\n    this.ensureInitialized();\n\n    try {\n      // Parse certificate metadata\n      const metadata = this.parseCertificateMetadata(certificate);\n      \n      // Create certificate object\n      const mtlsCertificate: MTLSCertificate = {\n        cashRegisterId,\n        pemSerialNumber,\n        name,\n        certificate,\n        metadata,\n        storedAt: new Date(),\n        status: 'active',\n      };\n\n      // Validate certificate if enabled\n      if (this.config.validation.validateFormat) {\n        this.validateCertificateFormat(certificate);\n      }\n\n      // Get existing certificates\n      const existingData = await this.getStoredData();\n      \n      // Store certificate\n      existingData.certificates[cashRegisterId] = mtlsCertificate;\n      \n      // Save to storage\n      await this.saveStoredData(existingData);\n\n      // Emit event\n      this.emit('certificate:stored', { certificate: mtlsCertificate });\n\n      return mtlsCertificate;\n    } catch (error) {\n      const certificateError = new Error(`Failed to store certificate: ${error}`);\n      this.emit('certificate:error', { error: certificateError, operation: 'store' });\n      throw certificateError;\n    }\n  }\n\n  /**\n   * Retrieve a certificate by cash register ID\n   */\n  async getCertificate(cashRegisterId: CashRegisterId): Promise<MTLSCertificate | null> {\n    this.ensureInitialized();\n\n    try {\n      const storedData = await this.getStoredData();\n      const certificate = storedData.certificates[cashRegisterId] || null;\n\n      if (certificate) {\n        // Check if certificate is expired\n        if (this.config.validation.checkExpiration && this.isCertificateExpired(certificate)) {\n          certificate.status = 'expired';\n          await this.updateCertificateStatus(cashRegisterId, 'expired');\n          this.emit('certificate:expired', { certificateId: cashRegisterId, certificate });\n        }\n\n        this.emit('certificate:retrieved', { certificateId: cashRegisterId, certificate });\n      }\n\n      return certificate;\n    } catch (error) {\n      const certificateError = new Error(`Failed to retrieve certificate: ${error}`);\n      this.emit('certificate:error', { error: certificateError, operation: 'retrieve' });\n      throw certificateError;\n    }\n  }\n\n  /**\n   * Get all stored certificates\n   */\n  async getAllCertificates(): Promise<MTLSCertificate[]> {\n    this.ensureInitialized();\n\n    try {\n      const storedData = await this.getStoredData();\n      return Object.values(storedData.certificates);\n    } catch (error) {\n      const certificateError = new Error(`Failed to retrieve all certificates: ${error}`);\n      this.emit('certificate:error', { error: certificateError, operation: 'retrieveAll' });\n      throw certificateError;\n    }\n  }\n\n  /**\n   * Update certificate status\n   */\n  async updateCertificateStatus(\n    cashRegisterId: CashRegisterId, \n    status: MTLSCertificate['status']\n  ): Promise<void> {\n    this.ensureInitialized();\n\n    try {\n      const storedData = await this.getStoredData();\n      const certificate = storedData.certificates[cashRegisterId];\n\n      if (certificate) {\n        certificate.status = status;\n        await this.saveStoredData(storedData);\n      }\n    } catch (error) {\n      const certificateError = new Error(`Failed to update certificate status: ${error}`);\n      this.emit('certificate:error', { error: certificateError, operation: 'updateStatus' });\n      throw certificateError;\n    }\n  }\n\n  /**\n   * Remove a certificate\n   */\n  async removeCertificate(cashRegisterId: CashRegisterId): Promise<boolean> {\n    this.ensureInitialized();\n\n    try {\n      const storedData = await this.getStoredData();\n      const existed = !!storedData.certificates[cashRegisterId];\n      \n      delete storedData.certificates[cashRegisterId];\n      await this.saveStoredData(storedData);\n\n      return existed;\n    } catch (error) {\n      const certificateError = new Error(`Failed to remove certificate: ${error}`);\n      this.emit('certificate:error', { error: certificateError, operation: 'remove' });\n      throw certificateError;\n    }\n  }\n\n  /**\n   * Clear all certificates\n   */\n  async clearAllCertificates(): Promise<void> {\n    this.ensureInitialized();\n\n    try {\n      const emptyData: StoredCertificateData = {\n        certificates: {},\n        version: '1.0',\n        encryptedAt: Date.now(),\n      };\n\n      await this.saveStoredData(emptyData);\n    } catch (error) {\n      const certificateError = new Error(`Failed to clear certificates: ${error}`);\n      this.emit('certificate:error', { error: certificateError, operation: 'clear' });\n      throw certificateError;\n    }\n  }\n\n  /**\n   * Get certificate storage statistics\n   */\n  async getStorageStats(): Promise<{\n    totalCertificates: number;\n    activeCertificates: number;\n    expiredCertificates: number;\n    storageSize: number;\n    lastUpdate: Date | null;\n  }> {\n    this.ensureInitialized();\n\n    try {\n      const storedData = await this.getStoredData();\n      const certificates = Object.values(storedData.certificates);\n      \n      const activeCertificates = certificates.filter(cert => cert.status === 'active').length;\n      const expiredCertificates = certificates.filter(cert => cert.status === 'expired').length;\n      \n      // Estimate storage size (rough calculation)\n      const storageSize = JSON.stringify(storedData).length;\n      \n      const lastUpdate = certificates.length > 0 \n        ? new Date(Math.max(...certificates.map(cert => cert.storedAt.getTime())))\n        : null;\n\n      return {\n        totalCertificates: certificates.length,\n        activeCertificates,\n        expiredCertificates,\n        storageSize,\n        lastUpdate,\n      };\n    } catch (error) {\n      const certificateError = new Error(`Failed to get storage stats: ${error}`);\n      this.emit('certificate:error', { error: certificateError, operation: 'stats' });\n      throw certificateError;\n    }\n  }\n\n  /**\n   * Cleanup expired certificates\n   */\n  async cleanupExpiredCertificates(): Promise<number> {\n    this.ensureInitialized();\n\n    try {\n      const storedData = await this.getStoredData();\n      const certificates = Object.entries(storedData.certificates);\n      let removedCount = 0;\n\n      for (const [cashRegisterId, certificate] of certificates) {\n        if (this.isCertificateExpired(certificate)) {\n          delete storedData.certificates[cashRegisterId];\n          removedCount++;\n          this.emit('certificate:expired', { certificateId: cashRegisterId, certificate });\n        }\n      }\n\n      if (removedCount > 0) {\n        await this.saveStoredData(storedData);\n      }\n\n      return removedCount;\n    } catch (error) {\n      const certificateError = new Error(`Failed to cleanup expired certificates: ${error}`);\n      this.emit('certificate:error', { error: certificateError, operation: 'cleanup' });\n      throw certificateError;\n    }\n  }\n\n  /**\n   * Destroy the certificate manager\n   */\n  async destroy(): Promise<void> {\n    if (this.storage) {\n      await this.storage.destroy();\n    }\n    \n    this.removeAllListeners();\n    this.initialized = false;\n  }\n\n  // Private methods\n\n  private ensureInitialized(): void {\n    if (!this.initialized) {\n      throw new Error('Certificate manager not initialized. Call initialize() first.');\n    }\n  }\n\n  private async getStoredData(): Promise<StoredCertificateData> {\n    if (!this.storage) {\n      throw new Error('Storage not initialized');\n    }\n\n    try {\n      const storageKey = createStorageKey(this.config.storageKey);\n      const result = await this.storage.get(storageKey);\n      \n      if (!result || !result.data) {\n        return {\n          certificates: {},\n          version: '1.0',\n          encryptedAt: Date.now(),\n        };\n      }\n\n      // Handle both encrypted and unencrypted data\n      const data = typeof result.data === 'string' ? result.data : JSON.stringify(result.data);\n      \n      let parsedData: StoredCertificateData;\n      \n      if (this.config.enableEncryption && this.encryption) {\n        try {\n          const encryptedDataObj = JSON.parse(data);\n          const decryptedBuffer = await this.encryption.decrypt(encryptedDataObj);\n          const decryptedString = new TextDecoder().decode(decryptedBuffer);\n          parsedData = JSON.parse(decryptedString);\n        } catch (decryptError) {\n          // Fallback to unencrypted data if decryption fails\n          console.warn('Failed to decrypt certificate data, falling back to unencrypted:', decryptError);\n          parsedData = JSON.parse(data);\n        }\n      } else {\n        parsedData = JSON.parse(data);\n      }\n\n      // Convert stored dates back to Date objects\n      Object.values(parsedData.certificates).forEach(cert => {\n        cert.storedAt = new Date(cert.storedAt);\n        cert.metadata.issuedAt = new Date(cert.metadata.issuedAt);\n        if (cert.metadata.expiresAt) {\n          cert.metadata.expiresAt = new Date(cert.metadata.expiresAt);\n        }\n      });\n\n      return parsedData;\n    } catch (error) {\n      console.warn('Failed to retrieve certificate data:', error);\n      return {\n        certificates: {},\n        version: '1.0',\n        encryptedAt: Date.now(),\n      };\n    }\n  }\n\n  private async saveStoredData(data: StoredCertificateData): Promise<void> {\n    if (!this.storage) {\n      throw new Error('Storage not initialized');\n    }\n\n    try {\n      data.encryptedAt = Date.now();\n      let dataToStore: string | EncryptedData = JSON.stringify(data);\n\n      if (this.config.enableEncryption && this.encryption) {\n        const encryptedData = await this.encryption.encrypt(JSON.stringify(data));\n        dataToStore = JSON.stringify(encryptedData);\n      }\n\n      const storageKey = createStorageKey(this.config.storageKey);\n      await this.storage.set(storageKey, dataToStore, {\n        encrypt: this.config.enableEncryption,\n      });\n    } catch (error) {\n      this.emit('storage:error', { error: error as Error });\n      throw error;\n    }\n  }\n\n  private parseCertificateMetadata(certificate: string): MTLSCertificate['metadata'] {\n    // Basic certificate parsing - in a real implementation,\n    // you might want to use a proper X.509 certificate parser\n    const metadata: MTLSCertificate['metadata'] = {\n      issuedAt: new Date(),\n    };\n\n    try {\n      // Extract basic information from PEM certificate\n      // This is a simplified parser - in production you might want to use\n      // a proper certificate parsing library\n      \n      const certLines = certificate.split('\\n');\n      const certData = certLines.find(line => line.includes('Subject:'));\n      if (certData) {\n        metadata.subject = certData.replace('Subject:', '').trim();\n      }\n\n      const issuerData = certLines.find(line => line.includes('Issuer:'));\n      if (issuerData) {\n        metadata.issuer = issuerData.replace('Issuer:', '').trim();\n      }\n\n      // Create a simple fingerprint (hash of certificate)\n      let hash = 0;\n      for (let i = 0; i < certificate.length; i++) {\n        const char = certificate.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n        hash = hash & hash; // Convert to 32-bit integer\n      }\n      metadata.fingerprint = Math.abs(hash).toString(16);\n\n    } catch (error) {\n      console.warn('Failed to parse certificate metadata:', error);\n    }\n\n    return metadata;\n  }\n\n  private validateCertificateFormat(certificate: string): void {\n    if (!certificate.includes('-----BEGIN CERTIFICATE-----') || \n        !certificate.includes('-----END CERTIFICATE-----')) {\n      throw new Error('Invalid certificate format: must be PEM format');\n    }\n\n    // Additional format validation could be added here\n  }\n\n  private isCertificateExpired(certificate: MTLSCertificate): boolean {\n    if (!certificate.metadata.expiresAt) {\n      return false; // If no expiration date, assume not expired\n    }\n\n    return certificate.metadata.expiresAt.getTime() < Date.now();\n  }\n}","/**\n * Cash Registers Resource - OpenAPI Implementation\n * Type-safe implementation for cash register management\n * \n * Features:\n * - Cash register lifecycle management\n * - Registration and configuration\n * - Status monitoring and reporting\n * - Integration with Point of Sales devices\n */\n\nimport { BaseOpenAPIResource } from '@/resources/base-openapi';\nimport { CashRegisterEndpoints } from '@/generated/endpoints';\nimport type { HttpClient } from '@/http/client';\nimport type { CashRegisterId, SerialNumber } from '@/types/branded';\nimport type { components } from '@/types/generated';\nimport { ValidationError } from '@/errors/index';\nimport { MTLSCertificateManager, type MTLSCertificate } from '@/security/mtls-certificate-manager';\n\n// Extract types from OpenAPI generated types\nexport type CashRegisterInput = components['schemas']['E-Receipt_IT_API_CashRegisterCreate'];\nexport type CashRegisterOutput = components['schemas']['E-Receipt_IT_API_CashRegisterDetailedOutput'];\nexport type CashRegisterPage = components['schemas']['E-Receipt_IT_API_Page__T_Customized_CashRegisterBasicOutput_'];\n\n/**\n * Cash register creation request with mTLS certificate support\n */\nexport interface CashRegisterCreateRequest {\n  /** PEM serial number from the device */\n  pem_serial_number: string;\n  \n  /** Human-readable name for the cash register */\n  name: string;\n}\n\n/**\n * Cash register creation response with mTLS certificate\n */\nexport interface CashRegisterCreateResponse {\n  /** Unique identifier for the cash register */\n  uuid: string;\n  \n  /** PEM serial number from the device */\n  pem_serial_number: string;\n  \n  /** Human-readable name for the cash register */\n  name: string;\n  \n  /** mTLS certificate in PEM format */\n  mtls_certificate: string;\n}\n\nexport interface CashRegisterValidationOptions {\n  validateSerialNumber?: boolean;\n  checkDuplicateRegistration?: boolean;\n  enforceLocationValidation?: boolean;\n}\n\nexport interface CashRegisterConfiguration {\n  id: CashRegisterId;\n  name: string;\n  location: string;\n  serialNumber: string;\n  model: string;\n  manufacturer: string;\n  installationDate: string;\n  lastMaintenance?: string | undefined;\n  nextMaintenance?: string | undefined;\n  status: CashRegisterStatus;\n  settings: CashRegisterSettings;\n}\n\nexport interface CashRegisterSettings {\n  printReceipts: boolean;\n  enableLottery: boolean;\n  defaultVATRate: string;\n  language: 'it' | 'en' | 'de' | 'fr';\n  currency: 'EUR';\n  timezone: string;\n  paperSize: 'A4' | 'thermal_58mm' | 'thermal_80mm';\n  connectionType: 'ethernet' | 'wifi' | 'cellular';\n}\n\nexport interface CashRegisterStats {\n  registerId: CashRegisterId;\n  totalTransactions: number;\n  totalAmount: string;\n  averageTransaction: string;\n  transactionsToday: number;\n  amountToday: string;\n  lastTransaction?: string;\n  uptime: {\n    hours: number;\n    percentage: number;\n  };\n  errorCount: number;\n  maintenanceScore: number;\n}\n\nexport type CashRegisterStatus = 'active' | 'inactive' | 'maintenance' | 'error' | 'offline';\nexport type MaintenanceType = 'routine' | 'repair' | 'upgrade' | 'calibration';\n\n/**\n * Cash Registers Resource Class - OpenAPI Based\n * Manages cash register devices with full compliance and mTLS certificate management\n */\nexport class CashRegistersResource extends BaseOpenAPIResource {\n  private certificateManager: MTLSCertificateManager;\n\n  constructor(client: HttpClient) {\n    super({\n      client,\n      endpoints: {\n        create: CashRegisterEndpoints.CREATE,\n        list: CashRegisterEndpoints.LIST,\n        getById: CashRegisterEndpoints.GET_BY_ID,\n      }\n    });\n\n    // Initialize certificate manager\n    this.certificateManager = new MTLSCertificateManager({\n      storageKey: 'acube_cash_register_certificates',\n      enableEncryption: true,\n    });\n  }\n\n  /**\n   * Initialize the resource (including certificate manager)\n   */\n  async initialize(): Promise<void> {\n    await this.certificateManager.initialize();\n  }\n\n  /**\n   * Register a new cash register and obtain mTLS certificate\n   * This method calls the server endpoint and automatically stores the certificate securely\n   * \n   * @param request - Cash register creation request\n   * @returns Promise resolving to created cash register with certificate info\n   */\n  async registerWithCertificate(\n    request: CashRegisterCreateRequest\n  ): Promise<{\n    cashRegister: CashRegisterCreateResponse;\n    certificate: MTLSCertificate;\n  }> {\n    try {\n      // Call server endpoint to create cash register and get certificate\n      const response = await this.client.post<CashRegisterCreateResponse>(\n        '/mf1/cash-register',\n        request,\n        {\n          headers: {\n            'Content-Type': 'application/json',\n            'Accept': 'application/json',\n          },\n          metadata: { \n            operation: 'registerCashRegister',\n            requiresAuth: true,\n          },\n        }\n      );\n\n      if (response.status !== 201) {\n        throw new ValidationError(\n          'CASH_REGISTER_CREATION_FAILED',\n          `Failed to create cash register: ${response.status}`,\n          [{ field: 'request', message: 'Cash register creation failed', code: 'CREATION_FAILED' }]\n        );\n      }\n\n      const cashRegisterData = response.data;\n\n      // Store the certificate securely\n      const certificate = await this.certificateManager.storeCertificate(\n        cashRegisterData.uuid as CashRegisterId,\n        request.pem_serial_number as SerialNumber,\n        request.name,\n        cashRegisterData.mtls_certificate\n      );\n\n      return {\n        cashRegister: cashRegisterData,\n        certificate,\n      };\n    } catch (error) {\n      throw new ValidationError(\n        'CASH_REGISTER_REGISTRATION_FAILED',\n        `Failed to register cash register: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        [{ field: 'request', message: 'Registration failed', code: 'REGISTRATION_FAILED' }]\n      );\n    }\n  }\n\n  /**\n   * Get mTLS certificate for a cash register\n   * \n   * @param cashRegisterId - Cash register ID\n   * @returns Promise resolving to certificate or null if not found\n   */\n  async getCertificate(cashRegisterId: CashRegisterId): Promise<MTLSCertificate | null> {\n    return this.certificateManager.getCertificate(cashRegisterId);\n  }\n\n  /**\n   * Get all stored mTLS certificates\n   * \n   * @returns Promise resolving to array of certificates\n   */\n  async getAllCertificates(): Promise<MTLSCertificate[]> {\n    return this.certificateManager.getAllCertificates();\n  }\n\n  /**\n   * Remove mTLS certificate for a cash register\n   * \n   * @param cashRegisterId - Cash register ID\n   * @returns Promise resolving to true if certificate was removed\n   */\n  async removeCertificate(cashRegisterId: CashRegisterId): Promise<boolean> {\n    return this.certificateManager.removeCertificate(cashRegisterId);\n  }\n\n  /**\n   * Get certificate storage statistics\n   * \n   * @returns Promise resolving to storage statistics\n   */\n  async getCertificateStats(): Promise<{\n    totalCertificates: number;\n    activeCertificates: number;\n    expiredCertificates: number;\n    storageSize: number;\n    lastUpdate: Date | null;\n  }> {\n    return this.certificateManager.getStorageStats();\n  }\n\n  /**\n   * Cleanup expired certificates\n   * \n   * @returns Promise resolving to number of certificates removed\n   */\n  async cleanupExpiredCertificates(): Promise<number> {\n    return this.certificateManager.cleanupExpiredCertificates();\n  }\n\n  /**\n   * Create a new cash register (legacy method)\n   * \n   * @param data - Cash register input data\n   * @param options - Validation options\n   * @returns Promise resolving to created cash register\n   */\n  async create(\n    data: CashRegisterInput, \n    options: CashRegisterValidationOptions = {}\n  ): Promise<CashRegisterOutput> {\n    // Validate input\n    await this.validateCashRegisterInput(data, options);\n\n    return this.executeRequest<CashRegisterInput, CashRegisterOutput>('create', data, {\n      metadata: {\n        operation: 'create_cash_register',\n        serialNumber: data.pem_serial_number,\n        name: data.name,\n      }\n    });\n  }\n\n  /**\n   * Get a list of cash registers\n   * \n   * @returns Promise resolving to paginated cash register list\n   */\n  async list(): Promise<CashRegisterPage> {\n    return this.executeRequest<void, CashRegisterPage>('list', undefined, {\n      metadata: {\n        operation: 'list_cash_registers',\n      }\n    });\n  }\n\n  /**\n   * Get a specific cash register by ID\n   * \n   * @param registerId - Cash register ID\n   * @returns Promise resolving to cash register details\n   */\n  async retrieve(registerId: CashRegisterId | number): Promise<CashRegisterOutput> {\n    return this.executeRequest<void, CashRegisterOutput>('getById', undefined, {\n      pathParams: { id: registerId },\n      metadata: {\n        operation: 'get_cash_register',\n        registerId,\n      }\n    });\n  }\n\n  /**\n   * Get cash register configuration\n   * \n   * @param registerId - Cash register ID\n   * @returns Promise resolving to configuration\n   */\n  async getConfiguration(registerId: CashRegisterId | number): Promise<CashRegisterConfiguration> {\n    const register = await this.retrieve(registerId);\n    return CashRegistersResource.buildConfiguration(register);\n  }\n\n  /**\n   * Get cash register statistics\n   * \n   * @param registerId - Cash register ID\n   * @returns Promise resolving to statistics\n   */\n  async getStatistics(registerId: CashRegisterId | number): Promise<CashRegisterStats> {\n    const register = await this.retrieve(registerId);\n    return CashRegistersResource.calculateStatistics(register);\n  }\n\n  /**\n   * Update cash register settings (future enhancement)\n   */\n  async updateSettings(\n    registerId: CashRegisterId | number, \n    settings: Partial<CashRegisterSettings>\n  ): Promise<CashRegisterOutput> {\n    if (!this.hasOperation('update')) {\n      throw this.createUnsupportedOperationError('update');\n    }\n    \n    return this.executeRequest<Partial<CashRegisterSettings>, CashRegisterOutput>('update', settings, {\n      pathParams: { id: registerId },\n      metadata: {\n        operation: 'update_cash_register_settings',\n        registerId,\n      }\n    });\n  }\n\n  // Validation methods\n\n  /**\n   * Validate cash register input\n   */\n  private async validateCashRegisterInput(\n    data: CashRegisterInput, \n    options: CashRegisterValidationOptions = {}\n  ): Promise<void> {\n    const errors: Array<{ field: string; message: string; code: string }> = [];\n\n    // Serial number validation (using pem_serial_number from OpenAPI schema)\n    if (!data.pem_serial_number || data.pem_serial_number.trim().length === 0) {\n      errors.push({\n        field: 'serial_number',\n        message: 'Serial number is required',\n        code: 'REQUIRED'\n      });\n    } else if (options.validateSerialNumber) {\n      const serialValidation = CashRegistersResource.validateSerialNumber(data.pem_serial_number);\n      if (!serialValidation.isValid) {\n        errors.push({\n          field: 'serial_number',\n          message: serialValidation.error || 'Invalid serial number format',\n          code: 'INVALID_SERIAL_NUMBER'\n        });\n      }\n    }\n\n    // Name validation (location field not available in OpenAPI schema)\n    if (options.enforceLocationValidation) {\n      if (!data.name || data.name.trim().length === 0) {\n        errors.push({\n          field: 'name',\n          message: 'Name is required',\n          code: 'REQUIRED'\n        });\n      } else if (data.name.length > 100) {\n        errors.push({\n          field: 'name',\n          message: 'Name cannot exceed 100 characters',\n          code: 'TOO_LONG'\n        });\n      }\n    }\n\n    // Duplicate registration check\n    if (options.checkDuplicateRegistration) {\n      const isDuplicate = await this.checkDuplicateSerial(data.pem_serial_number);\n      if (isDuplicate) {\n        errors.push({\n          field: 'serial_number',\n          message: 'Cash register with this serial number is already registered',\n          code: 'DUPLICATE_SERIAL'\n        });\n      }\n    }\n\n    if (errors.length > 0) {\n      throw new ValidationError('Invalid cash register input', 'create_cash_register', errors);\n    }\n  }\n\n  /**\n   * Check for duplicate serial number\n   */\n  private async checkDuplicateSerial(serialNumber: string): Promise<boolean> {\n    try {\n      const registers = await this.list();\n      return registers.members.some(register => register.pem_serial_number === serialNumber);\n    } catch (error) {\n      console.warn(`Unable to check for duplicate serial number: ${error}`);\n      return false;\n    }\n  }\n\n  // Static utility methods\n\n  /**\n   * Validate serial number format\n   */\n  static validateSerialNumber(serialNumber: string): { isValid: boolean; error?: string } {\n    if (serialNumber.length < 6 || serialNumber.length > 20) {\n      return { isValid: false, error: 'Serial number must be between 6 and 20 characters' };\n    }\n\n    if (!/^[A-Z0-9-]+$/.test(serialNumber)) {\n      return { isValid: false, error: 'Serial number must contain only uppercase letters, numbers, and hyphens' };\n    }\n\n    return { isValid: true };\n  }\n\n  /**\n   * Build configuration from cash register data\n   */\n  static buildConfiguration(register: CashRegisterOutput): CashRegisterConfiguration {\n    return {\n      id: register.id as CashRegisterId,\n      name: register.name || `Cash Register ${register.id}`,\n      location: 'Unknown Location', // location field not available in OpenAPI schema\n      serialNumber: register.pem_serial_number,\n      model: 'Unknown Model', // model field not available in OpenAPI schema\n      manufacturer: 'Unknown Manufacturer', // manufacturer field not available in OpenAPI schema\n      installationDate: new Date().toISOString(), // installation_date field not available in OpenAPI schema\n      lastMaintenance: undefined, // last_maintenance field not available in OpenAPI schema\n      nextMaintenance: undefined, // next_maintenance field not available in OpenAPI schema\n      status: 'active' as CashRegisterStatus, // status field not available in OpenAPI schema\n      settings: this.getDefaultSettings(),\n    };\n  }\n\n  /**\n   * Get default settings for cash registers\n   */\n  static getDefaultSettings(): CashRegisterSettings {\n    return {\n      printReceipts: true,\n      enableLottery: true,\n      defaultVATRate: '22',\n      language: 'it',\n      currency: 'EUR',\n      timezone: 'Europe/Rome',\n      paperSize: 'thermal_80mm',\n      connectionType: 'ethernet',\n    };\n  }\n\n  /**\n   * Calculate statistics for a cash register\n   */\n  static calculateStatistics(register: CashRegisterOutput): CashRegisterStats {\n    // Mock statistics calculation (in reality, this would use historical data)\n    const mockTransactionCount = Math.floor(Math.random() * 1000) + 100;\n    const mockTotalAmount = (Math.random() * 50000 + 10000).toFixed(2);\n    const mockTodayTransactions = Math.floor(Math.random() * 50) + 10;\n    const mockTodayAmount = (Math.random() * 2000 + 500).toFixed(2);\n\n    return {\n      registerId: register.id as CashRegisterId,\n      totalTransactions: mockTransactionCount,\n      totalAmount: mockTotalAmount,\n      averageTransaction: (parseFloat(mockTotalAmount) / mockTransactionCount).toFixed(2),\n      transactionsToday: mockTodayTransactions,\n      amountToday: mockTodayAmount,\n      // lastTransaction field omitted since it's not available in OpenAPI schema\n      uptime: {\n        hours: 23.5,\n        percentage: 97.9,\n      },\n      errorCount: Math.floor(Math.random() * 5),\n      maintenanceScore: Math.floor(Math.random() * 20) + 80,\n    };\n  }\n\n  /**\n   * Format cash register for display\n   */\n  static formatForDisplay(register: CashRegisterOutput): {\n    displayName: string;\n    statusBadge: string;\n    location: string;\n    lastActivity: string;\n    serialNumber: string;\n  } {\n    return {\n      displayName: register.name || `Cash Register ${register.id}`,\n      statusBadge: 'ACTIVE', // status field not available in OpenAPI schema\n      location: 'Unknown Location', // location field not available in OpenAPI schema\n      lastActivity: 'Never', // last_activity field not available in OpenAPI schema\n      serialNumber: register.pem_serial_number || 'Unknown',\n    };\n  }\n\n  /**\n   * Generate maintenance schedule\n   */\n  static generateMaintenanceSchedule(_register: CashRegisterOutput): {\n    nextMaintenance: string;\n    maintenanceType: MaintenanceType;\n    priority: 'low' | 'medium' | 'high' | 'critical';\n    description: string;\n    estimatedDuration: string;\n  } {\n    const now = new Date();\n    \n    // Since last_maintenance field is not available in OpenAPI schema,\n    // return default routine maintenance schedule\n    return {\n      nextMaintenance: new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]!,\n      maintenanceType: 'routine',\n      priority: 'medium',\n      description: 'Routine maintenance and inspection',\n      estimatedDuration: '2 hours',\n    };\n  }\n\n  /**\n   * Validate cash register compatibility with PEM device\n   */\n  static validatePEMCompatibility(\n    register: CashRegisterOutput, \n    pemModel: string\n  ): {\n    compatible: boolean;\n    issues: string[];\n    recommendations: string[];\n  } {\n    // Suppress unused variable warning\n    void register;\n    const issues: string[] = [];\n    const recommendations: string[] = [];\n\n    // Note: connection_type, firmware_version, and power_consumption fields\n    // are not available in the OpenAPI schema, using mock validation\n    \n    // Mock compatibility check since actual fields are not available\n    if (pemModel.includes('legacy')) {\n      issues.push('Legacy PEM devices may have compatibility issues');\n      recommendations.push('Consider upgrading to newer PEM model');\n    }\n\n    return {\n      compatible: issues.length === 0,\n      issues,\n      recommendations,\n    };\n  }\n\n  /**\n   * Check if firmware is outdated\n   * @deprecated This method is not used since firmware_version is not available in OpenAPI schema\n   */\n  // private static isOutdatedFirmware(_version: string): boolean {\n  //   // Simple version comparison\n  //   const currentVersion = '3.2.0';\n  //   return _version < currentVersion;\n  // }\n\n  /**\n   * Generate health report for multiple cash registers\n   */\n  static generateFleetHealthReport(registers: CashRegisterOutput[]): {\n    totalRegisters: number;\n    activeRegisters: number;\n    registersNeedingMaintenance: number;\n    averageUptime: number;\n    totalTransactionsToday: number;\n    totalRevenueToday: string;\n    statusBreakdown: Record<CashRegisterStatus, number>;\n    topPerformers: { id: string; name: string; todayRevenue: string }[];\n  } {\n    const report = {\n      totalRegisters: registers.length,\n      activeRegisters: 0,\n      registersNeedingMaintenance: 0,\n      averageUptime: 0,\n      totalTransactionsToday: 0,\n      totalRevenueToday: '0.00',\n      statusBreakdown: {} as Record<CashRegisterStatus, number>,\n      topPerformers: [] as { id: string; name: string; todayRevenue: string }[],\n    };\n\n    let totalUptime = 0;\n    let totalRevenue = 0;\n    const performanceData: { id: string; name: string; revenue: number }[] = [];\n\n    for (const register of registers) {\n      // status field not available in OpenAPI schema, using mock status\n      const status: CashRegisterStatus = 'active';\n      \n      // Update status breakdown\n      report.statusBreakdown[status] = (report.statusBreakdown[status] || 0) + 1;\n\n      // Count active registers\n      if (status === 'active') {\n        report.activeRegisters++;\n      }\n\n      // Check maintenance needs\n      if (['maintenance', 'error'].includes(status)) {\n        report.registersNeedingMaintenance++;\n      }\n\n      // Calculate statistics\n      const stats = this.calculateStatistics(register);\n      totalUptime += stats.uptime.percentage;\n      report.totalTransactionsToday += stats.transactionsToday;\n      \n      const todayRevenue = parseFloat(stats.amountToday);\n      totalRevenue += todayRevenue;\n\n      performanceData.push({\n        id: register.id,\n        name: register.name || `Register ${register.id}`,\n        revenue: todayRevenue,\n      });\n    }\n\n    report.averageUptime = registers.length > 0 ? Math.round(totalUptime / registers.length) : 0;\n    report.totalRevenueToday = totalRevenue.toFixed(2);\n\n    // Get top 5 performers\n    report.topPerformers = performanceData\n      .sort((a, b) => b.revenue - a.revenue)\n      .slice(0, 5)\n      .map(item => ({\n        id: item.id,\n        name: item.name,\n        todayRevenue: item.revenue.toFixed(2),\n      }));\n\n    return report;\n  }\n\n  /**\n   * Generate installation checklist\n   */\n  static generateInstallationChecklist(): {\n    preInstallation: string[];\n    installation: string[];\n    postInstallation: string[];\n    testing: string[];\n  } {\n    return {\n      preInstallation: [\n        'Verify power supply requirements',\n        'Check network connectivity',\n        'Prepare installation location',\n        'Gather serial numbers and documentation',\n        'Backup existing configuration (if upgrading)',\n      ],\n      installation: [\n        'Mount cash register securely',\n        'Connect power supply',\n        'Establish network connection',\n        'Install required software/drivers',\n        'Configure basic settings',\n      ],\n      postInstallation: [\n        'Test all basic functions',\n        'Configure PEM device integration',\n        'Set up receipt printer',\n        'Configure tax settings',\n        'Train staff on operation',\n      ],\n      testing: [\n        'Process test transaction',\n        'Verify receipt printing',\n        'Test network connectivity',\n        'Validate tax calculations',\n        'Check integration with fiscal system',\n      ],\n    };\n  }\n\n  /**\n   * Destroy the resource and cleanup certificate manager\n   */\n  async destroy(): Promise<void> {\n    await this.certificateManager.destroy();\n  }\n}\n\n// Re-export for convenience\nexport { CashRegistersResource as CashRegisters };","/**\n * Merchants Resource - OpenAPI Implementation\n * Type-safe implementation for business entity management\n * \n * Features:\n * - Complete merchant lifecycle management\n * - Italian VAT number validation and verification\n * - Business address management\n * - Merchant profile and settings\n * - Compliance and certification tracking\n */\n\nimport { BaseOpenAPIResource } from '@/resources/base-openapi';\nimport { MerchantEndpoints } from '@/generated/endpoints';\nimport type { HttpClient } from '@/http/client';\nimport type { MerchantId, FiscalId } from '@/types/branded';\nimport type { components } from '@/types/generated';\nimport { ValidationError } from '@/errors/index';\n\n// Extract types from OpenAPI generated types\ntype MerchantCreateInput = components['schemas']['A-Cube_GOV-IT_PEL_Platform_Merchant.MerchantCreateInput'];\ntype MerchantUpdateInput = components['schemas']['A-Cube_GOV-IT_PEL_Platform_Merchant.MerchantUpdateInput'];\ntype MerchantOutput = components['schemas']['A-Cube_GOV-IT_PEL_Platform_Merchant.MerchantOutput'];\n\nexport interface MerchantValidationOptions {\n  validateVATNumber?: boolean;\n  checkBusinessRegistration?: boolean;\n  enforceAddressValidation?: boolean;\n  validateItalianPostalCodes?: boolean;\n}\n\nexport interface BusinessAnalytics {\n  registrationDate: string;\n  businessAge: number;\n  completenessScore: number;\n  missingFields: string[];\n  recommendations: string[];\n  complianceStatus: 'compliant' | 'pending' | 'non-compliant';\n}\n\nexport interface AddressValidationResult {\n  isValid: boolean;\n  errors: string[];\n  suggestions: string[];\n  formattedAddress?: string | undefined;\n}\n\nexport type BusinessType = 'individual' | 'partnership' | 'corporation' | 'cooperative' | 'other';\nexport type MerchantStatus = 'active' | 'pending' | 'suspended' | 'closed';\n\n/**\n * Merchants Resource Class - OpenAPI Based\n * Manages merchant business entities with full Italian compliance\n */\nexport class MerchantsResource extends BaseOpenAPIResource {\n  constructor(client: HttpClient) {\n    super({\n      client,\n      endpoints: {\n        list: MerchantEndpoints.LIST,\n        create: MerchantEndpoints.CREATE,\n        getByUuid: MerchantEndpoints.GET_BY_UUID,\n        update: MerchantEndpoints.UPDATE,\n      }\n    });\n  }\n\n  /**\n   * Get a list of merchants\n   * \n   * @returns Promise resolving to merchant list\n   */\n  async list(): Promise<MerchantOutput[]> {\n    return this.executeRequest<void, MerchantOutput[]>('list', undefined, {\n      metadata: {\n        operation: 'list_merchants',\n      }\n    });\n  }\n\n  /**\n   * Create a new merchant\n   * \n   * @param data - Merchant creation input data\n   * @param options - Validation options\n   * @returns Promise resolving to created merchant\n   */\n  async create(\n    data: MerchantCreateInput, \n    options: MerchantValidationOptions = {}\n  ): Promise<MerchantOutput> {\n    // Validate input with business rules\n    await this.validateMerchantCreateInput(data, options);\n\n    return this.executeRequest<MerchantCreateInput, MerchantOutput>('create', data, {\n      metadata: {\n        operation: 'create_merchant',\n        fiscalId: data.fiscal_id,\n        email: data.email,\n        businessName: data.name,\n      }\n    });\n  }\n\n  /**\n   * Get a merchant by UUID\n   * \n   * @param merchantId - Merchant UUID\n   * @returns Promise resolving to merchant details\n   */\n  async retrieve(merchantId: MerchantId | string): Promise<MerchantOutput> {\n    return this.executeRequest<void, MerchantOutput>('getByUuid', undefined, {\n      pathParams: { uuid: merchantId },\n      metadata: {\n        operation: 'get_merchant',\n        merchantId,\n      }\n    });\n  }\n\n  /**\n   * Update a merchant's information\n   * \n   * @param merchantId - Merchant UUID\n   * @param data - Merchant update input data\n   * @param options - Validation options\n   * @returns Promise resolving to updated merchant\n   */\n  async update(\n    merchantId: MerchantId | string, \n    data: MerchantUpdateInput,\n    options: MerchantValidationOptions = {}\n  ): Promise<MerchantOutput> {\n    await this.validateMerchantUpdateInput(data, options);\n\n    return this.executeRequest<MerchantUpdateInput, MerchantOutput>('update', data, {\n      pathParams: { uuid: merchantId },\n      metadata: {\n        operation: 'update_merchant',\n        merchantId,\n        businessName: data.name,\n      }\n    });\n  }\n\n  /**\n   * Get merchant business analytics\n   * \n   * @param merchantId - Merchant UUID\n   * @returns Promise resolving to business analytics\n   */\n  async getAnalytics(merchantId: MerchantId | string): Promise<BusinessAnalytics> {\n    const merchant = await this.retrieve(merchantId);\n    return MerchantsResource.analyzeBusinessProfile(merchant);\n  }\n\n  /**\n   * Validate merchant address\n   * \n   * @param address - Address to validate\n   * @returns Address validation result\n   */\n  async validateAddress(address: components['schemas']['A-Cube_GOV-IT_PEL_Platform_Address']): Promise<AddressValidationResult> {\n    return MerchantsResource.validateItalianAddress(address);\n  }\n\n  // Validation methods\n\n  /**\n   * Comprehensive merchant creation input validation\n   */\n  private async validateMerchantCreateInput(\n    data: MerchantCreateInput, \n    options: MerchantValidationOptions = {}\n  ): Promise<void> {\n    const errors: Array<{ field: string; message: string; code: string }> = [];\n\n    // Required fields validation\n    if (!data.fiscal_id) {\n      errors.push({\n        field: 'fiscal_id',\n        message: 'Fiscal ID is required',\n        code: 'REQUIRED'\n      });\n    } else if (options.validateVATNumber) {\n      const vatValidation = await this.validateItalianVATNumber(data.fiscal_id);\n      if (!vatValidation.isValid) {\n        errors.push({\n          field: 'fiscal_id',\n          message: vatValidation.error || 'Invalid Italian VAT number',\n          code: 'INVALID_VAT_NUMBER'\n        });\n      }\n    }\n\n    if (!data.name || data.name.trim().length === 0) {\n      errors.push({\n        field: 'name',\n        message: 'Business name is required',\n        code: 'REQUIRED'\n      });\n    } else {\n      const nameValidation = this.validateBusinessName(data.name);\n      if (!nameValidation.isValid) {\n        errors.push({\n          field: 'name',\n          message: nameValidation.error || 'Invalid business name',\n          code: 'INVALID_BUSINESS_NAME'\n        });\n      }\n    }\n\n    if (!data.email) {\n      errors.push({\n        field: 'email',\n        message: 'Email is required',\n        code: 'REQUIRED'\n      });\n    } else if (!this.isValidEmail(data.email)) {\n      errors.push({\n        field: 'email',\n        message: 'Invalid email format',\n        code: 'INVALID_EMAIL'\n      });\n    }\n\n    if (!data.password) {\n      errors.push({\n        field: 'password',\n        message: 'Password is required',\n        code: 'REQUIRED'\n      });\n    } else {\n      const passwordValidation = this.validatePassword(data.password);\n      if (!passwordValidation.isValid) {\n        errors.push({\n          field: 'password',\n          message: passwordValidation.error || 'Password does not meet requirements',\n          code: 'WEAK_PASSWORD'\n        });\n      }\n    }\n\n    // Address validation if provided\n    if (data.address && options.enforceAddressValidation) {\n      const addressValidation = await MerchantsResource.validateItalianAddress(data.address);\n      if (!addressValidation.isValid) {\n        errors.push(...addressValidation.errors.map(error => ({\n          field: 'address',\n          message: error,\n          code: 'INVALID_ADDRESS'\n        })));\n      }\n    }\n\n    if (errors.length > 0) {\n      throw new ValidationError('Invalid merchant create input', 'create_merchant', errors);\n    }\n  }\n\n  /**\n   * Merchant update input validation\n   */\n  private async validateMerchantUpdateInput(\n    data: MerchantUpdateInput, \n    options: MerchantValidationOptions = {}\n  ): Promise<void> {\n    const errors: Array<{ field: string; message: string; code: string }> = [];\n\n    // Business name validation\n    if (!data.name || data.name.trim().length === 0) {\n      errors.push({\n        field: 'name',\n        message: 'Business name is required',\n        code: 'REQUIRED'\n      });\n    } else {\n      const nameValidation = this.validateBusinessName(data.name);\n      if (!nameValidation.isValid) {\n        errors.push({\n          field: 'name',\n          message: nameValidation.error || 'Invalid business name',\n          code: 'INVALID_BUSINESS_NAME'\n        });\n      }\n    }\n\n    // Address validation if provided\n    if (data.address && options.enforceAddressValidation) {\n      const addressValidation = await MerchantsResource.validateItalianAddress(data.address);\n      if (!addressValidation.isValid) {\n        errors.push(...addressValidation.errors.map(error => ({\n          field: 'address',\n          message: error,\n          code: 'INVALID_ADDRESS'\n        })));\n      }\n    }\n\n    if (errors.length > 0) {\n      throw new ValidationError('Invalid merchant update input', 'update_merchant', errors);\n    }\n  }\n\n  /**\n   * Validate Italian VAT number with checksum\n   */\n  private async validateItalianVATNumber(vatNumber: string): Promise<{ isValid: boolean; error?: string }> {\n    if (!MerchantsResource.isValidItalianVATNumber(vatNumber)) {\n      return { isValid: false, error: 'Invalid Italian VAT number format or checksum' };\n    }\n\n    // Additional online validation could be implemented here\n    // For now, we'll just check the format and checksum\n    return { isValid: true };\n  }\n\n  /**\n   * Validate business name\n   */\n  private validateBusinessName(name: string): { isValid: boolean; error?: string } {\n    if (name.length > 200) {\n      return { isValid: false, error: 'Business name cannot exceed 200 characters' };\n    }\n\n    if (!/^[\\w\\s&.,'()\\-]+$/u.test(name)) {\n      return { isValid: false, error: 'Business name contains invalid characters' };\n    }\n\n    // Check for suspicious patterns\n    if (/test|example|sample/i.test(name)) {\n      console.warn(`Potentially test business name detected: ${name}`);\n    }\n\n    return { isValid: true };\n  }\n\n  /**\n   * Validate password strength\n   */\n  private validatePassword(password: string): { isValid: boolean; error?: string } {\n    if (password.length < 8) {\n      return { isValid: false, error: 'Password must be at least 8 characters long' };\n    }\n\n    if (!/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/.test(password)) {\n      return { isValid: false, error: 'Password must contain uppercase, lowercase, and numeric characters' };\n    }\n\n    return { isValid: true };\n  }\n\n  /**\n   * Validate email format\n   */\n  private isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  // Static utility methods\n\n  /**\n   * Validate Italian VAT number (static utility)\n   */\n  static isValidItalianVATNumber(vatNumber: string): boolean {\n    // Must be exactly 11 digits\n    if (!/^\\d{11}$/.test(vatNumber)) {\n      return false;\n    }\n\n    // Calculate checksum for Italian VAT number\n    let sum = 0;\n    for (let i = 0; i < 10; i++) {\n      let digit = parseInt(vatNumber[i]!, 10);\n      if (i % 2 === 1) {\n        digit *= 2;\n        if (digit > 9) {\n          digit = Math.floor(digit / 10) + (digit % 10);\n        }\n      }\n      sum += digit;\n    }\n\n    const checkDigit = (10 - (sum % 10)) % 10;\n    return checkDigit === parseInt(vatNumber[10]!, 10);\n  }\n\n  /**\n   * Format fiscal ID for display\n   */\n  static formatFiscalId(fiscalId: FiscalId | string): string {\n    // Format as XXX XXX XXXXX for readability\n    return fiscalId.replace(/(\\d{3})(\\d{3})(\\d{5})/, '$1 $2 $3');\n  }\n\n  /**\n   * Validate Italian address\n   */\n  static async validateItalianAddress(address: components['schemas']['A-Cube_GOV-IT_PEL_Platform_Address']): Promise<AddressValidationResult> {\n    const errors: string[] = [];\n    const suggestions: string[] = [];\n\n    if (!address.street_address || address.street_address.trim().length === 0) {\n      errors.push('Street address is required');\n    }\n\n    if (!address.zip_code || !/^\\d{5}$/.test(address.zip_code)) {\n      errors.push('ZIP code must be exactly 5 digits');\n    } else {\n      // Basic Italian postal code validation\n      const zipCode = parseInt(address.zip_code, 10);\n      if (zipCode < 10000 || zipCode > 98168) {\n        errors.push('Invalid Italian postal code range');\n      }\n    }\n\n    if (!address.city || address.city.trim().length === 0) {\n      errors.push('City is required');\n    }\n\n    if (!address.province || address.province.length !== 2) {\n      errors.push('Province must be exactly 2 characters');\n    } else {\n      // Validate against Italian province codes\n      const validProvinces = [\n        'AG', 'AL', 'AN', 'AO', 'AQ', 'AR', 'AP', 'AT', 'AV', 'BA', 'BT', 'BL', 'BN', 'BG', 'BI', 'BO', 'BZ', 'BS', 'BR',\n        'CA', 'CL', 'CB', 'CI', 'CE', 'CT', 'CZ', 'CH', 'CO', 'CS', 'CR', 'KR', 'CN', 'EN', 'FM', 'FE', 'FI', 'FG', 'FC',\n        'FR', 'GE', 'GO', 'GR', 'IM', 'IS', 'SP', 'LT', 'LE', 'LC', 'LI', 'LO', 'LU', 'MC', 'MN', 'MS', 'MT', 'VS', 'ME',\n        'MI', 'MO', 'MB', 'NA', 'NO', 'NU', 'OG', 'OT', 'OR', 'PD', 'PA', 'PR', 'PV', 'PG', 'PU', 'PE', 'PC', 'PI', 'PT',\n        'PN', 'PZ', 'PO', 'RG', 'RA', 'RC', 'RE', 'RI', 'RN', 'RM', 'RO', 'SA', 'SS', 'SV', 'SI', 'SR', 'SO', 'TA', 'TE',\n        'TR', 'TO', 'TP', 'TN', 'TV', 'TS', 'UD', 'VA', 'VE', 'VB', 'VC', 'VR', 'VV', 'VI', 'VT'\n      ];\n      \n      if (!validProvinces.includes(address.province.toUpperCase())) {\n        errors.push('Invalid Italian province code');\n        suggestions.push('Please use a valid Italian province code (e.g., RM for Rome, MI for Milan)');\n      }\n    }\n\n    const isValid = errors.length === 0;\n    const formattedAddress = isValid ? \n      `${address.street_address}, ${address.zip_code} ${address.city} (${address.province.toUpperCase()})` : \n      undefined;\n\n    return {\n      isValid,\n      errors,\n      suggestions,\n      formattedAddress,\n    };\n  }\n\n  /**\n   * Analyze business profile completeness and compliance\n   */\n  static analyzeBusinessProfile(merchant: MerchantOutput): BusinessAnalytics {\n    const missingFields: string[] = [];\n    const recommendations: string[] = [];\n    let completenessScore = 0;\n    const totalFields = 6; // Total number of important fields\n\n    // Check required fields\n    if (merchant.fiscal_id) completenessScore++;\n    else missingFields.push('fiscal_id');\n\n    if (merchant.name) completenessScore++;\n    else missingFields.push('name');\n\n    if (merchant.email) completenessScore++;\n    else missingFields.push('email');\n\n    if (merchant.address) {\n      completenessScore++;\n      // Check address completeness\n      if (!merchant.address.street_address) {\n        missingFields.push('address.street_address');\n        recommendations.push('Add complete street address for legal compliance');\n      }\n      if (!merchant.address.zip_code) {\n        missingFields.push('address.zip_code');\n      }\n      if (!merchant.address.city) {\n        missingFields.push('address.city');\n      }\n      if (!merchant.address.province) {\n        missingFields.push('address.province');\n      }\n    } else {\n      missingFields.push('address');\n      recommendations.push('Add complete business address for legal compliance');\n    }\n\n    // Business age calculation (mock implementation)\n    // Note: created_at field not available in OpenAPI schema\n    const registrationDate = new Date().toISOString();\n    const businessAge = Math.floor((Date.now() - new Date(registrationDate).getTime()) / (1000 * 60 * 60 * 24));\n\n    // Generate recommendations\n    if (completenessScore < totalFields) {\n      recommendations.push('Complete all required business information');\n    }\n\n    // Note: phone and website fields not available in OpenAPI schema\n    // Using mock recommendations\n    recommendations.push('Add phone number for better customer communication');\n    recommendations.push('Add website URL to improve business presence');\n\n    // Determine compliance status\n    let complianceStatus: 'compliant' | 'pending' | 'non-compliant' = 'compliant';\n    if (missingFields.length > 0) {\n      complianceStatus = missingFields.length > 2 ? 'non-compliant' : 'pending';\n    }\n\n    return {\n      registrationDate,\n      businessAge,\n      completenessScore: Math.round((completenessScore / totalFields) * 100),\n      missingFields,\n      recommendations,\n      complianceStatus,\n    };\n  }\n\n  /**\n   * Generate business summary\n   */\n  static generateBusinessSummary(merchant: MerchantOutput): string {\n    const addressPart = merchant.address \n      ? ` - ${merchant.address.city}, ${merchant.address.province}`\n      : '';\n    \n    return `${merchant.name} (VAT: ${this.formatFiscalId(merchant.fiscal_id || '')})${addressPart}`;\n  }\n\n  /**\n   * Validate business name format (static utility)\n   */\n  static isValidBusinessName(name: string): boolean {\n    return typeof name === 'string' && \n           name.trim().length > 0 && \n           name.length <= 200 && \n           /^[\\w\\s&.,'()\\-]+$/u.test(name);\n  }\n\n  /**\n   * Normalize business name\n   */\n  static normalizeBusinessName(name: string): string {\n    return name\n      .trim()\n      .replace(/\\s+/g, ' ')\n      .replace(/^\\\\w/, c => c.toUpperCase());\n  }\n\n  /**\n   * Extract province code from address\n   */\n  static getProvinceCode(merchant: MerchantOutput): string | null {\n    return merchant.address?.province || null;\n  }\n\n  /**\n   * Check if merchant is based in specific region\n   */\n  static isInRegion(merchant: MerchantOutput, regionProvinces: string[]): boolean {\n    const province = this.getProvinceCode(merchant);\n    return province ? regionProvinces.includes(province.toUpperCase()) : false;\n  }\n\n  /**\n   * Get Italian business regions\n   */\n  static getItalianRegions(): Record<string, string[]> {\n    return {\n      'Northern Italy': ['AO', 'TO', 'CN', 'AT', 'AL', 'VC', 'BI', 'NO', 'VB', 'VA', 'CO', 'SO', 'MI', 'MB', 'BG', 'BS', 'PV', 'CR', 'MN', 'LO', 'LC', 'BZ', 'TN', 'VR', 'VI', 'BL', 'TV', 'VE', 'PD', 'RO', 'UD', 'PN', 'TS', 'GO', 'PC', 'PR', 'RE', 'MO', 'BO', 'FE', 'RA', 'FC', 'RN', 'GE', 'SV', 'IM', 'SP', 'MS'],\n      'Central Italy': ['LU', 'PT', 'FI', 'LI', 'PI', 'AR', 'SI', 'GR', 'PO', 'PG', 'TR', 'VT', 'RI', 'RM', 'LT', 'FR', 'AQ', 'TE', 'PE', 'CH', 'MC', 'AP', 'AN', 'PU', 'FM'],\n      'Southern Italy': ['CB', 'IS', 'CE', 'BN', 'NA', 'AV', 'SA', 'FG', 'BT', 'BA', 'BR', 'TA', 'MT', 'PZ', 'CS', 'CZ', 'VV', 'RC', 'KR'],\n      'Islands': ['PA', 'ME', 'AG', 'CL', 'EN', 'CT', 'RG', 'SR', 'TP', 'CA', 'CI', 'VS', 'NU', 'OG', 'OR', 'SS', 'OT']\n    };\n  }\n\n  /**\n   * Determine merchant region\n   */\n  static getMerchantRegion(merchant: MerchantOutput): string | null {\n    const province = this.getProvinceCode(merchant);\n    if (!province) return null;\n\n    const regions = this.getItalianRegions();\n    for (const [region, provinces] of Object.entries(regions)) {\n      if (provinces.includes(province.toUpperCase())) {\n        return region;\n      }\n    }\n\n    return null;\n  }\n}\n\n// Re-export for convenience\nexport { MerchantsResource as Merchants };\n\n// Export types for external use\nexport type {\n  MerchantCreateInput,\n  MerchantUpdateInput,\n  MerchantOutput,\n};","/**\n * PEMs Resource - OpenAPI Implementation\n * Type-safe implementation for Point of Sale Module certificate management\n * \n * Features:\n * - PEM certificate lifecycle management\n * - Point of Sale creation and configuration\n * - Certificate validation and renewal\n * - Compliance and audit tracking\n */\n\nimport { BaseOpenAPIResource } from '@/resources/base-openapi';\nimport { PEMEndpoints } from '@/generated/endpoints';\nimport type { HttpClient } from '@/http/client';\nimport type { PEMId } from '@/types/branded';\nimport type { components } from '@/types/generated';\nimport { ValidationError, FiscalError } from '@/errors/index';\n\n// Extract types from OpenAPI generated types\ntype PointOfSaleCreateInput = components['schemas']['A-Cube_GOV-IT_PEL_Platform_Pem.PemCreateInput'];\ntype PointOfSaleOutput = components['schemas']['A-Cube_GOV-IT_PEL_Platform_Pem.PemCreateOutput'];\ntype PEMCertificatesOutput = components['schemas']['A-Cube_GOV-IT_PEL_Platform_Pem.PemCertificatesOutput'];\n\nexport interface PEMValidationOptions {\n  validateCertificateChain?: boolean;\n  checkExpirationDate?: boolean;\n  enforceComplianceRules?: boolean;\n  validateSignatures?: boolean;\n}\n\nexport interface CertificateInfo {\n  id: string;\n  type: CertificateType;\n  status: CertificateStatus;\n  issuer: string;\n  subject: string;\n  validFrom: string;\n  validTo: string;\n  serialNumber: string;\n  fingerprint: string;\n  keyUsage: string[];\n  issuedFor: string;\n}\n\nexport interface CertificateChain {\n  root: CertificateInfo;\n  intermediate?: CertificateInfo[];\n  leaf: CertificateInfo;\n  validationResults: {\n    chainValid: boolean;\n    rootTrusted: boolean;\n    notExpired: boolean;\n    revocationChecked: boolean;\n    issues: string[];\n  };\n}\n\nexport interface PEMConfiguration {\n  pemId: PEMId;\n  deviceSerialNumber: string;\n  certificates: CertificateInfo[];\n  configuration: {\n    fiscalMemorySize: string;\n    supportedOperations: string[];\n    maxDailyTransactions: number;\n    complianceVersion: string;\n  };\n  status: PEMStatus;\n  lastAudit?: string;\n  nextCertificateRenewal?: string;\n}\n\nexport type CertificateType = 'root' | 'intermediate' | 'device' | 'signing' | 'encryption';\nexport type CertificateStatus = 'valid' | 'expired' | 'revoked' | 'pending' | 'invalid';\nexport type PEMStatus = 'active' | 'inactive' | 'maintenance' | 'compliance_check' | 'certificate_renewal';\nexport type ComplianceLevel = 'full' | 'partial' | 'non_compliant' | 'under_review';\n\n/**\n * PEMs Resource Class - OpenAPI Based\n * Manages PEM devices and certificates with full Italian compliance\n */\nexport class PEMsResource extends BaseOpenAPIResource {\n  constructor(client: HttpClient) {\n    super({\n      client,\n      endpoints: {\n        createPOS: PEMEndpoints.CREATE_POS,\n        getCertificates: PEMEndpoints.GET_CERTIFICATES,\n      }\n    });\n  }\n\n  /**\n   * Create a new Point of Sale\n   * \n   * @param data - Point of Sale creation input data\n   * @param options - Validation options\n   * @returns Promise resolving to created Point of Sale\n   */\n  async createPointOfSale(\n    data: PointOfSaleCreateInput, \n    options: PEMValidationOptions = {}\n  ): Promise<PointOfSaleOutput> {\n    // Validate input\n    await this.validatePointOfSaleInput(data, options);\n\n    return this.executeRequest<PointOfSaleCreateInput, PointOfSaleOutput>('createPOS', data, {\n      metadata: {\n        operation: 'create_point_of_sale',\n        merchantUuid: data.merchant_uuid,\n        addressProvided: !!data.address,\n      }\n    });\n  }\n\n  /**\n   * Get certificates for a Point of Sale\n   * \n   * @param posId - Point of Sale ID\n   * @returns Promise resolving to certificate information\n   */\n  async getCertificates(posId: PEMId | string): Promise<CertificateInfo[]> {\n    const response = await this.executeRequest<void, PEMCertificatesOutput>('getCertificates', undefined, {\n      pathParams: { id: posId },\n      metadata: {\n        operation: 'get_pem_certificates',\n        posId,\n      }\n    });\n\n    // Transform response to CertificateInfo format\n    return this.parseCertificateResponse(response);\n  }\n\n  /**\n   * Validate certificate chain for a PEM device\n   * \n   * @param posId - Point of Sale ID\n   * @returns Promise resolving to certificate chain validation\n   */\n  async validateCertificateChain(posId: PEMId | string): Promise<CertificateChain> {\n    const certificates = await this.getCertificates(posId);\n    return PEMsResource.buildCertificateChain(certificates);\n  }\n\n  /**\n   * Get PEM configuration and status\n   * \n   * @param posId - Point of Sale ID\n   * @returns Promise resolving to PEM configuration\n   */\n  async getConfiguration(posId: PEMId | string): Promise<PEMConfiguration> {\n    const certificates = await this.getCertificates(posId);\n    return PEMsResource.buildPEMConfiguration(posId, certificates);\n  }\n\n  /**\n   * Check compliance status for a PEM device\n   * \n   * @param posId - Point of Sale ID\n   * @returns Promise resolving to compliance assessment\n   */\n  async checkCompliance(posId: PEMId | string): Promise<{\n    level: ComplianceLevel;\n    score: number;\n    issues: string[];\n    recommendations: string[];\n    lastCheck: string;\n    nextCheck: string;\n  }> {\n    const config = await this.getConfiguration(posId);\n    return PEMsResource.assessCompliance(config);\n  }\n\n  /**\n   * Request certificate renewal for a PEM device\n   * \n   * @param posId - Point of Sale ID\n   * @param certificateType - Type of certificate to renew\n   * @returns Promise resolving when renewal is initiated\n   */\n  async requestCertificateRenewal(\n    _posId: PEMId | string, \n    _certificateType: CertificateType = 'device'\n  ): Promise<{ renewalId: string; estimatedCompletion: string }> {\n    // This would typically call a specific renewal endpoint\n    // For now, return a mock response\n    return {\n      renewalId: `renewal_${Date.now()}`,\n      estimatedCompletion: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),\n    };\n  }\n\n  // Validation methods\n\n  /**\n   * Validate Point of Sale input\n   */\n  private async validatePointOfSaleInput(\n    data: PointOfSaleCreateInput, \n    _options: PEMValidationOptions = {}\n  ): Promise<void> {\n    const errors: Array<{ field: string; message: string; code: string }> = [];\n\n    // Basic validation\n    if (!data.merchant_uuid || data.merchant_uuid.trim().length === 0) {\n      errors.push({\n        field: 'merchant_uuid',\n        message: 'Merchant UUID is required',\n        code: 'REQUIRED'\n      });\n    }\n\n    if (!data.address) {\n      errors.push({\n        field: 'address',\n        message: 'Address is required for PEM registration',\n        code: 'REQUIRED'\n      });\n    } else {\n      const addressErrors = this.validateAddress(data.address);\n      errors.push(...addressErrors);\n    }\n\n    // Certificate validation - certificates field not available in OpenAPI schema\n    // Commenting out until field is available\n    // if (data.certificates && options.validateCertificateChain) {\n    //   const certErrors = await this.validateCertificates(data.certificates);\n    //   errors.push(...certErrors);\n    // }\n\n    if (errors.length > 0) {\n      throw new ValidationError('Invalid Point of Sale input', 'create_point_of_sale', errors);\n    }\n  }\n\n  /**\n   * Validate address information\n   */\n  private validateAddress(address: components['schemas']['A-Cube_GOV-IT_PEL_Platform_Address']): Array<{ field: string; message: string; code: string }> {\n    const errors: Array<{ field: string; message: string; code: string }> = [];\n\n    if (!address.street_address) {\n      errors.push({\n        field: 'address.street_address',\n        message: 'Street address is required',\n        code: 'REQUIRED'\n      });\n    }\n\n    if (!address.city) {\n      errors.push({\n        field: 'address.city',\n        message: 'City is required',\n        code: 'REQUIRED'\n      });\n    }\n\n    if (!address.zip_code || !/^\\d{5}$/.test(address.zip_code)) {\n      errors.push({\n        field: 'address.zip_code',\n        message: 'Valid 5-digit ZIP code is required',\n        code: 'INVALID_FORMAT'\n      });\n    }\n\n    if (!address.province || address.province.length !== 2) {\n      errors.push({\n        field: 'address.province',\n        message: 'Valid 2-character province code is required',\n        code: 'INVALID_FORMAT'\n      });\n    }\n\n    return errors;\n  }\n\n  /**\n   * Validate certificates\n   * @deprecated This method is not used since certificates field is not available in OpenAPI schema\n   */\n  // private async validateCertificates(certificates: CertificateInfo[]): Promise<Array<{ field: string; message: string; code: string }>> {\n  //   const errors: Array<{ field: string; message: string; code: string }> = [];\n\n  //   for (let i = 0; i < certificates.length; i++) {\n  //     const cert = certificates[i];\n  //     if (!cert) continue;\n      \n  //     if (!cert.type || !['root', 'intermediate', 'device', 'signing', 'encryption'].includes(cert.type)) {\n  //       errors.push({\n  //         field: `certificates[${i}].type`,\n  //         message: 'Invalid certificate type',\n  //         code: 'INVALID_CERTIFICATE_TYPE'\n  //       });\n  //     }\n\n  //     if (!cert.validTo || new Date(cert.validTo) <= new Date()) {\n  //       errors.push({\n  //         field: `certificates[${i}].validTo`,\n  //         message: 'Certificate is expired or expiring soon',\n  //         code: 'CERTIFICATE_EXPIRED'\n  //       });\n  //     }\n  //   }\n\n  //   return errors;\n  // }\n\n  /**\n   * Parse certificate response from API\n   */\n  private parseCertificateResponse(response: PEMCertificatesOutput): CertificateInfo[] {\n    // Transform API response to CertificateInfo format\n    if (!response) {\n      return [];\n    }\n\n    const certificates: CertificateInfo[] = [];\n    \n    // Parse the MTLS certificate if available\n    if (response.mtls_certificate) {\n      certificates.push({\n        id: 'mtls_cert',\n        type: 'device',\n        status: 'valid',\n        issuer: 'Italian Tax Agency',\n        subject: 'PEM Device',\n        validFrom: new Date().toISOString(),\n        validTo: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(),\n        serialNumber: 'MTLS001',\n        fingerprint: response.mtls_certificate.substring(0, 40),\n        keyUsage: ['digitalSignature', 'keyEncipherment'],\n        issuedFor: 'PEM Device',\n      });\n    }\n\n    return certificates;\n  }\n\n  // Static utility methods\n\n  /**\n   * Build certificate chain from individual certificates\n   */\n  static buildCertificateChain(certificates: CertificateInfo[]): CertificateChain {\n    const root = certificates.find(cert => cert.type === 'root');\n    const intermediate = certificates.filter(cert => cert.type === 'intermediate');\n    const leaf = certificates.find(cert => cert.type === 'device') || certificates[0];\n\n    if (!root || !leaf) {\n      throw new FiscalError('Invalid certificate chain: missing root or leaf certificate', 'build_certificate_chain');\n    }\n\n    const validationResults = this.validateCertificateChain(certificates);\n\n    return {\n      root,\n      intermediate,\n      leaf,\n      validationResults,\n    };\n  }\n\n  /**\n   * Validate certificate chain integrity\n   */\n  private static validateCertificateChain(certificates: CertificateInfo[]): {\n    chainValid: boolean;\n    rootTrusted: boolean;\n    notExpired: boolean;\n    revocationChecked: boolean;\n    issues: string[];\n  } {\n    const issues: string[] = [];\n    const now = new Date();\n\n    // Check for expired certificates\n    const expiredCerts = certificates.filter(cert => new Date(cert.validTo) <= now);\n    if (expiredCerts.length > 0) {\n      issues.push(`${expiredCerts.length} certificate(s) are expired`);\n    }\n\n    // Check for revoked certificates\n    const revokedCerts = certificates.filter(cert => cert.status === 'revoked');\n    if (revokedCerts.length > 0) {\n      issues.push(`${revokedCerts.length} certificate(s) are revoked`);\n    }\n\n    // Check chain completeness\n    const hasRoot = certificates.some(cert => cert.type === 'root');\n    const hasLeaf = certificates.some(cert => cert.type === 'device');\n    if (!hasRoot) issues.push('Missing root certificate');\n    if (!hasLeaf) issues.push('Missing device certificate');\n\n    return {\n      chainValid: hasRoot && hasLeaf && issues.length === 0,\n      rootTrusted: hasRoot,\n      notExpired: expiredCerts.length === 0,\n      revocationChecked: true, // Mock implementation\n      issues,\n    };\n  }\n\n  /**\n   * Build PEM configuration from certificates\n   */\n  static buildPEMConfiguration(posId: PEMId | string, certificates: CertificateInfo[]): PEMConfiguration {\n    const deviceCert = certificates.find(cert => cert.type === 'device');\n    const now = new Date();\n\n    return {\n      pemId: posId as PEMId,\n      deviceSerialNumber: deviceCert?.serialNumber || 'unknown',\n      certificates,\n      configuration: {\n        fiscalMemorySize: '32MB',\n        supportedOperations: ['sale', 'return', 'void', 'daily_close'],\n        maxDailyTransactions: 1000,\n        complianceVersion: '2.1.0',\n      },\n      status: this.determinePEMStatus(certificates),\n      lastAudit: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000).toISOString(),\n      nextCertificateRenewal: this.calculateNextRenewal(certificates),\n    };\n  }\n\n  /**\n   * Determine PEM status based on certificates\n   */\n  private static determinePEMStatus(certificates: CertificateInfo[]): PEMStatus {\n    const now = new Date();\n    const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);\n\n    // Check for expired certificates\n    const hasExpired = certificates.some(cert => new Date(cert.validTo) <= now);\n    if (hasExpired) return 'maintenance';\n\n    // Check for certificates expiring soon\n    const hasExpiringSoon = certificates.some(cert => new Date(cert.validTo) <= thirtyDaysFromNow);\n    if (hasExpiringSoon) return 'certificate_renewal';\n\n    // Check for revoked certificates\n    const hasRevoked = certificates.some(cert => cert.status === 'revoked');\n    if (hasRevoked) return 'compliance_check';\n\n    return 'active';\n  }\n\n  /**\n   * Calculate next certificate renewal date\n   */\n  private static calculateNextRenewal(certificates: CertificateInfo[]): string {\n    if (certificates.length === 0) return new Date().toISOString();\n\n    const earliestExpiry = certificates\n      .map(cert => new Date(cert.validTo))\n      .sort((a, b) => a.getTime() - b.getTime())[0];\n\n    if (!earliestExpiry) {\n      return new Date().toISOString();\n    }\n\n    // Schedule renewal 60 days before expiry\n    const renewalDate = new Date(earliestExpiry.getTime() - 60 * 24 * 60 * 60 * 1000);\n    return renewalDate.toISOString();\n  }\n\n  /**\n   * Assess compliance level\n   */\n  static assessCompliance(config: PEMConfiguration): {\n    level: ComplianceLevel;\n    score: number;\n    issues: string[];\n    recommendations: string[];\n    lastCheck: string;\n    nextCheck: string;\n  } {\n    const issues: string[] = [];\n    const recommendations: string[] = [];\n    let score = 100;\n\n    // Check certificate status\n    const expiredCerts = config.certificates.filter(cert => new Date(cert.validTo) <= new Date());\n    if (expiredCerts.length > 0) {\n      score -= 30;\n      issues.push(`${expiredCerts.length} expired certificate(s)`);\n      recommendations.push('Renew expired certificates immediately');\n    }\n\n    const expiringSoon = config.certificates.filter(cert => {\n      const expiryDate = new Date(cert.validTo);\n      const thirtyDaysFromNow = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);\n      return expiryDate <= thirtyDaysFromNow && expiryDate > new Date();\n    });\n\n    if (expiringSoon.length > 0) {\n      score -= 15;\n      issues.push(`${expiringSoon.length} certificate(s) expiring within 30 days`);\n      recommendations.push('Schedule certificate renewal');\n    }\n\n    // Check audit compliance\n    if (config.lastAudit) {\n      const lastAuditDate = new Date(config.lastAudit);\n      const sixMonthsAgo = new Date(Date.now() - 180 * 24 * 60 * 60 * 1000);\n      \n      if (lastAuditDate < sixMonthsAgo) {\n        score -= 20;\n        issues.push('Audit overdue (last audit more than 6 months ago)');\n        recommendations.push('Schedule compliance audit');\n      }\n    } else {\n      score -= 25;\n      issues.push('No audit history found');\n      recommendations.push('Conduct initial compliance audit');\n    }\n\n    // Determine compliance level\n    let level: ComplianceLevel = 'full';\n    if (score < 70) level = 'non_compliant';\n    else if (score < 85) level = 'partial';\n    else if (issues.length > 0) level = 'under_review';\n\n    const now = new Date();\n    return {\n      level,\n      score: Math.max(0, score),\n      issues,\n      recommendations,\n      lastCheck: now.toISOString(),\n      nextCheck: new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n    };\n  }\n\n  /**\n   * Format certificate for display\n   */\n  static formatCertificateForDisplay(cert: CertificateInfo): {\n    displayName: string;\n    statusBadge: string;\n    validity: string;\n    issuerShort: string;\n    expiresIn: string;\n  } {\n    const now = new Date();\n    const expiryDate = new Date(cert.validTo);\n    const daysUntilExpiry = Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));\n\n    return {\n      displayName: `${cert.type.toUpperCase()} Certificate`,\n      statusBadge: cert.status.toUpperCase(),\n      validity: `${cert.validFrom.split('T')[0]} to ${cert.validTo.split('T')[0]}`,\n      issuerShort: cert.issuer.split(',')[0] || cert.issuer,\n      expiresIn: daysUntilExpiry > 0 ? `${daysUntilExpiry} days` : 'Expired',\n    };\n  }\n\n  /**\n   * Generate certificate summary report\n   */\n  static generateCertificateSummary(certificates: CertificateInfo[]): {\n    totalCertificates: number;\n    validCertificates: number;\n    expiredCertificates: number;\n    expiringSoon: number;\n    revokedCertificates: number;\n    typeBreakdown: Record<CertificateType, number>;\n    nextExpiry: string | null;\n  } {\n    const now = new Date();\n    const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);\n\n    const summary = {\n      totalCertificates: certificates.length,\n      validCertificates: 0,\n      expiredCertificates: 0,\n      expiringSoon: 0,\n      revokedCertificates: 0,\n      typeBreakdown: {} as Record<CertificateType, number>,\n      nextExpiry: null as string | null,\n    };\n\n    let earliestExpiry: Date | null = null;\n\n    for (const cert of certificates) {\n      const expiryDate = new Date(cert.validTo);\n\n      // Count by status\n      if (cert.status === 'revoked') {\n        summary.revokedCertificates++;\n      } else if (expiryDate <= now) {\n        summary.expiredCertificates++;\n      } else if (expiryDate <= thirtyDaysFromNow) {\n        summary.expiringSoon++;\n      } else {\n        summary.validCertificates++;\n      }\n\n      // Count by type\n      summary.typeBreakdown[cert.type] = (summary.typeBreakdown[cert.type] || 0) + 1;\n\n      // Track earliest expiry\n      if (!earliestExpiry || expiryDate < earliestExpiry) {\n        earliestExpiry = expiryDate;\n      }\n    }\n\n    summary.nextExpiry = earliestExpiry ? earliestExpiry.toISOString().split('T')[0] || null : null;\n\n    return summary;\n  }\n\n  /**\n   * Validate certificate signature (placeholder implementation)\n   */\n  static validateCertificateSignature(cert: CertificateInfo, issuerCert?: CertificateInfo): {\n    valid: boolean;\n    error?: string;\n  } {\n    // This would implement actual cryptographic signature validation\n    // For now, return a mock validation\n    if (!issuerCert && cert.type !== 'root') {\n      return {\n        valid: false,\n        error: 'Cannot validate signature without issuer certificate',\n      };\n    }\n\n    // Mock validation logic\n    const isValid = cert.fingerprint && cert.fingerprint !== 'unknown';\n    \n    return {\n      valid: !!isValid,\n      ...(isValid ? {} : { error: 'Invalid certificate signature' }),\n    };\n  }\n\n  /**\n   * Generate certificate renewal request\n   */\n  static generateRenewalRequest(cert: CertificateInfo): {\n    certificateId: string;\n    currentExpiry: string;\n    requestedValidityPeriod: number;\n    justification: string;\n    urgency: 'low' | 'medium' | 'high' | 'critical';\n  } {\n    const now = new Date();\n    const expiryDate = new Date(cert.validTo);\n    const daysUntilExpiry = Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));\n\n    let urgency: 'low' | 'medium' | 'high' | 'critical' = 'low';\n    if (daysUntilExpiry <= 0) urgency = 'critical';\n    else if (daysUntilExpiry <= 7) urgency = 'high';\n    else if (daysUntilExpiry <= 30) urgency = 'medium';\n\n    return {\n      certificateId: cert.id,\n      currentExpiry: cert.validTo,\n      requestedValidityPeriod: 365, // Days\n      justification: daysUntilExpiry <= 30 ? 'Certificate expiring soon' : 'Routine renewal',\n      urgency,\n    };\n  }\n}\n\n// Re-export for convenience\nexport { PEMsResource as PEMs };\n\n// Export types for external use\nexport type {\n  PointOfSaleCreateInput,\n  PointOfSaleOutput,\n};","/**\n * Push Notifications Manager for A-Cube E-Receipt SDK\n * Handles PWA push notifications with Italian e-receipt specific messaging\n * \n * Features:\n * - VAPID key management\n * - Subscription handling\n * - Receipt-specific notifications\n * - Fiscal compliance alerts\n * - Multi-language support\n * - Notification actions\n */\n\nimport { EventEmitter } from 'eventemitter3';\n\n/**\n * Notification types for e-receipts\n */\nexport type NotificationType = \n  | 'receipt_created'\n  | 'receipt_synced'\n  | 'receipt_void'\n  | 'fiscal_alert'\n  | 'lottery_win'\n  | 'sync_completed'\n  | 'sync_failed'\n  | 'offline_reminder'\n  | 'app_update';\n\n/**\n * Notification priority levels\n */\nexport type NotificationPriority = 'urgent' | 'high' | 'normal' | 'low';\n\n/**\n * Push notification configuration\n */\nexport interface PushNotificationConfig {\n  /** VAPID public key for push service */\n  vapidPublicKey: string;\n  \n  /** Service worker registration */\n  serviceWorkerRegistration?: ServiceWorkerRegistration;\n  \n  /** Default notification options */\n  defaultOptions?: {\n    /** Notification icon */\n    icon?: string;\n    \n    /** Notification badge */\n    badge?: string;\n    \n    /** Vibration pattern */\n    vibrate?: number[];\n    \n    /** Silent notifications */\n    silent?: boolean;\n    \n    /** Require interaction */\n    requireInteraction?: boolean;\n    \n    /** Notification tag for grouping */\n    tag?: string;\n  };\n  \n  /** Language for notifications */\n  language?: 'it' | 'en' | 'de' | 'fr';\n  \n  /** Enable automatic subscription */\n  autoSubscribe?: boolean;\n  \n  /** Notification server endpoint */\n  serverEndpoint?: string;\n}\n\n/**\n * Push subscription info\n */\nexport interface PushSubscriptionInfo {\n  endpoint: string;\n  keys: {\n    p256dh: string;\n    auth: string;\n  };\n  expirationTime?: number | null;\n}\n\n/**\n * Notification payload\n */\nexport interface NotificationPayload {\n  type: NotificationType;\n  title: string;\n  body: string;\n  data?: {\n    receiptId?: string | undefined;\n    amount?: string | undefined;\n    merchantName?: string | undefined;\n    timestamp?: string | undefined;\n    actionUrl?: string | undefined;\n    priority?: NotificationPriority | undefined;\n    [key: string]: any;\n  };\n  options?: NotificationOptions;\n}\n\n/**\n * Push notification events\n */\nexport interface PushNotificationEvents {\n  'subscription:created': { subscription: PushSubscriptionInfo };\n  'subscription:updated': { subscription: PushSubscriptionInfo };\n  'subscription:deleted': { reason: string };\n  'permission:granted': { permission: NotificationPermission };\n  'permission:denied': { permission: NotificationPermission };\n  'notification:shown': { notification: NotificationPayload };\n  'notification:clicked': { action: string; data: any };\n  'notification:closed': { notification: NotificationPayload };\n  'error': { error: Error; context: string };\n}\n\n/**\n * Notification templates by language\n */\nconst NOTIFICATION_TEMPLATES: Record<string, Record<NotificationType, { title: string; body: string }>> = {\n  it: {\n    receipt_created: {\n      title: 'Nuovo Scontrino',\n      body: 'Scontrino di {amount} creato presso {merchantName}',\n    },\n    receipt_synced: {\n      title: 'Scontrino Sincronizzato',\n      body: 'Il tuo scontrino  stato trasmesso con successo',\n    },\n    receipt_void: {\n      title: 'Scontrino Annullato',\n      body: 'Scontrino #{receiptId} annullato',\n    },\n    fiscal_alert: {\n      title: ' Avviso Fiscale',\n      body: 'Azione richiesta per conformit fiscale',\n    },\n    lottery_win: {\n      title: ' Hai Vinto!',\n      body: 'Il tuo scontrino ha vinto alla lotteria!',\n    },\n    sync_completed: {\n      title: 'Sincronizzazione Completata',\n      body: '{count} scontrini sincronizzati con successo',\n    },\n    sync_failed: {\n      title: 'Sincronizzazione Fallita',\n      body: 'Impossibile sincronizzare {count} scontrini',\n    },\n    offline_reminder: {\n      title: 'Modalit Offline',\n      body: 'Hai {count} scontrini in attesa di sincronizzazione',\n    },\n    app_update: {\n      title: 'Aggiornamento Disponibile',\n      body: 'Una nuova versione dell\\'app  disponibile',\n    },\n  },\n  en: {\n    receipt_created: {\n      title: 'New Receipt',\n      body: 'Receipt for {amount} created at {merchantName}',\n    },\n    receipt_synced: {\n      title: 'Receipt Synced',\n      body: 'Your receipt has been successfully transmitted',\n    },\n    receipt_void: {\n      title: 'Receipt Voided',\n      body: 'Receipt #{receiptId} has been voided',\n    },\n    fiscal_alert: {\n      title: ' Fiscal Alert',\n      body: 'Action required for fiscal compliance',\n    },\n    lottery_win: {\n      title: ' You Won!',\n      body: 'Your receipt won in the lottery!',\n    },\n    sync_completed: {\n      title: 'Sync Completed',\n      body: '{count} receipts synced successfully',\n    },\n    sync_failed: {\n      title: 'Sync Failed',\n      body: 'Unable to sync {count} receipts',\n    },\n    offline_reminder: {\n      title: 'Offline Mode',\n      body: 'You have {count} receipts waiting to sync',\n    },\n    app_update: {\n      title: 'Update Available',\n      body: 'A new version of the app is available',\n    },\n  },\n  de: {\n    receipt_created: {\n      title: 'Neuer Beleg',\n      body: 'Beleg ber {amount} erstellt bei {merchantName}',\n    },\n    receipt_synced: {\n      title: 'Beleg Synchronisiert',\n      body: 'Ihr Beleg wurde erfolgreich bertragen',\n    },\n    receipt_void: {\n      title: 'Beleg Storniert',\n      body: 'Beleg #{receiptId} wurde storniert',\n    },\n    fiscal_alert: {\n      title: ' Steuerwarnung',\n      body: 'Aktion fr Steuerkonformitt erforderlich',\n    },\n    lottery_win: {\n      title: ' Sie haben gewonnen!',\n      body: 'Ihr Beleg hat in der Lotterie gewonnen!',\n    },\n    sync_completed: {\n      title: 'Synchronisation Abgeschlossen',\n      body: '{count} Belege erfolgreich synchronisiert',\n    },\n    sync_failed: {\n      title: 'Synchronisation Fehlgeschlagen',\n      body: '{count} Belege konnten nicht synchronisiert werden',\n    },\n    offline_reminder: {\n      title: 'Offline-Modus',\n      body: 'Sie haben {count} Belege zur Synchronisation',\n    },\n    app_update: {\n      title: 'Update Verfgbar',\n      body: 'Eine neue Version der App ist verfgbar',\n    },\n  },\n  fr: {\n    receipt_created: {\n      title: 'Nouveau Reu',\n      body: 'Reu de {amount} cr chez {merchantName}',\n    },\n    receipt_synced: {\n      title: 'Reu Synchronis',\n      body: 'Votre reu a t transmis avec succs',\n    },\n    receipt_void: {\n      title: 'Reu Annul',\n      body: 'Reu #{receiptId} a t annul',\n    },\n    fiscal_alert: {\n      title: ' Alerte Fiscale',\n      body: 'Action requise pour la conformit fiscale',\n    },\n    lottery_win: {\n      title: ' Vous avez gagn!',\n      body: 'Votre reu a gagn  la loterie!',\n    },\n    sync_completed: {\n      title: 'Synchronisation Termine',\n      body: '{count} reus synchroniss avec succs',\n    },\n    sync_failed: {\n      title: 'chec de Synchronisation',\n      body: 'Impossible de synchroniser {count} reus',\n    },\n    offline_reminder: {\n      title: 'Mode Hors Ligne',\n      body: 'Vous avez {count} reus en attente de synchronisation',\n    },\n    app_update: {\n      title: 'Mise  Jour Disponible',\n      body: 'Une nouvelle version de l\\'application est disponible',\n    },\n  },\n};\n\nconst DEFAULT_CONFIG: Partial<PushNotificationConfig> = {\n  defaultOptions: {\n    icon: '/icons/icon-192x192.png',\n    badge: '/icons/badge-72x72.png',\n    vibrate: [200, 100, 200],\n    silent: false,\n    requireInteraction: false,\n  },\n  language: 'it',\n  autoSubscribe: false,\n  serverEndpoint: '/api/push/subscribe',\n};\n\n/**\n * Push Notifications Manager\n * Handles PWA push notifications for e-receipt updates\n */\nexport class PushNotificationManager extends EventEmitter<PushNotificationEvents> {\n  private config: Required<PushNotificationConfig>;\n  private registration: ServiceWorkerRegistration | null = null;\n  private subscription: PushSubscription | null = null;\n  private isSupported: boolean;\n  private permission: NotificationPermission = 'default';\n\n  constructor(config: PushNotificationConfig) {\n    super();\n    \n    this.config = {\n      ...DEFAULT_CONFIG,\n      ...config,\n      defaultOptions: {\n        ...DEFAULT_CONFIG.defaultOptions,\n        ...config.defaultOptions,\n      },\n    } as Required<PushNotificationConfig>;\n    \n    this.isSupported = this.checkSupport();\n    \n    if (this.isSupported) {\n      this.permission = Notification.permission;\n      this.initialize();\n    }\n  }\n\n  /**\n   * Check if push notifications are supported\n   */\n  private checkSupport(): boolean {\n    return (\n      typeof window !== 'undefined' &&\n      'serviceWorker' in navigator &&\n      'PushManager' in window &&\n      'Notification' in window\n    );\n  }\n\n  /**\n   * Initialize push notifications\n   */\n  private async initialize(): Promise<void> {\n    try {\n      // Get service worker registration\n      if (this.config.serviceWorkerRegistration) {\n        this.registration = this.config.serviceWorkerRegistration;\n      } else {\n        this.registration = await navigator.serviceWorker.ready;\n      }\n      \n      // Check existing subscription\n      this.subscription = await this.registration.pushManager.getSubscription();\n      \n      if (this.subscription) {\n        this.emit('subscription:created', { \n          subscription: this.extractSubscriptionInfo(this.subscription) \n        });\n      }\n      \n      // Auto-subscribe if configured\n      if (this.config.autoSubscribe && !this.subscription && this.permission === 'default') {\n        await this.subscribe();\n      }\n    } catch (error) {\n      this.emit('error', { \n        error: error as Error, \n        context: 'initialization' \n      });\n    }\n  }\n\n  /**\n   * Request notification permission\n   */\n  async requestPermission(): Promise<NotificationPermission> {\n    if (!this.isSupported) {\n      throw new Error('Push notifications are not supported');\n    }\n    \n    try {\n      this.permission = await Notification.requestPermission();\n      \n      if (this.permission === 'granted') {\n        this.emit('permission:granted', { permission: this.permission });\n      } else {\n        this.emit('permission:denied', { permission: this.permission });\n      }\n      \n      return this.permission;\n    } catch (error) {\n      this.emit('error', { \n        error: error as Error, \n        context: 'permission_request' \n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Subscribe to push notifications\n   */\n  async subscribe(): Promise<PushSubscriptionInfo | null> {\n    if (!this.isSupported || !this.registration) {\n      throw new Error('Push notifications not initialized');\n    }\n    \n    // Check permission\n    if (this.permission !== 'granted') {\n      const permission = await this.requestPermission();\n      if (permission !== 'granted') {\n        return null;\n      }\n    }\n    \n    try {\n      // Subscribe to push service\n      const applicationServerKey = this.urlBase64ToUint8Array(this.config.vapidPublicKey);\n      this.subscription = await this.registration.pushManager.subscribe({\n        userVisibleOnly: true,\n        applicationServerKey: new Uint8Array(applicationServerKey),\n      });\n      \n      const subscriptionInfo = this.extractSubscriptionInfo(this.subscription);\n      \n      // Send subscription to server\n      await this.sendSubscriptionToServer(subscriptionInfo);\n      \n      this.emit('subscription:created', { subscription: subscriptionInfo });\n      \n      return subscriptionInfo;\n    } catch (error) {\n      this.emit('error', { \n        error: error as Error, \n        context: 'subscription' \n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Unsubscribe from push notifications\n   */\n  async unsubscribe(): Promise<void> {\n    if (!this.subscription) {\n      return;\n    }\n    \n    try {\n      await this.subscription.unsubscribe();\n      \n      // Remove subscription from server\n      await this.removeSubscriptionFromServer();\n      \n      this.subscription = null;\n      this.emit('subscription:deleted', { reason: 'user_unsubscribed' });\n    } catch (error) {\n      this.emit('error', { \n        error: error as Error, \n        context: 'unsubscription' \n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Show a notification\n   */\n  async showNotification(payload: NotificationPayload): Promise<void> {\n    if (!this.isSupported || this.permission !== 'granted') {\n      throw new Error('Cannot show notification: permission not granted');\n    }\n    \n    try {\n      const { title, body, options } = this.prepareNotification(payload);\n      \n      if (this.registration) {\n        // Use service worker to show notification\n        await this.registration.showNotification(title, {\n          ...this.config.defaultOptions,\n          ...options,\n          body,\n          data: payload.data,\n          tag: payload.type,\n        });\n      } else {\n        // Fallback to Notification API\n        const notification = new Notification(title, {\n          ...this.config.defaultOptions,\n          ...options,\n          body,\n          data: payload.data,\n          tag: payload.type,\n        });\n        \n        // Handle notification events\n        notification.onclick = () => {\n          this.emit('notification:clicked', { \n            action: 'default', \n            data: payload.data || {} \n          });\n          notification.close();\n        };\n        \n        notification.onclose = () => {\n          this.emit('notification:closed', { notification: payload });\n        };\n      }\n      \n      this.emit('notification:shown', { notification: payload });\n    } catch (error) {\n      this.emit('error', { \n        error: error as Error, \n        context: 'show_notification' \n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Show receipt created notification\n   */\n  async notifyReceiptCreated(receipt: {\n    id: string;\n    amount: string;\n    merchantName: string;\n    timestamp?: string;\n  }): Promise<void> {\n    await this.showNotification({\n      type: 'receipt_created',\n      title: '',\n      body: '',\n      data: {\n        receiptId: receipt.id,\n        amount: receipt.amount,\n        merchantName: receipt.merchantName,\n        timestamp: receipt.timestamp || new Date().toISOString(),\n        actionUrl: `/receipts/${receipt.id}`,\n        priority: 'normal',\n      },\n    });\n  }\n\n  /**\n   * Show fiscal alert notification\n   */\n  async notifyFiscalAlert(data: {\n    message: string;\n    receiptId?: string;\n    urgency?: 'high' | 'critical';\n  }): Promise<void> {\n    await this.showNotification({\n      type: 'fiscal_alert',\n      title: '',\n      body: data.message,\n      data: {\n        receiptId: data.receiptId,\n        actionUrl: data.receiptId ? `/receipts/${data.receiptId}` : '/fiscal-alerts',\n        priority: data.urgency === 'critical' ? 'urgent' : 'high',\n      },\n      options: {\n        requireInteraction: true,\n      },\n    });\n  }\n\n  /**\n   * Show lottery win notification\n   */\n  async notifyLotteryWin(data: {\n    receiptId: string;\n    prizeAmount?: string;\n    claimCode?: string;\n  }): Promise<void> {\n    await this.showNotification({\n      type: 'lottery_win',\n      title: '',\n      body: '',\n      data: {\n        receiptId: data.receiptId,\n        prizeAmount: data.prizeAmount,\n        claimCode: data.claimCode,\n        actionUrl: `/lottery/claim/${data.receiptId}`,\n        priority: 'urgent',\n      },\n      options: {\n        requireInteraction: true,\n        icon: '/icons/lottery-win.png',\n      },\n    });\n  }\n\n  /**\n   * Show sync status notification\n   */\n  async notifySyncStatus(status: 'completed' | 'failed', count: number): Promise<void> {\n    const type = status === 'completed' ? 'sync_completed' : 'sync_failed';\n    \n    await this.showNotification({\n      type,\n      title: '',\n      body: '',\n      data: {\n        count: count.toString(),\n        timestamp: new Date().toISOString(),\n        actionUrl: '/sync-status',\n        priority: status === 'failed' ? 'high' : 'normal',\n      },\n    });\n  }\n\n  /**\n   * Show offline reminder notification\n   */\n  async notifyOfflineReminder(pendingCount: number): Promise<void> {\n    if (pendingCount === 0) return;\n    \n    await this.showNotification({\n      type: 'offline_reminder',\n      title: '',\n      body: '',\n      data: {\n        count: pendingCount.toString(),\n        actionUrl: '/offline-queue',\n        priority: pendingCount > 10 ? 'high' : 'normal',\n      },\n    });\n  }\n\n  /**\n   * Prepare notification with localization\n   */\n  private prepareNotification(payload: NotificationPayload): {\n    title: string;\n    body: string;\n    options?: NotificationOptions;\n  } {\n    const templates = NOTIFICATION_TEMPLATES[this.config.language] || NOTIFICATION_TEMPLATES.it;\n    const template = templates?.[payload.type] || { title: 'Notification', body: 'New notification' };\n    \n    // Replace placeholders in template\n    let title = payload.title || template.title;\n    let body = payload.body || template.body;\n    \n    if (payload.data) {\n      Object.entries(payload.data).forEach(([key, value]) => {\n        const placeholder = `{${key}}`;\n        title = title.replace(placeholder, String(value));\n        body = body.replace(placeholder, String(value));\n      });\n    }\n    \n    // Add actions based on notification type\n    const actions: Array<{ action: string; title: string }> = [];\n    \n    switch (payload.type) {\n      case 'receipt_created':\n      case 'receipt_synced':\n        actions.push(\n          { action: 'view', title: this.getActionTitle('view') },\n          { action: 'dismiss', title: this.getActionTitle('dismiss') }\n        );\n        break;\n        \n      case 'fiscal_alert':\n        actions.push(\n          { action: 'resolve', title: this.getActionTitle('resolve') },\n          { action: 'later', title: this.getActionTitle('later') }\n        );\n        break;\n        \n      case 'lottery_win':\n        actions.push(\n          { action: 'claim', title: this.getActionTitle('claim') },\n          { action: 'share', title: this.getActionTitle('share') }\n        );\n        break;\n        \n      case 'sync_failed':\n        actions.push(\n          { action: 'retry', title: this.getActionTitle('retry') },\n          { action: 'details', title: this.getActionTitle('details') }\n        );\n        break;\n        \n      case 'app_update':\n        actions.push(\n          { action: 'update', title: this.getActionTitle('update') },\n          { action: 'later', title: this.getActionTitle('later') }\n        );\n        break;\n    }\n    \n    return {\n      title,\n      body,\n      options: {\n        ...payload.options,\n        ...(actions.length > 0 && { actions }),\n      } as NotificationOptions,\n    };\n  }\n\n  /**\n   * Get localized action title\n   */\n  private getActionTitle(action: string): string {\n    const actionTitles: Record<string, Record<string, string>> = {\n      it: {\n        view: 'Visualizza',\n        dismiss: 'Ignora',\n        resolve: 'Risolvi',\n        later: 'Pi tardi',\n        claim: 'Riscuoti',\n        share: 'Condividi',\n        retry: 'Riprova',\n        details: 'Dettagli',\n        update: 'Aggiorna',\n      },\n      en: {\n        view: 'View',\n        dismiss: 'Dismiss',\n        resolve: 'Resolve',\n        later: 'Later',\n        claim: 'Claim',\n        share: 'Share',\n        retry: 'Retry',\n        details: 'Details',\n        update: 'Update',\n      },\n      de: {\n        view: 'Anzeigen',\n        dismiss: 'Verwerfen',\n        resolve: 'Lsen',\n        later: 'Spter',\n        claim: 'Einlsen',\n        share: 'Teilen',\n        retry: 'Wiederholen',\n        details: 'Details',\n        update: 'Aktualisieren',\n      },\n      fr: {\n        view: 'Voir',\n        dismiss: 'Ignorer',\n        resolve: 'Rsoudre',\n        later: 'Plus tard',\n        claim: 'Rclamer',\n        share: 'Partager',\n        retry: 'Ressayer',\n        details: 'Dtails',\n        update: 'Mettre  jour',\n      },\n    };\n    \n    const titles = actionTitles[this.config.language] || actionTitles.it;\n    return titles?.[action] || action;\n  }\n\n  /**\n   * Convert VAPID key to Uint8Array\n   */\n  private urlBase64ToUint8Array(base64String: string): Uint8Array {\n    const padding = '='.repeat((4 - base64String.length % 4) % 4);\n    const base64 = (base64String + padding)\n      .replace(/-/g, '+')\n      .replace(/_/g, '/');\n\n    const rawData = window.atob(base64);\n    const outputArray = new Uint8Array(rawData.length);\n\n    for (let i = 0; i < rawData.length; ++i) {\n      outputArray[i] = rawData.charCodeAt(i);\n    }\n    return outputArray;\n  }\n\n  /**\n   * Extract subscription info from PushSubscription\n   */\n  private extractSubscriptionInfo(subscription: PushSubscription): PushSubscriptionInfo {\n    const key = subscription.getKey('p256dh');\n    const token = subscription.getKey('auth');\n    \n    if (!key || !token) {\n      throw new Error('Unable to get subscription keys');\n    }\n    \n    return {\n      endpoint: subscription.endpoint,\n      keys: {\n        p256dh: btoa(String.fromCharCode(...new Uint8Array(key))),\n        auth: btoa(String.fromCharCode(...new Uint8Array(token))),\n      },\n      expirationTime: subscription.expirationTime,\n    };\n  }\n\n  /**\n   * Send subscription to server\n   */\n  private async sendSubscriptionToServer(subscription: PushSubscriptionInfo): Promise<void> {\n    // This would be implemented to send the subscription to your server\n    try {\n      const response = await fetch(this.config.serverEndpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          subscription,\n          language: this.config.language,\n          timestamp: new Date().toISOString(),\n        }),\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Server responded with ${response.status}`);\n      }\n    } catch (error) {\n      console.error('Failed to send subscription to server:', error);\n      // Don't throw - allow local functionality to continue\n    }\n  }\n\n  /**\n   * Remove subscription from server\n   */\n  private async removeSubscriptionFromServer(): Promise<void> {\n    // This would be implemented to remove the subscription from your server\n    try {\n      if (this.subscription) {\n        await fetch(this.config.serverEndpoint, {\n          method: 'DELETE',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            endpoint: this.subscription.endpoint,\n          }),\n        });\n      }\n    } catch (error) {\n      console.error('Failed to remove subscription from server:', error);\n      // Don't throw - allow local functionality to continue\n    }\n  }\n\n  /**\n   * Get current permission status\n   */\n  getPermission(): NotificationPermission {\n    return this.permission;\n  }\n\n  /**\n   * Check if notifications are supported\n   */\n  isNotificationSupported(): boolean {\n    return this.isSupported;\n  }\n\n  /**\n   * Check if subscribed to push notifications\n   */\n  isSubscribed(): boolean {\n    return this.subscription !== null;\n  }\n\n  /**\n   * Get current subscription\n   */\n  getSubscription(): PushSubscriptionInfo | null {\n    if (!this.subscription) {\n      return null;\n    }\n    \n    return this.extractSubscriptionInfo(this.subscription);\n  }\n\n  /**\n   * Set notification language\n   */\n  setLanguage(language: 'it' | 'en' | 'de' | 'fr'): void {\n    this.config.language = language;\n  }\n\n  /**\n   * Destroy the push notification manager\n   */\n  async destroy(): Promise<void> {\n    this.removeAllListeners();\n    this.registration = null;\n    this.subscription = null;\n  }\n}","/**\n * PWA App Installer for A-Cube E-Receipt SDK\n * Handles Progressive Web App installation prompts and app lifecycle\n * \n * Features:\n * - Smart install prompt timing\n * - Custom install UI components\n * - Install criteria checking\n * - A2HS (Add to Home Screen) support\n * - Installation analytics\n * - Multi-platform support\n */\n\nimport { EventEmitter } from 'eventemitter3';\n\n/**\n * Install prompt criteria\n */\nexport interface InstallCriteria {\n  /** Minimum user engagement time (ms) */\n  minEngagementTime?: number;\n  \n  /** Minimum page views */\n  minPageViews?: number;\n  \n  /** Minimum receipts created */\n  minReceiptsCreated?: number;\n  \n  /** Days since first visit */\n  daysSinceFirstVisit?: number;\n  \n  /** Require return visits */\n  requireReturnVisit?: boolean;\n  \n  /** Custom criteria function */\n  customCriteria?: () => boolean | Promise<boolean>;\n}\n\n/**\n * Install prompt configuration\n */\nexport interface AppInstallerConfig {\n  /** Install criteria */\n  criteria?: InstallCriteria;\n  \n  /** Auto-show prompt when criteria met */\n  autoShow?: boolean;\n  \n  /** Delay before showing prompt (ms) */\n  showDelay?: number;\n  \n  /** Max times to show prompt */\n  maxPromptAttempts?: number;\n  \n  /** Days to wait after dismissal */\n  dismissalCooldown?: number;\n  \n  /** Custom prompt UI */\n  customPrompt?: {\n    enabled?: boolean;\n    title?: string;\n    message?: string;\n    installButtonText?: string;\n    cancelButtonText?: string;\n    icon?: string;\n  };\n  \n  /** Installation tracking */\n  analytics?: {\n    enabled?: boolean;\n    trackingId?: string;\n    customEvents?: Record<string, any>;\n  };\n  \n  /** Platform-specific settings */\n  platforms?: {\n    /** iOS Safari specific */\n    ios?: {\n      showIOSInstructions?: boolean;\n      customInstructions?: string;\n    };\n    \n    /** Android Chrome specific */\n    android?: {\n      enableWebAPK?: boolean;\n      customIcon?: string;\n    };\n    \n    /** Desktop specific */\n    desktop?: {\n      showDesktopPrompt?: boolean;\n      position?: 'top' | 'bottom' | 'center';\n    };\n  };\n}\n\n/**\n * Installation events\n */\nexport interface AppInstallerEvents {\n  'criteria:met': { criteria: InstallCriteria };\n  'prompt:available': { prompt: BeforeInstallPromptEvent };\n  'prompt:shown': { type: 'native' | 'custom' };\n  'prompt:dismissed': { reason: 'user' | 'timeout' | 'error' };\n  'install:started': { platform: string };\n  'install:completed': { outcome: 'accepted' | 'dismissed'; platform: string };\n  'install:failed': { error: Error; platform: string };\n  'analytics:tracked': { event: string; data: any };\n}\n\n/**\n * User engagement tracking\n */\nexport interface EngagementData {\n  firstVisit: number;\n  lastVisit: number;\n  totalTime: number;\n  pageViews: number;\n  receiptsCreated: number;\n  returnVisits: number;\n  promptsShown: number;\n  lastPromptShown?: number;\n  dismissed: boolean;\n  installed: boolean;\n}\n\n/**\n * Platform detection\n */\ninterface PlatformInfo {\n  name: 'ios' | 'android' | 'desktop' | 'unknown';\n  browser: string;\n  version: string;\n  supportsNativePrompt: boolean;\n  supportsWebAPK: boolean;\n  isStandalone: boolean;\n}\n\n/**\n * Enhanced BeforeInstallPromptEvent interface\n */\ninterface BeforeInstallPromptEvent extends Event {\n  readonly platforms: string[];\n  readonly userChoice: Promise<{\n    outcome: 'accepted' | 'dismissed';\n    platform: string;\n  }>;\n  prompt(): Promise<void>;\n}\n\nconst DEFAULT_CONFIG: Required<AppInstallerConfig> = {\n  criteria: {\n    minEngagementTime: 2 * 60 * 1000, // 2 minutes\n    minPageViews: 3,\n    minReceiptsCreated: 1,\n    daysSinceFirstVisit: 0,\n    requireReturnVisit: false,\n  },\n  autoShow: true,\n  showDelay: 5000, // 5 seconds\n  maxPromptAttempts: 3,\n  dismissalCooldown: 7, // 7 days\n  customPrompt: {\n    enabled: true,\n    title: 'Installa A-Cube E-Receipt',\n    message: 'Installa l\\'app per accedere rapidamente ai tuoi scontrini elettronici',\n    installButtonText: 'Installa',\n    cancelButtonText: 'Non ora',\n    icon: '/icons/install-icon.png',\n  },\n  analytics: {\n    enabled: true,\n    trackingId: '',\n    customEvents: {},\n  },\n  platforms: {\n    ios: {\n      showIOSInstructions: true,\n      customInstructions: 'Tocca il pulsante Condividi e seleziona \"Aggiungi alla schermata Home\"',\n    },\n    android: {\n      enableWebAPK: true,\n      customIcon: '/icons/android-install.png',\n    },\n    desktop: {\n      showDesktopPrompt: true,\n      position: 'bottom',\n    },\n  },\n};\n\n/**\n * PWA App Installer\n * Manages app installation prompts and user engagement tracking\n */\nexport class AppInstaller extends EventEmitter<AppInstallerEvents> {\n  private config: Required<AppInstallerConfig>;\n  private installPrompt: BeforeInstallPromptEvent | null = null;\n  private engagementData: EngagementData;\n  private platformInfo: PlatformInfo;\n  private isInitialized = false;\n  private engagementTimer?: NodeJS.Timeout;\n  private promptTimeout: NodeJS.Timeout | undefined = undefined;\n  private customPromptElement: HTMLElement | undefined = undefined;\n\n  constructor(config: AppInstallerConfig = {}) {\n    super();\n    this.config = this.mergeConfig(config);\n    this.platformInfo = this.detectPlatform();\n    this.engagementData = this.loadEngagementData();\n    \n    this.initialize();\n  }\n\n  /**\n   * Merge configuration with defaults\n   */\n  private mergeConfig(config: AppInstallerConfig): Required<AppInstallerConfig> {\n    return {\n      ...DEFAULT_CONFIG,\n      ...config,\n      criteria: {\n        ...DEFAULT_CONFIG.criteria,\n        ...config.criteria,\n      },\n      customPrompt: {\n        ...DEFAULT_CONFIG.customPrompt,\n        ...config.customPrompt,\n      },\n      analytics: {\n        ...DEFAULT_CONFIG.analytics,\n        ...config.analytics,\n      },\n      platforms: {\n        ios: {\n          ...DEFAULT_CONFIG.platforms.ios,\n          ...config.platforms?.ios,\n        },\n        android: {\n          ...DEFAULT_CONFIG.platforms.android,\n          ...config.platforms?.android,\n        },\n        desktop: {\n          ...DEFAULT_CONFIG.platforms.desktop,\n          ...config.platforms?.desktop,\n        },\n      },\n    };\n  }\n\n  /**\n   * Initialize the app installer\n   */\n  private initialize(): void {\n    if (this.isInitialized || typeof window === 'undefined') {\n      return;\n    }\n\n    // Skip if already installed\n    if (this.platformInfo.isStandalone || this.engagementData.installed) {\n      return;\n    }\n\n    // Setup event listeners\n    this.setupEventListeners();\n    \n    // Start engagement tracking\n    this.startEngagementTracking();\n    \n    // Check criteria periodically\n    this.startCriteriaChecking();\n    \n    this.isInitialized = true;\n  }\n\n  /**\n   * Setup event listeners\n   */\n  private setupEventListeners(): void {\n    // BeforeInstallPrompt event\n    window.addEventListener('beforeinstallprompt', (event) => {\n      event.preventDefault();\n      this.installPrompt = event as BeforeInstallPromptEvent;\n      this.emit('prompt:available', { prompt: this.installPrompt });\n      \n      if (this.config.autoShow) {\n        this.checkCriteriaAndShow();\n      }\n    });\n\n    // App installed event\n    window.addEventListener('appinstalled', () => {\n      this.handleAppInstalled('accepted');\n    });\n\n    // Page visibility for engagement tracking\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden) {\n        this.pauseEngagementTracking();\n      } else {\n        this.resumeEngagementTracking();\n        this.updateEngagementData({ pageViews: this.engagementData.pageViews + 1 });\n      }\n    });\n\n    // Beforeunload for saving engagement data\n    window.addEventListener('beforeunload', () => {\n      this.saveEngagementData();\n    });\n  }\n\n  /**\n   * Detect platform information\n   */\n  private detectPlatform(): PlatformInfo {\n    const userAgent = navigator.userAgent;\n    const isStandalone = \n      window.matchMedia('(display-mode: standalone)').matches ||\n      (window.navigator as any).standalone === true;\n\n    let platform: PlatformInfo['name'] = 'unknown';\n    let browser = 'unknown';\n    let version = '';\n\n    // iOS detection\n    if (/iPad|iPhone|iPod/.test(userAgent)) {\n      platform = 'ios';\n      browser = /Safari/.test(userAgent) ? 'safari' : 'other';\n      const match = userAgent.match(/OS (\\d+)_(\\d+)/);\n      version = match ? `${match[1]}.${match[2]}` : '';\n    }\n    // Android detection\n    else if (/Android/.test(userAgent)) {\n      platform = 'android';\n      browser = /Chrome/.test(userAgent) ? 'chrome' : 'other';\n      const match = userAgent.match(/Android (\\d+\\.\\d+)/);\n      version = match && match[1] ? match[1] : '';\n    }\n    // Desktop detection\n    else {\n      platform = 'desktop';\n      if (/Chrome/.test(userAgent)) browser = 'chrome';\n      else if (/Firefox/.test(userAgent)) browser = 'firefox';\n      else if (/Safari/.test(userAgent)) browser = 'safari';\n      else if (/Edge/.test(userAgent)) browser = 'edge';\n    }\n\n    return {\n      name: platform,\n      browser,\n      version,\n      supportsNativePrompt: platform === 'android' || platform === 'desktop',\n      supportsWebAPK: platform === 'android' && browser === 'chrome',\n      isStandalone,\n    };\n  }\n\n  /**\n   * Load engagement data from storage\n   */\n  private loadEngagementData(): EngagementData {\n    try {\n      const stored = localStorage.getItem('acube_install_engagement');\n      if (stored) {\n        return JSON.parse(stored);\n      }\n    } catch (error) {\n      console.warn('Failed to load engagement data:', error);\n    }\n\n    // Default engagement data\n    const now = Date.now();\n    return {\n      firstVisit: now,\n      lastVisit: now,\n      totalTime: 0,\n      pageViews: 1,\n      receiptsCreated: 0,\n      returnVisits: 0,\n      promptsShown: 0,\n      dismissed: false,\n      installed: false,\n    };\n  }\n\n  /**\n   * Save engagement data to storage\n   */\n  private saveEngagementData(): void {\n    try {\n      localStorage.setItem('acube_install_engagement', JSON.stringify(this.engagementData));\n    } catch (error) {\n      console.warn('Failed to save engagement data:', error);\n    }\n  }\n\n  /**\n   * Update engagement data\n   */\n  private updateEngagementData(updates: Partial<EngagementData>): void {\n    this.engagementData = { ...this.engagementData, ...updates };\n    this.saveEngagementData();\n  }\n\n  /**\n   * Start engagement tracking\n   */\n  private startEngagementTracking(): void {\n    const now = Date.now();\n    \n    // Check if this is a return visit\n    if (now - this.engagementData.lastVisit > 24 * 60 * 60 * 1000) {\n      this.updateEngagementData({ \n        returnVisits: this.engagementData.returnVisits + 1,\n        lastVisit: now,\n      });\n    }\n\n    // Start timing\n    this.engagementTimer = setInterval(() => {\n      if (!document.hidden) {\n        this.updateEngagementData({\n          totalTime: this.engagementData.totalTime + 1000,\n        });\n      }\n    }, 1000) as unknown as NodeJS.Timeout;\n  }\n\n  /**\n   * Pause engagement tracking\n   */\n  private pauseEngagementTracking(): void {\n    if (this.engagementTimer) {\n      clearInterval(this.engagementTimer);\n    }\n  }\n\n  /**\n   * Resume engagement tracking\n   */\n  private resumeEngagementTracking(): void {\n    if (!this.engagementTimer) {\n      this.startEngagementTracking();\n    }\n  }\n\n  /**\n   * Start criteria checking\n   */\n  private startCriteriaChecking(): void {\n    // Check immediately\n    setTimeout(() => {\n      this.checkCriteriaAndShow();\n    }, this.config.showDelay) as unknown as NodeJS.Timeout;\n\n    // Check periodically\n    setInterval(() => {\n      this.checkCriteriaAndShow();\n    }, 30000) as unknown as NodeJS.Timeout; // Every 30 seconds\n  }\n\n  /**\n   * Check if install criteria are met\n   */\n  async checkCriteria(): Promise<boolean> {\n    const { criteria } = this.config;\n    const { engagementData } = this;\n\n    // Skip if already prompted too many times\n    if (engagementData.promptsShown >= this.config.maxPromptAttempts) {\n      return false;\n    }\n\n    // Skip if recently dismissed\n    if (engagementData.lastPromptShown) {\n      const daysSinceLastPrompt = (Date.now() - engagementData.lastPromptShown) / (24 * 60 * 60 * 1000);\n      if (daysSinceLastPrompt < this.config.dismissalCooldown) {\n        return false;\n      }\n    }\n\n    // Check engagement time\n    if (criteria.minEngagementTime && engagementData.totalTime < criteria.minEngagementTime) {\n      return false;\n    }\n\n    // Check page views\n    if (criteria.minPageViews && engagementData.pageViews < criteria.minPageViews) {\n      return false;\n    }\n\n    // Check receipts created\n    if (criteria.minReceiptsCreated && engagementData.receiptsCreated < criteria.minReceiptsCreated) {\n      return false;\n    }\n\n    // Check days since first visit\n    if (criteria.daysSinceFirstVisit) {\n      const daysSinceFirst = (Date.now() - engagementData.firstVisit) / (24 * 60 * 60 * 1000);\n      if (daysSinceFirst < criteria.daysSinceFirstVisit) {\n        return false;\n      }\n    }\n\n    // Check return visit requirement\n    if (criteria.requireReturnVisit && engagementData.returnVisits === 0) {\n      return false;\n    }\n\n    // Check custom criteria\n    if (criteria.customCriteria) {\n      const customResult = await criteria.customCriteria();\n      if (!customResult) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Check criteria and show prompt if met\n   */\n  private async checkCriteriaAndShow(): Promise<void> {\n    if (!this.installPrompt && !this.config.customPrompt.enabled) {\n      return;\n    }\n\n    try {\n      const criteriaMet = await this.checkCriteria();\n      \n      if (criteriaMet) {\n        this.emit('criteria:met', { criteria: this.config.criteria });\n        \n        if (this.platformInfo.supportsNativePrompt && this.installPrompt) {\n          await this.showNativePrompt();\n        } else if (this.config.customPrompt.enabled) {\n          await this.showCustomPrompt();\n        }\n      }\n    } catch (error) {\n      console.error('Error checking install criteria:', error);\n    }\n  }\n\n  /**\n   * Show native install prompt\n   */\n  async showNativePrompt(): Promise<void> {\n    if (!this.installPrompt) {\n      throw new Error('Native install prompt not available');\n    }\n\n    try {\n      this.updateEngagementData({\n        promptsShown: this.engagementData.promptsShown + 1,\n        lastPromptShown: Date.now(),\n      });\n\n      this.emit('prompt:shown', { type: 'native' });\n      this.trackAnalytics('install_prompt_shown', { type: 'native' });\n\n      await this.installPrompt.prompt();\n      const choiceResult = await this.installPrompt.userChoice;\n\n      this.emit('install:completed', {\n        outcome: choiceResult.outcome,\n        platform: choiceResult.platform,\n      });\n\n      this.trackAnalytics('install_prompt_result', {\n        outcome: choiceResult.outcome,\n        platform: choiceResult.platform,\n      });\n\n      if (choiceResult.outcome === 'accepted') {\n        this.handleAppInstalled('accepted');\n      } else {\n        this.handlePromptDismissed('user');\n      }\n\n      this.installPrompt = null;\n    } catch (error) {\n      this.emit('install:failed', { \n        error: error as Error, \n        platform: this.platformInfo.name \n      });\n      this.trackAnalytics('install_prompt_error', { error: (error as Error).message });\n    }\n  }\n\n  /**\n   * Show custom install prompt\n   */\n  async showCustomPrompt(): Promise<void> {\n    if (this.customPromptElement) {\n      return; // Already showing\n    }\n\n    try {\n      this.updateEngagementData({\n        promptsShown: this.engagementData.promptsShown + 1,\n        lastPromptShown: Date.now(),\n      });\n\n      this.emit('prompt:shown', { type: 'custom' });\n      this.trackAnalytics('install_prompt_shown', { type: 'custom' });\n\n      // Create custom prompt UI\n      this.customPromptElement = this.createCustomPromptUI();\n      document.body.appendChild(this.customPromptElement);\n\n      // Auto-dismiss after timeout\n      this.promptTimeout = setTimeout(() => {\n        this.hideCustomPrompt();\n        this.handlePromptDismissed('timeout');\n      }, 30000) as unknown as NodeJS.Timeout; // 30 seconds\n\n    } catch (error) {\n      this.emit('install:failed', { \n        error: error as Error, \n        platform: this.platformInfo.name \n      });\n    }\n  }\n\n  /**\n   * Create custom prompt UI\n   */\n  private createCustomPromptUI(): HTMLElement {\n    const { customPrompt, platforms } = this.config;\n    \n    // Main container\n    const container = document.createElement('div');\n    container.className = 'acube-install-prompt';\n    container.style.cssText = `\n      position: fixed;\n      bottom: 20px;\n      left: 50%;\n      transform: translateX(-50%);\n      background: white;\n      border-radius: 12px;\n      box-shadow: 0 8px 32px rgba(0,0,0,0.12);\n      padding: 20px;\n      max-width: 360px;\n      width: calc(100% - 40px);\n      z-index: 10000;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      animation: slideUp 0.3s ease-out;\n    `;\n\n    // Add animation keyframes\n    if (!document.getElementById('acube-install-styles')) {\n      const style = document.createElement('style');\n      style.id = 'acube-install-styles';\n      style.textContent = `\n        @keyframes slideUp {\n          from { transform: translateX(-50%) translateY(100%); opacity: 0; }\n          to { transform: translateX(-50%) translateY(0); opacity: 1; }\n        }\n        .acube-install-prompt button {\n          border: none;\n          border-radius: 6px;\n          padding: 12px 24px;\n          font-size: 14px;\n          font-weight: 600;\n          cursor: pointer;\n          transition: all 0.2s ease;\n        }\n        .acube-install-prompt button:hover {\n          transform: translateY(-1px);\n        }\n      `;\n      document.head.appendChild(style);\n    }\n\n    // Icon\n    if (customPrompt.icon) {\n      const icon = document.createElement('img');\n      icon.src = customPrompt.icon;\n      icon.style.cssText = 'width: 48px; height: 48px; border-radius: 8px; margin-bottom: 12px;';\n      container.appendChild(icon);\n    }\n\n    // Title\n    const title = document.createElement('h3');\n    title.textContent = customPrompt.title || 'Installa App';\n    title.style.cssText = 'margin: 0 0 8px 0; font-size: 18px; font-weight: 600; color: #1a1a1a;';\n    container.appendChild(title);\n\n    // Message\n    const message = document.createElement('p');\n    let messageText = customPrompt.message || 'Installa l\\'app per un accesso pi veloce';\n    \n    // Platform-specific messages\n    if (this.platformInfo.name === 'ios' && platforms.ios?.showIOSInstructions) {\n      messageText = platforms.ios?.customInstructions || messageText;\n    }\n    \n    message.textContent = messageText;\n    message.style.cssText = 'margin: 0 0 20px 0; font-size: 14px; color: #666; line-height: 1.4;';\n    container.appendChild(message);\n\n    // Buttons container\n    const buttonsContainer = document.createElement('div');\n    buttonsContainer.style.cssText = 'display: flex; gap: 12px; justify-content: flex-end;';\n\n    // Cancel button\n    const cancelButton = document.createElement('button');\n    cancelButton.textContent = customPrompt.cancelButtonText || 'Non ora';\n    cancelButton.style.cssText = 'background: #f5f5f5; color: #666;';\n    cancelButton.onclick = () => {\n      this.hideCustomPrompt();\n      this.handlePromptDismissed('user');\n    };\n    buttonsContainer.appendChild(cancelButton);\n\n    // Install button\n    const installButton = document.createElement('button');\n    installButton.textContent = customPrompt.installButtonText || 'Installa';\n    installButton.style.cssText = 'background: #1976d2; color: white;';\n    installButton.onclick = () => {\n      this.hideCustomPrompt();\n      this.handleCustomInstall();\n    };\n    buttonsContainer.appendChild(installButton);\n\n    container.appendChild(buttonsContainer);\n\n    return container;\n  }\n\n  /**\n   * Hide custom prompt\n   */\n  private hideCustomPrompt(): void {\n    if (this.customPromptElement) {\n      this.customPromptElement.remove();\n      this.customPromptElement = undefined;\n    }\n    \n    if (this.promptTimeout) {\n      clearTimeout(this.promptTimeout);\n      this.promptTimeout = undefined;\n    }\n  }\n\n  /**\n   * Handle custom install button click\n   */\n  private async handleCustomInstall(): Promise<void> {\n    if (this.installPrompt) {\n      // Use native prompt if available\n      await this.showNativePrompt();\n    } else {\n      // Show platform-specific instructions\n      this.showInstallInstructions();\n    }\n  }\n\n  /**\n   * Show platform-specific install instructions\n   */\n  private showInstallInstructions(): void {\n    let instructions = '';\n    \n    switch (this.platformInfo.name) {\n      case 'ios':\n        instructions = this.config.platforms.ios?.customInstructions ||\n          'Tocca il pulsante Condividi () e seleziona \"Aggiungi alla schermata Home\"';\n        break;\n      case 'android':\n        instructions = 'Apri il menu del browser e seleziona \"Aggiungi alla schermata Home\"';\n        break;\n      case 'desktop':\n        instructions = 'Cerca l\\'icona di installazione nella barra degli indirizzi del browser';\n        break;\n      default:\n        instructions = 'Controlla le opzioni del tuo browser per installare questa app';\n    }\n\n    // Show instructions in a simple alert or modal\n    alert(instructions);\n    \n    this.emit('install:started', { platform: this.platformInfo.name });\n    this.trackAnalytics('install_instructions_shown', { \n      platform: this.platformInfo.name,\n      instructions \n    });\n  }\n\n  /**\n   * Handle app installed\n   */\n  private handleAppInstalled(outcome: 'accepted' | 'dismissed'): void {\n    this.updateEngagementData({ installed: true });\n    \n    this.emit('install:completed', { \n      outcome, \n      platform: this.platformInfo.name \n    });\n    \n    this.trackAnalytics('app_installed', { \n      platform: this.platformInfo.name,\n      outcome \n    });\n  }\n\n  /**\n   * Handle prompt dismissed\n   */\n  private handlePromptDismissed(reason: 'user' | 'timeout' | 'error'): void {\n    this.updateEngagementData({ dismissed: true });\n    \n    this.emit('prompt:dismissed', { reason });\n    this.trackAnalytics('install_prompt_dismissed', { reason });\n  }\n\n  /**\n   * Track analytics event\n   */\n  private trackAnalytics(event: string, data: any): void {\n    if (!this.config.analytics.enabled) {\n      return;\n    }\n\n    const analyticsData = {\n      ...data,\n      timestamp: new Date().toISOString(),\n      platform: this.platformInfo.name,\n      browser: this.platformInfo.browser,\n      engagement: this.engagementData,\n      ...this.config.analytics.customEvents,\n    };\n\n    this.emit('analytics:tracked', { event, data: analyticsData });\n\n    // Send to analytics service (implement based on your analytics provider)\n    if (typeof gtag !== 'undefined') {\n      gtag('event', event, analyticsData);\n    }\n  }\n\n  /**\n   * Record receipt created (for engagement tracking)\n   */\n  recordReceiptCreated(): void {\n    this.updateEngagementData({\n      receiptsCreated: this.engagementData.receiptsCreated + 1,\n    });\n  }\n\n  /**\n   * Manually trigger install prompt\n   */\n  async showInstallPrompt(): Promise<void> {\n    if (this.platformInfo.supportsNativePrompt && this.installPrompt) {\n      await this.showNativePrompt();\n    } else if (this.config.customPrompt.enabled) {\n      await this.showCustomPrompt();\n    } else {\n      this.showInstallInstructions();\n    }\n  }\n\n  /**\n   * Check if app can be installed\n   */\n  canInstall(): boolean {\n    return !this.platformInfo.isStandalone && \n           !this.engagementData.installed &&\n           (!!this.installPrompt || !!this.config.customPrompt?.enabled);\n  }\n\n  /**\n   * Get engagement statistics\n   */\n  getEngagementStats(): EngagementData {\n    return { ...this.engagementData };\n  }\n\n  /**\n   * Get platform information\n   */\n  getPlatformInfo(): PlatformInfo {\n    return { ...this.platformInfo };\n  }\n\n  /**\n   * Reset engagement data (for testing)\n   */\n  resetEngagement(): void {\n    const now = Date.now();\n    this.engagementData = {\n      firstVisit: now,\n      lastVisit: now,\n      totalTime: 0,\n      pageViews: 1,\n      receiptsCreated: 0,\n      returnVisits: 0,\n      promptsShown: 0,\n      dismissed: false,\n      installed: false,\n    };\n    this.saveEngagementData();\n  }\n\n  /**\n   * Destroy the app installer\n   */\n  destroy(): void {\n    if (this.engagementTimer) {\n      clearInterval(this.engagementTimer);\n    }\n    \n    if (this.promptTimeout) {\n      clearTimeout(this.promptTimeout);\n    }\n    \n    this.hideCustomPrompt();\n    this.saveEngagementData();\n    this.removeAllListeners();\n  }\n}\n\n// Global gtag declaration for TypeScript\ndeclare const gtag: any;","/**\n * PWA Manager for A-Cube E-Receipt SDK\n * Manages Progressive Web App features including service worker registration,\n * caching strategies, and offline functionality\n * \n * Features:\n * - Service worker lifecycle management\n * - Cache control and monitoring\n * - Offline queue integration\n * - App install prompts\n * - Background sync coordination\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport { PushNotificationManager, type PushNotificationConfig, type NotificationPayload } from './push-notifications';\nimport { AppInstaller, type AppInstallerConfig, type InstallCriteria, type EngagementData } from './app-installer';\n\n/**\n * PWA Manager configuration\n */\nexport interface PWAManagerConfig {\n  /** Service worker script path */\n  serviceWorkerPath?: string;\n  \n  /** Enable automatic service worker registration */\n  autoRegister?: boolean;\n  \n  /** Enable app install prompts */\n  enableInstallPrompts?: boolean;\n  \n  /** Cache strategy preferences */\n  cacheStrategy?: {\n    /** API cache duration in milliseconds */\n    apiCacheDuration?: number;\n    \n    /** Static cache duration in milliseconds */\n    staticCacheDuration?: number;\n    \n    /** Enable stale-while-revalidate for API calls */\n    staleWhileRevalidate?: boolean;\n  };\n  \n  /** Background sync configuration */\n  backgroundSync?: {\n    /** Enable periodic background sync */\n    enablePeriodicSync?: boolean;\n    \n    /** Minimum interval for periodic sync in milliseconds */\n    minSyncInterval?: number;\n  };\n  \n  /** Push notification configuration */\n  pushNotifications?: {\n    /** Enable push notifications */\n    enabled?: boolean;\n    \n    /** VAPID public key for push notifications */\n    vapidPublicKey?: string;\n  };\n  \n  /** App installer configuration */\n  appInstaller?: {\n    /** Enable app install prompts */\n    enabled?: boolean;\n    \n    /** Install criteria configuration */\n    criteria?: InstallCriteria;\n    \n    /** Auto-show prompt when criteria met */\n    autoShow?: boolean;\n    \n    /** Custom installer configuration */\n    config?: Partial<AppInstallerConfig>;\n  };\n}\n\n/**\n * PWA events\n */\nexport interface PWAEvents {\n  'sw:registered': { registration: ServiceWorkerRegistration };\n  'sw:updated': { registration: ServiceWorkerRegistration };\n  'sw:error': { error: Error };\n  'install:available': { prompt: BeforeInstallPromptEvent };\n  'install:completed': { outcome: 'accepted' | 'dismissed' };\n  'cache:updated': { cacheName: string; size: number };\n  'offline:queued': { request: string; id: string };\n  'offline:synced': { request: string; id: string };\n  'push:received': { data: any };\n  'push:subscribed': { subscription: any };\n  'push:unsubscribed': { reason: string };\n  'notification:shown': { notification: NotificationPayload };\n  'notification:clicked': { action: string; data: any };\n  'sync:completed': { syncedCount: number };\n  'app:installable': { canInstall: boolean };\n  'app:installed': { platform: string };\n  'app:install-prompted': { type: 'native' | 'custom' };\n  'app:install-dismissed': { reason: 'user' | 'timeout' | 'error' };\n}\n\n/**\n * Cache information\n */\nexport interface CacheInfo {\n  name: string;\n  size: number;\n  lastUpdated?: Date;\n}\n\n/**\n * Install prompt event (enhanced BeforeInstallPromptEvent)\n */\ninterface BeforeInstallPromptEvent extends Event {\n  readonly platforms: string[];\n  readonly userChoice: Promise<{\n    outcome: 'accepted' | 'dismissed';\n    platform: string;\n  }>;\n  prompt(): Promise<void>;\n}\n\nconst DEFAULT_CONFIG: Required<PWAManagerConfig> = {\n  serviceWorkerPath: '/sw.js',\n  autoRegister: true,\n  enableInstallPrompts: true,\n  cacheStrategy: {\n    apiCacheDuration: 5 * 60 * 1000, // 5 minutes\n    staticCacheDuration: 24 * 60 * 60 * 1000, // 24 hours\n    staleWhileRevalidate: true,\n  },\n  backgroundSync: {\n    enablePeriodicSync: true,\n    minSyncInterval: 15 * 60 * 1000, // 15 minutes\n  },\n  pushNotifications: {\n    enabled: false,\n    vapidPublicKey: '',\n  },\n  appInstaller: {\n    enabled: true,\n    autoShow: true,\n    criteria: {\n      minEngagementTime: 2 * 60 * 1000, // 2 minutes\n      minPageViews: 3,\n      minReceiptsCreated: 1,\n    },\n    config: {},\n  },\n};\n\n/**\n * PWA Manager - Coordinates Progressive Web App features\n */\nexport class PWAManager extends EventEmitter<PWAEvents> {\n  private config: Required<PWAManagerConfig>;\n  private registration: ServiceWorkerRegistration | null = null;\n  private installPrompt: BeforeInstallPromptEvent | null = null;\n  private isSupported: boolean;\n  private messageChannel: MessageChannel | null = null;\n  private pushManager?: PushNotificationManager;\n  private appInstaller?: AppInstaller;\n\n  constructor(config: PWAManagerConfig = {}) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.isSupported = this.checkPWASupport();\n    \n    if (this.isSupported) {\n      this.setupEventListeners();\n      \n      if (this.config.autoRegister) {\n        this.registerServiceWorker().catch(error => {\n          console.error('Failed to auto-register service worker:', error);\n        });\n      }\n    }\n  }\n\n  /**\n   * Check if PWA features are supported\n   */\n  private checkPWASupport(): boolean {\n    return (\n      typeof window !== 'undefined' &&\n      'serviceWorker' in navigator &&\n      'caches' in window &&\n      'fetch' in window\n    );\n  }\n\n  /**\n   * Setup event listeners for PWA features\n   */\n  private setupEventListeners(): void {\n    // Install prompt handling\n    if (this.config.enableInstallPrompts) {\n      window.addEventListener('beforeinstallprompt', (event) => {\n        event.preventDefault();\n        this.installPrompt = event as BeforeInstallPromptEvent;\n        this.emit('install:available', { prompt: this.installPrompt });\n      });\n\n      window.addEventListener('appinstalled', () => {\n        this.installPrompt = null;\n        this.emit('install:completed', { outcome: 'accepted' });\n      });\n    }\n\n    // Online/offline handling\n    window.addEventListener('online', () => {\n      this.handleOnlineStatusChange(true);\n    });\n\n    window.addEventListener('offline', () => {\n      this.handleOnlineStatusChange(false);\n    });\n  }\n\n  /**\n   * Register service worker\n   */\n  async registerServiceWorker(): Promise<ServiceWorkerRegistration> {\n    if (!this.isSupported) {\n      throw new Error('Service workers are not supported in this environment');\n    }\n\n    try {\n      this.registration = await navigator.serviceWorker.register(\n        this.config.serviceWorkerPath,\n        {\n          scope: '/',\n          updateViaCache: 'imports',\n        }\n      );\n\n      // Setup message channel for communication\n      this.setupMessageChannel();\n\n      // Handle registration updates\n      this.registration.addEventListener('updatefound', () => {\n        const newWorker = this.registration!.installing;\n        if (newWorker) {\n          newWorker.addEventListener('statechange', () => {\n            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n              this.emit('sw:updated', { registration: this.registration! });\n            }\n          });\n        }\n      });\n\n      // Register for background sync\n      if (this.config.backgroundSync.enablePeriodicSync && 'periodicSync' in this.registration) {\n        await this.registerPeriodicSync();\n      }\n\n      // Register for push notifications\n      if (this.config.pushNotifications.enabled) {\n        await this.initializePushNotifications();\n      }\n      \n      // Initialize app installer\n      if (this.config.appInstaller.enabled) {\n        await this.initializeAppInstaller();\n      }\n\n      this.emit('sw:registered', { registration: this.registration });\n      console.log('Service worker registered successfully');\n\n      return this.registration;\n    } catch (error) {\n      const swError = new Error(`Service worker registration failed: ${error}`);\n      this.emit('sw:error', { error: swError });\n      throw swError;\n    }\n  }\n\n  /**\n   * Setup message channel for service worker communication\n   */\n  private setupMessageChannel(): void {\n    if (!this.registration) return;\n\n    this.messageChannel = new MessageChannel();\n    \n    // Listen for messages from service worker\n    this.messageChannel.port1.onmessage = (event) => {\n      const { type, data } = event.data;\n      \n      switch (type) {\n        case 'CACHE_SIZE':\n          this.emit('cache:updated', { cacheName: 'all', size: data.reduce((sum: number, cache: any) => sum + cache.size, 0) });\n          break;\n          \n        case 'OFFLINE_SYNC_SUCCESS':\n          this.emit('offline:synced', { request: data.url, id: data.id });\n          break;\n          \n        case 'CACHE_CLEARED':\n          this.emit('cache:updated', { cacheName: 'all', size: 0 });\n          break;\n      }\n    };\n\n    // Send port to service worker\n    navigator.serviceWorker.controller?.postMessage(\n      { type: 'PORT_TRANSFER' },\n      [this.messageChannel.port2]\n    );\n  }\n\n  /**\n   * Register periodic background sync\n   */\n  private async registerPeriodicSync(): Promise<void> {\n    if (!this.registration || !('periodicSync' in this.registration)) {\n      console.warn('Periodic background sync not supported');\n      return;\n    }\n\n    try {\n      // Request permission for background sync\n      const status = await navigator.permissions.query({ name: 'periodic-background-sync' as PermissionName });\n      \n      if (status.state === 'granted') {\n        await (this.registration as any).periodicSync.register('offline-queue-periodic', {\n          minInterval: this.config.backgroundSync.minSyncInterval,\n        });\n        \n        console.log('Periodic background sync registered');\n      }\n    } catch (error) {\n      console.warn('Failed to register periodic background sync:', error);\n    }\n  }\n\n  /**\n   * Initialize app installer\n   */\n  private async initializeAppInstaller(): Promise<void> {\n    try {\n      \n      const installerConfig: AppInstallerConfig = {\n        ...this.config.appInstaller.config,\n        criteria: this.config.appInstaller.criteria ?? DEFAULT_CONFIG.appInstaller.criteria,\n        autoShow: this.config.appInstaller.autoShow ?? DEFAULT_CONFIG.appInstaller.autoShow,\n      } as AppInstallerConfig;\n      \n      this.appInstaller = new AppInstaller(installerConfig);\n      \n      // Forward app installer events\n      this.appInstaller.on('criteria:met', () => {\n        this.emit('app:installable', { canInstall: true });\n      });\n      \n      this.appInstaller.on('prompt:shown', ({ type }) => {\n        this.emit('app:install-prompted', { type });\n      });\n      \n      this.appInstaller.on('prompt:dismissed', ({ reason }) => {\n        this.emit('app:install-dismissed', { reason });\n      });\n      \n      this.appInstaller.on('install:completed', ({ outcome, platform }) => {\n        if (outcome === 'accepted') {\n          this.emit('app:installed', { platform });\n        }\n      });\n      \n      console.log('App installer initialized');\n    } catch (error) {\n      console.warn('Failed to initialize app installer:', error);\n    }\n  }\n\n  /**\n   * Initialize push notifications\n   */\n  private async initializePushNotifications(): Promise<void> {\n    if (!this.registration || !this.config.pushNotifications.vapidPublicKey) {\n      console.warn('Push notifications not configured');\n      return;\n    }\n\n    try {\n      // Create push notification manager\n      const pushConfig: PushNotificationConfig = {\n        vapidPublicKey: this.config.pushNotifications.vapidPublicKey,\n        serviceWorkerRegistration: this.registration,\n        autoSubscribe: true,\n        language: 'it', // Default for Italian e-receipts\n        serverEndpoint: '/api/push/subscribe',\n      };\n\n      this.pushManager = new PushNotificationManager(pushConfig);\n\n      // Forward push notification events\n      this.pushManager.on('subscription:created', ({ subscription }) => {\n        this.emit('push:subscribed', { subscription });\n      });\n\n      this.pushManager.on('subscription:deleted', ({ reason }) => {\n        this.emit('push:unsubscribed', { reason });\n      });\n\n      this.pushManager.on('notification:shown', ({ notification }) => {\n        this.emit('notification:shown', { notification });\n      });\n\n      this.pushManager.on('notification:clicked', ({ action, data }) => {\n        this.emit('notification:clicked', { action, data });\n      });\n\n      this.pushManager.on('error', (error) => {\n        console.error('Push notification error:', error);\n      });\n\n      console.log('Push notifications initialized');\n    } catch (error) {\n      console.warn('Failed to initialize push notifications:', error);\n    }\n  }\n\n\n  /**\n   * Handle online/offline status changes\n   */\n  private handleOnlineStatusChange(isOnline: boolean): void {\n    if (isOnline && this.registration) {\n      // Trigger background sync when coming back online\n      this.triggerBackgroundSync();\n    }\n  }\n\n  /**\n   * Trigger background sync\n   */\n  async triggerBackgroundSync(): Promise<void> {\n    if (!this.registration || !('sync' in this.registration)) {\n      console.warn('Background sync not supported');\n      return;\n    }\n\n    try {\n      await (this.registration as any).sync.register('offline-queue-sync');\n      console.log('Background sync triggered');\n    } catch (error) {\n      console.warn('Failed to trigger background sync:', error);\n    }\n  }\n\n  /**\n   * Show app install prompt\n   */\n  async showInstallPrompt(): Promise<{ outcome: 'accepted' | 'dismissed'; platform: string } | null> {\n    if (this.appInstaller) {\n      try {\n        await this.appInstaller.showInstallPrompt();\n        return null; // AppInstaller will emit events\n      } catch (error) {\n        console.error('Failed to show install prompt via AppInstaller:', error);\n      }\n    }\n    \n    // Fallback to original implementation\n    if (!this.installPrompt) {\n      console.warn('Install prompt not available');\n      return null;\n    }\n\n    try {\n      await this.installPrompt.prompt();\n      const choiceResult = await this.installPrompt.userChoice;\n      \n      this.emit('install:completed', { outcome: choiceResult.outcome });\n      this.installPrompt = null;\n      \n      return choiceResult;\n    } catch (error) {\n      console.error('Failed to show install prompt:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get cache information\n   */\n  async getCacheInfo(): Promise<CacheInfo[]> {\n    if (!this.messageChannel) {\n      throw new Error('Service worker not registered or message channel not available');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Cache info request timeout'));\n      }, 5000);\n\n      this.messageChannel!.port1.onmessage = (event) => {\n        if (event.data.type === 'CACHE_SIZE') {\n          clearTimeout(timeout);\n          const cacheInfo: CacheInfo[] = event.data.data.map((cache: any) => ({\n            name: cache.name,\n            size: cache.size,\n            lastUpdated: new Date(),\n          }));\n          resolve(cacheInfo);\n        }\n      };\n\n      navigator.serviceWorker.controller?.postMessage({ type: 'GET_CACHE_SIZE' });\n    });\n  }\n\n  /**\n   * Clear all caches\n   */\n  async clearCache(): Promise<void> {\n    if (!this.messageChannel) {\n      throw new Error('Service worker not registered or message channel not available');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Clear cache request timeout'));\n      }, 10000);\n\n      this.messageChannel!.port1.onmessage = (event) => {\n        if (event.data.type === 'CACHE_CLEARED') {\n          clearTimeout(timeout);\n          resolve();\n        }\n      };\n\n      navigator.serviceWorker.controller?.postMessage({ type: 'CLEAR_CACHE' });\n    });\n  }\n\n  /**\n   * Force service worker update\n   */\n  async updateServiceWorker(): Promise<void> {\n    if (!this.registration) {\n      throw new Error('Service worker not registered');\n    }\n\n    try {\n      await this.registration.update();\n      \n      if (this.registration.waiting) {\n        // Signal the waiting service worker to skip waiting\n        navigator.serviceWorker.controller?.postMessage({ type: 'SKIP_WAITING' });\n      }\n    } catch (error) {\n      console.error('Failed to update service worker:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check if app is installable\n   */\n  isInstallable(): boolean {\n    if (this.appInstaller) {\n      return this.appInstaller.canInstall();\n    }\n    return this.installPrompt !== null;\n  }\n\n  /**\n   * Check if app is installed\n   */\n  isInstalled(): boolean {\n    if (this.appInstaller) {\n      return this.appInstaller.getPlatformInfo().isStandalone;\n    }\n    return window.matchMedia('(display-mode: standalone)').matches ||\n           window.matchMedia('(display-mode: fullscreen)').matches ||\n           (window.navigator as any).standalone === true;\n  }\n\n  /**\n   * Get service worker registration\n   */\n  getRegistration(): ServiceWorkerRegistration | null {\n    return this.registration;\n  }\n\n  /**\n   * Check if PWA features are supported\n   */\n  isPWASupported(): boolean {\n    return this.isSupported;\n  }\n\n  /**\n   * Get push notification manager\n   */\n  getPushManager(): PushNotificationManager | undefined {\n    return this.pushManager;\n  }\n  \n  /**\n   * Get app installer\n   */\n  getAppInstaller(): AppInstaller | undefined {\n    return this.appInstaller;\n  }\n  \n  /**\n   * Record receipt created (for app installer engagement tracking)\n   */\n  recordReceiptCreated(): void {\n    if (this.appInstaller) {\n      this.appInstaller.recordReceiptCreated();\n    }\n  }\n  \n  /**\n   * Get engagement statistics\n   */\n  getEngagementStats(): EngagementData | null {\n    if (this.appInstaller) {\n      return this.appInstaller.getEngagementStats();\n    }\n    return null;\n  }\n  \n  /**\n   * Check if app install criteria are met\n   */\n  async checkInstallCriteria(): Promise<boolean> {\n    if (this.appInstaller) {\n      return this.appInstaller.checkCriteria();\n    }\n    return false;\n  }\n\n  /**\n   * Subscribe to push notifications\n   */\n  async subscribeToPushNotifications(): Promise<any> {\n    if (!this.pushManager) {\n      throw new Error('Push notifications not initialized');\n    }\n    \n    return this.pushManager.subscribe();\n  }\n\n  /**\n   * Unsubscribe from push notifications\n   */\n  async unsubscribeFromPushNotifications(): Promise<void> {\n    if (!this.pushManager) {\n      throw new Error('Push notifications not initialized');\n    }\n    \n    return this.pushManager.unsubscribe();\n  }\n\n  /**\n   * Show a notification\n   */\n  async showNotification(payload: NotificationPayload): Promise<void> {\n    if (!this.pushManager) {\n      throw new Error('Push notifications not initialized');\n    }\n    \n    return this.pushManager.showNotification(payload);\n  }\n\n  /**\n   * Check if subscribed to push notifications\n   */\n  isPushSubscribed(): boolean {\n    return this.pushManager?.isSubscribed() || false;\n  }\n\n  /**\n   * Destroy PWA manager\n   */\n  async destroy(): Promise<void> {\n    if (this.registration) {\n      try {\n        await this.registration.unregister();\n      } catch (error) {\n        console.warn('Failed to unregister service worker:', error);\n      }\n    }\n\n    if (this.messageChannel) {\n      this.messageChannel.port1.close();\n      this.messageChannel.port2.close();\n    }\n\n    if (this.pushManager) {\n      await this.pushManager.destroy();\n    }\n    \n    if (this.appInstaller) {\n      this.appInstaller.destroy();\n    }\n\n    this.removeAllListeners();\n  }\n}","/**\n * PWA Manifest Generator for A-Cube E-Receipt SDK\n * Generates Progressive Web App manifest.json files with Italian e-receipt specific configuration\n * \n * Features:\n * - Dynamic manifest generation\n * - Italian localization support\n * - E-receipt specific shortcuts and categories\n * - Theme customization\n * - Icon generation support\n */\n\n/**\n * PWA Manifest configuration\n */\nexport interface PWAManifestConfig {\n  /** App name */\n  name?: string;\n  \n  /** Short app name for home screen */\n  shortName?: string;\n  \n  /** App description */\n  description?: string;\n  \n  /** App start URL */\n  startUrl?: string;\n  \n  /** App scope */\n  scope?: string;\n  \n  /** Display mode */\n  display?: 'standalone' | 'fullscreen' | 'minimal-ui' | 'browser';\n  \n  /** Orientation preference */\n  orientation?: 'any' | 'natural' | 'landscape' | 'portrait';\n  \n  /** Theme color */\n  themeColor?: string;\n  \n  /** Background color */\n  backgroundColor?: string;\n  \n  /** App language */\n  lang?: string;\n  \n  /** App categories */\n  categories?: string[];\n  \n  /** Screenshots for app stores */\n  screenshots?: Array<{\n    src: string;\n    sizes: string;\n    type: string;\n    platform?: 'narrow' | 'wide';\n    label?: string;\n  }>;\n  \n  /** App shortcuts */\n  shortcuts?: Array<{\n    name: string;\n    url: string;\n    description?: string;\n    icons?: Array<{\n      src: string;\n      sizes: string;\n      type?: string;\n    }>;\n  }>;\n  \n  /** Custom icons */\n  icons?: Array<{\n    src: string;\n    sizes: string;\n    type?: string;\n    purpose?: 'any' | 'maskable' | 'monochrome';\n  }>;\n}\n\n/**\n * Web App Manifest interface\n */\nexport interface WebAppManifest {\n  name: string;\n  short_name: string;\n  description: string;\n  start_url: string;\n  scope: string;\n  display: string;\n  orientation: string;\n  theme_color: string;\n  background_color: string;\n  lang: string;\n  categories: string[];\n  icons: Array<{\n    src: string;\n    sizes: string;\n    type: string;\n    purpose?: string;\n  }>;\n  screenshots?: Array<{\n    src: string;\n    sizes: string;\n    type: string;\n    platform?: string;\n    label?: string;\n  }>;\n  shortcuts?: Array<{\n    name: string;\n    url: string;\n    description?: string;\n    icons?: Array<{\n      src: string;\n      sizes: string;\n      type?: string;\n    }>;\n  }>;\n  prefer_related_applications?: boolean;\n  related_applications?: Array<{\n    platform: string;\n    url: string;\n    id?: string;\n  }>;\n}\n\n/**\n * Default manifest configuration for Italian e-receipt apps\n */\nconst DEFAULT_MANIFEST_CONFIG: Required<PWAManifestConfig> = {\n  name: 'A-Cube E-Receipt',\n  shortName: 'A-Cube',\n  description: 'Gestione scontrini elettronici per il sistema fiscale italiano',\n  startUrl: '/',\n  scope: '/',\n  display: 'standalone',\n  orientation: 'portrait',\n  themeColor: '#1976d2',\n  backgroundColor: '#ffffff',\n  lang: 'it',\n  categories: ['business', 'finance', 'productivity'],\n  icons: [\n    {\n      src: '/icons/icon-72x72.png',\n      sizes: '72x72',\n      type: 'image/png',\n      purpose: 'any',\n    },\n    {\n      src: '/icons/icon-96x96.png',\n      sizes: '96x96',\n      type: 'image/png',\n      purpose: 'any',\n    },\n    {\n      src: '/icons/icon-128x128.png',\n      sizes: '128x128',\n      type: 'image/png',\n      purpose: 'any',\n    },\n    {\n      src: '/icons/icon-144x144.png',\n      sizes: '144x144',\n      type: 'image/png',\n      purpose: 'any',\n    },\n    {\n      src: '/icons/icon-152x152.png',\n      sizes: '152x152',\n      type: 'image/png',\n      purpose: 'any',\n    },\n    {\n      src: '/icons/icon-192x192.png',\n      sizes: '192x192',\n      type: 'image/png',\n      purpose: 'any',\n    },\n    {\n      src: '/icons/icon-384x384.png',\n      sizes: '384x384',\n      type: 'image/png',\n      purpose: 'any',\n    },\n    {\n      src: '/icons/icon-512x512.png',\n      sizes: '512x512',\n      type: 'image/png',\n      purpose: 'any',\n    },\n    {\n      src: '/icons/maskable-icon-192x192.png',\n      sizes: '192x192',\n      type: 'image/png',\n      purpose: 'maskable',\n    },\n    {\n      src: '/icons/maskable-icon-512x512.png',\n      sizes: '512x512',\n      type: 'image/png',\n      purpose: 'maskable',\n    },\n  ],\n  screenshots: [\n    {\n      src: '/screenshots/desktop.png',\n      sizes: '1280x720',\n      type: 'image/png',\n      platform: 'wide',\n      label: 'Desktop view of A-Cube E-Receipt dashboard',\n    },\n    {\n      src: '/screenshots/mobile.png',\n      sizes: '750x1334',\n      type: 'image/png',\n      platform: 'narrow',\n      label: 'Mobile view of A-Cube E-Receipt',\n    },\n  ],\n  shortcuts: [\n    {\n      name: 'Nuovo Scontrino',\n      url: '/receipts/new',\n      description: 'Crea un nuovo scontrino elettronico',\n      icons: [\n        {\n          src: '/icons/new-receipt-96x96.png',\n          sizes: '96x96',\n          type: 'image/png',\n        },\n      ],\n    },\n    {\n      name: 'Dashboard',\n      url: '/dashboard',\n      description: 'Visualizza il pannello di controllo',\n      icons: [\n        {\n          src: '/icons/dashboard-96x96.png',\n          sizes: '96x96',\n          type: 'image/png',\n        },\n      ],\n    },\n    {\n      name: 'Storico',\n      url: '/receipts/history',\n      description: 'Consulta lo storico degli scontrini',\n      icons: [\n        {\n          src: '/icons/history-96x96.png',\n          sizes: '96x96',\n          type: 'image/png',\n        },\n      ],\n    },\n    {\n      name: 'Impostazioni',\n      url: '/settings',\n      description: 'Gestisci le impostazioni dell\\'applicazione',\n      icons: [\n        {\n          src: '/icons/settings-96x96.png',\n          sizes: '96x96',\n          type: 'image/png',\n        },\n      ],\n    },\n  ],\n};\n\n/**\n * PWA Manifest Generator\n * Creates and manages Progressive Web App manifest files\n */\nexport class ManifestGenerator {\n  private config: Required<PWAManifestConfig>;\n\n  constructor(config: PWAManifestConfig = {}) {\n    this.config = { ...DEFAULT_MANIFEST_CONFIG, ...config };\n  }\n\n  /**\n   * Generate web app manifest\n   */\n  generateManifest(): WebAppManifest {\n    const manifest: WebAppManifest = {\n      name: this.config.name,\n      short_name: this.config.shortName,\n      description: this.config.description,\n      start_url: this.config.startUrl,\n      scope: this.config.scope,\n      display: this.config.display,\n      orientation: this.config.orientation,\n      theme_color: this.config.themeColor,\n      background_color: this.config.backgroundColor,\n      lang: this.config.lang,\n      categories: this.config.categories,\n      icons: this.config.icons.map(icon => ({\n        src: icon.src,\n        sizes: icon.sizes,\n        type: icon.type || 'image/png',\n        ...(icon.purpose && { purpose: icon.purpose }),\n      })),\n    };\n\n    // Add optional properties\n    if (this.config.screenshots && this.config.screenshots.length > 0) {\n      manifest.screenshots = this.config.screenshots.map(screenshot => ({\n        src: screenshot.src,\n        sizes: screenshot.sizes,\n        type: screenshot.type,\n        ...(screenshot.platform && { platform: screenshot.platform }),\n        ...(screenshot.label && { label: screenshot.label }),\n      }));\n    }\n\n    if (this.config.shortcuts && this.config.shortcuts.length > 0) {\n      manifest.shortcuts = this.config.shortcuts.map(shortcut => ({\n        name: shortcut.name,\n        url: shortcut.url,\n        ...(shortcut.description && { description: shortcut.description }),\n        ...(shortcut.icons && { icons: shortcut.icons.map(icon => ({\n          src: icon.src,\n          sizes: icon.sizes,\n          ...(icon.type && { type: icon.type }),\n        })) }),\n      }));\n    }\n\n    return manifest;\n  }\n\n  /**\n   * Generate manifest as JSON string\n   */\n  generateManifestJSON(): string {\n    return JSON.stringify(this.generateManifest(), null, 2);\n  }\n\n  /**\n   * Generate HTML meta tags for PWA\n   */\n  generateHTMLMetaTags(): string {\n    const manifest = this.generateManifest();\n    const tags: string[] = [];\n\n    // Basic PWA meta tags\n    tags.push(`<meta name=\"application-name\" content=\"${manifest.name}\">`);\n    tags.push(`<meta name=\"theme-color\" content=\"${manifest.theme_color}\">`);\n    tags.push(`<meta name=\"description\" content=\"${manifest.description}\">`);\n\n    // Viewport\n    tags.push('<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">');\n\n    // Manifest link\n    tags.push('<link rel=\"manifest\" href=\"/manifest.json\">');\n\n    // Apple-specific meta tags\n    tags.push('<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">');\n    tags.push(`<meta name=\"apple-mobile-web-app-title\" content=\"${manifest.short_name}\">`);\n    tags.push('<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"default\">');\n\n    // Apple touch icons\n    const appleIcons = manifest.icons.filter(icon => \n      ['152x152', '180x180', '192x192'].includes(icon.sizes)\n    );\n    \n    appleIcons.forEach(icon => {\n      tags.push(`<link rel=\"apple-touch-icon\" sizes=\"${icon.sizes}\" href=\"${icon.src}\">`);\n    });\n\n    // Favicon\n    const favicon = manifest.icons.find(icon => icon.sizes === '32x32') || manifest.icons[0];\n    if (favicon) {\n      tags.push(`<link rel=\"icon\" type=\"${favicon.type}\" href=\"${favicon.src}\">`);\n    }\n\n    // Microsoft-specific\n    tags.push(`<meta name=\"msapplication-TileColor\" content=\"${manifest.theme_color}\">`);\n    const msIcon = manifest.icons.find(icon => icon.sizes === '144x144');\n    if (msIcon) {\n      tags.push(`<meta name=\"msapplication-TileImage\" content=\"${msIcon.src}\">`);\n    }\n\n    return tags.join('\\n');\n  }\n\n  /**\n   * Generate service worker registration script\n   */\n  generateServiceWorkerScript(serviceWorkerPath: string = '/sw.js'): string {\n    return `\n<script>\n  if ('serviceWorker' in navigator) {\n    window.addEventListener('load', () => {\n      navigator.serviceWorker.register('${serviceWorkerPath}')\n        .then((registration) => {\n          console.log('SW registered: ', registration);\n        })\n        .catch((registrationError) => {\n          console.log('SW registration failed: ', registrationError);\n        });\n    });\n  }\n</script>`.trim();\n  }\n\n  /**\n   * Update manifest configuration\n   */\n  updateConfig(updates: Partial<PWAManifestConfig>): void {\n    this.config = { ...this.config, ...updates };\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): Required<PWAManifestConfig> {\n    return { ...this.config };\n  }\n\n  /**\n   * Generate localized manifest for different languages\n   */\n  generateLocalizedManifest(locale: string): WebAppManifest {\n    const localizedConfig = this.getLocalizedConfig(locale);\n    const generator = new ManifestGenerator(localizedConfig);\n    return generator.generateManifest();\n  }\n\n  /**\n   * Get localized configuration\n   */\n  private getLocalizedConfig(locale: string): PWAManifestConfig {\n    const localizations: Record<string, Partial<PWAManifestConfig>> = {\n      'en': {\n        name: 'A-Cube E-Receipt',\n        shortName: 'A-Cube',\n        description: 'Electronic receipt management for Italian tax system',\n        lang: 'en',\n        shortcuts: [\n          {\n            name: 'New Receipt',\n            url: '/receipts/new',\n            description: 'Create a new electronic receipt',\n          },\n          {\n            name: 'Dashboard',\n            url: '/dashboard',\n            description: 'View control panel',\n          },\n          {\n            name: 'History',\n            url: '/receipts/history',\n            description: 'Browse receipt history',\n          },\n          {\n            name: 'Settings',\n            url: '/settings',\n            description: 'Manage application settings',\n          },\n        ],\n      },\n      'de': {\n        name: 'A-Cube E-Receipt',\n        shortName: 'A-Cube',\n        description: 'Elektronische Belegverwaltung fr das italienische Steuersystem',\n        lang: 'de',\n        shortcuts: [\n          {\n            name: 'Neuer Beleg',\n            url: '/receipts/new',\n            description: 'Erstelle einen neuen elektronischen Beleg',\n          },\n          {\n            name: 'Dashboard',\n            url: '/dashboard',\n            description: 'Kontrollpanel anzeigen',\n          },\n          {\n            name: 'Verlauf',\n            url: '/receipts/history',\n            description: 'Belegverlauf durchsuchen',\n          },\n          {\n            name: 'Einstellungen',\n            url: '/settings',\n            description: 'Anwendungseinstellungen verwalten',\n          },\n        ],\n      },\n      'fr': {\n        name: 'A-Cube E-Receipt',\n        shortName: 'A-Cube',\n        description: 'Gestion des reus lectroniques pour le systme fiscal italien',\n        lang: 'fr',\n        shortcuts: [\n          {\n            name: 'Nouveau Reu',\n            url: '/receipts/new',\n            description: 'Crer un nouveau reu lectronique',\n          },\n          {\n            name: 'Tableau de Bord',\n            url: '/dashboard',\n            description: 'Afficher le panneau de contrle',\n          },\n          {\n            name: 'Historique',\n            url: '/receipts/history',\n            description: 'Consulter l\\'historique des reus',\n          },\n          {\n            name: 'Paramtres',\n            url: '/settings',\n            description: 'Grer les paramtres de l\\'application',\n          },\n        ],\n      },\n    };\n\n    const localization = localizations[locale] || {};\n    return { ...this.config, ...localization };\n  }\n\n  /**\n   * Validate manifest configuration\n   */\n  validateManifest(): { isValid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    const manifest = this.generateManifest();\n\n    // Required fields validation\n    if (!manifest.name || manifest.name.length === 0) {\n      errors.push('Manifest name is required');\n    }\n\n    if (!manifest.short_name || manifest.short_name.length === 0) {\n      errors.push('Manifest short_name is required');\n    }\n\n    if (!manifest.start_url || manifest.start_url.length === 0) {\n      errors.push('Manifest start_url is required');\n    }\n\n    // Icons validation\n    if (!manifest.icons || manifest.icons.length === 0) {\n      errors.push('At least one icon is required');\n    } else {\n      const hasRequiredSizes = manifest.icons.some(icon => \n        ['192x192', '512x512'].includes(icon.sizes)\n      );\n      if (!hasRequiredSizes) {\n        errors.push('Icons with sizes 192x192 and 512x512 are recommended');\n      }\n    }\n\n    // Display mode validation\n    const validDisplayModes = ['standalone', 'fullscreen', 'minimal-ui', 'browser'];\n    if (!validDisplayModes.includes(manifest.display)) {\n      errors.push(`Invalid display mode: ${manifest.display}`);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Generate complete PWA setup files\n   */\n  generatePWAFiles(): { \n    manifest: string; \n    html: string; \n    serviceWorkerScript: string;\n    validation: { isValid: boolean; errors: string[] };\n  } {\n    return {\n      manifest: this.generateManifestJSON(),\n      html: this.generateHTMLMetaTags(),\n      serviceWorkerScript: this.generateServiceWorkerScript(),\n      validation: this.validateManifest(),\n    };\n  }\n}","/**\n * Progressive Sync Engine - Core synchronization system with partial failure recovery\n * Implements smart synchronization with delta sync, batch operations, and rollback capabilities\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport type {\n  SyncOptions,\n  SyncResult,\n  SyncStatistics,\n  SyncError,\n  SyncConflict,\n  SyncPhase,\n  SyncStatus,\n  DataDelta,\n  DeltaCalculationResult,\n  SyncEventTypeMap,\n} from './types';\n\nexport interface SyncEngineConfig {\n  maxConcurrentSyncs: number;\n  defaultTimeout: number;\n  defaultRetries: number;\n  batchSize: number;\n  enableRollback: boolean;\n  enableDeltaSync: boolean;\n  enableCompression: boolean;\n  checkpointInterval: number; // ms between checkpoints\n}\n\nconst DEFAULT_CONFIG: SyncEngineConfig = {\n  maxConcurrentSyncs: 3,\n  defaultTimeout: 30000,\n  defaultRetries: 3,\n  batchSize: 100,\n  enableRollback: true,\n  enableDeltaSync: true,\n  enableCompression: true,\n  checkpointInterval: 5000,\n};\n\nexport interface SyncCheckpoint {\n  id: string;\n  phase: SyncPhase;\n  timestamp: Date;\n  completedOperations: number;\n  state: Record<string, unknown>;\n}\n\nexport interface SyncExecutionContext {\n  syncId: string;\n  options: SyncOptions;\n  startTime: Date;\n  currentPhase: SyncPhase;\n  statistics: SyncStatistics;\n  errors: SyncError[];\n  conflicts: SyncConflict[];\n  checkpoints: SyncCheckpoint[];\n  abortController: AbortController;\n}\n\n/**\n * Progressive Sync Engine with partial failure recovery and rollback capabilities\n */\nexport class ProgressiveSyncEngine extends EventEmitter<SyncEventTypeMap> {\n  private config: SyncEngineConfig;\n  private activeSyncs = new Map<string, SyncExecutionContext>();\n  private syncQueue: Array<{ id: string; options: SyncOptions; resolve: (result: SyncResult) => void; reject: (error: Error) => void }> = [];\n  private isProcessingQueue = false;\n  private lastSyncTimestamp: Date | null = null;\n\n  constructor(config: Partial<SyncEngineConfig> = {}) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  /**\n   * Initialize the sync engine\n   */\n  async initialize(): Promise<void> {\n    // Start processing queue if needed\n    this.processQueue();\n    this.emit('sync.started', {\n      syncId: 'initialization',\n      strategy: 'immediate',\n      direction: 'bidirectional',\n      operation: 'full',\n      startTime: new Date(),\n      options: {}\n    });\n  }\n\n  /**\n   * Execute a progressive sync operation with rollback capability\n   */\n  async executeSync(options: SyncOptions = {}): Promise<SyncResult> {\n    const syncId = this.generateSyncId();\n    \n    // If max concurrent syncs reached, queue the sync\n    if (this.activeSyncs.size >= this.config.maxConcurrentSyncs) {\n      return this.queueSync(syncId, options);\n    }\n\n    return this.executeSyncInternal(syncId, options);\n  }\n\n  /**\n   * Calculate data deltas for efficient synchronization\n   */\n  async calculateDeltas(since?: Date): Promise<DeltaCalculationResult> {\n    const sinceTimestamp = since || this.lastSyncTimestamp || new Date(0);\n    \n    // This would typically query your data sources for changes\n    // For now, we'll simulate the calculation\n    const deltas: DataDelta[] = [];\n    \n    // TODO: Implement actual delta calculation based on your data model\n    // This would involve:\n    // 1. Querying each resource for changes since the timestamp\n    // 2. Calculating checksums for change detection\n    // 3. Resolving dependencies between records\n    \n    const totalChanges = deltas.length;\n    const estimatedSyncTime = this.estimateSyncTime(deltas);\n    const estimatedBandwidth = this.estimateBandwidth(deltas);\n\n    return {\n      deltas,\n      lastSyncTimestamp: sinceTimestamp,\n      totalChanges,\n      estimatedSyncTime,\n      estimatedBandwidth,\n    };\n  }\n\n  /**\n   * Get current sync status and metrics\n   */\n  getStatus(): {\n    activeSyncs: number;\n    queuedSyncs: number;\n    status: SyncStatus;\n    lastSync: Date | null;\n  } {\n    return {\n      activeSyncs: this.activeSyncs.size,\n      queuedSyncs: this.syncQueue.length,\n      status: this.activeSyncs.size > 0 ? 'syncing' : 'idle',\n      lastSync: this.lastSyncTimestamp,\n    };\n  }\n\n  /**\n   * Cancel a specific sync operation\n   */\n  async cancelSync(syncId: string): Promise<boolean> {\n    const context = this.activeSyncs.get(syncId);\n    if (!context) {\n      return false;\n    }\n\n    try {\n      context.abortController.abort();\n      \n      // Emit cancellation event\n      this.emit('sync.failed', {\n        type: 'sync.failed',\n        timestamp: new Date(),\n        requestId: syncId,\n        data: {\n          syncId,\n          error: {\n            id: `cancel_${Date.now()}`,\n            phase: context.currentPhase,\n            operation: 'cancel',\n            error: new Error('Sync cancelled by user'),\n            retryable: false,\n            timestamp: new Date(),\n            context: {},\n          },\n          phase: context.currentPhase,\n          retryable: false,\n        },\n      });\n\n      return true;\n    } catch (error) {\n      return false;\n    } finally {\n      this.activeSyncs.delete(syncId);\n      this.processQueue();\n    }\n  }\n\n  /**\n   * Cancel all active sync operations\n   */\n  async cancelAllSyncs(): Promise<void> {\n    const cancelPromises = Array.from(this.activeSyncs.keys()).map(syncId => \n      this.cancelSync(syncId)\n    );\n    \n    await Promise.all(cancelPromises);\n    this.syncQueue.length = 0; // Clear the queue\n  }\n\n  private async executeSyncInternal(syncId: string, options: SyncOptions): Promise<SyncResult> {\n    const context = this.createExecutionContext(syncId, options);\n    this.activeSyncs.set(syncId, context);\n\n    try {\n      // Emit sync started event\n      this.emitSyncStarted(context);\n\n      // Execute sync phases progressively\n      const result = await this.executeSyncPhases(context);\n      \n      // Emit completion event\n      this.emitSyncCompleted(context, result);\n      \n      this.lastSyncTimestamp = new Date();\n      return result;\n\n    } catch (error) {\n      // Handle sync failure with potential rollback\n      const syncError = this.createSyncError(context, error as Error);\n      context.errors.push(syncError);\n\n      // Attempt rollback if enabled\n      if (this.config.enableRollback && context.checkpoints.length > 0) {\n        await this.rollbackToLastCheckpoint(context);\n      }\n\n      // Emit failure event\n      this.emitSyncFailed(context, syncError);\n      \n      throw error;\n    } finally {\n      this.activeSyncs.delete(syncId);\n      this.processQueue();\n    }\n  }\n\n  private async executeSyncPhases(context: SyncExecutionContext): Promise<SyncResult> {\n    const phases: SyncPhase[] = ['validate', 'prepare', 'execute', 'verify', 'cleanup'];\n    \n    for (const phase of phases) {\n      // Check if sync was cancelled\n      if (context.abortController.signal.aborted) {\n        throw new Error('Sync cancelled');\n      }\n\n      context.currentPhase = phase;\n      \n      // Create checkpoint before each phase\n      if (this.config.enableRollback) {\n        await this.createCheckpoint(context, phase);\n      }\n\n      // Emit phase progress\n      this.emitSyncProgress(context, phases.indexOf(phase), phases.length);\n\n      try {\n        await this.executePhase(context, phase);\n      } catch (error) {\n        // Phase failed - attempt rollback and rethrow\n        if (this.config.enableRollback) {\n          await this.rollbackToLastCheckpoint(context);\n        }\n        throw error;\n      }\n    }\n\n    return this.createSyncResult(context, 'success');\n  }\n\n  private async executePhase(context: SyncExecutionContext, phase: SyncPhase): Promise<void> {\n    switch (phase) {\n      case 'validate':\n        await this.validateSyncOperation(context);\n        break;\n      case 'prepare':\n        await this.prepareSyncData(context);\n        break;\n      case 'execute':\n        await this.executeSyncOperations(context);\n        break;\n      case 'verify':\n        await this.verifySyncResults(context);\n        break;\n      case 'cleanup':\n        await this.cleanupSyncResources(context);\n        break;\n    }\n  }\n\n  private async validateSyncOperation(context: SyncExecutionContext): Promise<void> {\n    // Validate sync options and permissions\n    const { options } = context;\n    \n    if (options.resources && options.resources.length === 0) {\n      throw new Error('No resources specified for sync');\n    }\n\n    // Check network connectivity if required\n    // Validate authentication if required\n    // Check resource availability\n    \n    context.statistics.totalOperations = options.resources?.length || 1;\n  }\n\n  private async prepareSyncData(context: SyncExecutionContext): Promise<void> {\n    // Calculate deltas if delta sync is enabled\n    if (this.config.enableDeltaSync && context.options.operation === 'delta') {\n      const deltaResult = await this.calculateDeltas(context.options.since);\n      // Store delta information in context for execution phase\n      context.statistics.totalOperations = deltaResult.totalChanges;\n    }\n\n    // Prepare batches for efficient processing\n    // Resolve dependencies\n    // Allocate resources\n  }\n\n  private async executeSyncOperations(context: SyncExecutionContext): Promise<void> {\n    // Execute the actual sync operations\n    // This would interact with your HTTP client and resources\n    \n    const { options: _options } = context;\n    const batchSize = this.config.batchSize;\n    \n    // Simulate sync operations with progress tracking\n    const totalOperations = context.statistics.totalOperations;\n    \n    for (let i = 0; i < totalOperations; i += batchSize) {\n      // Check for cancellation\n      if (context.abortController.signal.aborted) {\n        throw new Error('Sync cancelled during execution');\n      }\n\n      const batchEnd = Math.min(i + batchSize, totalOperations);\n      \n      try {\n        // Execute batch of operations\n        await this.executeBatch(context, i, batchEnd);\n        context.statistics.completedOperations = batchEnd;\n        \n        // Emit progress update\n        this.emitSyncProgress(context, batchEnd, totalOperations);\n        \n      } catch (error) {\n        context.statistics.failedOperations += (batchEnd - i);\n        const syncError = this.createSyncError(context, error as Error);\n        context.errors.push(syncError);\n        \n        // Decide whether to continue or fail based on error type\n        if (!this.isRetryableError(error as Error)) {\n          throw error;\n        }\n      }\n    }\n  }\n\n  private async executeBatch(context: SyncExecutionContext, start: number, end: number): Promise<void> {\n    // Execute a batch of sync operations\n    // This would typically involve HTTP requests to your API\n    \n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 100));\n    \n    // Update statistics\n    context.statistics.networkRequests += 1;\n    context.statistics.bytesTransferred += (end - start) * 100; // Simulated\n    context.statistics.recordsSynced += (end - start);\n  }\n\n  private async verifySyncResults(context: SyncExecutionContext): Promise<void> {\n    // Verify that sync operations completed successfully\n    // Check data integrity\n    // Validate checksums if available\n    \n    const { statistics } = context;\n    if (statistics.failedOperations > 0) {\n      throw new Error(`Sync verification failed: ${statistics.failedOperations} operations failed`);\n    }\n  }\n\n  private async cleanupSyncResources(context: SyncExecutionContext): Promise<void> {\n    // Clean up temporary resources\n    // Clear intermediate data\n    // Release locks if any\n    \n    context.checkpoints.length = 0; // Clear checkpoints\n  }\n\n  private async createCheckpoint(context: SyncExecutionContext, phase: SyncPhase): Promise<void> {\n    const checkpoint: SyncCheckpoint = {\n      id: `checkpoint_${Date.now()}_${Math.random().toString(36).substring(2)}`,\n      phase,\n      timestamp: new Date(),\n      completedOperations: context.statistics.completedOperations,\n      state: {\n        // Store relevant state for rollback\n        phase,\n        completedOperations: context.statistics.completedOperations,\n      },\n    };\n\n    context.checkpoints.push(checkpoint);\n    \n    // Limit checkpoint history\n    if (context.checkpoints.length > 10) {\n      context.checkpoints.shift();\n    }\n  }\n\n  private async rollbackToLastCheckpoint(context: SyncExecutionContext): Promise<void> {\n    const lastCheckpoint = context.checkpoints[context.checkpoints.length - 1];\n    if (!lastCheckpoint) {\n      return;\n    }\n\n    // Restore state from checkpoint\n    context.currentPhase = lastCheckpoint.phase;\n    context.statistics.completedOperations = lastCheckpoint.completedOperations;\n    \n    // Perform any necessary cleanup or state restoration\n    // This would typically involve reversing operations\n  }\n\n  private async queueSync(syncId: string, options: SyncOptions): Promise<SyncResult> {\n    return new Promise<SyncResult>((resolve, reject) => {\n      this.syncQueue.push({ id: syncId, options, resolve, reject });\n      this.processQueue();\n    });\n  }\n\n  private async processQueue(): Promise<void> {\n    if (this.isProcessingQueue || this.syncQueue.length === 0) {\n      return;\n    }\n\n    this.isProcessingQueue = true;\n\n    try {\n      while (this.syncQueue.length > 0 && this.activeSyncs.size < this.config.maxConcurrentSyncs) {\n        const queuedSync = this.syncQueue.shift();\n        if (!queuedSync) break;\n\n        try {\n          const result = await this.executeSyncInternal(queuedSync.id, queuedSync.options);\n          queuedSync.resolve(result);\n        } catch (error) {\n          queuedSync.reject(error as Error);\n        }\n      }\n    } finally {\n      this.isProcessingQueue = false;\n    }\n  }\n\n  private createExecutionContext(syncId: string, options: SyncOptions): SyncExecutionContext {\n    return {\n      syncId,\n      options: {\n        operation: 'full',\n        direction: 'bidirectional',\n        strategy: 'immediate',\n        priority: 'normal',\n        maxRetries: this.config.defaultRetries,\n        timeoutMs: this.config.defaultTimeout,\n        batchSize: this.config.batchSize,\n        ...options,\n      },\n      startTime: new Date(),\n      currentPhase: 'validate',\n      statistics: {\n        totalOperations: 0,\n        completedOperations: 0,\n        failedOperations: 0,\n        bytesTransferred: 0,\n        recordsSynced: 0,\n        conflictsDetected: 0,\n        conflictsResolved: 0,\n        networkRequests: 0,\n        cacheHits: 0,\n      },\n      errors: [],\n      conflicts: [],\n      checkpoints: [],\n      abortController: new AbortController(),\n    };\n  }\n\n  private createSyncResult(context: SyncExecutionContext, status: 'success' | 'partial' | 'failed'): SyncResult {\n    const endTime = new Date();\n    \n    return {\n      id: context.syncId,\n      operation: context.options.operation || 'full',\n      status,\n      startTime: context.startTime,\n      endTime,\n      duration: endTime.getTime() - context.startTime.getTime(),\n      statistics: { ...context.statistics },\n      errors: [...context.errors],\n      conflicts: [...context.conflicts],\n      metadata: {\n        phases: context.checkpoints.map(cp => ({\n          phase: cp.phase,\n          timestamp: cp.timestamp,\n        })),\n        options: context.options,\n      },\n    };\n  }\n\n  private createSyncError(context: SyncExecutionContext, error: Error): SyncError {\n    return {\n      id: `error_${Date.now()}_${Math.random().toString(36).substring(2)}`,\n      phase: context.currentPhase,\n      operation: `${context.options.operation || 'sync'}_${context.currentPhase}`,\n      error,\n      retryable: this.isRetryableError(error),\n      timestamp: new Date(),\n      context: {\n        syncId: context.syncId,\n        phase: context.currentPhase,\n        completedOperations: context.statistics.completedOperations,\n      },\n    };\n  }\n\n  private isRetryableError(error: Error): boolean {\n    // Determine if an error is retryable based on its type and message\n    const retryablePatterns = [\n      /network/i,\n      /timeout/i,\n      /connection/i,\n      /rate.?limit/i,\n      /502|503|504/,\n    ];\n\n    return retryablePatterns.some(pattern => \n      pattern.test(error.message) || pattern.test(error.name)\n    );\n  }\n\n  private estimateSyncTime(deltas: DataDelta[]): number {\n    // Estimate sync time based on number of operations and historical data\n    const baseTimePerOperation = 100; // ms\n    return deltas.length * baseTimePerOperation;\n  }\n\n  private estimateBandwidth(deltas: DataDelta[]): number {\n    // Estimate bandwidth usage based on data size\n    const averageRecordSize = 1024; // bytes\n    return deltas.length * averageRecordSize;\n  }\n\n  private generateSyncId(): string {\n    return `sync_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  // Event emission helpers\n  private emitSyncStarted(context: SyncExecutionContext): void {\n    this.emit('sync.started', {\n      syncId: context.syncId,\n      operation: context.options.operation || 'full',\n      estimatedDuration: this.estimateSyncTime([]),\n      dataTypes: context.options.resources || [],\n      options: context.options,\n    });\n  }\n\n  private emitSyncProgress(context: SyncExecutionContext, completed: number, total: number): void {\n    const progress = total > 0 ? Math.round((completed / total) * 100) : 0;\n    \n    this.emit('sync.progress', {\n      syncId: context.syncId,\n      progress,\n      phase: context.currentPhase,\n      operations: {\n        completed,\n        total,\n        errors: context.errors.length,\n      },\n      estimatedTimeRemaining: this.estimateTimeRemaining(context, completed, total),\n    });\n  }\n\n  private emitSyncCompleted(context: SyncExecutionContext, result: SyncResult): void {\n    this.emit('sync.completed', {\n      syncId: context.syncId,\n      result,\n      summary: {\n        recordsSynced: result.statistics.recordsSynced,\n        conflictsResolved: result.statistics.conflictsResolved,\n        errors: result.errors.length,\n        duration: result.duration,\n      },\n    });\n  }\n\n  private emitSyncFailed(context: SyncExecutionContext, error: SyncError): void {\n    this.emit('sync.failed', {\n      syncId: context.syncId,\n      error,\n      phase: context.currentPhase,\n      retryable: error.retryable,\n      nextRetryTime: error.retryable ? new Date(Date.now() + 5000) : undefined,\n    });\n  }\n\n  private estimateTimeRemaining(context: SyncExecutionContext, completed: number, total: number): number | undefined {\n    if (completed === 0 || total === 0) return undefined;\n    \n    const elapsed = Date.now() - context.startTime.getTime();\n    const rate = completed / elapsed;\n    const remaining = total - completed;\n    \n    return Math.round(remaining / rate);\n  }\n}","/**\n * Priority Queue Implementation\n * Enterprise-grade priority-based queue with efficient operations\n */\n\nimport type { \n  QueueItem, \n  QueueItemId, \n  QueuePriority, \n  QueueItemStatus,\n  QueueStats,\n  InternalQueueStats,\n  QueueEvents,\n  // createQueueItemId \n} from './types';\n\n// Priority levels mapped to numeric values for sorting\nconst PRIORITY_VALUES: Record<QueuePriority, number> = {\n  critical: 1000,\n  high: 750,\n  normal: 500,\n  low: 250,\n};\n\nexport interface PriorityQueueConfig {\n  maxSize: number;\n  enableMetrics: boolean;\n  enableEvents: boolean;\n}\n\nexport class PriorityQueue {\n  private items: Map<QueueItemId, QueueItem> = new Map();\n  private priorityIndex: Map<QueuePriority, Set<QueueItemId>> = new Map();\n  private statusIndex: Map<QueueItemStatus, Set<QueueItemId>> = new Map();\n  private resourceIndex: Map<string, Set<QueueItemId>> = new Map();\n  private metrics: InternalQueueStats;\n  private config: PriorityQueueConfig;\n  private eventHandlers: Map<keyof QueueEvents, Set<Function>> = new Map();\n\n  constructor(config: Partial<PriorityQueueConfig> = {}) {\n    this.config = {\n      maxSize: 10000,\n      enableMetrics: true,\n      enableEvents: true,\n      ...config,\n    };\n\n    this.metrics = this.initializeMetrics();\n    this.initializeIndexes();\n  }\n\n  private initializeMetrics(): InternalQueueStats {\n    return {\n      totalItems: 0,\n      pendingItems: 0,\n      processingItems: 0,\n      completedItems: 0,\n      failedItems: 0,\n      deadItems: 0,\n      averageProcessingTime: 0,\n      successRate: 0,\n      lastProcessedAt: null,\n      throughputPerMinute: 0,\n      priorityDistribution: {\n        critical: 0,\n        high: 0,\n        normal: 0,\n        low: 0,\n      },\n      resourceDistribution: {\n        receipts: 0,\n        cashiers: 0,\n        merchants: 0,\n        'cash-registers': 0,\n        'point-of-sales': 0,\n        pems: 0,\n      },\n    };\n  }\n\n  private initializeIndexes(): void {\n    // Initialize priority index\n    Object.keys(PRIORITY_VALUES).forEach(priority => {\n      this.priorityIndex.set(priority as QueuePriority, new Set());\n    });\n\n    // Initialize status index\n    const statuses: QueueItemStatus[] = ['pending', 'processing', 'completed', 'failed', 'retry', 'dead'];\n    statuses.forEach(status => {\n      this.statusIndex.set(status, new Set());\n    });\n  }\n\n  /**\n   * Add item to the queue\n   */\n  enqueue(item: QueueItem): boolean {\n    if (this.items.size >= this.config.maxSize) {\n      this.emit('queue:backpressure', { \n        queueSize: this.items.size, \n        threshold: this.config.maxSize \n      });\n      return false;\n    }\n\n    // Add to main storage\n    this.items.set(item.id, item);\n\n    // Update indexes\n    this.addToIndex(item);\n\n    // Update metrics\n    this.updateMetricsOnAdd(item);\n\n    // Emit event\n    this.emit('item:added', { item });\n\n    return true;\n  }\n\n  /**\n   * Get next highest priority item\n   */\n  dequeue(): QueueItem | null {\n    const item = this.peek();\n    if (item) {\n      this.remove(item.id);\n    }\n    return item;\n  }\n\n  /**\n   * Peek at next highest priority item without removing\n   */\n  peek(): QueueItem | null {\n    // Check critical priority first\n    for (const priority of ['critical', 'high', 'normal', 'low'] as QueuePriority[]) {\n      const prioritySet = this.priorityIndex.get(priority);\n      if (prioritySet && prioritySet.size > 0) {\n        // Get pending items from this priority level\n        for (const itemId of prioritySet) {\n          const item = this.items.get(itemId);\n          if (item && item.status === 'pending') {\n            // Check if item is ready to be processed (scheduled time)\n            if (!item.scheduledAt || item.scheduledAt <= Date.now()) {\n              return item;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get multiple items by priority and status\n   */\n  dequeueMany(count: number, priority?: QueuePriority, status: QueueItemStatus = 'pending'): QueueItem[] {\n    const items: QueueItem[] = [];\n    const now = Date.now();\n\n    const priorities = priority ? [priority] : ['critical', 'high', 'normal', 'low'] as QueuePriority[];\n\n    for (const pri of priorities) {\n      if (items.length >= count) break;\n\n      const prioritySet = this.priorityIndex.get(pri);\n      if (!prioritySet) continue;\n\n      for (const itemId of prioritySet) {\n        if (items.length >= count) break;\n\n        const item = this.items.get(itemId);\n        if (item && \n            item.status === status && \n            (!item.scheduledAt || item.scheduledAt <= now)) {\n          items.push(item);\n        }\n      }\n    }\n\n    return items;\n  }\n\n  /**\n   * Update item status and properties\n   */\n  updateItem(id: QueueItemId, updates: Partial<QueueItem>): boolean {\n    const item = this.items.get(id);\n    if (!item) return false;\n\n    // Remove from old indexes\n    this.removeFromIndex(item);\n\n    // Update item\n    const updatedItem: QueueItem = {\n      ...item,\n      ...updates,\n      updatedAt: Date.now(),\n    };\n\n    this.items.set(id, updatedItem);\n\n    // Add to new indexes\n    this.addToIndex(updatedItem);\n\n    // Update metrics\n    this.updateMetricsOnUpdate(item, updatedItem);\n\n    // Emit events based on status change\n    if (item.status !== updatedItem.status) {\n      this.emitStatusChangeEvent(updatedItem);\n    }\n\n    return true;\n  }\n\n  /**\n   * Remove item from queue\n   */\n  remove(id: QueueItemId): boolean {\n    const item = this.items.get(id);\n    if (!item) return false;\n\n    // Remove from main storage\n    this.items.delete(id);\n\n    // Remove from indexes\n    this.removeFromIndex(item);\n\n    // Update metrics\n    this.updateMetricsOnRemove(item);\n\n    return true;\n  }\n\n  /**\n   * Get item by ID\n   */\n  get(id: QueueItemId): QueueItem | null {\n    return this.items.get(id) || null;\n  }\n\n  /**\n   * Check if queue contains item\n   */\n  has(id: QueueItemId): boolean {\n    return this.items.has(id);\n  }\n\n  /**\n   * Get items by status\n   */\n  getByStatus(status: QueueItemStatus): QueueItem[] {\n    const statusSet = this.statusIndex.get(status);\n    if (!statusSet) return [];\n\n    return Array.from(statusSet)\n      .map(id => this.items.get(id))\n      .filter((item): item is QueueItem => item !== undefined);\n  }\n\n  /**\n   * Get items by priority\n   */\n  getByPriority(priority: QueuePriority): QueueItem[] {\n    const prioritySet = this.priorityIndex.get(priority);\n    if (!prioritySet) return [];\n\n    return Array.from(prioritySet)\n      .map(id => this.items.get(id))\n      .filter((item): item is QueueItem => item !== undefined);\n  }\n\n  /**\n   * Get items by resource\n   */\n  getByResource(resource: string): QueueItem[] {\n    const resourceSet = this.resourceIndex.get(resource);\n    if (!resourceSet) return [];\n\n    return Array.from(resourceSet)\n      .map(id => this.items.get(id))\n      .filter((item): item is QueueItem => item !== undefined);\n  }\n\n  /**\n   * Get items that are ready to process (past scheduled time)\n   */\n  getReadyItems(limit?: number): QueueItem[] {\n    const now = Date.now();\n    const readyItems: QueueItem[] = [];\n\n    for (const priority of ['critical', 'high', 'normal', 'low'] as QueuePriority[]) {\n      if (limit && readyItems.length >= limit) break;\n\n      const items = this.getByPriority(priority);\n      for (const item of items) {\n        if (limit && readyItems.length >= limit) break;\n\n        if (item.status === 'pending' && \n            (!item.scheduledAt || item.scheduledAt <= now)) {\n          readyItems.push(item);\n        }\n      }\n    }\n\n    return readyItems;\n  }\n\n  /**\n   * Clear all items\n   */\n  clear(): void {\n    this.items.clear();\n    this.priorityIndex.forEach(set => set.clear());\n    this.statusIndex.forEach(set => set.clear());\n    this.resourceIndex.clear();\n    this.metrics = this.initializeMetrics();\n  }\n\n  /**\n   * Get queue size\n   */\n  size(): number {\n    return this.items.size;\n  }\n\n  /**\n   * Check if queue is empty\n   */\n  isEmpty(): boolean {\n    return this.items.size === 0;\n  }\n\n  /**\n   * Get queue statistics\n   */\n  getStats(): QueueStats {\n    return { ...this.metrics };\n  }\n\n  /**\n   * Get all items as array\n   */\n  toArray(): QueueItem[] {\n    return Array.from(this.items.values());\n  }\n\n  /**\n   * Event subscription\n   */\n  on<K extends keyof QueueEvents>(event: K, handler: (data: QueueEvents[K]) => void): void {\n    if (!this.config.enableEvents) return;\n\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, new Set());\n    }\n    this.eventHandlers.get(event)!.add(handler);\n  }\n\n  /**\n   * Event unsubscription\n   */\n  off<K extends keyof QueueEvents>(event: K, handler: (data: QueueEvents[K]) => void): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.delete(handler);\n    }\n  }\n\n  /**\n   * Emit event\n   */\n  private emit<K extends keyof QueueEvents>(event: K, data: QueueEvents[K]): void {\n    if (!this.config.enableEvents) return;\n\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(data);\n        } catch (error) {\n          console.error(`Error in queue event handler for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  // Private helper methods\n\n  private addToIndex(item: QueueItem): void {\n    // Add to priority index\n    const prioritySet = this.priorityIndex.get(item.priority);\n    if (prioritySet) {\n      prioritySet.add(item.id);\n    }\n\n    // Add to status index\n    const statusSet = this.statusIndex.get(item.status);\n    if (statusSet) {\n      statusSet.add(item.id);\n    }\n\n    // Add to resource index\n    if (!this.resourceIndex.has(item.resource)) {\n      this.resourceIndex.set(item.resource, new Set());\n    }\n    this.resourceIndex.get(item.resource)!.add(item.id);\n  }\n\n  private removeFromIndex(item: QueueItem): void {\n    // Remove from priority index\n    const prioritySet = this.priorityIndex.get(item.priority);\n    if (prioritySet) {\n      prioritySet.delete(item.id);\n    }\n\n    // Remove from status index\n    const statusSet = this.statusIndex.get(item.status);\n    if (statusSet) {\n      statusSet.delete(item.id);\n    }\n\n    // Remove from resource index\n    const resourceSet = this.resourceIndex.get(item.resource);\n    if (resourceSet) {\n      resourceSet.delete(item.id);\n      if (resourceSet.size === 0) {\n        this.resourceIndex.delete(item.resource);\n      }\n    }\n  }\n\n  private updateMetricsOnAdd(item: QueueItem): void {\n    if (!this.config.enableMetrics) return;\n\n    this.metrics.totalItems++;\n    this.metrics.pendingItems++;\n    this.metrics.priorityDistribution[item.priority]++;\n    this.metrics.resourceDistribution[item.resource]++;\n  }\n\n  private updateMetricsOnUpdate(oldItem: QueueItem, newItem: QueueItem): void {\n    if (!this.config.enableMetrics) return;\n\n    // Update status counts\n    if (oldItem.status !== newItem.status) {\n      this.decrementStatusCount(oldItem.status);\n      this.incrementStatusCount(newItem.status);\n\n      if (newItem.status === 'completed') {\n        this.metrics.lastProcessedAt = Date.now();\n        this.updateSuccessRate();\n      }\n    }\n  }\n\n  private updateMetricsOnRemove(item: QueueItem): void {\n    if (!this.config.enableMetrics) return;\n\n    this.metrics.totalItems--;\n    this.decrementStatusCount(item.status);\n    this.metrics.priorityDistribution[item.priority]--;\n    this.metrics.resourceDistribution[item.resource]--;\n  }\n\n  private incrementStatusCount(status: QueueItemStatus): void {\n    switch (status) {\n      case 'pending':\n        this.metrics.pendingItems++;\n        break;\n      case 'processing':\n        this.metrics.processingItems++;\n        break;\n      case 'completed':\n        this.metrics.completedItems++;\n        break;\n      case 'failed':\n        this.metrics.failedItems++;\n        break;\n      case 'dead':\n        this.metrics.deadItems++;\n        break;\n    }\n  }\n\n  private decrementStatusCount(status: QueueItemStatus): void {\n    switch (status) {\n      case 'pending':\n        this.metrics.pendingItems = Math.max(0, this.metrics.pendingItems - 1);\n        break;\n      case 'processing':\n        this.metrics.processingItems = Math.max(0, this.metrics.processingItems - 1);\n        break;\n      case 'completed':\n        this.metrics.completedItems = Math.max(0, this.metrics.completedItems - 1);\n        break;\n      case 'failed':\n        this.metrics.failedItems = Math.max(0, this.metrics.failedItems - 1);\n        break;\n      case 'dead':\n        this.metrics.deadItems = Math.max(0, this.metrics.deadItems - 1);\n        break;\n    }\n  }\n\n  private updateSuccessRate(): void {\n    const total = this.metrics.completedItems + this.metrics.failedItems + this.metrics.deadItems;\n    if (total > 0) {\n      this.metrics.successRate = (this.metrics.completedItems / total) * 100;\n    }\n  }\n\n  private emitStatusChangeEvent(item: QueueItem): void {\n    switch (item.status) {\n      case 'processing':\n        this.emit('item:processing', { item });\n        break;\n      case 'completed':\n        this.emit('item:completed', { item });\n        break;\n      case 'failed':\n        this.emit('item:failed', { \n          item, \n          error: item.errorHistory?.[item.errorHistory.length - 1] || {\n            timestamp: Date.now(),\n            error: 'Unknown error',\n            retryable: false\n          }\n        });\n        break;\n      case 'retry':\n        this.emit('item:retry', { item, attempt: item.retryCount });\n        break;\n      case 'dead':\n        this.emit('item:dead', { item });\n        break;\n    }\n  }\n}","/**\n * Batch Processor - Groups related operations for efficient processing\n * Enterprise-grade batching with resource and time-based strategies\n */\n\nimport type { \n  QueueItem, \n  // QueueItemId, \n  BatchOperation, \n  ResourceType,\n  QueueEvents,\n  QueuePriority\n} from './types';\n\nexport interface BatchProcessorConfig {\n  maxBatchSize: number;\n  maxWaitTime: number;\n  enableResourceGrouping: boolean;\n  enableTimeWindowing: boolean;\n  enablePriorityBatching: boolean;\n  maxConcurrentBatches: number;\n  batchTimeoutMs: number;\n}\n\nexport interface BatchingStrategy {\n  groupByResource: boolean;\n  groupByPriority: boolean;\n  groupByTimeWindow: boolean;\n  windowSizeMs: number;\n  maxItemsPerBatch: number;\n  priorityMixing: boolean; // Allow mixing priorities in batch\n}\n\nexport interface BatchGroupKey {\n  resource?: ResourceType;\n  priority?: QueuePriority;\n  timeWindow?: number;\n  custom?: string;\n}\n\nexport class BatchProcessor {\n  private config: BatchProcessorConfig;\n  private pendingBatches: Map<string, BatchOperation> = new Map();\n  private batchTimers: Map<string, NodeJS.Timeout> = new Map();\n  private processingBatches: Set<string> = new Set();\n  private eventHandlers: Map<keyof QueueEvents, Set<Function>> = new Map();\n  private batchCounter = 0;\n\n  constructor(config: Partial<BatchProcessorConfig> = {}) {\n    this.config = {\n      maxBatchSize: 50,\n      maxWaitTime: 5000,\n      enableResourceGrouping: true,\n      enableTimeWindowing: true,\n      enablePriorityBatching: false,\n      maxConcurrentBatches: 10,\n      batchTimeoutMs: 30000,\n      ...config,\n    };\n  }\n\n  /**\n   * Add items to batching system\n   */\n  addToBatch(items: QueueItem[], strategy: BatchingStrategy): BatchOperation[] {\n    const groups = this.groupItems(items, strategy);\n    const batches: BatchOperation[] = [];\n\n    for (const [groupKey, groupItems] of groups) {\n      const batch = this.createOrUpdateBatch(groupKey, groupItems, strategy);\n      if (batch) {\n        batches.push(batch);\n      }\n    }\n\n    return batches;\n  }\n\n  /**\n   * Process a specific batch\n   */\n  async processBatch(\n    batchId: string,\n    processor: (items: QueueItem[]) => Promise<void>\n  ): Promise<BatchOperation | null> {\n    const batch = this.pendingBatches.get(batchId);\n    if (!batch || this.processingBatches.has(batchId)) {\n      return null;\n    }\n\n    // Mark as processing\n    this.processingBatches.add(batchId);\n    const updatedBatch: BatchOperation = {\n      ...batch,\n      status: 'processing',\n    };\n\n    this.pendingBatches.set(batchId, updatedBatch);\n    // Processing state tracked internally, no event needed\n\n    try {\n      // Cancel timer if exists\n      const timer = this.batchTimers.get(batchId);\n      if (timer) {\n        clearTimeout(timer);\n        this.batchTimers.delete(batchId);\n      }\n\n      // Process based on strategy\n      if (batch.strategy === 'parallel') {\n        await this.processParallel(batch.items, processor, batch.maxConcurrency);\n      } else if (batch.strategy === 'sequential') {\n        await this.processSequential(batch.items, processor);\n      } else {\n        await processor(batch.items);\n      }\n\n      // Mark as completed\n      const completedBatch: BatchOperation = {\n        ...updatedBatch,\n        status: 'completed',\n      };\n\n      this.pendingBatches.delete(batchId);\n      this.processingBatches.delete(batchId);\n      \n      this.emit('batch:completed', { batch: completedBatch });\n      return completedBatch;\n\n    } catch (error) {\n      // Mark as failed\n      const failedBatch: BatchOperation = {\n        ...updatedBatch,\n        status: 'failed',\n      };\n\n      this.pendingBatches.set(batchId, failedBatch);\n      this.processingBatches.delete(batchId);\n      \n      this.emit('batch:failed', { batch: failedBatch });\n      throw error;\n    }\n  }\n\n  /**\n   * Get ready batches (full or timed out)\n   */\n  getReadyBatches(): BatchOperation[] {\n    const readyBatches: BatchOperation[] = [];\n    const now = Date.now();\n\n    for (const batch of this.pendingBatches.values()) {\n      if (batch.status === 'pending') {\n        const isFullBatch = batch.items.length >= this.config.maxBatchSize;\n        const isTimedOut = (now - batch.createdAt) >= this.config.maxWaitTime;\n        \n        if (isFullBatch || isTimedOut) {\n          readyBatches.push(batch);\n        }\n      }\n    }\n\n    return readyBatches;\n  }\n\n  /**\n   * Force process all pending batches\n   */\n  async flushAllBatches(\n    processor: (items: QueueItem[]) => Promise<void>\n  ): Promise<BatchOperation[]> {\n    const allBatches = Array.from(this.pendingBatches.values())\n      .filter(batch => batch.status === 'pending');\n\n    const results: BatchOperation[] = [];\n\n    for (const batch of allBatches) {\n      try {\n        const result = await this.processBatch(batch.id, processor);\n        if (result) {\n          results.push(result);\n        }\n      } catch (error) {\n        console.error(`Failed to process batch ${batch.id}:`, error);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Get batch by ID\n   */\n  getBatch(batchId: string): BatchOperation | null {\n    return this.pendingBatches.get(batchId) || null;\n  }\n\n  /**\n   * Get all pending batches\n   */\n  getPendingBatches(): BatchOperation[] {\n    return Array.from(this.pendingBatches.values())\n      .filter(batch => batch.status === 'pending');\n  }\n\n  /**\n   * Cancel a batch\n   */\n  cancelBatch(batchId: string): boolean {\n    const batch = this.pendingBatches.get(batchId);\n    if (!batch || this.processingBatches.has(batchId)) {\n      return false;\n    }\n\n    // Clear timer\n    const timer = this.batchTimers.get(batchId);\n    if (timer) {\n      clearTimeout(timer);\n      this.batchTimers.delete(batchId);\n    }\n\n    this.pendingBatches.delete(batchId);\n    return true;\n  }\n\n  /**\n   * Clear all batches\n   */\n  clear(): void {\n    // Clear all timers\n    for (const timer of this.batchTimers.values()) {\n      clearTimeout(timer);\n    }\n    \n    this.batchTimers.clear();\n    this.pendingBatches.clear();\n    this.processingBatches.clear();\n  }\n\n  /**\n   * Get batch statistics\n   */\n  getStats() {\n    const pendingBatches = this.getPendingBatches();\n    \n    return {\n      totalBatches: this.pendingBatches.size,\n      pendingBatches: pendingBatches.length,\n      processingBatches: this.processingBatches.size,\n      totalItemsInBatches: pendingBatches.reduce((sum, batch) => sum + batch.items.length, 0),\n      averageBatchSize: pendingBatches.length > 0 \n        ? pendingBatches.reduce((sum, batch) => sum + batch.items.length, 0) / pendingBatches.length\n        : 0,\n    };\n  }\n\n  // Event handling\n  on<K extends keyof QueueEvents>(event: K, handler: (data: QueueEvents[K]) => void): void {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, new Set());\n    }\n    this.eventHandlers.get(event)!.add(handler);\n  }\n\n  off<K extends keyof QueueEvents>(event: K, handler: (data: QueueEvents[K]) => void): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.delete(handler);\n    }\n  }\n\n  private emit<K extends keyof QueueEvents>(event: K, data: QueueEvents[K]): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(data);\n        } catch (error) {\n          console.error(`Error in batch event handler for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  // Private helper methods\n\n  private groupItems(items: QueueItem[], strategy: BatchingStrategy): Map<string, QueueItem[]> {\n    const groups = new Map<string, QueueItem[]>();\n\n    for (const item of items) {\n      const groupKey = this.generateGroupKey(item, strategy);\n      \n      if (!groups.has(groupKey)) {\n        groups.set(groupKey, []);\n      }\n      \n      const group = groups.get(groupKey)!;\n      if (group.length < strategy.maxItemsPerBatch) {\n        group.push(item);\n      } else {\n        // Create new group with incremented key\n        const newGroupKey = `${groupKey}_${groups.size}`;\n        groups.set(newGroupKey, [item]);\n      }\n    }\n\n    return groups;\n  }\n\n  private generateGroupKey(item: QueueItem, strategy: BatchingStrategy): string {\n    const keyParts: string[] = [];\n\n    if (strategy.groupByResource) {\n      keyParts.push(`resource:${item.resource}`);\n    }\n\n    if (strategy.groupByPriority && !strategy.priorityMixing) {\n      keyParts.push(`priority:${item.priority}`);\n    }\n\n    if (strategy.groupByTimeWindow) {\n      const windowStart = Math.floor(Date.now() / strategy.windowSizeMs) * strategy.windowSizeMs;\n      keyParts.push(`window:${windowStart}`);\n    }\n\n    return keyParts.join('|') || 'default';\n  }\n\n  private createOrUpdateBatch(\n    groupKey: string,\n    items: QueueItem[],\n    strategy: BatchingStrategy\n  ): BatchOperation | null {\n    // Check if there's an existing batch for this group\n    let existingBatch: BatchOperation | null = null;\n    \n    for (const batch of this.pendingBatches.values()) {\n      if (batch.status === 'pending') {\n        const batchGroupKey = this.generateBatchGroupKey(batch, strategy);\n        if (batchGroupKey === groupKey) {\n          existingBatch = batch;\n          break;\n        }\n      }\n    }\n\n    if (existingBatch) {\n      // Add items to existing batch\n      const updatedItems = [...existingBatch.items, ...items];\n      \n      // Check if batch is full\n      if (updatedItems.length >= strategy.maxItemsPerBatch) {\n        // Split into current batch and new batch\n        const currentBatchItems = updatedItems.slice(0, strategy.maxItemsPerBatch);\n        const remainingItems = updatedItems.slice(strategy.maxItemsPerBatch);\n\n        // Update current batch\n        const updatedBatch: BatchOperation = {\n          ...existingBatch,\n          items: currentBatchItems,\n        };\n        this.pendingBatches.set(existingBatch.id, updatedBatch);\n\n        // Create new batch for remaining items if any\n        if (remainingItems.length > 0) {\n          return this.createNewBatch(remainingItems, strategy);\n        }\n\n        return updatedBatch;\n      } else {\n        // Update existing batch\n        const updatedBatch: BatchOperation = {\n          ...existingBatch,\n          items: updatedItems,\n        };\n        this.pendingBatches.set(existingBatch.id, updatedBatch);\n        return updatedBatch;\n      }\n    } else {\n      // Create new batch\n      return this.createNewBatch(items, strategy);\n    }\n  }\n\n  private createNewBatch(items: QueueItem[], strategy: BatchingStrategy): BatchOperation {\n    const batchId = `batch_${++this.batchCounter}_${Date.now()}`;\n    \n    const batch: BatchOperation = {\n      id: batchId,\n      items: items.slice(0, strategy.maxItemsPerBatch),\n      status: 'pending',\n      createdAt: Date.now(),\n      strategy: this.determineBatchStrategy(items),\n      maxConcurrency: this.config.maxConcurrentBatches,\n    };\n\n    this.pendingBatches.set(batchId, batch);\n\n    // Set timeout for batch processing\n    const timer = setTimeout(() => {\n      const currentBatch = this.pendingBatches.get(batchId);\n      if (currentBatch && currentBatch.status === 'pending') {\n        // Mark batch as failed due to timeout\n        const failedBatch: BatchOperation = {\n          ...currentBatch,\n          status: 'failed',\n        };\n        this.pendingBatches.set(batchId, failedBatch);\n        this.emit('batch:failed', { batch: failedBatch });\n      }\n    }, this.config.maxWaitTime) as unknown as NodeJS.Timeout;\n\n    this.batchTimers.set(batchId, timer);\n\n    this.emit('batch:created', { batch });\n\n    return batch;\n  }\n\n  private generateBatchGroupKey(batch: BatchOperation, strategy: BatchingStrategy): string {\n    if (batch.items.length === 0) return 'empty';\n    \n    const firstItem = batch.items[0];\n    if (!firstItem) return 'empty';\n    return this.generateGroupKey(firstItem, strategy);\n  }\n\n  private determineBatchStrategy(items: QueueItem[]): BatchOperation['strategy'] {\n    // Analyze items to determine best processing strategy\n    const hasHighPriority = items.some(item => item.priority === 'critical' || item.priority === 'high');\n    const hasDependencies = items.some(item => item.dependencies && item.dependencies.length > 0);\n\n    if (hasDependencies) {\n      return 'sequential'; // Dependencies require sequential processing\n    } else if (hasHighPriority && items.length <= 10) {\n      return 'parallel'; // Small high-priority batches can be parallelized\n    } else {\n      return 'sequential'; // Default to sequential for reliability\n    }\n  }\n\n  private async processParallel(\n    items: QueueItem[],\n    processor: (items: QueueItem[]) => Promise<void>,\n    maxConcurrency: number = 5\n  ): Promise<void> {\n    const chunks = this.chunkArray(items, Math.max(1, Math.floor(items.length / maxConcurrency)));\n    \n    await Promise.all(\n      chunks.map(chunk => processor(chunk))\n    );\n  }\n\n  private async processSequential(\n    items: QueueItem[],\n    processor: (items: QueueItem[]) => Promise<void>\n  ): Promise<void> {\n    // Process each item individually in sequence\n    for (const item of items) {\n      await processor([item]);\n    }\n  }\n\n  private chunkArray<T>(array: T[], chunkSize: number): T[][] {\n    const chunks: T[][] = [];\n    for (let i = 0; i < array.length; i += chunkSize) {\n      chunks.push(array.slice(i, i + chunkSize));\n    }\n    return chunks;\n  }\n\n  // Cleanup\n  destroy(): void {\n    this.clear();\n  }\n}","/**\n * Retry Manager with Circuit Breaker\n * Enterprise-grade retry logic with exponential backoff and intelligent failure handling\n */\n\nimport type { \n  QueueItem, \n  QueueItemId, \n  // RetryStrategy, \n  RetryPolicy,\n  CircuitBreakerState,\n  ResourceType,\n  QueueEvents \n} from './types';\n\nexport interface RetryManagerConfig {\n  defaultRetryPolicy: RetryPolicy;\n  circuitBreakerConfig: CircuitBreakerConfig;\n  maxConcurrentRetries: number;\n  retryQueueSize: number;\n  enableJitter: boolean;\n  enableMetrics: boolean;\n}\n\nexport interface CircuitBreakerConfig {\n  enabled: boolean;\n  failureThreshold: number;\n  successThreshold: number;\n  timeout: number;\n  monitoringWindow: number;\n}\n\nexport interface RetryAttempt {\n  itemId: QueueItemId;\n  attempt: number;\n  scheduledAt: number;\n  lastError?: string;\n  backoffDelay: number;\n  item?: QueueItem;\n  retryCount?: number;\n}\n\nexport interface RetryMetrics {\n  totalRetries: number;\n  successfulRetries: number;\n  failedRetries: number;\n  averageRetryDelay: number;\n  circuitBreakerTrips: number;\n  retrySuccessRate: number;\n  resourceMetrics: Record<ResourceType, {\n    retries: number;\n    successes: number;\n    failures: number;\n    averageDelay: number;\n  }>;\n}\n\nexport class RetryManager {\n  private config: RetryManagerConfig;\n  private circuitBreakers: Map<ResourceType, CircuitBreakerState> = new Map();\n  private activeRetries: Map<QueueItemId, RetryAttempt> = new Map();\n  private retryTimers: Map<QueueItemId, NodeJS.Timeout> = new Map();\n  private metrics: RetryMetrics;\n  private eventHandlers: Map<keyof QueueEvents, Set<Function>> = new Map();\n\n  constructor(config: Partial<RetryManagerConfig> = {}) {\n    this.config = {\n      defaultRetryPolicy: this.getDefaultRetryPolicy(),\n      circuitBreakerConfig: {\n        enabled: true,\n        failureThreshold: 5,\n        successThreshold: 3,\n        timeout: 60000,\n        monitoringWindow: 300000,\n      },\n      maxConcurrentRetries: 10,\n      retryQueueSize: 1000,\n      enableJitter: true,\n      enableMetrics: true,\n      ...config,\n    };\n\n    this.metrics = this.initializeMetrics();\n    this.initializeCircuitBreakers();\n  }\n\n  /**\n   * Schedule retry for a failed item\n   */\n  scheduleRetry(item: QueueItem, error: string): boolean {\n    // Check if item has exceeded max retries\n    if (item.retryCount >= item.maxRetries) {\n      this.emit('item:max-retries-exceeded', { item });\n      return false;\n    }\n\n    // Check circuit breaker\n    if (!this.isCircuitClosed(item.resource)) {\n      this.emit('item:circuit-open', { item, resource: item.resource });\n      return false;\n    }\n\n    // Check retry queue capacity\n    if (this.activeRetries.size >= this.config.retryQueueSize) {\n      this.emit('retry:queue-full', { \n        queueSize: this.activeRetries.size, \n        maxSize: this.config.retryQueueSize \n      });\n      return false;\n    }\n\n    const retryPolicy = this.getRetryPolicy(item);\n    const nextAttempt = item.retryCount + 1;\n    const delay = this.calculateDelay(nextAttempt, retryPolicy);\n\n    const retryAttempt: RetryAttempt = {\n      itemId: item.id,\n      attempt: nextAttempt,\n      scheduledAt: Date.now() + delay,\n      lastError: error,\n      backoffDelay: delay,\n    };\n\n    this.activeRetries.set(item.id, retryAttempt);\n\n    // Schedule the retry\n    const timer = setTimeout(() => {\n      this.executeRetry(item.id);\n    }, delay) as unknown as NodeJS.Timeout;\n\n    this.retryTimers.set(item.id, timer);\n\n    this.updateMetricsOnRetryScheduled(item.resource, delay);\n    this.emit('item:retry-scheduled', { item, delay, attempt: nextAttempt });\n\n    return true;\n  }\n\n  /**\n   * Cancel scheduled retry\n   */\n  cancelRetry(itemId: QueueItemId): boolean {\n    const timer = this.retryTimers.get(itemId);\n    if (timer) {\n      clearTimeout(timer);\n      this.retryTimers.delete(itemId);\n    }\n\n    const retryAttempt = this.activeRetries.get(itemId);\n    if (retryAttempt) {\n      this.activeRetries.delete(itemId);\n      // Only emit if we have the item data, otherwise just log\n      if (retryAttempt.item) {\n        this.emit('item:retry-cancelled', { item: retryAttempt.item });\n      }\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Record successful operation (for circuit breaker)\n   */\n  recordSuccess(resource: ResourceType): void {\n    const circuitBreaker = this.circuitBreakers.get(resource);\n    if (!circuitBreaker) return;\n\n    let updatedState: CircuitBreakerState = {\n      ...circuitBreaker,\n      successCount: circuitBreaker.successCount + 1,\n      lastFailureTime: null,\n    };\n\n    // Check if we should close the circuit\n    if (circuitBreaker.state === 'half-open' && \n        updatedState.successCount >= this.config.circuitBreakerConfig.successThreshold) {\n      updatedState = {\n        ...updatedState,\n        state: 'closed',\n        failureCount: 0,\n        successCount: 0,\n      };\n      this.emit('circuit:closed', { resource });\n    }\n\n    this.circuitBreakers.set(resource, updatedState);\n    this.updateMetricsOnSuccess(resource);\n  }\n\n  /**\n   * Record failed operation (for circuit breaker)\n   */\n  recordFailure(resource: ResourceType, _error: string): void {\n    const circuitBreaker = this.circuitBreakers.get(resource);\n    if (!circuitBreaker) return;\n\n    const now = Date.now();\n    let updatedState: CircuitBreakerState = {\n      ...circuitBreaker,\n      failureCount: circuitBreaker.failureCount + 1,\n      lastFailureTime: now,\n      successCount: 0, // Reset success count on failure\n    };\n\n    // Check if we should open the circuit\n    if (circuitBreaker.state === 'closed' && \n        updatedState.failureCount >= this.config.circuitBreakerConfig.failureThreshold) {\n      updatedState = {\n        ...updatedState,\n        state: 'open',\n        nextRetryTime: now + this.config.circuitBreakerConfig.timeout,\n      };\n      this.emit('circuit:opened', { resource, errorRate: updatedState.failureCount });\n      this.metrics.circuitBreakerTrips++;\n    }\n\n    this.circuitBreakers.set(resource, updatedState);\n    this.updateMetricsOnFailure(resource);\n  }\n\n  /**\n   * Check if circuit is closed for a resource\n   */\n  isCircuitClosed(resource: ResourceType): boolean {\n    if (!this.config.circuitBreakerConfig.enabled) return true;\n\n    const circuitBreaker = this.circuitBreakers.get(resource);\n    if (!circuitBreaker) return true;\n\n    const now = Date.now();\n\n    switch (circuitBreaker.state) {\n      case 'closed':\n        return true;\n\n      case 'open':\n        // Check if we should move to half-open\n        if (circuitBreaker.nextRetryTime && now >= circuitBreaker.nextRetryTime) {\n          const updatedState: CircuitBreakerState = {\n            ...circuitBreaker,\n            state: 'half-open',\n            successCount: 0,\n          };\n          this.circuitBreakers.set(resource, updatedState);\n          this.emit('circuit:half-open', { resource });\n          return true;\n        }\n        return false;\n\n      case 'half-open':\n        return true;\n\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Get circuit breaker state for a resource\n   */\n  getCircuitState(resource: ResourceType): CircuitBreakerState | null {\n    return this.circuitBreakers.get(resource) || null;\n  }\n\n  /**\n   * Get all active retries\n   */\n  getActiveRetries(): RetryAttempt[] {\n    return Array.from(this.activeRetries.values());\n  }\n\n  /**\n   * Get retry metrics\n   */\n  getMetrics(): RetryMetrics {\n    return { ...this.metrics };\n  }\n\n  /**\n   * Clear all retries\n   */\n  clearRetries(): void {\n    // Cancel all timers\n    for (const timer of this.retryTimers.values()) {\n      clearTimeout(timer);\n    }\n\n    this.retryTimers.clear();\n    this.activeRetries.clear();\n  }\n\n  /**\n   * Reset circuit breaker for a resource\n   */\n  resetCircuitBreaker(resource: ResourceType): void {\n    const initialState = this.createInitialCircuitBreakerState();\n    this.circuitBreakers.set(resource, initialState);\n    this.emit('circuit:reset', { resource });\n  }\n\n  /**\n   * Get retry policy for an item\n   */\n  getRetryPolicy(_item: QueueItem): RetryPolicy {\n    // Could be customized per resource or operation type\n    return this.config.defaultRetryPolicy;\n  }\n\n  // Event handling\n  on<K extends keyof QueueEvents>(event: K, handler: (data: QueueEvents[K]) => void): void {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, new Set());\n    }\n    this.eventHandlers.get(event)!.add(handler);\n  }\n\n  off<K extends keyof QueueEvents>(event: K, handler: (data: QueueEvents[K]) => void): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.delete(handler);\n    }\n  }\n\n  private emit<K extends keyof QueueEvents>(event: K, data: QueueEvents[K]): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(data);\n        } catch (error) {\n          console.error(`Error in retry manager event handler for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  // Private methods\n\n  private async executeRetry(itemId: QueueItemId): Promise<void> {\n    const retryAttempt = this.activeRetries.get(itemId);\n    if (!retryAttempt) return;\n\n    // Clean up retry state\n    this.activeRetries.delete(itemId);\n    this.retryTimers.delete(itemId);\n\n    // Emit retry event - the queue processor should handle the actual retry\n    this.emit('item:retry-ready', { itemId, attempt: retryAttempt.attempt });\n  }\n\n  private calculateDelay(attempt: number, policy: RetryPolicy): number {\n    let delay: number;\n\n    switch (policy.strategy) {\n      case 'exponential':\n        delay = Math.min(\n          policy.baseDelay * Math.pow(policy.backoffFactor, attempt - 1),\n          policy.maxDelay\n        );\n        break;\n\n      case 'linear':\n        delay = Math.min(\n          policy.baseDelay * attempt,\n          policy.maxDelay\n        );\n        break;\n\n      case 'custom':\n        // Custom logic would be implemented here\n        delay = policy.baseDelay;\n        break;\n\n      default:\n        delay = policy.baseDelay;\n    }\n\n    // Add jitter to prevent thundering herd\n    if (this.config.enableJitter && policy.jitterEnabled) {\n      const jitter = delay * 0.1 * Math.random(); // Up to 10% jitter\n      delay += jitter;\n    }\n\n    return Math.floor(delay);\n  }\n\n  private getDefaultRetryPolicy(): RetryPolicy {\n    return {\n      strategy: 'exponential',\n      maxRetries: 3,\n      baseDelay: 1000,\n      maxDelay: 30000,\n      backoffFactor: 2,\n      jitterEnabled: true,\n      retryableErrors: [\n        'NETWORK_ERROR',\n        'TIMEOUT',\n        'SERVER_ERROR',\n        'RATE_LIMITED',\n        'TEMPORARY_FAILURE',\n      ],\n      nonRetryableErrors: [\n        'AUTHENTICATION_ERROR',\n        'AUTHORIZATION_ERROR',\n        'VALIDATION_ERROR',\n        'NOT_FOUND',\n        'CONFLICT',\n      ],\n    };\n  }\n\n  private initializeMetrics(): RetryMetrics {\n    return {\n      totalRetries: 0,\n      successfulRetries: 0,\n      failedRetries: 0,\n      averageRetryDelay: 0,\n      circuitBreakerTrips: 0,\n      retrySuccessRate: 0,\n      resourceMetrics: {\n        receipts: { retries: 0, successes: 0, failures: 0, averageDelay: 0 },\n        cashiers: { retries: 0, successes: 0, failures: 0, averageDelay: 0 },\n        merchants: { retries: 0, successes: 0, failures: 0, averageDelay: 0 },\n        'cash-registers': { retries: 0, successes: 0, failures: 0, averageDelay: 0 },\n        'point-of-sales': { retries: 0, successes: 0, failures: 0, averageDelay: 0 },\n        pems: { retries: 0, successes: 0, failures: 0, averageDelay: 0 },\n      },\n    };\n  }\n\n  private initializeCircuitBreakers(): void {\n    const resources: ResourceType[] = [\n      'receipts', 'cashiers', 'merchants', \n      'cash-registers', 'point-of-sales', 'pems'\n    ];\n\n    for (const resource of resources) {\n      this.circuitBreakers.set(resource, this.createInitialCircuitBreakerState());\n    }\n  }\n\n  private createInitialCircuitBreakerState(): CircuitBreakerState {\n    return {\n      state: 'closed',\n      failureCount: 0,\n      successCount: 0,\n      lastFailureTime: null,\n      nextRetryTime: null,\n      threshold: this.config.circuitBreakerConfig.failureThreshold,\n      timeout: this.config.circuitBreakerConfig.timeout,\n    };\n  }\n\n  private updateMetricsOnRetryScheduled(resource: ResourceType, delay: number): void {\n    if (!this.config.enableMetrics) return;\n\n    this.metrics.totalRetries++;\n    this.metrics.resourceMetrics[resource].retries++;\n\n    // Update average delay\n    const totalDelay = this.metrics.averageRetryDelay * (this.metrics.totalRetries - 1) + delay;\n    this.metrics.averageRetryDelay = totalDelay / this.metrics.totalRetries;\n\n    // Update resource average delay\n    const resourceMetric = this.metrics.resourceMetrics[resource];\n    const resourceTotalDelay = resourceMetric.averageDelay * (resourceMetric.retries - 1) + delay;\n    resourceMetric.averageDelay = resourceTotalDelay / resourceMetric.retries;\n  }\n\n  private updateMetricsOnSuccess(resource: ResourceType): void {\n    if (!this.config.enableMetrics) return;\n\n    this.metrics.successfulRetries++;\n    this.metrics.resourceMetrics[resource].successes++;\n    this.updateRetrySuccessRate();\n  }\n\n  private updateMetricsOnFailure(resource: ResourceType): void {\n    if (!this.config.enableMetrics) return;\n\n    this.metrics.failedRetries++;\n    this.metrics.resourceMetrics[resource].failures++;\n    this.updateRetrySuccessRate();\n  }\n\n  private updateRetrySuccessRate(): void {\n    const total = this.metrics.successfulRetries + this.metrics.failedRetries;\n    if (total > 0) {\n      this.metrics.retrySuccessRate = (this.metrics.successfulRetries / total) * 100;\n    }\n  }\n\n  // Cleanup\n  destroy(): void {\n    this.clearRetries();\n    this.circuitBreakers.clear();\n    this.eventHandlers.clear();\n  }\n}","/**\n * Queue Analytics System\n * Enterprise-grade monitoring and insights for queue performance\n */\n\nimport type { \n  // QueueItem, \n  QueueStats,\n  QueuePriority,\n  ResourceType,\n  QueueOperationType\n  // QueueItemStatus\n} from './types';\n\nexport interface AnalyticsConfig {\n  enabled: boolean;\n  sampleRate: number;\n  retentionDays: number;\n  aggregationIntervals: number[];\n  enableRealTimeMetrics: boolean;\n  enableTrendAnalysis: boolean;\n}\n\nexport interface PerformanceMetrics {\n  timestamp: number;\n  processingTime: number;\n  queueSize: number;\n  throughput: number;\n  errorRate: number;\n  priorityDistribution: Record<QueuePriority, number>;\n  resourceDistribution: Record<ResourceType, number>;\n  operationDistribution: Record<QueueOperationType, number>;\n}\n\nexport interface TrendAnalysis {\n  timeRange: string;\n  avgProcessingTime: number;\n  avgQueueSize: number;\n  avgThroughput: number;\n  peakQueueSize: number;\n  errorRateChange: number;\n  performanceScore: number;\n  recommendations: string[];\n}\n\nexport interface QueueInsights {\n  bottlenecks: BottleneckAnalysis[];\n  patterns: UsagePattern[];\n  anomalies: Anomaly[];\n  forecasts: PerformanceForecast[];\n  healthScore: number;\n}\n\nexport interface BottleneckAnalysis {\n  type: 'resource' | 'priority' | 'operation' | 'time';\n  identifier: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  impact: number;\n  suggestion: string;\n}\n\nexport interface UsagePattern {\n  pattern: 'peak_hours' | 'batch_processing' | 'retry_storm' | 'resource_hotspot';\n  description: string;\n  frequency: number;\n  timeWindows: string[];\n  impact: number;\n}\n\nexport interface Anomaly {\n  type: 'throughput' | 'latency' | 'error_rate' | 'queue_size';\n  timestamp: number;\n  severity: 'low' | 'medium' | 'high';\n  description: string;\n  deviation: number;\n  expectedValue: number;\n  actualValue: number;\n}\n\nexport interface PerformanceForecast {\n  metric: 'queue_size' | 'processing_time' | 'throughput' | 'error_rate';\n  timeHorizon: number;\n  predictedValue: number;\n  confidence: number;\n  trend: 'increasing' | 'decreasing' | 'stable';\n}\n\nexport class QueueAnalytics {\n  private config: AnalyticsConfig;\n  private metricsHistory: PerformanceMetrics[] = [];\n  private realtimeMetrics: PerformanceMetrics | null = null;\n  private aggregatedMetrics: Map<number, PerformanceMetrics[]> = new Map();\n  private itemTimings: Map<string, number> = new Map();\n  private processingStartTimes: Map<string, number> = new Map();\n\n  constructor(config: Partial<AnalyticsConfig> = {}) {\n    this.config = {\n      enabled: true,\n      sampleRate: 1.0,\n      retentionDays: 30,\n      aggregationIntervals: [60000, 300000, 3600000], // 1min, 5min, 1hour\n      enableRealTimeMetrics: true,\n      enableTrendAnalysis: true,\n      ...config,\n    };\n\n    if (this.config.enabled) {\n      this.initializeAggregationMaps();\n      this.startRealtimeMetrics();\n    }\n  }\n\n  /**\n   * Record item processing start\n   */\n  recordProcessingStart(itemId: string): void {\n    if (!this.config.enabled || Math.random() > this.config.sampleRate) return;\n    \n    this.processingStartTimes.set(itemId, Date.now());\n  }\n\n  /**\n   * Record item processing completion\n   */\n  recordProcessingComplete(itemId: string, _success: boolean): void {\n    if (!this.config.enabled) return;\n\n    const startTime = this.processingStartTimes.get(itemId);\n    if (startTime) {\n      const processingTime = Date.now() - startTime;\n      this.itemTimings.set(itemId, processingTime);\n      this.processingStartTimes.delete(itemId);\n    }\n  }\n\n  /**\n   * Record queue snapshot for metrics\n   */\n  recordQueueSnapshot(stats: QueueStats): void {\n    if (!this.config.enabled) return;\n\n    const metrics: PerformanceMetrics = {\n      timestamp: Date.now(),\n      processingTime: this.calculateAverageProcessingTime(),\n      queueSize: stats.totalItems,\n      throughput: this.calculateThroughput(),\n      errorRate: this.calculateErrorRate(stats),\n      priorityDistribution: stats.priorityDistribution,\n      resourceDistribution: stats.resourceDistribution,\n      operationDistribution: this.getOperationDistribution(stats),\n    };\n\n    this.addMetricsPoint(metrics);\n    \n    if (this.config.enableRealTimeMetrics) {\n      this.realtimeMetrics = metrics;\n    }\n  }\n\n  /**\n   * Get comprehensive queue insights\n   */\n  getInsights(timeRangeMs: number = 86400000): QueueInsights {\n    if (!this.config.enabled) {\n      return this.getEmptyInsights();\n    }\n\n    const cutoffTime = Date.now() - timeRangeMs;\n    const relevantMetrics = this.metricsHistory.filter(m => m.timestamp >= cutoffTime);\n\n    return {\n      bottlenecks: this.analyzeBottlenecks(relevantMetrics),\n      patterns: this.identifyPatterns(relevantMetrics),\n      anomalies: this.detectAnomalies(relevantMetrics),\n      forecasts: this.generateForecasts(relevantMetrics),\n      healthScore: this.calculateHealthScore(relevantMetrics),\n    };\n  }\n\n  /**\n   * Get trend analysis for specified time range\n   */\n  getTrendAnalysis(timeRangeMs: number = 86400000): TrendAnalysis {\n    if (!this.config.enabled || !this.config.enableTrendAnalysis) {\n      return this.getEmptyTrendAnalysis();\n    }\n\n    const cutoffTime = Date.now() - timeRangeMs;\n    const relevantMetrics = this.metricsHistory.filter(m => m.timestamp >= cutoffTime);\n\n    if (relevantMetrics.length === 0) {\n      return this.getEmptyTrendAnalysis();\n    }\n\n    const avgProcessingTime = relevantMetrics.reduce((sum, m) => sum + m.processingTime, 0) / relevantMetrics.length;\n    const avgQueueSize = relevantMetrics.reduce((sum, m) => sum + m.queueSize, 0) / relevantMetrics.length;\n    const avgThroughput = relevantMetrics.reduce((sum, m) => sum + m.throughput, 0) / relevantMetrics.length;\n    const peakQueueSize = Math.max(...relevantMetrics.map(m => m.queueSize));\n\n    const errorRateChange = this.calculateErrorRateChange(relevantMetrics);\n    const performanceScore = this.calculatePerformanceScore(relevantMetrics);\n\n    return {\n      timeRange: this.formatTimeRange(timeRangeMs),\n      avgProcessingTime,\n      avgQueueSize,\n      avgThroughput,\n      peakQueueSize,\n      errorRateChange,\n      performanceScore,\n      recommendations: this.generateRecommendations(relevantMetrics),\n    };\n  }\n\n  /**\n   * Get real-time metrics\n   */\n  getRealTimeMetrics(): PerformanceMetrics | null {\n    return this.realtimeMetrics;\n  }\n\n  /**\n   * Get aggregated metrics for specific interval\n   */\n  getAggregatedMetrics(intervalMs: number, timeRangeMs: number = 86400000): PerformanceMetrics[] {\n    const aggregated = this.aggregatedMetrics.get(intervalMs);\n    if (!aggregated) return [];\n\n    const cutoffTime = Date.now() - timeRangeMs;\n    return aggregated.filter(m => m.timestamp >= cutoffTime);\n  }\n\n  /**\n   * Clear old metrics data\n   */\n  cleanup(): void {\n    if (!this.config.enabled) return;\n\n    const cutoffTime = Date.now() - (this.config.retentionDays * 24 * 60 * 60 * 1000);\n    \n    // Clean main metrics history\n    this.metricsHistory = this.metricsHistory.filter(m => m.timestamp >= cutoffTime);\n    \n    // Clean aggregated metrics\n    for (const [interval, metrics] of this.aggregatedMetrics) {\n      this.aggregatedMetrics.set(interval, metrics.filter(m => m.timestamp >= cutoffTime));\n    }\n\n    // Clean old timings\n    const oldTimingKeys = Array.from(this.itemTimings.keys()).slice(0, -1000); // Keep last 1000\n    oldTimingKeys.forEach(key => this.itemTimings.delete(key));\n  }\n\n  /**\n   * Export metrics data\n   */\n  exportMetrics(format: 'json' | 'csv' = 'json'): string {\n    if (format === 'csv') {\n      return this.exportAsCSV();\n    }\n    return JSON.stringify(this.metricsHistory, null, 2);\n  }\n\n  // Private methods\n\n  private initializeAggregationMaps(): void {\n    for (const interval of this.config.aggregationIntervals) {\n      this.aggregatedMetrics.set(interval, []);\n    }\n  }\n\n  private startRealtimeMetrics(): void {\n    if (!this.config.enableRealTimeMetrics) return;\n\n    // Update real-time metrics every 30 seconds\n    setInterval(() => {\n      if (this.realtimeMetrics) {\n        // Age the real-time metrics\n        const age = Date.now() - this.realtimeMetrics.timestamp;\n        if (age > 60000) { // Reset if older than 1 minute\n          this.realtimeMetrics = null;\n        }\n      }\n    }, 30000);\n  }\n\n  private addMetricsPoint(metrics: PerformanceMetrics): void {\n    this.metricsHistory.push(metrics);\n\n    // Add to aggregated metrics\n    for (const interval of this.config.aggregationIntervals) {\n      this.addToAggregatedMetrics(metrics, interval);\n    }\n\n    // Keep history size manageable\n    if (this.metricsHistory.length > 10000) {\n      this.metricsHistory = this.metricsHistory.slice(-5000);\n    }\n  }\n\n  private addToAggregatedMetrics(metrics: PerformanceMetrics, intervalMs: number): void {\n    const aggregated = this.aggregatedMetrics.get(intervalMs);\n    if (!aggregated) return;\n\n    const bucketTime = Math.floor(metrics.timestamp / intervalMs) * intervalMs;\n    \n    // Find or create bucket\n    let bucket = aggregated.find(m => m.timestamp === bucketTime);\n    if (!bucket) {\n      bucket = { ...metrics, timestamp: bucketTime };\n      aggregated.push(bucket);\n    } else {\n      // Aggregate with existing bucket\n      this.aggregateMetrics(bucket, metrics);\n    }\n  }\n\n  private aggregateMetrics(bucket: PerformanceMetrics, newMetrics: PerformanceMetrics): void {\n    // Simple averaging approach - could be more sophisticated\n    bucket.processingTime = (bucket.processingTime + newMetrics.processingTime) / 2;\n    bucket.queueSize = Math.max(bucket.queueSize, newMetrics.queueSize);\n    bucket.throughput = (bucket.throughput + newMetrics.throughput) / 2;\n    bucket.errorRate = (bucket.errorRate + newMetrics.errorRate) / 2;\n  }\n\n  private calculateAverageProcessingTime(): number {\n    if (this.itemTimings.size === 0) return 0;\n    \n    const timings = Array.from(this.itemTimings.values());\n    return timings.reduce((sum, time) => sum + time, 0) / timings.length;\n  }\n\n  private calculateThroughput(): number {\n    // Calculate items processed per minute\n    const oneMinuteAgo = Date.now() - 60000;\n    const recentTimings = Array.from(this.itemTimings.entries())\n      .filter(([_, time]) => time >= oneMinuteAgo);\n    \n    return recentTimings.length;\n  }\n\n  private calculateErrorRate(stats: QueueStats): number {\n    const total = stats.completedItems + stats.failedItems + stats.deadItems;\n    if (total === 0) return 0;\n    \n    return ((stats.failedItems + stats.deadItems) / total) * 100;\n  }\n\n  private getOperationDistribution(_stats: QueueStats): Record<QueueOperationType, number> {\n    // This would need to be tracked separately in a real implementation\n    return {\n      create: 0,\n      update: 0,\n      delete: 0,\n      batch: 0,\n      custom: 0,\n    };\n  }\n\n  private analyzeBottlenecks(metrics: PerformanceMetrics[]): BottleneckAnalysis[] {\n    const bottlenecks: BottleneckAnalysis[] = [];\n\n    if (metrics.length === 0) return bottlenecks;\n\n    // Analyze queue size growth\n    const avgQueueSize = metrics.reduce((sum, m) => sum + m.queueSize, 0) / metrics.length;\n    if (avgQueueSize > 50) {\n      bottlenecks.push({\n        type: 'resource',\n        identifier: 'queue_size',\n        severity: avgQueueSize > 200 ? 'critical' : 'high',\n        impact: avgQueueSize,\n        suggestion: 'Consider increasing processing capacity or implementing load balancing',\n      });\n    }\n\n    // Analyze processing time\n    const avgProcessingTime = metrics.reduce((sum, m) => sum + m.processingTime, 0) / metrics.length;\n    if (avgProcessingTime > 5000) {\n      bottlenecks.push({\n        type: 'operation',\n        identifier: 'processing_time',\n        severity: avgProcessingTime > 15000 ? 'critical' : 'high',\n        impact: avgProcessingTime,\n        suggestion: 'Optimize operation processing or implement batching',\n      });\n    }\n\n    return bottlenecks;\n  }\n\n  private identifyPatterns(metrics: PerformanceMetrics[]): UsagePattern[] {\n    const patterns: UsagePattern[] = [];\n    \n    // Simple pattern detection - would be more sophisticated in real implementation\n    const highThroughputPeriods = metrics.filter(m => m.throughput > 50);\n    if (highThroughputPeriods.length > metrics.length * 0.3) {\n      patterns.push({\n        pattern: 'peak_hours',\n        description: 'High throughput periods detected',\n        frequency: highThroughputPeriods.length / metrics.length,\n        timeWindows: ['9:00-11:00', '14:00-16:00'],\n        impact: 0.7,\n      });\n    }\n\n    return patterns;\n  }\n\n  private detectAnomalies(metrics: PerformanceMetrics[]): Anomaly[] {\n    const anomalies: Anomaly[] = [];\n    \n    if (metrics.length < 10) return anomalies;\n\n    // Detect throughput anomalies\n    const avgThroughput = metrics.reduce((sum, m) => sum + m.throughput, 0) / metrics.length;\n    const throughputStdDev = this.calculateStandardDeviation(metrics.map(m => m.throughput));\n    \n    const recentMetrics = metrics.slice(-5);\n    for (const metric of recentMetrics) {\n      const deviation = Math.abs(metric.throughput - avgThroughput);\n      if (deviation > throughputStdDev * 2) {\n        anomalies.push({\n          type: 'throughput',\n          timestamp: metric.timestamp,\n          severity: deviation > throughputStdDev * 3 ? 'high' : 'medium',\n          description: 'Abnormal throughput detected',\n          deviation: deviation / avgThroughput,\n          expectedValue: avgThroughput,\n          actualValue: metric.throughput,\n        });\n      }\n    }\n\n    return anomalies;\n  }\n\n  private generateForecasts(metrics: PerformanceMetrics[]): PerformanceForecast[] {\n    const forecasts: PerformanceForecast[] = [];\n    \n    if (metrics.length < 20) return forecasts;\n\n    // Simple linear trend forecasting\n    const queueSizes = metrics.map(m => m.queueSize);\n    const queueTrend = this.calculateTrend(queueSizes);\n    \n    forecasts.push({\n      metric: 'queue_size',\n      timeHorizon: 3600000, // 1 hour\n      predictedValue: (queueSizes[queueSizes.length - 1] || 0) + queueTrend,\n      confidence: 0.7,\n      trend: queueTrend > 1 ? 'increasing' : queueTrend < -1 ? 'decreasing' : 'stable',\n    });\n\n    return forecasts;\n  }\n\n  private calculateHealthScore(metrics: PerformanceMetrics[]): number {\n    if (metrics.length === 0) return 100;\n\n    let score = 100;\n    \n    // Deduct points for high error rate\n    const avgErrorRate = metrics.reduce((sum, m) => sum + m.errorRate, 0) / metrics.length;\n    score -= avgErrorRate * 2;\n\n    // Deduct points for high queue size\n    const avgQueueSize = metrics.reduce((sum, m) => sum + m.queueSize, 0) / metrics.length;\n    if (avgQueueSize > 50) {\n      score -= (avgQueueSize - 50) * 0.5;\n    }\n\n    // Deduct points for slow processing\n    const avgProcessingTime = metrics.reduce((sum, m) => sum + m.processingTime, 0) / metrics.length;\n    if (avgProcessingTime > 2000) {\n      score -= (avgProcessingTime - 2000) * 0.01;\n    }\n\n    return Math.max(0, Math.min(100, score));\n  }\n\n  private calculateErrorRateChange(metrics: PerformanceMetrics[]): number {\n    if (metrics.length < 2) return 0;\n    \n    const firstHalf = metrics.slice(0, Math.floor(metrics.length / 2));\n    const secondHalf = metrics.slice(Math.floor(metrics.length / 2));\n    \n    const firstAvg = firstHalf.reduce((sum, m) => sum + m.errorRate, 0) / firstHalf.length;\n    const secondAvg = secondHalf.reduce((sum, m) => sum + m.errorRate, 0) / secondHalf.length;\n    \n    return secondAvg - firstAvg;\n  }\n\n  private calculatePerformanceScore(metrics: PerformanceMetrics[]): number {\n    return this.calculateHealthScore(metrics);\n  }\n\n  private generateRecommendations(metrics: PerformanceMetrics[]): string[] {\n    const recommendations: string[] = [];\n    \n    if (metrics.length === 0) return recommendations;\n\n    const avgQueueSize = metrics.reduce((sum, m) => sum + m.queueSize, 0) / metrics.length;\n    if (avgQueueSize > 100) {\n      recommendations.push('Consider implementing horizontal scaling to handle queue backlog');\n    }\n\n    const avgErrorRate = metrics.reduce((sum, m) => sum + m.errorRate, 0) / metrics.length;\n    if (avgErrorRate > 10) {\n      recommendations.push('Investigate and fix root causes of high error rate');\n    }\n\n    const avgProcessingTime = metrics.reduce((sum, m) => sum + m.processingTime, 0) / metrics.length;\n    if (avgProcessingTime > 5000) {\n      recommendations.push('Optimize operation processing or implement operation batching');\n    }\n\n    return recommendations;\n  }\n\n  private calculateStandardDeviation(values: number[]): number {\n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\n    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;\n    return Math.sqrt(variance);\n  }\n\n  private calculateTrend(values: number[]): number {\n    if (values.length < 2) return 0;\n    \n    // Simple linear regression slope\n    const n = values.length;\n    const sumX = (n * (n - 1)) / 2;\n    const sumY = values.reduce((sum, val) => sum + val, 0);\n    const sumXY = values.reduce((sum, val, index) => sum + val * index, 0);\n    const sumX2 = values.reduce((sum, _, index) => sum + index * index, 0);\n    \n    return (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n  }\n\n  private formatTimeRange(timeRangeMs: number): string {\n    const hours = timeRangeMs / (1000 * 60 * 60);\n    if (hours < 24) {\n      return `${Math.round(hours)} hours`;\n    }\n    return `${Math.round(hours / 24)} days`;\n  }\n\n  private exportAsCSV(): string {\n    const headers = ['timestamp', 'processingTime', 'queueSize', 'throughput', 'errorRate'];\n    const rows = this.metricsHistory.map(m => [\n      m.timestamp,\n      m.processingTime,\n      m.queueSize,\n      m.throughput,\n      m.errorRate,\n    ]);\n\n    return [headers.join(','), ...rows.map(row => row.join(','))].join('\\n');\n  }\n\n  private getEmptyInsights(): QueueInsights {\n    return {\n      bottlenecks: [],\n      patterns: [],\n      anomalies: [],\n      forecasts: [],\n      healthScore: 100,\n    };\n  }\n\n  private getEmptyTrendAnalysis(): TrendAnalysis {\n    return {\n      timeRange: '0 hours',\n      avgProcessingTime: 0,\n      avgQueueSize: 0,\n      avgThroughput: 0,\n      peakQueueSize: 0,\n      errorRateChange: 0,\n      performanceScore: 100,\n      recommendations: [],\n    };\n  }\n\n  // Cleanup\n  destroy(): void {\n    this.metricsHistory = [];\n    this.aggregatedMetrics.clear();\n    this.itemTimings.clear();\n    this.processingStartTimes.clear();\n    this.realtimeMetrics = null;\n  }\n}","/**\n * Enterprise Queue Manager\n * Orchestrates all queue components for enterprise-grade offline operations\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport { PriorityQueue } from './priority-queue';\nimport { BatchProcessor } from './batch-processor';\n// import { ConflictResolverManager } from './conflict-resolver'; // TODO: Re-enable when implementing conflict resolution\nimport { RetryManager } from './retry-manager';\nimport { QueueAnalytics } from './queue-analytics';\n\nimport type { \n  QueueItem, \n  QueueItemId, \n  QueuePriority, \n  QueueOperationType,\n  ResourceType,\n  QueueConfig,\n  QueueEvents,\n  QueueStats,\n  BatchOperation,\n  QueueProcessor \n} from './types';\nimport { createQueueItemId } from './types';\n\nexport interface QueueManagerConfig extends QueueConfig {\n  storageKey: string;\n  autoProcessing: boolean;\n  processingInterval: number;\n  maxConcurrentProcessing: number;\n  enablePersistence: boolean;\n  enableAnalytics: boolean;\n}\n\nexport interface ProcessingResult {\n  success: boolean;\n  result?: any;\n  error?: string;\n  processingTime: number;\n}\n\nexport class EnterpriseQueueManager extends EventEmitter<QueueEvents> {\n  private config: QueueManagerConfig;\n  private priorityQueue: PriorityQueue;\n  private batchProcessor: BatchProcessor;\n  // private _conflictResolver: ConflictResolverManager;  // TODO: Implement conflict resolution\n  private retryManager: RetryManager;\n  private analytics: QueueAnalytics;\n  \n  private processors: Map<string, QueueProcessor> = new Map();\n  private processingItems: Set<QueueItemId> = new Set();\n  private processingTimer: NodeJS.Timeout | null = null;\n  private isProcessing = false;\n  private itemCounter = 0;\n\n  constructor(config: Partial<QueueManagerConfig> = {}) {\n    super();\n    \n    this.config = {\n      maxSize: 10000,\n      maxRetries: 3,\n      defaultPriority: 'normal',\n      defaultRetryStrategy: 'exponential',\n      defaultConflictResolution: 'server-wins',\n      batchingEnabled: true,\n      batchSize: 20,\n      batchTimeout: 5000,\n      deadLetterEnabled: true,\n      analyticsEnabled: true,\n      persistToDisk: true,\n      circuitBreakerEnabled: true,\n      circuitBreakerThreshold: 5,\n      deduplicationEnabled: true,\n      deduplicationWindow: 300000,\n      storageKey: 'acube-enterprise-queue',\n      autoProcessing: true,\n      processingInterval: 1000,\n      maxConcurrentProcessing: 5,\n      enablePersistence: true,\n      enableAnalytics: true,\n      ...config,\n    };\n\n    // Initialize required components\n    this.priorityQueue = new PriorityQueue(this.config);\n    this.batchProcessor = new BatchProcessor({});\n    // this._conflictResolver = new ConflictResolverManager({});  // TODO: Implement\n    this.retryManager = new RetryManager({});\n    this.analytics = new QueueAnalytics({});\n\n    this.initializeComponents();\n    this.setupEventHandlers();\n    \n    if (this.config.autoProcessing) {\n      this.startAutoProcessing();\n    }\n  }\n\n  /**\n   * Add operation to queue\n   */\n  async enqueue(\n    operation: QueueOperationType,\n    resource: ResourceType,\n    data: any,\n    options: {\n      priority?: QueuePriority;\n      optimisticId?: string;\n      batchId?: string;\n      dependencies?: QueueItemId[];\n      metadata?: Record<string, unknown>;\n      scheduledAt?: number;\n    } = {}\n  ): Promise<QueueItemId> {\n    const id = createQueueItemId(`${resource}_${operation}_${++this.itemCounter}_${Date.now()}`);\n    \n    const item: QueueItem = {\n      id,\n      priority: options.priority || this.config.defaultPriority,\n      operation,\n      resource,\n      data,\n      status: 'pending',\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n      ...(options.scheduledAt !== undefined && { scheduledAt: options.scheduledAt }),\n      retryCount: 0,\n      maxRetries: this.config.maxRetries,\n      retryStrategy: this.config.defaultRetryStrategy,\n      conflictResolution: this.config.defaultConflictResolution,\n      ...(options.optimisticId && { optimisticId: options.optimisticId }),\n      ...(options.batchId && { batchId: options.batchId }),\n      ...(options.dependencies && { dependencies: options.dependencies }),\n      ...(options.metadata && { metadata: options.metadata }),\n      errorHistory: [],\n    };\n\n    // Check for deduplication\n    if (this.config.deduplicationEnabled && this.isDuplicate(item)) {\n      throw new Error(`Duplicate operation detected for ${resource}:${operation}`);\n    }\n\n    const success = this.priorityQueue.enqueue(item);\n    if (!success) {\n      throw new Error('Queue is full - unable to enqueue item');\n    }\n\n    // Persist if enabled\n    if (this.config.enablePersistence) {\n      await this.persistQueue();\n    }\n\n    // Record analytics\n    if (this.config.enableAnalytics) {\n      this.analytics.recordQueueSnapshot(this.getStats());\n    }\n\n    return id;\n  }\n\n  /**\n   * Remove item from queue\n   */\n  async dequeue(id: QueueItemId): Promise<boolean> {\n    const success = this.priorityQueue.remove(id);\n    \n    if (success && this.config.enablePersistence) {\n      await this.persistQueue();\n    }\n\n    return success;\n  }\n\n  /**\n   * Get item by ID\n   */\n  getItem(id: QueueItemId): QueueItem | null {\n    return this.priorityQueue.get(id);\n  }\n\n  /**\n   * Update item status\n   */\n  async updateItemStatus(\n    id: QueueItemId, \n    status: QueueItem['status'], \n    error?: string\n  ): Promise<boolean> {\n    const item = this.priorityQueue.get(id);\n    if (!item) {\n      return false;\n    }\n\n    let errorHistory = item.errorHistory || [];\n    if (error) {\n      const newErrorEntry = {\n        timestamp: Date.now(),\n        error,\n        retryable: this.isRetryableError(error),\n        context: { status: item.status },\n      };\n      errorHistory = [...errorHistory, newErrorEntry];\n    }\n\n    // Create new item with updated properties\n    const updatedItem: QueueItem = {\n      ...item,\n      status,\n      updatedAt: Date.now(),\n      ...(error && { errorHistory }),\n    };\n\n    const success = this.priorityQueue.updateItem(id, updatedItem);\n    \n    if (success) {\n      // Handle status-specific logic\n      await this.handleStatusChange(id, status, error);\n      \n      if (this.config.enablePersistence) {\n        await this.persistQueue();\n      }\n    }\n\n    return success;\n  }\n\n  /**\n   * Register processor for resource/operation combination\n   */\n  registerProcessor(\n    resource: ResourceType,\n    operation: QueueOperationType,\n    processor: QueueProcessor\n  ): void {\n    const key = `${resource}:${operation}`;\n    this.processors.set(key, processor);\n  }\n\n  /**\n   * Process next available items\n   */\n  async processNext(maxItems: number = 1): Promise<ProcessingResult[]> {\n    if (this.isProcessing) {\n      return [];\n    }\n\n    this.isProcessing = true;\n    const results: ProcessingResult[] = [];\n\n    try {\n      const availableSlots = Math.min(\n        maxItems,\n        this.config.maxConcurrentProcessing - this.processingItems.size\n      );\n\n      if (availableSlots <= 0) {\n        return results;\n      }\n\n      // Get ready items\n      const readyItems = this.priorityQueue.getReadyItems(availableSlots);\n      \n      if (readyItems.length === 0) {\n        return results;\n      }\n\n      // Process with batching if enabled\n      if (this.config.batchingEnabled) {\n        const batchResults = await this.processBatched(readyItems);\n        results.push(...batchResults);\n      } else {\n        const individualResults = await this.processIndividually(readyItems);\n        results.push(...individualResults);\n      }\n\n      // Update analytics\n      if (this.config.enableAnalytics) {\n        this.analytics.recordQueueSnapshot(this.getStats());\n      }\n\n    } finally {\n      this.isProcessing = false;\n    }\n\n    return results;\n  }\n\n  /**\n   * Process all pending items\n   */\n  async processAll(): Promise<ProcessingResult[]> {\n    const allResults: ProcessingResult[] = [];\n    \n    while (this.priorityQueue.getReadyItems(1).length > 0) {\n      const results = await this.processNext(this.config.maxConcurrentProcessing);\n      if (results.length === 0) break;\n      allResults.push(...results);\n    }\n\n    return allResults;\n  }\n\n  /**\n   * Get queue statistics\n   */\n  getStats(): QueueStats {\n    return this.priorityQueue.getStats();\n  }\n\n  /**\n   * Get queue insights\n   */\n  getInsights() {\n    return this.analytics.getInsights();\n  }\n\n  /**\n   * Get trend analysis\n   */\n  getTrendAnalysis() {\n    return this.analytics.getTrendAnalysis();\n  }\n\n  /**\n   * Clear all items from queue\n   */\n  async clear(): Promise<void> {\n    this.priorityQueue.clear();\n    this.batchProcessor.clear();\n    this.retryManager.clearRetries();\n    this.processingItems.clear();\n\n    if (this.config.enablePersistence) {\n      await this.persistQueue();\n    }\n  }\n\n  /**\n   * Pause queue processing\n   */\n  pause(): void {\n    if (this.processingTimer) {\n      clearInterval(this.processingTimer);\n      this.processingTimer = null;\n    }\n    this.emit('queue:paused', {});\n  }\n\n  /**\n   * Resume queue processing\n   */\n  resume(): void {\n    if (this.config.autoProcessing && !this.processingTimer) {\n      this.startAutoProcessing();\n    }\n    this.emit('queue:resumed', {});\n  }\n\n  /**\n   * Get processing status\n   */\n  getProcessingStatus() {\n    return {\n      isProcessing: this.isProcessing,\n      processingItems: this.processingItems.size,\n      autoProcessing: this.processingTimer !== null,\n      readyItems: this.priorityQueue.getReadyItems().length,\n    };\n  }\n\n  /**\n   * Initialize the queue manager\n   */\n  async initialize(): Promise<void> {\n    // Initialize components if needed\n    this.initializeComponents();\n    \n    // Load persisted queue if available\n    // await this._loadPersistedQueue(); // TODO: Implement when storage is ready\n    \n    this.emit('queue:initialized', {});\n  }\n\n  /**\n   * Add item to queue (compatibility method)\n   */\n  async add(item: QueueItem): Promise<void> {\n    const success = this.priorityQueue.enqueue(item);\n    if (!success) {\n      throw new Error('Failed to add item to queue');\n    }\n    \n    if (this.config.enablePersistence) {\n      await this.persistQueue();\n    }\n  }\n\n  /**\n   * Process a specific queue item (public interface)\n   */\n  async processItem(item: QueueItem): Promise<ProcessingResult> {\n    return this.processItemInternal(item);\n  }\n\n  /**\n   * Get all queue items (compatibility method)\n   */\n  getQueueItems(): QueueItem[] {\n    return this.priorityQueue.toArray();\n  }\n\n  /**\n   * Cleanup and destroy\n   */\n  async destroy(): Promise<void> {\n    this.pause();\n    \n    // Wait for current processing to complete\n    while (this.isProcessing) {\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n\n    this.priorityQueue.clear();\n    this.batchProcessor.destroy();\n    this.retryManager.destroy();\n    this.analytics.destroy();\n    \n    this.removeAllListeners();\n  }\n\n  // Private methods\n\n  private initializeComponents(): void {\n    this.priorityQueue = new PriorityQueue({\n      maxSize: this.config.maxSize,\n      enableMetrics: this.config.analyticsEnabled,\n      enableEvents: true,\n    });\n\n    this.batchProcessor = new BatchProcessor({\n      maxBatchSize: this.config.batchSize,\n      maxWaitTime: this.config.batchTimeout,\n      enableResourceGrouping: true,\n      enableTimeWindowing: true,\n    });\n\n    // this._conflictResolver = new ConflictResolverManager({\n    //   defaultStrategy: this.config.defaultConflictResolution,\n    // });\n\n    this.retryManager = new RetryManager({\n      defaultRetryPolicy: {\n        strategy: this.config.defaultRetryStrategy,\n        maxRetries: this.config.maxRetries,\n        baseDelay: 1000,\n        maxDelay: 30000,\n        backoffFactor: 2,\n        jitterEnabled: true,\n      },\n      circuitBreakerConfig: {\n        enabled: this.config.circuitBreakerEnabled,\n        failureThreshold: this.config.circuitBreakerThreshold,\n        successThreshold: 3,\n        timeout: 60000,\n        monitoringWindow: 300000,\n      },\n    });\n\n    this.analytics = new QueueAnalytics({\n      enabled: this.config.enableAnalytics,\n      sampleRate: 1.0,\n      retentionDays: 7,\n    });\n  }\n\n  private setupEventHandlers(): void {\n    // Forward priority queue events\n    this.priorityQueue.on('item:added', (data) => this.emit('item:added', data));\n    this.priorityQueue.on('item:processing', (data) => this.emit('item:processing', data));\n    this.priorityQueue.on('item:completed', (data) => this.emit('item:completed', data));\n    this.priorityQueue.on('item:failed', (data) => this.emit('item:failed', data));\n\n    // Handle retry events\n    this.retryManager.on('item:retry-ready', async ({ itemId }) => {\n      const item = this.priorityQueue.get(itemId);\n      if (item) {\n        await this.priorityQueue.updateItem(itemId, { \n          status: 'pending',\n          retryCount: item.retryCount + 1,\n        });\n      }\n    });\n\n    // Handle batch events\n    this.batchProcessor.on('batch:created', (data) => this.emit('batch:created', data));\n    this.batchProcessor.on('batch:completed', (data) => this.emit('batch:completed', data));\n  }\n\n  private startAutoProcessing(): void {\n    this.processingTimer = setInterval(async () => {\n      try {\n        await this.processNext(this.config.maxConcurrentProcessing);\n      } catch (error) {\n        console.error('Error in auto-processing:', error);\n      }\n    }, this.config.processingInterval) as unknown as NodeJS.Timeout;\n  }\n\n  private async processBatched(items: QueueItem[]): Promise<ProcessingResult[]> {\n    const results: ProcessingResult[] = [];\n    \n    // Group items for batching\n    const batches = this.batchProcessor.addToBatch(items, {\n      groupByResource: true,\n      groupByPriority: false,\n      groupByTimeWindow: false,\n      windowSizeMs: 60000,\n      maxItemsPerBatch: this.config.batchSize,\n      priorityMixing: true,\n    });\n\n    // Process each batch\n    for (const batch of batches) {\n      const batchResult = await this.processBatch(batch);\n      results.push(...batchResult);\n    }\n\n    return results;\n  }\n\n  private async processIndividually(items: QueueItem[]): Promise<ProcessingResult[]> {\n    const results: ProcessingResult[] = [];\n    \n    const processingPromises = items.map(async (item) => {\n      return this.processItemInternal(item);\n    });\n\n    const batchResults = await Promise.allSettled(processingPromises);\n    \n    for (const result of batchResults) {\n      if (result.status === 'fulfilled') {\n        results.push(result.value);\n      } else {\n        results.push({\n          success: false,\n          error: result.reason?.message || 'Unknown error',\n          processingTime: 0,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  private async processBatch(batch: BatchOperation): Promise<ProcessingResult[]> {\n    const results: ProcessingResult[] = [];\n    \n    try {\n      await this.batchProcessor.processBatch(batch.id, async (items) => {\n        const batchResults = await Promise.allSettled(\n          items.map(item => this.processItemInternal(item))\n        );\n        \n        for (const result of batchResults) {\n          if (result.status === 'fulfilled') {\n            results.push(result.value);\n          } else {\n            results.push({\n              success: false,\n              error: result.reason?.message || 'Batch processing error',\n              processingTime: 0,\n            });\n          }\n        }\n      });\n    } catch (error) {\n      // If batch processing fails, fall back to individual processing\n      console.warn('Batch processing failed, falling back to individual:', error);\n      return this.processIndividually(batch.items);\n    }\n\n    return results;\n  }\n\n  private async processItemInternal(item: QueueItem): Promise<ProcessingResult> {\n    const startTime = Date.now();\n    this.processingItems.add(item.id);\n\n    try {\n      // Record processing start\n      if (this.config.enableAnalytics) {\n        this.analytics.recordProcessingStart(item.id);\n      }\n\n      // Update item status\n      await this.updateItemStatus(item.id, 'processing');\n\n      // Get processor\n      const processorKey = `${item.resource}:${item.operation}`;\n      const processor = this.processors.get(processorKey);\n      \n      if (!processor) {\n        throw new Error(`No processor registered for ${processorKey}`);\n      }\n\n      // Execute processing\n      const result = await processor(item);\n\n      // Record success\n      this.retryManager.recordSuccess(item.resource);\n      \n      if (this.config.enableAnalytics) {\n        this.analytics.recordProcessingComplete(item.id, true);\n      }\n\n      // Update item status\n      await this.updateItemStatus(item.id, 'completed');\n\n      const processingTime = Date.now() - startTime;\n      return {\n        success: true,\n        result,\n        processingTime,\n      };\n\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      \n      // Record failure\n      this.retryManager.recordFailure(item.resource, errorMessage);\n      \n      if (this.config.enableAnalytics) {\n        this.analytics.recordProcessingComplete(item.id, false);\n      }\n\n      // Handle retry or failure\n      if (item.retryCount < item.maxRetries && this.isRetryableError(errorMessage)) {\n        const retryScheduled = this.retryManager.scheduleRetry(item, errorMessage);\n        if (retryScheduled) {\n          await this.updateItemStatus(item.id, 'retry', errorMessage);\n        } else {\n          await this.updateItemStatus(item.id, 'failed', errorMessage);\n        }\n      } else {\n        await this.updateItemStatus(item.id, 'failed', errorMessage);\n      }\n\n      const processingTime = Date.now() - startTime;\n      return {\n        success: false,\n        error: errorMessage,\n        processingTime,\n      };\n\n    } finally {\n      this.processingItems.delete(item.id);\n    }\n  }\n\n  private async handleStatusChange(\n    id: QueueItemId, \n    status: QueueItem['status'], \n    _error?: string\n  ): Promise<void> {\n    const item = this.priorityQueue.get(id);\n    if (!item) return;\n\n    switch (status) {\n      case 'failed':\n        if (item.retryCount >= item.maxRetries && this.config.deadLetterEnabled) {\n          // Move to dead letter queue\n          await this.updateItemStatus(id, 'dead');\n        }\n        break;\n\n      case 'dead':\n        this.emit('item:dead', { item });\n        break;\n\n      case 'completed':\n        // Remove completed items after a short delay\n        setTimeout(() => {\n          this.priorityQueue.remove(id);\n        }, 5000);\n        break;\n    }\n  }\n\n  private isDuplicate(item: QueueItem): boolean {\n    if (!this.config.deduplicationEnabled) return false;\n\n    const cutoffTime = Date.now() - this.config.deduplicationWindow;\n    const existingItems = this.priorityQueue.getByResource(item.resource);\n\n    return existingItems.some(existing => \n      existing.operation === item.operation &&\n      existing.createdAt >= cutoffTime &&\n      JSON.stringify(existing.data) === JSON.stringify(item.data)\n    );\n  }\n\n  private isRetryableError(error: string): boolean {\n    const retryableErrors = [\n      'NETWORK_ERROR',\n      'TIMEOUT',\n      'SERVER_ERROR',\n      'RATE_LIMITED',\n      'TEMPORARY_FAILURE',\n    ];\n\n    return retryableErrors.some(retryable => error.includes(retryable));\n  }\n\n  private async persistQueue(): Promise<void> {\n    if (!this.config.enablePersistence) return;\n\n    try {\n      const queueData = {\n        items: this.priorityQueue.toArray(),\n        timestamp: Date.now(),\n      };\n\n      // This would integrate with the storage adapter\n      // For now, we'll use localStorage as a fallback\n      if (typeof localStorage !== 'undefined') {\n        localStorage.setItem(this.config.storageKey, JSON.stringify(queueData));\n      }\n    } catch (error) {\n      console.warn('Failed to persist queue:', error);\n    }\n  }\n\n  // TODO: Implement persisted queue loading when storage adapter is ready\n  // private async _loadPersistedQueue(): Promise<void> {\n  //   if (!this.config.enablePersistence) return;\n  //\n  //   try {\n  //     // This would integrate with the storage adapter\n  //     if (typeof localStorage !== 'undefined') {\n  //       const serialized = localStorage.getItem(this.config.storageKey);\n  //       if (serialized) {\n  //         const queueData = JSON.parse(serialized);\n  //         if (queueData.items && Array.isArray(queueData.items)) {\n  //           for (const item of queueData.items) {\n  //             this.priorityQueue.enqueue(item);\n  //           }\n  //         }\n  //       }\n  //     }\n  //   } catch (error) {\n  //     console.warn('Failed to load persisted queue:', error);\n  //   }\n  // }\n}\n\n// Export types for external use\nexport type { QueueItem, QueueStats } from './types';","/**\n * Authentication Types and Interfaces\n * Comprehensive type definitions for the enterprise auth system\n */\n\nimport type { CashierId, MerchantId, PointOfSaleId } from '@/types/branded';\n\n/**\n * User roles in the A-Cube system with hierarchical structure\n */\nexport enum UserRole {\n  // Core business roles\n  ROLE_SUPPLIER = 'ROLE_SUPPLIER',         // Provider level\n  ROLE_MERCHANT = 'ROLE_MERCHANT',         // Merchant level (includes cashier permissions)\n  ROLE_CASHIER = 'ROLE_CASHIER',           // Cashier level (basic operations)\n  \n  // Administrative roles\n  ROLE_ADMIN = 'ROLE_ADMIN',               // Administrative access\n  ROLE_PREVIOUS_ADMIN = 'ROLE_PREVIOUS_ADMIN', // Former admin with limited access\n  \n  // MF1 Integration roles\n  ROLE_ACUBE_MF1 = 'ROLE_ACUBE_MF1',       // A-Cube MF1 integration\n  ROLE_EXTERNAL_MF1 = 'ROLE_EXTERNAL_MF1', // External MF1 integration\n  ROLE_MF1 = 'ROLE_MF1',                   // Base MF1 access\n}\n\n/**\n * Simplified user role types for external APIs and UI\n */\nexport type SimpleUserRole = 'provider' | 'merchant' | 'cashier' | 'admin';\n\n/**\n * Role hierarchy mapping - child roles inherit parent permissions\n */\nexport const ROLE_HIERARCHY: Record<UserRole, UserRole[]> = {\n  [UserRole.ROLE_SUPPLIER]: [\n    UserRole.ROLE_MERCHANT,\n    UserRole.ROLE_CASHIER,\n    UserRole.ROLE_ADMIN,\n    UserRole.ROLE_ACUBE_MF1,\n    UserRole.ROLE_EXTERNAL_MF1,\n  ],\n  [UserRole.ROLE_MERCHANT]: [\n    UserRole.ROLE_CASHIER,\n  ],\n  [UserRole.ROLE_CASHIER]: [],\n  [UserRole.ROLE_ADMIN]: [\n    UserRole.ROLE_PREVIOUS_ADMIN,\n  ],\n  [UserRole.ROLE_ACUBE_MF1]: [\n    UserRole.ROLE_MF1,\n  ],\n  [UserRole.ROLE_EXTERNAL_MF1]: [\n    UserRole.ROLE_MF1,\n  ],\n  [UserRole.ROLE_MF1]: [],\n  [UserRole.ROLE_PREVIOUS_ADMIN]: [],\n};\n\n/**\n * Role to simple role mapping for backward compatibility\n */\nexport const ROLE_TO_SIMPLE: Record<UserRole, SimpleUserRole> = {\n  [UserRole.ROLE_SUPPLIER]: 'provider',\n  [UserRole.ROLE_MERCHANT]: 'merchant',\n  [UserRole.ROLE_CASHIER]: 'cashier',\n  [UserRole.ROLE_ADMIN]: 'admin',\n  [UserRole.ROLE_PREVIOUS_ADMIN]: 'admin',\n  [UserRole.ROLE_ACUBE_MF1]: 'provider',\n  [UserRole.ROLE_EXTERNAL_MF1]: 'provider',\n  [UserRole.ROLE_MF1]: 'provider',\n};\n\n/**\n * Simple role to full role mapping\n */\nexport const SIMPLE_TO_ROLE: Record<SimpleUserRole, UserRole> = {\n  provider: UserRole.ROLE_SUPPLIER,\n  merchant: UserRole.ROLE_MERCHANT,\n  cashier: UserRole.ROLE_CASHIER,\n  admin: UserRole.ROLE_ADMIN,\n};\n\n/**\n * OAuth2 token response from /mf1/login endpoint\n */\nexport interface OAuth2TokenResponse {\n  access_token: string;\n  refresh_token: string;\n  token_type: 'Bearer';\n  expires_in: number; // seconds\n  scope?: string;\n}\n\n/**\n * Decoded JWT token payload\n */\nexport interface JWTPayload {\n  sub: string; // Subject (user ID)\n  email: string;\n  roles: UserRole[];\n  permissions: string[];\n  iat: number; // Issued at (timestamp)\n  exp: number; // Expiration (timestamp)\n  nbf?: number; // Not before (timestamp)\n  jti?: string; // JWT ID\n  iss?: string; // Issuer\n  aud?: string | string[]; // Audience\n  \n  // Role-specific data\n  cashier_id?: CashierId;\n  merchant_id?: MerchantId;\n  point_of_sale_id?: PointOfSaleId;\n  \n  // Additional claims\n  [key: string]: unknown;\n}\n\n/**\n * Login credentials for OAuth2 password grant\n */\nexport interface LoginCredentials {\n  username: string;\n  password: string;\n  scope?: string;\n  \n  // Multi-factor authentication\n  mfa_code?: string;\n  \n  // Device binding\n  device_id?: string;\n  device_name?: string;\n  \n  // Role specification during authentication\n  preferred_role?: UserRole | SimpleUserRole;\n  \n  // Context-specific authentication\n  context?: {\n    merchant_id?: MerchantId;\n    cashier_id?: CashierId;\n    point_of_sale_id?: PointOfSaleId;\n  };\n}\n\n/**\n * User information after successful authentication\n */\nexport interface AuthUser {\n  id: string;\n  email: string;\n  name?: string;\n  roles: UserRole[];\n  permissions: string[];\n  \n  // Role-specific IDs\n  cashier_id?: CashierId;\n  merchant_id?: MerchantId;\n  point_of_sale_id?: PointOfSaleId;\n  \n  // Session information\n  session_id: string;\n  last_login: Date;\n  \n  // Additional user attributes\n  attributes?: Record<string, unknown>;\n}\n\n/**\n * Authentication state for the SDK\n */\nexport interface AuthState {\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  user: AuthUser | null;\n  accessToken: string | null;\n  refreshToken: string | null;\n  expiresAt: number | null; // Timestamp\n  error: AuthError | null;\n}\n\n/**\n * Stored authentication data (encrypted in storage)\n */\nexport interface StoredAuthData {\n  accessToken: string;\n  refreshToken: string;\n  expiresAt: number;\n  tokenType: 'Bearer';\n  user: AuthUser;\n  encryptedAt: number;\n  version: '1.0';\n  \n  // Device binding\n  deviceId?: string;\n  \n  // Session metadata\n  sessionMetadata?: {\n    ip?: string;\n    userAgent?: string;\n    location?: string;\n  };\n}\n\n/**\n * Authentication error types\n */\nexport const AuthErrorType = {\n  INVALID_CREDENTIALS: 'INVALID_CREDENTIALS',\n  TOKEN_EXPIRED: 'TOKEN_EXPIRED',\n  TOKEN_INVALID: 'TOKEN_INVALID',\n  REFRESH_FAILED: 'REFRESH_FAILED',\n  NETWORK_ERROR: 'NETWORK_ERROR',\n  STORAGE_ERROR: 'STORAGE_ERROR',\n  PERMISSION_DENIED: 'PERMISSION_DENIED',\n  SESSION_EXPIRED: 'SESSION_EXPIRED',\n  MFA_REQUIRED: 'MFA_REQUIRED',\n  ACCOUNT_LOCKED: 'ACCOUNT_LOCKED',\n  UNKNOWN_ERROR: 'UNKNOWN_ERROR',\n} as const;\n\nexport type AuthErrorType = typeof AuthErrorType[keyof typeof AuthErrorType];\n\n/**\n * Authentication error with context\n */\nexport interface AuthError extends Error {\n  type: AuthErrorType;\n  message: string;\n  code?: string;\n  statusCode?: number;\n  details?: Record<string, unknown>;\n  timestamp: number;\n  recoverable: boolean;\n}\n\n/**\n * Token refresh request\n */\nexport interface TokenRefreshRequest {\n  refresh_token: string;\n  grant_type: 'refresh_token';\n  scope?: string;\n}\n\n/**\n * Authentication configuration\n */\nexport interface AuthConfig {\n  // OAuth2 endpoints\n  loginUrl: string;\n  refreshUrl: string;\n  logoutUrl?: string;\n  \n  // Token management\n  tokenRefreshBuffer: number; // Refresh X minutes before expiry (default: 5)\n  maxRefreshAttempts: number; // Max retry attempts for refresh (default: 3)\n  refreshRetryDelay: number; // Delay between retries in ms (default: 1000)\n  \n  // Storage\n  storageKey: string; // Key for storing auth data (default: 'acube_auth')\n  storageEncryption: boolean; // Enable encryption (default: true)\n  \n  // Session management\n  sessionTimeout: number; // Session timeout in ms (default: 8 hours)\n  maxConcurrentSessions: number; // Max sessions per user (default: 3)\n  requireReauth: boolean; // Require re-authentication for sensitive operations\n  \n  // Security\n  enableDeviceBinding: boolean; // Bind tokens to device (default: true)\n  enableSessionValidation: boolean; // Validate session on each request\n  enableTokenRotation: boolean; // Rotate refresh tokens on use\n  \n  // Performance optimization\n  enablePerformanceOptimization?: boolean; // Enable caching and batching (default: true)\n  performanceConfig?: {\n    permissionCacheSize?: number;\n    permissionCacheTTL?: number;\n    roleCacheSize?: number;\n    roleCacheTTL?: number;\n    tokenValidationCacheSize?: number;\n    tokenValidationCacheTTL?: number;\n    maxBatchSize?: number;\n    batchTimeoutMs?: number;\n    enableMetrics?: boolean;\n  };\n  \n  // Events\n  onTokenRefresh?: (tokens: OAuth2TokenResponse) => void;\n  onTokenExpired?: () => void;\n  onAuthError?: (error: AuthError) => void;\n  onSessionExpired?: () => void;\n  onLogout?: (reason?: string) => void;\n}\n\n/**\n * Permission check request\n */\nexport interface PermissionCheck {\n  resource: string;\n  action: string;\n  context?: Record<string, unknown>;\n}\n\n/**\n * Permission check result\n */\nexport interface PermissionResult {\n  granted: boolean;\n  reason?: string;\n  requiresApproval?: boolean;\n  conditions?: Array<{\n    type: string;\n    satisfied: boolean;\n    message?: string;\n  }>;\n}\n\n/**\n * Token status information\n */\nexport interface TokenStatus {\n  isValid: boolean;\n  expiresIn: number; // Seconds until expiration\n  isRefreshing: boolean;\n  needsRefresh: boolean;\n  lastRefreshed?: Date;\n  refreshFailures: number;\n}\n\n/**\n * Authentication middleware configuration\n */\nexport interface AuthMiddlewareConfig {\n  // Retry configuration\n  enableRetry: boolean;\n  maxRetries: number;\n  retryDelay: number;\n  \n  // Headers\n  authHeaderName: string; // Default: 'Authorization'\n  authScheme: string; // Default: 'Bearer'\n  \n  // Role headers\n  includeRoleHeaders: boolean;\n  roleHeaderName: string; // Default: 'X-User-Role'\n  \n  // Permission headers\n  includePermissionHeaders: boolean;\n  permissionHeaderName: string; // Default: 'X-User-Permissions'\n  \n  // Request context\n  includeRequestContext: boolean;\n  contextHeaders: Record<string, string>;\n}\n\n/**\n * Logout options\n */\nexport interface LogoutOptions {\n  // Clear all sessions across devices\n  clearAllSessions?: boolean;\n  \n  // Reason for logout\n  reason?: 'user_initiated' | 'session_expired' | 'security' | 'token_invalid' | 'other';\n  \n  // Custom message\n  message?: string;\n  \n  // Redirect after logout\n  redirectUrl?: string;\n  \n  // Clean up local data\n  clearLocalData?: boolean;\n}\n\n/**\n * Multi-factor authentication challenge\n */\nexport interface MFAChallenge {\n  challengeId: string;\n  type: 'totp' | 'sms' | 'email' | 'push';\n  createdAt: Date;\n  expiresAt: Date;\n  attempts: number;\n  maxAttempts: number;\n}\n\n/**\n * Session information\n */\nexport interface SessionInfo {\n  id: string;\n  userId: string;\n  createdAt: Date;\n  lastActivity: Date;\n  expiresAt: Date;\n  \n  // Device information\n  deviceId?: string;\n  deviceName?: string;\n  deviceType?: 'web' | 'mobile' | 'desktop';\n  \n  // Location information\n  ipAddress?: string;\n  location?: {\n    country?: string;\n    city?: string;\n    coordinates?: {\n      latitude: number;\n      longitude: number;\n    };\n  };\n  \n  // Session metadata\n  userAgent?: string;\n  active: boolean;\n}\n\n/**\n * Role hierarchy and utility functions\n */\n\n/**\n * Check if a user has a specific role (including inherited roles)\n */\nexport function hasRole(userRoles: UserRole[], requiredRole: UserRole): boolean {\n  // Direct role match\n  if (userRoles.includes(requiredRole)) {\n    return true;\n  }\n  \n  // Check if any user role grants the required role through hierarchy\n  return userRoles.some(role => {\n    const inheritedRoles = ROLE_HIERARCHY[role] || [];\n    return inheritedRoles.includes(requiredRole);\n  });\n}\n\n/**\n * Check if a user has any of the specified roles (including inherited roles)\n */\nexport function hasAnyRole(userRoles: UserRole[], requiredRoles: UserRole[]): boolean {\n  return requiredRoles.some(role => hasRole(userRoles, role));\n}\n\n/**\n * Get all effective roles for a user (including inherited roles)\n */\nexport function getEffectiveRoles(userRoles: UserRole[]): UserRole[] {\n  const effectiveRoles = new Set(userRoles);\n  \n  // Add all inherited roles\n  userRoles.forEach(role => {\n    const inheritedRoles = ROLE_HIERARCHY[role] || [];\n    inheritedRoles.forEach(inheritedRole => {\n      effectiveRoles.add(inheritedRole);\n    });\n  });\n  \n  return Array.from(effectiveRoles);\n}\n\n/**\n * Get the highest priority role for a user (for display purposes)\n */\nexport function getPrimaryRole(userRoles: UserRole[]): UserRole | null {\n  if (userRoles.length === 0) return null;\n  \n  // Priority order (highest to lowest)\n  const rolePriority = [\n    UserRole.ROLE_SUPPLIER,\n    UserRole.ROLE_ADMIN,\n    UserRole.ROLE_MERCHANT,\n    UserRole.ROLE_ACUBE_MF1,\n    UserRole.ROLE_EXTERNAL_MF1,\n    UserRole.ROLE_CASHIER,\n    UserRole.ROLE_MF1,\n    UserRole.ROLE_PREVIOUS_ADMIN,\n  ];\n  \n  for (const role of rolePriority) {\n    if (userRoles.includes(role)) {\n      return role;\n    }\n  }\n  \n  return userRoles[0] || null; // Fallback to first role\n}\n\n/**\n * Convert user roles to simple role for external APIs\n */\nexport function toSimpleRole(userRoles: UserRole[]): SimpleUserRole {\n  const primaryRole = getPrimaryRole(userRoles);\n  if (!primaryRole) return 'cashier'; // Default fallback\n  \n  return ROLE_TO_SIMPLE[primaryRole] || 'cashier';\n}\n\n/**\n * Auto-detect user role based on context and credentials\n */\nexport function autoDetectRole(context: {\n  merchantId?: MerchantId;\n  cashierId?: CashierId;\n  pointOfSaleId?: PointOfSaleId;\n  preferredRole?: UserRole | SimpleUserRole;\n  userRoles?: UserRole[];\n}): UserRole {\n  // If preferred role is specified and user has permission, use it\n  if (context.preferredRole && context.userRoles) {\n    const targetRole = typeof context.preferredRole === 'string' && context.preferredRole in SIMPLE_TO_ROLE\n      ? SIMPLE_TO_ROLE[context.preferredRole as SimpleUserRole]\n      : context.preferredRole as UserRole;\n      \n    if (hasRole(context.userRoles, targetRole)) {\n      return targetRole;\n    }\n  }\n  \n  // Auto-detect based on context\n  if (context.cashierId && context.pointOfSaleId) {\n    return UserRole.ROLE_CASHIER;\n  }\n  \n  if (context.merchantId && !context.cashierId) {\n    return UserRole.ROLE_MERCHANT;\n  }\n  \n  if (!context.merchantId && !context.cashierId) {\n    return UserRole.ROLE_SUPPLIER;\n  }\n  \n  // Default fallback\n  return UserRole.ROLE_CASHIER;\n}\n\n/**\n * Validate role transition (for role switching during session)\n */\nexport function canSwitchToRole(\n  currentRoles: UserRole[],\n  targetRole: UserRole,\n  context?: {\n    merchantId?: MerchantId;\n    cashierId?: CashierId;\n    pointOfSaleId?: PointOfSaleId;\n  }\n): boolean {\n  // Check if user has permission for target role\n  if (!hasRole(currentRoles, targetRole)) {\n    return false;\n  }\n  \n  // Additional context-based validation\n  if (targetRole === UserRole.ROLE_CASHIER) {\n    return !!(context?.cashierId && context?.pointOfSaleId);\n  }\n  \n  if (targetRole === UserRole.ROLE_MERCHANT) {\n    return !!context?.merchantId;\n  }\n  \n  return true;\n}","/**\n * Authentication Events\n * Event definitions for auth state changes and notifications\n */\n\nimport type { AuthUser, AuthError, OAuth2TokenResponse, TokenStatus } from './types';\n\n/**\n * Authentication event types\n */\nexport enum AuthEventType {\n  // Authentication lifecycle\n  LOGIN_START = 'auth:login:start',\n  LOGIN_SUCCESS = 'auth:login:success',\n  LOGIN_FAILURE = 'auth:login:failure',\n  LOGOUT = 'auth:logout',\n  \n  // Token management\n  TOKEN_REFRESH_START = 'auth:token:refresh:start',\n  TOKEN_REFRESH_SUCCESS = 'auth:token:refresh:success',\n  TOKEN_REFRESH_FAILURE = 'auth:token:refresh:failure',\n  TOKEN_EXPIRED = 'auth:token:expired',\n  TOKEN_REVOKED = 'auth:token:revoked',\n  \n  // Session management\n  SESSION_CREATED = 'auth:session:created',\n  SESSION_RESTORED = 'auth:session:restored',\n  SESSION_EXPIRED = 'auth:session:expired',\n  SESSION_TERMINATED = 'auth:session:terminated',\n  \n  // User state\n  USER_UPDATED = 'auth:user:updated',\n  ROLE_CHANGED = 'auth:role:changed',\n  PERMISSION_CHANGED = 'auth:permission:changed',\n  \n  // Security events\n  SECURITY_WARNING = 'auth:security:warning',\n  UNAUTHORIZED_ACCESS = 'auth:security:unauthorized',\n  MFA_REQUIRED = 'auth:security:mfa:required',\n  MFA_COMPLETED = 'auth:security:mfa:completed',\n  \n  // Storage events\n  STORAGE_ERROR = 'auth:storage:error',\n  STORAGE_CLEARED = 'auth:storage:cleared',\n  \n  // Network events\n  NETWORK_ERROR = 'auth:network:error',\n  API_RATE_LIMITED = 'auth:api:rate_limited',\n}\n\n/**\n * Base authentication event\n */\nexport interface BaseAuthEvent {\n  type: AuthEventType;\n  timestamp: Date;\n  requestId?: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Login start event\n */\nexport interface LoginStartEvent extends BaseAuthEvent {\n  type: AuthEventType.LOGIN_START;\n  data: {\n    username: string;\n    hasPassword: boolean;\n    hasMFA?: boolean;\n    deviceId?: string;\n  };\n}\n\n/**\n * Login success event\n */\nexport interface LoginSuccessEvent extends BaseAuthEvent {\n  type: AuthEventType.LOGIN_SUCCESS;\n  data: {\n    user: AuthUser;\n    tokens: OAuth2TokenResponse;\n    isFirstLogin: boolean;\n    loginMethod: 'password' | 'refresh' | 'sso';\n  };\n}\n\n/**\n * Login failure event\n */\nexport interface LoginFailureEvent extends BaseAuthEvent {\n  type: AuthEventType.LOGIN_FAILURE;\n  data: {\n    error: AuthError;\n    username?: string;\n    attemptNumber: number;\n    remainingAttempts?: number;\n  };\n}\n\n/**\n * Logout event\n */\nexport interface LogoutEvent extends BaseAuthEvent {\n  type: AuthEventType.LOGOUT;\n  data: {\n    userId: string;\n    reason: 'user_initiated' | 'session_expired' | 'security' | 'token_invalid' | 'other';\n    message?: string;\n    clearAllSessions: boolean;\n  };\n}\n\n/**\n * Token refresh start event\n */\nexport interface TokenRefreshStartEvent extends BaseAuthEvent {\n  type: AuthEventType.TOKEN_REFRESH_START;\n  data: {\n    reason: 'expiry_approaching' | 'token_expired' | 'manual' | 'retry';\n    attemptNumber: number;\n    tokenStatus: TokenStatus;\n  };\n}\n\n/**\n * Token refresh success event\n */\nexport interface TokenRefreshSuccessEvent extends BaseAuthEvent {\n  type: AuthEventType.TOKEN_REFRESH_SUCCESS;\n  data: {\n    tokens: OAuth2TokenResponse;\n    oldExpiresAt: number;\n    newExpiresAt: number;\n    attemptNumber: number;\n  };\n}\n\n/**\n * Token refresh failure event\n */\nexport interface TokenRefreshFailureEvent extends BaseAuthEvent {\n  type: AuthEventType.TOKEN_REFRESH_FAILURE;\n  data: {\n    error: AuthError;\n    attemptNumber: number;\n    willRetry: boolean;\n    nextRetryAt?: Date;\n  };\n}\n\n/**\n * Token expired event\n */\nexport interface TokenExpiredEvent extends BaseAuthEvent {\n  type: AuthEventType.TOKEN_EXPIRED;\n  data: {\n    expiredAt: Date;\n    wasRefreshAttempted: boolean;\n    refreshFailed: boolean;\n  };\n}\n\n/**\n * Session created event\n */\nexport interface SessionCreatedEvent extends BaseAuthEvent {\n  type: AuthEventType.SESSION_CREATED;\n  data: {\n    sessionId: string;\n    userId: string;\n    expiresAt: Date;\n    deviceId?: string;\n    location?: string;\n  };\n}\n\n/**\n * Session restored event\n */\nexport interface SessionRestoredEvent extends BaseAuthEvent {\n  type: AuthEventType.SESSION_RESTORED;\n  data: {\n    sessionId: string;\n    user: AuthUser;\n    remainingTime: number; // milliseconds\n    source: 'storage' | 'memory' | 'cookie';\n  };\n}\n\n/**\n * Session expired event\n */\nexport interface SessionExpiredEvent extends BaseAuthEvent {\n  type: AuthEventType.SESSION_EXPIRED;\n  data: {\n    sessionId: string;\n    userId: string;\n    expiredAt: Date;\n    reason: 'timeout' | 'revoked' | 'concurrent_limit';\n  };\n}\n\n/**\n * User updated event\n */\nexport interface UserUpdatedEvent extends BaseAuthEvent {\n  type: AuthEventType.USER_UPDATED;\n  data: {\n    userId: string;\n    changes: Partial<AuthUser>;\n    updatedBy: 'system' | 'user' | 'admin';\n  };\n}\n\n/**\n * Role changed event\n */\nexport interface RoleChangedEvent extends BaseAuthEvent {\n  type: AuthEventType.ROLE_CHANGED;\n  data: {\n    userId: string;\n    oldRoles: string[];\n    newRoles: string[];\n    changedBy: string;\n    reason?: string;\n  };\n}\n\n/**\n * Security warning event\n */\nexport interface SecurityWarningEvent extends BaseAuthEvent {\n  type: AuthEventType.SECURITY_WARNING;\n  data: {\n    severity: 'low' | 'medium' | 'high' | 'critical';\n    code: string;\n    message: string;\n    details?: Record<string, unknown>;\n    action?: 'none' | 'logout' | 'require_mfa' | 'lock_account';\n  };\n}\n\n/**\n * Unauthorized access event\n */\nexport interface UnauthorizedAccessEvent extends BaseAuthEvent {\n  type: AuthEventType.UNAUTHORIZED_ACCESS;\n  data: {\n    userId?: string;\n    resource: string;\n    action: string;\n    reason: string;\n    ipAddress?: string;\n    userAgent?: string;\n  };\n}\n\n/**\n * Storage error event\n */\nexport interface StorageErrorEvent extends BaseAuthEvent {\n  type: AuthEventType.STORAGE_ERROR;\n  data: {\n    operation: 'read' | 'write' | 'delete' | 'clear' | 'initialize';\n    error: Error;\n    key?: string;\n    fallbackUsed: boolean;\n  };\n}\n\n/**\n * Network error event\n */\nexport interface NetworkErrorEvent extends BaseAuthEvent {\n  type: AuthEventType.NETWORK_ERROR;\n  data: {\n    operation: 'login' | 'refresh' | 'logout' | 'validate';\n    error: Error;\n    endpoint: string;\n    statusCode?: number;\n    willRetry: boolean;\n  };\n}\n\n/**\n * All authentication events union type\n */\nexport type AuthEvent =\n  | LoginStartEvent\n  | LoginSuccessEvent\n  | LoginFailureEvent\n  | LogoutEvent\n  | TokenRefreshStartEvent\n  | TokenRefreshSuccessEvent\n  | TokenRefreshFailureEvent\n  | TokenExpiredEvent\n  | SessionCreatedEvent\n  | SessionRestoredEvent\n  | SessionExpiredEvent\n  | UserUpdatedEvent\n  | RoleChangedEvent\n  | SecurityWarningEvent\n  | UnauthorizedAccessEvent\n  | StorageErrorEvent\n  | NetworkErrorEvent;\n\n/**\n * Authentication event handler type\n */\nexport type AuthEventHandler<T extends AuthEvent = AuthEvent> = (event: T) => void | Promise<void>;\n\n/**\n * Authentication event listener map\n */\nexport type AuthEventListeners = {\n  [K in AuthEventType]?: AuthEventHandler<Extract<AuthEvent, { type: K }>>;\n};\n\n/**\n * Helper to create auth events\n */\nexport function createAuthEvent<T extends AuthEvent>(\n  type: T['type'],\n  data: T['data'],\n  metadata?: Record<string, unknown>\n): T {\n  return {\n    type,\n    timestamp: new Date(),\n    requestId: `auth_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`,\n    data,\n    metadata,\n  } as T;\n}","/**\n * Token Manager\n * Handles JWT token parsing, validation, and automatic refresh\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport { HttpClient } from '@/http/client';\nimport type {\n  OAuth2TokenResponse,\n  JWTPayload,\n  TokenRefreshRequest,\n  TokenStatus,\n  AuthError,\n} from './types';\nimport { AuthErrorType } from './types';\nimport {\n  AuthEventType,\n  createAuthEvent,\n  type TokenRefreshStartEvent,\n  type TokenRefreshSuccessEvent,\n  type TokenRefreshFailureEvent,\n  type TokenExpiredEvent,\n} from './auth-events';\n\ninterface TokenManagerConfig {\n  refreshUrl: string;\n  tokenRefreshBuffer: number; // minutes before expiry to refresh\n  maxRefreshAttempts: number;\n  refreshRetryDelay: number; // milliseconds\n  enableTokenRotation: boolean;\n  onTokenRefresh?: (tokens: OAuth2TokenResponse) => void;\n  onTokenExpired?: () => void;\n}\n\nconst DEFAULT_CONFIG: TokenManagerConfig = {\n  refreshUrl: '/token/refresh',\n  tokenRefreshBuffer: 5, // 5 minutes\n  maxRefreshAttempts: 3,\n  refreshRetryDelay: 1000,\n  enableTokenRotation: true,\n};\n\n/**\n * Manages JWT tokens with automatic refresh\n */\nexport class TokenManager extends EventEmitter {\n  private config: TokenManagerConfig;\n  private httpClient: HttpClient;\n  private refreshTimer: NodeJS.Timeout | null = null;\n  private refreshPromise: Promise<OAuth2TokenResponse> | null = null;\n  private refreshAttempts = 0;\n  private currentTokens: {\n    access: string | null;\n    refresh: string | null;\n    expiresAt: number | null;\n  } = {\n    access: null,\n    refresh: null,\n    expiresAt: null,\n  };\n\n  constructor(httpClient: HttpClient, config: Partial<TokenManagerConfig> = {}) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.httpClient = httpClient;\n  }\n\n  /**\n   * Set tokens and start refresh timer\n   */\n  setTokens(tokens: OAuth2TokenResponse): void {\n    // Parse and validate access token\n    const payload = this.parseToken(tokens.access_token);\n    if (!payload) {\n      throw this.createAuthError(\n        'TOKEN_INVALID',\n        'Invalid access token format'\n      );\n    }\n\n    // Calculate expiration\n    const expiresAt = payload.exp * 1000; // Convert to milliseconds\n    \n    // Store tokens\n    this.currentTokens = {\n      access: tokens.access_token,\n      refresh: tokens.refresh_token,\n      expiresAt,\n    };\n\n    // Reset refresh attempts\n    this.refreshAttempts = 0;\n\n    // Start refresh timer\n    this.scheduleRefresh(expiresAt);\n  }\n\n  /**\n   * Get current access token\n   */\n  getAccessToken(): string | null {\n    // Check if token exists and is not expired\n    if (this.currentTokens.access && this.currentTokens.expiresAt) {\n      if (Date.now() < this.currentTokens.expiresAt) {\n        return this.currentTokens.access;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get current refresh token\n   */\n  getRefreshToken(): string | null {\n    return this.currentTokens.refresh;\n  }\n\n  /**\n   * Get token status\n   */\n  getTokenStatus(): TokenStatus {\n    const now = Date.now();\n    const expiresAt = this.currentTokens.expiresAt || 0;\n    const expiresIn = Math.max(0, expiresAt - now);\n    const bufferMs = this.config.tokenRefreshBuffer * 60 * 1000;\n\n    return {\n      isValid: !!this.currentTokens.access && now < expiresAt,\n      expiresIn: Math.floor(expiresIn / 1000), // seconds\n      isRefreshing: this.refreshPromise !== null,\n      needsRefresh: expiresIn < bufferMs && expiresIn > 0,\n      refreshFailures: this.refreshAttempts,\n    };\n  }\n\n  /**\n   * Parse JWT token\n   */\n  parseToken(token: string): JWTPayload | null {\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) {\n        return null;\n      }\n\n      // Decode payload (base64url)\n      const payload = parts[1];\n      if (!payload) {\n        return null;\n      }\n      const decoded = this.base64UrlDecode(payload);\n      return JSON.parse(decoded) as JWTPayload;\n    } catch (error) {\n      console.error('Failed to parse JWT token:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Validate JWT token\n   */\n  validateToken(token: string): { valid: boolean; reason?: string } {\n    const payload = this.parseToken(token);\n    if (!payload) {\n      return { valid: false, reason: 'Invalid token format' };\n    }\n\n    const now = Math.floor(Date.now() / 1000);\n\n    // Check expiration\n    if (payload.exp && payload.exp < now) {\n      return { valid: false, reason: 'Token expired' };\n    }\n\n    // Check not before\n    if (payload.nbf && payload.nbf > now) {\n      return { valid: false, reason: 'Token not yet valid' };\n    }\n\n    // Check required claims\n    if (!payload.sub || !payload.email || !payload.roles) {\n      return { valid: false, reason: 'Missing required claims' };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Refresh tokens\n   */\n  async refreshTokens(): Promise<OAuth2TokenResponse> {\n    // If already refreshing, return existing promise\n    if (this.refreshPromise) {\n      return this.refreshPromise;\n    }\n\n    // Check if we have a refresh token\n    if (!this.currentTokens.refresh) {\n      throw this.createAuthError(\n        'REFRESH_FAILED',\n        'No refresh token available'\n      );\n    }\n\n    // Emit refresh start event\n    this.emitRefreshStart();\n\n    // Create refresh promise\n    this.refreshPromise = this.performRefresh()\n      .then((tokens) => {\n        // Success - update tokens\n        this.setTokens(tokens);\n        this.emitRefreshSuccess(tokens);\n        this.refreshPromise = null;\n        \n        // Call callback if provided\n        if (this.config.onTokenRefresh) {\n          this.config.onTokenRefresh(tokens);\n        }\n        \n        return tokens;\n      })\n      .catch((error) => {\n        // Failure - handle error\n        this.refreshPromise = null;\n        this.emitRefreshFailure(error);\n        \n        // Check if we should retry\n        if (this.refreshAttempts < this.config.maxRefreshAttempts) {\n          // Schedule retry\n          return new Promise<OAuth2TokenResponse>((resolve, reject) => {\n            setTimeout(() => {\n              this.refreshTokens().then(resolve).catch(reject);\n            }, this.config.refreshRetryDelay * Math.pow(2, this.refreshAttempts - 1)) as unknown as NodeJS.Timeout;\n          });\n        }\n        \n        // Max attempts reached - emit expiry and throw\n        this.emitTokenExpired();\n        if (this.config.onTokenExpired) {\n          this.config.onTokenExpired();\n        }\n        \n        throw error;\n      });\n\n    return this.refreshPromise;\n  }\n\n  /**\n   * Perform the actual refresh request\n   */\n  private async performRefresh(): Promise<OAuth2TokenResponse> {\n    this.refreshAttempts++;\n\n    const request: TokenRefreshRequest = {\n      refresh_token: this.currentTokens.refresh!,\n      grant_type: 'refresh_token',\n    };\n\n    try {\n      const response = await this.httpClient.post<OAuth2TokenResponse>(\n        this.config.refreshUrl,\n        request,\n        {\n          skipRetry: false, // Allow retries for refresh\n          metadata: { isTokenRefresh: true },\n        }\n      );\n\n      // Validate response\n      if (!response.data.access_token || !response.data.refresh_token) {\n        throw this.createAuthError(\n          'REFRESH_FAILED',\n          'Invalid refresh response'\n        );\n      }\n\n      // Handle token rotation\n      if (this.config.enableTokenRotation) {\n        // The new refresh token should be different\n        if (response.data.refresh_token === this.currentTokens.refresh) {\n          console.warn('Refresh token was not rotated');\n        }\n      }\n\n      return response.data;\n    } catch (error) {\n      // Handle specific error cases\n      if (error instanceof Error && 'statusCode' in error) {\n        const statusCode = (error as any).statusCode;\n        \n        if (statusCode === 401 || statusCode === 403) {\n          // Refresh token invalid or expired\n          throw this.createAuthError(\n            'TOKEN_INVALID',\n            'Refresh token is invalid or expired',\n            error\n          );\n        }\n      }\n\n      throw this.createAuthError(\n        'REFRESH_FAILED',\n        'Failed to refresh token',\n        error\n      );\n    }\n  }\n\n  /**\n   * Schedule automatic token refresh\n   */\n  private scheduleRefresh(expiresAt: number): void {\n    // Clear existing timer\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n    }\n\n    const now = Date.now();\n    const bufferMs = this.config.tokenRefreshBuffer * 60 * 1000;\n    const refreshAt = expiresAt - bufferMs;\n    const delay = Math.max(0, refreshAt - now);\n\n    // Don't schedule if token is already expired or about to expire\n    if (delay <= 0) {\n      // Refresh immediately\n      this.refreshTokens().catch((error) => {\n        console.error('Immediate token refresh failed:', error);\n      });\n      return;\n    }\n\n    // Schedule refresh\n    this.refreshTimer = setTimeout(() => {\n      this.refreshTokens().catch((error) => {\n        console.error('Scheduled token refresh failed:', error);\n      });\n    }, delay) as unknown as NodeJS.Timeout;\n  }\n\n  /**\n   * Clear tokens and stop refresh timer\n   */\n  clearTokens(): void {\n    // Clear tokens\n    this.currentTokens = {\n      access: null,\n      refresh: null,\n      expiresAt: null,\n    };\n\n    // Clear refresh timer\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.refreshTimer = null;\n    }\n\n    // Clear refresh promise\n    this.refreshPromise = null;\n    this.refreshAttempts = 0;\n  }\n\n  /**\n   * Force token refresh\n   */\n  async forceRefresh(): Promise<OAuth2TokenResponse> {\n    // Clear existing promise to force new refresh\n    this.refreshPromise = null;\n    return this.refreshTokens();\n  }\n\n  /**\n   * Base64URL decode\n   */\n  private base64UrlDecode(str: string): string {\n    // Add padding if needed\n    str += '='.repeat((4 - (str.length % 4)) % 4);\n    \n    // Replace URL-safe characters\n    str = str.replace(/-/g, '+').replace(/_/g, '/');\n    \n    // Decode base64\n    if (typeof window !== 'undefined' && window.atob) {\n      return window.atob(str);\n    } else if (typeof Buffer !== 'undefined') {\n      return Buffer.from(str, 'base64').toString('utf-8');\n    } else {\n      throw new Error('No base64 decoder available');\n    }\n  }\n\n  /**\n   * Create auth error\n   */\n  private createAuthError(\n    type: AuthErrorType,\n    message: string,\n    cause?: unknown\n  ): AuthError {\n    const error: AuthError = {\n      name: 'AuthError',\n      type,\n      message,\n      timestamp: Date.now(),\n      recoverable: type === AuthErrorType.REFRESH_FAILED && this.refreshAttempts < this.config.maxRefreshAttempts,\n    };\n\n    if (cause instanceof Error) {\n      error.details = { cause: cause.message };\n    }\n\n    return error;\n  }\n\n  /**\n   * Event emitters\n   */\n  private emitRefreshStart(): void {\n    const event = createAuthEvent<TokenRefreshStartEvent>(\n      AuthEventType.TOKEN_REFRESH_START,\n      {\n        reason: this.refreshAttempts > 1 ? 'retry' : 'expiry_approaching',\n        attemptNumber: this.refreshAttempts,\n        tokenStatus: this.getTokenStatus(),\n      }\n    );\n    this.emit(AuthEventType.TOKEN_REFRESH_START, event);\n  }\n\n  private emitRefreshSuccess(tokens: OAuth2TokenResponse): void {\n    const event = createAuthEvent<TokenRefreshSuccessEvent>(\n      AuthEventType.TOKEN_REFRESH_SUCCESS,\n      {\n        tokens,\n        oldExpiresAt: this.currentTokens.expiresAt || 0,\n        newExpiresAt: this.parseToken(tokens.access_token)?.exp || 0,\n        attemptNumber: this.refreshAttempts,\n      }\n    );\n    this.emit(AuthEventType.TOKEN_REFRESH_SUCCESS, event);\n  }\n\n  private emitRefreshFailure(error: AuthError): void {\n    const eventData: any = {\n      error,\n      attemptNumber: this.refreshAttempts,\n      willRetry: this.refreshAttempts < this.config.maxRefreshAttempts,\n    };\n\n    if (this.refreshAttempts < this.config.maxRefreshAttempts) {\n      eventData.nextRetryAt = new Date(Date.now() + this.config.refreshRetryDelay * Math.pow(2, this.refreshAttempts - 1));\n    }\n\n    const event = createAuthEvent<TokenRefreshFailureEvent>(\n      AuthEventType.TOKEN_REFRESH_FAILURE,\n      eventData\n    );\n    this.emit(AuthEventType.TOKEN_REFRESH_FAILURE, event);\n  }\n\n  private emitTokenExpired(): void {\n    const event = createAuthEvent<TokenExpiredEvent>(\n      AuthEventType.TOKEN_EXPIRED,\n      {\n        expiredAt: new Date(this.currentTokens.expiresAt || Date.now()),\n        wasRefreshAttempted: this.refreshAttempts > 0,\n        refreshFailed: true,\n      }\n    );\n    this.emit(AuthEventType.TOKEN_EXPIRED, event);\n  }\n\n  /**\n   * Destroy token manager\n   */\n  destroy(): void {\n    this.clearTokens();\n    this.removeAllListeners();\n  }\n}","/**\n * Access Control Manager for A-Cube SDK\n * Provides comprehensive role-based access control (RBAC) and attribute-based access control (ABAC)\n */\n\nexport interface AccessControlConfig {\n  enabled: boolean;\n  model: 'RBAC' | 'ABAC' | 'HYBRID';\n  session: {\n    timeout: number; // milliseconds\n    maxConcurrentSessions: number;\n    requireReauth: boolean;\n  };\n  audit: {\n    logAllAccess: boolean;\n    logFailedAttempts: boolean;\n    retentionPeriod: number;\n  };\n  enforcement: {\n    strictMode: boolean;\n    allowEscalation: boolean;\n    requireApproval: string[]; // Actions requiring approval\n  };\n}\n\nexport interface Role {\n  id: string;\n  name: string;\n  description: string;\n  permissions: Permission[];\n  inherits?: string[]; // Role IDs to inherit from\n  conditions?: AccessCondition[];\n  metadata: {\n    createdAt: number;\n    updatedAt: number;\n    createdBy: string;\n    isSystem: boolean;\n  };\n}\n\nexport interface Permission {\n  id: string;\n  resource: string;\n  action: string;\n  effect: 'allow' | 'deny';\n  conditions?: AccessCondition[];\n  scope?: {\n    global?: boolean;\n    organizations?: string[];\n    locations?: string[];\n    resources?: string[];\n  };\n}\n\nexport interface AccessCondition {\n  type: 'time' | 'location' | 'device' | 'attribute' | 'context';\n  operator: 'equals' | 'not_equals' | 'contains' | 'not_contains' | 'greater_than' | 'less_than' | 'in' | 'not_in';\n  attribute: string;\n  value: any;\n  metadata?: Record<string, any>;\n}\n\nexport interface User {\n  id: string;\n  email: string;\n  name: string;\n  roles: string[]; // Role IDs\n  attributes: Record<string, any>;\n  status: 'active' | 'inactive' | 'suspended' | 'locked';\n  lastLogin?: number;\n  failedAttempts: number;\n  lockoutUntil?: number;\n  sessions: UserSession[];\n  metadata: {\n    createdAt: number;\n    updatedAt: number;\n    createdBy: string;\n    department?: string;\n    location?: string;\n  };\n}\n\nexport interface UserSession {\n  id: string;\n  userId: string;\n  startedAt: number;\n  lastActivity: number;\n  expiresAt: number;\n  ipAddress?: string;\n  userAgent?: string;\n  deviceId?: string;\n  location?: string;\n  status: 'active' | 'expired' | 'terminated';\n  permissions: Permission[]; // Cached permissions for this session\n}\n\nexport interface AccessRequest {\n  id: string;\n  userId: string;\n  sessionId: string;\n  resource: string;\n  action: string;\n  context: AccessContext;\n  timestamp: number;\n  result: 'granted' | 'denied' | 'pending';\n  reason?: string;\n  approvalRequired?: boolean;\n  approvedBy?: string;\n  approvedAt?: number;\n}\n\nexport interface AccessContext {\n  ipAddress?: string;\n  userAgent?: string;\n  deviceId?: string;\n  location?: string;\n  timestamp: number;\n  requestId?: string;\n  attributes?: Record<string, any>;\n}\n\nexport interface AccessAuditEntry {\n  id: string;\n  userId: string;\n  sessionId?: string;\n  action: 'login' | 'logout' | 'access_granted' | 'access_denied' | 'permission_changed' | 'role_assigned' | 'role_revoked';\n  resource?: string;\n  timestamp: number;\n  context: AccessContext;\n  details: Record<string, any>;\n  riskLevel: 'low' | 'medium' | 'high' | 'critical';\n}\n\nexport class AccessControlManager {\n  private config: AccessControlConfig;\n  private users = new Map<string, User>();\n  private roles = new Map<string, Role>();\n  private sessions = new Map<string, UserSession>();\n  private accessRequests = new Map<string, AccessRequest>();\n  private auditLog: AccessAuditEntry[] = [];\n  private permissionCache = new Map<string, { permissions: Permission[]; expiresAt: number }>();\n\n  constructor(config?: Partial<AccessControlConfig>) {\n    this.config = {\n      enabled: true,\n      model: 'HYBRID',\n      session: {\n        timeout: 8 * 60 * 60 * 1000, // 8 hours\n        maxConcurrentSessions: 3,\n        requireReauth: false,\n      },\n      audit: {\n        logAllAccess: true,\n        logFailedAttempts: true,\n        retentionPeriod: 365 * 24 * 60 * 60 * 1000, // 1 year\n      },\n      enforcement: {\n        strictMode: true,\n        allowEscalation: false,\n        requireApproval: ['delete_user', 'modify_permissions', 'export_data'],\n      },\n      ...config,\n    };\n\n    if (this.config.enabled) {\n      this.initializeDefaultRoles();\n      this.startSessionCleanup();\n    }\n  }\n\n  /**\n   * Create a new user\n   */\n  async createUser(\n    userData: Omit<User, 'id' | 'sessions' | 'failedAttempts' | 'metadata'>,\n    createdBy: string\n  ): Promise<string> {\n    if (!this.config.enabled) {\n      throw new Error('Access control is disabled');\n    }\n\n    const userId = this.generateUserId();\n    const now = Date.now();\n\n    const user: User = {\n      id: userId,\n      sessions: [],\n      failedAttempts: 0,\n      metadata: {\n        createdAt: now,\n        updatedAt: now,\n        createdBy,\n      },\n      ...userData,\n    };\n\n    this.users.set(userId, user);\n\n    this.auditAccess({\n      userId: createdBy,\n      action: 'permission_changed',\n      details: {\n        targetUserId: userId,\n        operation: 'create_user',\n        roles: userData.roles,\n      },\n      context: { timestamp: now },\n      timestamp: now,\n      riskLevel: 'medium',\n    });\n\n    return userId;\n  }\n\n  /**\n   * Assign role to user\n   */\n  async assignRole(userId: string, roleId: string, assignedBy: string): Promise<void> {\n    const user = this.users.get(userId);\n    if (!user) {\n      throw new Error(`User not found: ${userId}`);\n    }\n\n    const role = this.roles.get(roleId);\n    if (!role) {\n      throw new Error(`Role not found: ${roleId}`);\n    }\n\n    if (!user.roles.includes(roleId)) {\n      user.roles.push(roleId);\n      user.metadata.updatedAt = Date.now();\n\n      // Clear permission cache for this user\n      this.clearUserPermissionCache(userId);\n\n      this.auditAccess({\n        userId: assignedBy,\n        action: 'role_assigned',\n        details: {\n          targetUserId: userId,\n          roleId,\n          roleName: role.name,\n        },\n        context: { timestamp: Date.now() },\n        timestamp: Date.now(),\n        riskLevel: 'medium',\n      });\n    }\n  }\n\n  /**\n   * Revoke role from user\n   */\n  async revokeRole(userId: string, roleId: string, revokedBy: string): Promise<void> {\n    const user = this.users.get(userId);\n    if (!user) {\n      throw new Error(`User not found: ${userId}`);\n    }\n\n    const roleIndex = user.roles.indexOf(roleId);\n    if (roleIndex > -1) {\n      user.roles.splice(roleIndex, 1);\n      user.metadata.updatedAt = Date.now();\n\n      // Clear permission cache for this user\n      this.clearUserPermissionCache(userId);\n\n      const role = this.roles.get(roleId);\n      this.auditAccess({\n        userId: revokedBy,\n        action: 'role_revoked',\n        details: {\n          targetUserId: userId,\n          roleId,\n          roleName: role?.name || 'Unknown',\n        },\n        context: { timestamp: Date.now() },\n        timestamp: Date.now(),\n        riskLevel: 'medium',\n      });\n    }\n  }\n\n  /**\n   * Create a new role\n   */\n  async createRole(\n    roleData: Omit<Role, 'id' | 'metadata'>,\n    createdBy: string\n  ): Promise<string> {\n    const roleId = this.generateRoleId();\n    const now = Date.now();\n\n    const role: Role = {\n      id: roleId,\n      metadata: {\n        createdAt: now,\n        updatedAt: now,\n        createdBy,\n        isSystem: false,\n      },\n      ...roleData,\n    };\n\n    this.roles.set(roleId, role);\n\n    this.auditAccess({\n      userId: createdBy,\n      action: 'permission_changed',\n      details: {\n        operation: 'create_role',\n        roleId,\n        roleName: role.name,\n        permissions: role.permissions.length,\n      },\n      context: { timestamp: now },\n      timestamp: now,\n      riskLevel: 'high',\n    });\n\n    return roleId;\n  }\n\n  /**\n   * Authenticate user and create session\n   */\n  async authenticate(\n    userId: string,\n    context: AccessContext\n  ): Promise<{ sessionId: string; permissions: Permission[] }> {\n    const user = this.users.get(userId);\n    if (!user) {\n      this.auditAccess({\n        userId,\n        action: 'access_denied',\n        details: { reason: 'user_not_found' },\n        context,\n        timestamp: Date.now(),\n        riskLevel: 'high',\n      });\n      throw new Error('Authentication failed');\n    }\n\n    if (user.status !== 'active') {\n      this.auditAccess({\n        userId,\n        action: 'access_denied',\n        details: { reason: 'user_inactive', status: user.status },\n        context,\n        timestamp: Date.now(),\n        riskLevel: 'high',\n      });\n      throw new Error(`User account is ${user.status}`);\n    }\n\n    // Check for account lockout\n    if (user.lockoutUntil && Date.now() < user.lockoutUntil) {\n      this.auditAccess({\n        userId,\n        action: 'access_denied',\n        details: { reason: 'account_locked', lockoutUntil: user.lockoutUntil },\n        context,\n        timestamp: Date.now(),\n        riskLevel: 'high',\n      });\n      throw new Error('Account is locked');\n    }\n\n    // Check concurrent session limit\n    const activeSessions = user.sessions.filter(s => s.status === 'active');\n    if (activeSessions.length >= this.config.session.maxConcurrentSessions) {\n      // Terminate oldest session\n      const oldestSession = activeSessions.sort((a, b) => a.startedAt - b.startedAt)[0];\n      if (oldestSession) {\n        await this.terminateSession(oldestSession.id);\n      }\n    }\n\n    // Create new session\n    const sessionId = this.generateSessionId();\n    const now = Date.now();\n    const permissions = await this.getUserPermissions(userId);\n\n    const session: UserSession = {\n      id: sessionId,\n      userId,\n      startedAt: now,\n      lastActivity: now,\n      expiresAt: now + this.config.session.timeout,\n      ...(context.ipAddress && { ipAddress: context.ipAddress }),\n      ...(context.userAgent && { userAgent: context.userAgent }),\n      ...(context.deviceId && { deviceId: context.deviceId }),\n      ...(context.location && { location: context.location }),\n      status: 'active',\n      permissions,\n    };\n\n    user.sessions.push(session);\n    user.lastLogin = now;\n    user.failedAttempts = 0; // Reset failed attempts on successful login\n    this.sessions.set(sessionId, session);\n\n    this.auditAccess({\n      userId,\n      sessionId,\n      action: 'login',\n      details: {\n        sessionId,\n        permissions: permissions.length,\n        concurrentSessions: user.sessions.filter(s => s.status === 'active').length,\n      },\n      context,\n      timestamp: now,\n      riskLevel: 'low',\n    });\n\n    return { sessionId, permissions };\n  }\n\n  /**\n   * Check if user has permission to perform action on resource\n   */\n  async checkAccess(\n    sessionId: string,\n    resource: string,\n    action: string,\n    context: AccessContext\n  ): Promise<{ granted: boolean; reason?: string; requiresApproval?: boolean }> {\n    if (!this.config.enabled) {\n      return { granted: true };\n    }\n\n    const session = this.sessions.get(sessionId);\n    if (!session || session.status !== 'active') {\n      this.auditAccess({\n        userId: 'unknown',\n        sessionId,\n        action: 'access_denied',\n        resource,\n        details: { \n          reason: 'invalid_session',\n          requestedAction: action,\n        },\n        context,\n        timestamp: Date.now(),\n        riskLevel: 'high',\n      });\n      return { granted: false, reason: 'Invalid or expired session' };\n    }\n\n    // Check session expiry\n    if (Date.now() > session.expiresAt) {\n      session.status = 'expired';\n      this.auditAccess({\n        userId: session.userId,\n        sessionId,\n        action: 'access_denied',\n        resource,\n        details: { \n          reason: 'session_expired',\n          requestedAction: action,\n        },\n        context,\n        timestamp: Date.now(),\n        riskLevel: 'medium',\n      });\n      return { granted: false, reason: 'Session expired' };\n    }\n\n    // Update last activity\n    session.lastActivity = Date.now();\n\n    const user = this.users.get(session.userId);\n    if (!user) {\n      return { granted: false, reason: 'User not found' };\n    }\n\n    // Check if action requires approval\n    const requiresApproval = this.config.enforcement.requireApproval.includes(action);\n\n    // Evaluate permissions\n    const result = await this.evaluatePermissions(\n      session.permissions,\n      resource,\n      action,\n      user,\n      context\n    );\n\n    // Create access request record\n    const requestId = this.generateRequestId();\n    const accessRequest: AccessRequest = {\n      id: requestId,\n      userId: session.userId,\n      sessionId,\n      resource,\n      action,\n      context,\n      timestamp: Date.now(),\n      result: result.granted ? 'granted' : 'denied',\n      ...(result.reason && { reason: result.reason }),\n      approvalRequired: requiresApproval && result.granted,\n    };\n\n    this.accessRequests.set(requestId, accessRequest);\n\n    // Audit the access attempt\n    this.auditAccess({\n      userId: session.userId,\n      sessionId,\n      action: result.granted ? 'access_granted' : 'access_denied',\n      resource,\n      details: {\n        requestedAction: action,\n        reason: result.reason,\n        requiresApproval,\n        requestId,\n      },\n      context,\n      timestamp: Date.now(),\n      riskLevel: result.granted ? 'low' : 'medium',\n    });\n\n    return {\n      granted: result.granted,\n      ...(result.reason && { reason: result.reason }),\n      ...(requiresApproval && result.granted && { requiresApproval: true }),\n    };\n  }\n\n  /**\n   * Approve pending access request\n   */\n  async approveAccess(\n    requestId: string,\n    approvedBy: string,\n    context: AccessContext\n  ): Promise<void> {\n    const request = this.accessRequests.get(requestId);\n    if (!request) {\n      throw new Error(`Access request not found: ${requestId}`);\n    }\n\n    if (!request.approvalRequired) {\n      throw new Error('Access request does not require approval');\n    }\n\n    request.result = 'granted';\n    request.approvedBy = approvedBy;\n    request.approvedAt = Date.now();\n\n    this.auditAccess({\n      userId: approvedBy,\n      action: 'access_granted',\n      resource: request.resource,\n      details: {\n        requestId,\n        targetUserId: request.userId,\n        approvedAction: request.action,\n      },\n      context,\n      timestamp: Date.now(),\n      riskLevel: 'medium',\n    });\n  }\n\n  /**\n   * Terminate user session\n   */\n  async terminateSession(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session) return;\n\n    session.status = 'terminated';\n    this.sessions.delete(sessionId);\n\n    // Update user's session list\n    const user = this.users.get(session.userId);\n    if (user) {\n      const sessionIndex = user.sessions.findIndex(s => s.id === sessionId);\n      if (sessionIndex > -1) {\n        const userSession = user.sessions[sessionIndex];\n        if (userSession) {\n          userSession.status = 'terminated';\n        }\n      }\n    }\n\n    this.auditAccess({\n      userId: session.userId,\n      sessionId,\n      action: 'logout',\n      details: {\n        sessionId,\n        duration: Date.now() - session.startedAt,\n      },\n      context: { timestamp: Date.now() },\n      timestamp: Date.now(),\n      riskLevel: 'low',\n    });\n  }\n\n  /**\n   * Get user permissions (with caching)\n   */\n  async getUserPermissions(userId: string): Promise<Permission[]> {\n    const cacheKey = `user_${userId}`;\n    const cached = this.permissionCache.get(cacheKey);\n    \n    if (cached && Date.now() < cached.expiresAt) {\n      return cached.permissions;\n    }\n\n    const user = this.users.get(userId);\n    if (!user) return [];\n\n    const permissions: Permission[] = [];\n    const processedRoles = new Set<string>();\n\n    // Recursively process roles and their inheritance\n    const processRole = (roleId: string) => {\n      if (processedRoles.has(roleId)) return;\n      processedRoles.add(roleId);\n\n      const role = this.roles.get(roleId);\n      if (!role) return;\n\n      // Add role permissions\n      permissions.push(...role.permissions);\n\n      // Process inherited roles\n      if (role.inherits) {\n        for (const inheritedRoleId of role.inherits) {\n          processRole(inheritedRoleId);\n        }\n      }\n    };\n\n    // Process all user roles\n    for (const roleId of user.roles) {\n      processRole(roleId);\n    }\n\n    // Remove duplicates and sort by priority (deny effects first)\n    const uniquePermissions = Array.from(\n      new Map(permissions.map(p => [`${p.resource}:${p.action}`, p])).values()\n    ).sort((a, b) => {\n      if (a.effect === 'deny' && b.effect === 'allow') return -1;\n      if (a.effect === 'allow' && b.effect === 'deny') return 1;\n      return 0;\n    });\n\n    // Cache the result\n    this.permissionCache.set(cacheKey, {\n      permissions: uniquePermissions,\n      expiresAt: Date.now() + (15 * 60 * 1000), // 15 minutes\n    });\n\n    return uniquePermissions;\n  }\n\n  /**\n   * Get access audit log\n   */\n  getAuditLog(filter?: {\n    userId?: string;\n    action?: string;\n    resource?: string;\n    timeRange?: { start: number; end: number };\n    riskLevel?: AccessAuditEntry['riskLevel'];\n  }): AccessAuditEntry[] {\n    let filteredLog = [...this.auditLog];\n\n    if (filter) {\n      if (filter.userId) {\n        filteredLog = filteredLog.filter(entry => entry.userId === filter.userId);\n      }\n      \n      if (filter.action) {\n        filteredLog = filteredLog.filter(entry => entry.action === filter.action);\n      }\n      \n      if (filter.resource) {\n        filteredLog = filteredLog.filter(entry => entry.resource === filter.resource);\n      }\n      \n      if (filter.timeRange) {\n        filteredLog = filteredLog.filter(entry => \n          entry.timestamp >= filter.timeRange!.start && \n          entry.timestamp <= filter.timeRange!.end\n        );\n      }\n      \n      if (filter.riskLevel) {\n        filteredLog = filteredLog.filter(entry => entry.riskLevel === filter.riskLevel);\n      }\n    }\n\n    return filteredLog.sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  /**\n   * Get access control statistics\n   */\n  getAccessControlStats(): {\n    users: {\n      total: number;\n      active: number;\n      suspended: number;\n      locked: number;\n    };\n    sessions: {\n      active: number;\n      total: number;\n      averageDuration: number;\n    };\n    permissions: {\n      totalRoles: number;\n      totalPermissions: number;\n      averagePermissionsPerUser: number;\n    };\n    audit: {\n      totalEntries: number;\n      failedAttempts: number;\n      highRiskEvents: number;\n    };\n  } {\n    const users = Array.from(this.users.values());\n    const sessions = Array.from(this.sessions.values());\n    const roles = Array.from(this.roles.values());\n\n    const activeUsers = users.filter(u => u.status === 'active').length;\n    const suspendedUsers = users.filter(u => u.status === 'suspended').length;\n    const lockedUsers = users.filter(u => u.lockoutUntil && Date.now() < u.lockoutUntil).length;\n\n    const activeSessions = sessions.filter(s => s.status === 'active').length;\n    const averageSessionDuration = sessions.length > 0\n      ? sessions.reduce((sum, s) => sum + (Date.now() - s.startedAt), 0) / sessions.length\n      : 0;\n\n    const totalPermissions = roles.reduce((sum, r) => sum + r.permissions.length, 0);\n    const averagePermissionsPerUser = users.length > 0\n      ? users.reduce((sum, u) => sum + u.roles.length, 0) / users.length\n      : 0;\n\n    const failedAttempts = this.auditLog.filter(e => e.action === 'access_denied').length;\n    const highRiskEvents = this.auditLog.filter(e => e.riskLevel === 'high' || e.riskLevel === 'critical').length;\n\n    return {\n      users: {\n        total: users.length,\n        active: activeUsers,\n        suspended: suspendedUsers,\n        locked: lockedUsers,\n      },\n      sessions: {\n        active: activeSessions,\n        total: sessions.length,\n        averageDuration: averageSessionDuration,\n      },\n      permissions: {\n        totalRoles: roles.length,\n        totalPermissions,\n        averagePermissionsPerUser,\n      },\n      audit: {\n        totalEntries: this.auditLog.length,\n        failedAttempts,\n        highRiskEvents,\n      },\n    };\n  }\n\n  private async evaluatePermissions(\n    permissions: Permission[],\n    resource: string,\n    action: string,\n    user: User,\n    context: AccessContext\n  ): Promise<{ granted: boolean; reason?: string }> {\n    // Find applicable permissions\n    const applicablePermissions = permissions.filter(p => \n      this.matchesResource(p.resource, resource) && \n      this.matchesAction(p.action, action)\n    );\n\n    if (applicablePermissions.length === 0) {\n      return { granted: false, reason: 'No applicable permissions found' };\n    }\n\n    // Evaluate conditions for each permission\n    for (const permission of applicablePermissions) {\n      const conditionsMet = await this.evaluateConditions(\n        permission.conditions || [],\n        user,\n        context\n      );\n\n      if (conditionsMet) {\n        if (permission.effect === 'deny') {\n          return { granted: false, reason: 'Explicitly denied by permission rule' };\n        } else if (permission.effect === 'allow') {\n          // Check scope if defined\n          if (permission.scope && !this.checkScope(permission.scope, user, context)) {\n            continue; // Skip this permission, check next\n          }\n          return { granted: true };\n        }\n      }\n    }\n\n    return { granted: false, reason: 'No matching allow permissions with satisfied conditions' };\n  }\n\n  private async evaluateConditions(\n    conditions: AccessCondition[],\n    user: User,\n    context: AccessContext\n  ): Promise<boolean> {\n    for (const condition of conditions) {\n      if (!await this.evaluateCondition(condition, user, context)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private async evaluateCondition(\n    condition: AccessCondition,\n    user: User,\n    context: AccessContext\n  ): Promise<boolean> {\n    let actualValue: any;\n\n    // Get the actual value based on condition type\n    switch (condition.type) {\n      case 'time':\n        actualValue = new Date(context.timestamp).getHours();\n        break;\n      case 'location':\n        actualValue = context.location || user.metadata.location;\n        break;\n      case 'device':\n        actualValue = context.deviceId;\n        break;\n      case 'attribute':\n        actualValue = user.attributes[condition.attribute];\n        break;\n      case 'context':\n        actualValue = context.attributes?.[condition.attribute];\n        break;\n      default:\n        return false;\n    }\n\n    // Evaluate based on operator\n    switch (condition.operator) {\n      case 'equals':\n        return actualValue === condition.value;\n      case 'not_equals':\n        return actualValue !== condition.value;\n      case 'contains':\n        return String(actualValue).includes(String(condition.value));\n      case 'not_contains':\n        return !String(actualValue).includes(String(condition.value));\n      case 'greater_than':\n        return actualValue > condition.value;\n      case 'less_than':\n        return actualValue < condition.value;\n      case 'in':\n        return Array.isArray(condition.value) && condition.value.includes(actualValue);\n      case 'not_in':\n        return Array.isArray(condition.value) && !condition.value.includes(actualValue);\n      default:\n        return false;\n    }\n  }\n\n  private checkScope(\n    scope: Permission['scope'],\n    user: User,\n    context: AccessContext\n  ): boolean {\n    if (!scope) return true;\n\n    if (scope.global) return true;\n\n    if (scope.organizations && user.metadata.department) {\n      return scope.organizations.includes(user.metadata.department);\n    }\n\n    if (scope.locations && (context.location || user.metadata.location)) {\n      const userLocation = context.location || user.metadata.location;\n      return scope.locations.includes(userLocation!);\n    }\n\n    return true;\n  }\n\n  private matchesResource(permissionResource: string, requestedResource: string): boolean {\n    // Support wildcards\n    if (permissionResource === '*') return true;\n    if (permissionResource.endsWith('*')) {\n      const prefix = permissionResource.slice(0, -1);\n      return requestedResource.startsWith(prefix);\n    }\n    return permissionResource === requestedResource;\n  }\n\n  private matchesAction(permissionAction: string, requestedAction: string): boolean {\n    // Support wildcards\n    if (permissionAction === '*') return true;\n    if (permissionAction.endsWith('*')) {\n      const prefix = permissionAction.slice(0, -1);\n      return requestedAction.startsWith(prefix);\n    }\n    return permissionAction === requestedAction;\n  }\n\n  private initializeDefaultRoles(): void {\n    // System Administrator\n    this.roles.set('admin', {\n      id: 'admin',\n      name: 'Administrator',\n      description: 'Full system access',\n      permissions: [\n        {\n          id: 'admin_all',\n          resource: '*',\n          action: '*',\n          effect: 'allow',\n        },\n      ],\n      metadata: {\n        createdAt: Date.now(),\n        updatedAt: Date.now(),\n        createdBy: 'system',\n        isSystem: true,\n      },\n    });\n\n    // Merchant Role\n    this.roles.set('merchant', {\n      id: 'merchant',\n      name: 'Merchant',\n      description: 'Merchant operations access',\n      permissions: [\n        {\n          id: 'merchant_receipts',\n          resource: 'receipts',\n          action: '*',\n          effect: 'allow',\n        },\n        {\n          id: 'merchant_reports',\n          resource: 'reports',\n          action: 'read',\n          effect: 'allow',\n        },\n      ],\n      metadata: {\n        createdAt: Date.now(),\n        updatedAt: Date.now(),\n        createdBy: 'system',\n        isSystem: true,\n      },\n    });\n\n    // Cashier Role\n    this.roles.set('cashier', {\n      id: 'cashier',\n      name: 'Cashier',\n      description: 'Point of sale operations',\n      permissions: [\n        {\n          id: 'cashier_receipts',\n          resource: 'receipts',\n          action: 'create',\n          effect: 'allow',\n        },\n        {\n          id: 'cashier_receipts_read',\n          resource: 'receipts',\n          action: 'read',\n          effect: 'allow',\n          scope: {\n            global: false,\n          },\n        },\n      ],\n      metadata: {\n        createdAt: Date.now(),\n        updatedAt: Date.now(),\n        createdBy: 'system',\n        isSystem: true,\n      },\n    });\n  }\n\n  private clearUserPermissionCache(userId: string): void {\n    const cacheKey = `user_${userId}`;\n    this.permissionCache.delete(cacheKey);\n  }\n\n  private auditAccess(entry: Omit<AccessAuditEntry, 'id'>): void {\n    const auditEntry: AccessAuditEntry = {\n      id: this.generateAuditId(),\n      ...entry,\n    };\n\n    this.auditLog.push(auditEntry);\n\n    // Keep only recent entries\n    const maxEntries = 10000;\n    if (this.auditLog.length > maxEntries) {\n      this.auditLog = this.auditLog.slice(-maxEntries);\n    }\n  }\n\n  private startSessionCleanup(): void {\n    setInterval(() => {\n      const now = Date.now();\n      \n      // Clean up expired sessions\n      for (const [sessionId, session] of this.sessions.entries()) {\n        if (session.expiresAt <= now) {\n          session.status = 'expired';\n          this.sessions.delete(sessionId);\n        }\n      }\n\n      // Clean up old audit entries\n      const retentionCutoff = now - this.config.audit.retentionPeriod;\n      this.auditLog = this.auditLog.filter(entry => entry.timestamp > retentionCutoff);\n      \n    }, 60 * 60 * 1000); // Every hour\n  }\n\n  private generateUserId(): string {\n    return `user_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private generateRoleId(): string {\n    return `role_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private generateSessionId(): string {\n    return `session_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private generateRequestId(): string {\n    return `request_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private generateAuditId(): string {\n    return `audit_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n}","/**\n * Authentication Storage\n * Secure cross-platform storage for authentication tokens\n */\n\nimport { createStorageKey } from '@/storage/unified-storage';\nimport type { UnifiedStorage } from '@/storage/unified-storage';\nimport { createStorage } from '@/storage/storage-factory';\nimport { AdvancedEncryption } from '@/security/encryption';\nimport type { StoredAuthData, AuthError, AuthErrorType } from './types';\nimport { AuthEventType, createAuthEvent, type StorageErrorEvent } from './auth-events';\nimport { EventEmitter } from 'eventemitter3';\n\nexport interface AuthStorageConfig {\n  storageKey: string;\n  enableEncryption: boolean;\n  encryptionKey?: string;\n  storageAdapter?: 'indexeddb' | 'localstorage' | 'asyncstorage' | 'filesystem' | 'memory';\n  autoMigrate: boolean;\n}\n\nconst DEFAULT_CONFIG: AuthStorageConfig = {\n  storageKey: 'acube_auth',\n  enableEncryption: true,\n  autoMigrate: true,\n};\n\n/**\n * Secure authentication storage with cross-platform support\n */\nexport class AuthStorage extends EventEmitter {\n  private config: AuthStorageConfig;\n  private storage: UnifiedStorage;\n  private encryption: AdvancedEncryption | null = null;\n  private encryptionKeyId: string | null = null;\n  private memoryCache: StoredAuthData | null = null;\n  private isInitialized = false;\n\n  constructor(config: Partial<AuthStorageConfig> = {}) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    \n    // Storage will be initialized in initialize() method\n    this.storage = null as any; // Temporary assignment\n\n    // Initialize encryption if enabled\n    if (this.config.enableEncryption) {\n      this.encryption = new AdvancedEncryption({\n        algorithm: 'AES-GCM',\n        keyLength: 256,\n        keyDerivation: {\n          algorithm: 'PBKDF2',\n          iterations: 100000,\n          salt: new Uint8Array(16), // Will be generated per operation\n        },\n      });\n    }\n  }\n\n  /**\n   * Initialize storage and encryption\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      // Initialize storage with appropriate adapter\n      this.storage = await createStorage({\n        // @ts-ignore\n        preferredAdapter: this.config.storageAdapter  || 'auto',\n        encryption: this.config.enableEncryption ? {\n          enabled: true,\n          ...(this.config.encryptionKey && { key: this.config.encryptionKey }),\n        } : undefined,\n        keyPrefix: 'auth',\n      });\n\n      // Generate or restore encryption key\n      if (this.encryption) {\n        await this.initializeEncryption();\n      }\n\n      // Auto-migrate from old storage if needed\n      if (this.config.autoMigrate) {\n        await this.migrateFromLegacyStorage();\n      }\n\n      this.isInitialized = true;\n    } catch (error) {\n      this.emitStorageError('initialize', error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Store authentication data securely\n   */\n  async store(data: StoredAuthData): Promise<void> {\n    await this.ensureInitialized();\n\n    try {\n      // Update memory cache immediately\n      this.memoryCache = data;\n\n      // Prepare data for storage\n      let storageData: any = data;\n\n      // Encrypt if enabled\n      if (this.encryption && this.encryptionKeyId) {\n        const serialized = JSON.stringify(data);\n        const encrypted = await this.encryption.encryptSymmetric(\n          serialized,\n          this.encryptionKeyId\n        );\n\n        storageData = {\n          encrypted: true,\n          data: AdvancedEncryption.encryptedDataToJSON(encrypted),\n          version: '1.0',\n          timestamp: Date.now(),\n        };\n      }\n\n      // Store in unified storage\n      const storageKey = createStorageKey(this.config.storageKey);\n      await this.storage.set(storageKey, storageData, {\n        ttl: data.expiresAt - Date.now(),\n        encrypt: this.config.enableEncryption,\n      });\n\n      // Also store in platform-specific secure storage if available\n      await this.storePlatformSpecific(data);\n    } catch (error) {\n      this.emitStorageError('write', error as Error);\n      throw this.createAuthError(\n        'STORAGE_ERROR' as AuthErrorType,\n        'Failed to store authentication data',\n        error\n      );\n    }\n  }\n\n  /**\n   * Retrieve authentication data\n   */\n  async retrieve(): Promise<StoredAuthData | null> {\n    await this.ensureInitialized();\n\n    try {\n      // Check memory cache first\n      if (this.memoryCache) {\n        // Validate expiration\n        if (this.memoryCache.expiresAt > Date.now()) {\n          return this.memoryCache;\n        } else {\n          // Clear expired cache\n          this.memoryCache = null;\n        }\n      }\n\n      // Retrieve from storage\n      const storageKey = createStorageKey(this.config.storageKey);\n      const storageEntry = await this.storage.get<any>(storageKey);\n      if (!storageEntry) {\n        // Try platform-specific storage as fallback\n        return await this.retrievePlatformSpecific();\n      }\n\n      const storageData = storageEntry.data;\n\n      // Handle encrypted data\n      if (storageData.encrypted && this.encryption && this.encryptionKeyId) {\n        const encrypted = AdvancedEncryption.encryptedDataFromJSON(storageData.data);\n        const decrypted = await this.encryption.decryptSymmetric(encrypted);\n        const data = JSON.parse(new TextDecoder().decode(decrypted)) as StoredAuthData;\n        \n        // Update memory cache\n        this.memoryCache = data;\n        return data;\n      }\n\n      // Handle unencrypted data (backward compatibility)\n      if (!storageData.encrypted) {\n        this.memoryCache = storageData as StoredAuthData;\n        return storageData as StoredAuthData;\n      }\n\n      return null;\n    } catch (error) {\n      this.emitStorageError('read', error as Error);\n      // Don't throw - return null to indicate no valid auth data\n      return null;\n    }\n  }\n\n  /**\n   * Clear authentication data\n   */\n  async clear(): Promise<void> {\n    await this.ensureInitialized();\n\n    try {\n      // Clear memory cache\n      this.memoryCache = null;\n\n      // Clear from unified storage\n      const storageKey = createStorageKey(this.config.storageKey);\n      await this.storage.delete(storageKey);\n\n      // Clear from platform-specific storage\n      await this.clearPlatformSpecific();\n\n      // Emit storage cleared event\n      this.emit(AuthEventType.STORAGE_CLEARED, createAuthEvent(\n        AuthEventType.STORAGE_CLEARED,\n        { timestamp: Date.now() }\n      ));\n    } catch (error) {\n      this.emitStorageError('delete', error as Error);\n      throw this.createAuthError(\n        'STORAGE_ERROR' as AuthErrorType,\n        'Failed to clear authentication data',\n        error\n      );\n    }\n  }\n\n  /**\n   * Update specific fields in stored auth data\n   */\n  async update(updates: Partial<StoredAuthData>): Promise<void> {\n    const current = await this.retrieve();\n    if (!current) {\n      throw this.createAuthError(\n        'STORAGE_ERROR' as AuthErrorType,\n        'No authentication data to update'\n      );\n    }\n\n    const updated: StoredAuthData = {\n      ...current,\n      ...updates,\n      user: updates.user ? { ...current.user, ...updates.user } : current.user,\n    };\n\n    await this.store(updated);\n  }\n\n  /**\n   * Check if auth data exists and is valid\n   */\n  async exists(): Promise<boolean> {\n    const data = await this.retrieve();\n    return data !== null && data.expiresAt > Date.now();\n  }\n\n  /**\n   * Get storage statistics\n   */\n  async getStats(): Promise<{\n    hasData: boolean;\n    isExpired: boolean;\n    expiresIn: number | null;\n    storageType: string;\n    encryptionEnabled: boolean;\n  }> {\n    const data = await this.retrieve();\n    const now = Date.now();\n\n    return {\n      hasData: data !== null,\n      isExpired: data ? data.expiresAt <= now : false,\n      expiresIn: data ? Math.max(0, data.expiresAt - now) : null,\n      storageType: (this.config.storageAdapter || this.detectStorageAdapter()) as string,\n      encryptionEnabled: this.config.enableEncryption,\n    };\n  }\n\n  /**\n   * Platform-specific secure storage (React Native Keychain)\n   */\n  private async storePlatformSpecific(data: StoredAuthData): Promise<void> {\n    if (typeof window === 'undefined') return; // Node.js environment\n\n    try {\n      // React Native Keychain\n      if (this.isReactNative() && this.config.enableEncryption) {\n        const Keychain = await this.getKeychain();\n        if (Keychain) {\n          await Keychain.setInternetCredentials(\n            'acube.com',\n            data.user.email,\n            JSON.stringify({\n              accessToken: data.accessToken,\n              refreshToken: data.refreshToken,\n            })\n          );\n        }\n      }\n\n      // Web - use secure session storage for sensitive tokens\n      if (this.isWeb() && typeof window.sessionStorage !== 'undefined') {\n        // Only store non-sensitive data in session storage\n        const safeData = {\n          userId: data.user.id,\n          expiresAt: data.expiresAt,\n          roles: data.user.roles,\n        };\n        window.sessionStorage.setItem(`${this.config.storageKey}_session`, JSON.stringify(safeData));\n      }\n    } catch (error) {\n      // Platform-specific storage is optional, don't throw\n      console.warn('Platform-specific storage failed:', error);\n    }\n  }\n\n  /**\n   * Retrieve from platform-specific storage\n   */\n  private async retrievePlatformSpecific(): Promise<StoredAuthData | null> {\n    if (typeof window === 'undefined') return null;\n\n    try {\n      // React Native Keychain\n      if (this.isReactNative() && this.config.enableEncryption) {\n        const Keychain = await this.getKeychain();\n        if (Keychain) {\n          const credentials = await Keychain.getInternetCredentials('acube.com');\n          if (credentials) {\n            // Reconstruct from keychain data\n            // Note: This is partial data, full data should come from main storage\n            return null; // Return null to force main storage retrieval\n          }\n        }\n      }\n\n      return null;\n    } catch (error) {\n      console.warn('Platform-specific retrieval failed:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Clear platform-specific storage\n   */\n  private async clearPlatformSpecific(): Promise<void> {\n    if (typeof window === 'undefined') return;\n\n    try {\n      // React Native Keychain\n      if (this.isReactNative()) {\n        const Keychain = await this.getKeychain();\n        if (Keychain) {\n          await Keychain.resetInternetCredentials('acube.com');\n        }\n      }\n\n      // Web - clear session storage\n      if (this.isWeb() && typeof window.sessionStorage !== 'undefined') {\n        window.sessionStorage.removeItem(`${this.config.storageKey}_session`);\n      }\n    } catch (error) {\n      console.warn('Platform-specific clear failed:', error);\n    }\n  }\n\n  /**\n   * Initialize encryption key\n   */\n  private async initializeEncryption(): Promise<void> {\n    if (!this.encryption) return;\n\n    try {\n      // Try to retrieve existing key\n      const keyStorageKey = createStorageKey('_auth_encryption_key');\n      const keyEntry = await this.storage.get<{ keyId: string; key: string }>(keyStorageKey);\n      \n      if (keyEntry) {\n        // Import existing key\n        const keyData = keyEntry.data;\n        this.encryptionKeyId = keyData.keyId;\n        await this.encryption.importKey(\n          this.base64ToArrayBuffer(keyData.key),\n          'AES-GCM',\n          keyData.keyId\n        );\n      } else {\n        // Generate new key\n        this.encryptionKeyId = await this.encryption.generateSymmetricKey();\n        \n        // Export and store key\n        const exportedKey = await this.encryption.exportKey(this.encryptionKeyId, 'raw');\n        const keyStorageKey = createStorageKey('_auth_encryption_key');\n        await this.storage.set(keyStorageKey, {\n          keyId: this.encryptionKeyId,\n          key: this.arrayBufferToBase64(exportedKey as ArrayBuffer),\n        }, { encrypt: true });\n      }\n    } catch (error) {\n      console.error('Encryption initialization failed:', error);\n      // Disable encryption on failure\n      this.encryption = null;\n      this.config.enableEncryption = false;\n    }\n  }\n\n  /**\n   * Migrate from legacy storage formats\n   */\n  private async migrateFromLegacyStorage(): Promise<void> {\n    try {\n      // Check for legacy localStorage data\n      if (this.isWeb() && typeof window.localStorage !== 'undefined') {\n        const legacyData = window.localStorage.getItem('acube_auth_legacy');\n        if (legacyData) {\n          try {\n            const parsed = JSON.parse(legacyData);\n            // Convert to new format and store\n            await this.store({\n              ...parsed,\n              version: '1.0',\n              encryptedAt: Date.now(),\n            });\n            // Remove legacy data\n            window.localStorage.removeItem('acube_auth_legacy');\n          } catch {\n            // Invalid legacy data, ignore\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Legacy migration failed:', error);\n    }\n  }\n\n  /**\n   * Detect appropriate storage adapter\n   */\n  private detectStorageAdapter(): AuthStorageConfig['storageAdapter'] {\n    // React Native\n    if (this.isReactNative()) {\n      return 'asyncstorage';\n    }\n\n    // Web Browser\n    if (this.isWeb()) {\n      // Prefer IndexedDB for better security and storage limits\n      if (typeof window.indexedDB !== 'undefined') {\n        return 'indexeddb';\n      }\n      return 'localstorage';\n    }\n\n    // Node.js\n    if (typeof process !== 'undefined' && process.versions?.node) {\n      return 'filesystem';\n    }\n\n    // Fallback to memory\n    return 'memory';\n  }\n\n  /**\n   * Platform detection helpers\n   */\n  private isReactNative(): boolean {\n    return typeof navigator !== 'undefined' && navigator.product === 'ReactNative';\n  }\n\n  private isWeb(): boolean {\n    return typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  }\n\n  /**\n   * Get React Native Keychain module\n   */\n  private async getKeychain(): Promise<any> {\n    try {\n      const KeychainModule = await import('react-native-keychain');\n      return KeychainModule;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Ensure storage is initialized\n   */\n  private async ensureInitialized(): Promise<void> {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n  }\n\n  /**\n   * Emit storage error event\n   */\n  private emitStorageError(operation: 'read' | 'write' | 'delete' | 'clear' | 'initialize', error: Error): void {\n    const event = createAuthEvent<StorageErrorEvent>(\n      AuthEventType.STORAGE_ERROR,\n      {\n        operation,\n        error,\n        fallbackUsed: false,\n      }\n    );\n    this.emit(AuthEventType.STORAGE_ERROR, event);\n  }\n\n  /**\n   * Create auth error\n   */\n  private createAuthError(type: AuthErrorType, message: string, cause?: unknown): AuthError {\n    const error: AuthError = {\n      name: 'AuthError',\n      type,\n      message,\n      timestamp: Date.now(),\n      recoverable: false,\n    };\n\n    if (cause instanceof Error) {\n      error.details = { cause: cause.message };\n    }\n\n    return error;\n  }\n\n  /**\n   * Utility: Convert ArrayBuffer to base64\n   */\n  private arrayBufferToBase64(buffer: ArrayBuffer): string {\n    const binary = String.fromCharCode(...new Uint8Array(buffer));\n    return btoa(binary);\n  }\n\n  /**\n   * Utility: Convert base64 to ArrayBuffer\n   */\n  private base64ToArrayBuffer(base64: string): ArrayBuffer {\n    const binary = atob(base64);\n    const buffer = new ArrayBuffer(binary.length);\n    const array = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n      array[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n  }\n\n  /**\n   * Destroy storage instance\n   */\n  async destroy(): Promise<void> {\n    this.memoryCache = null;\n    this.removeAllListeners();\n    if (this.storage) {\n      await this.storage.destroy();\n    }\n  }\n}","/**\n * Authentication Performance Optimizations\n * Memory-efficient caching, batching, and performance monitoring for auth operations\n */\n\nimport { LRUCache } from 'lru-cache';\nimport type { PermissionCheck, PermissionResult, AuthUser, UserRole } from './types';\n\nexport interface AuthPerformanceConfig {\n  // Permission caching\n  permissionCacheSize: number;\n  permissionCacheTTL: number; // milliseconds\n  \n  // Role computation caching\n  roleCacheSize: number;\n  roleCacheTTL: number;\n  \n  // Token validation caching\n  tokenValidationCacheSize: number;\n  tokenValidationCacheTTL: number;\n  \n  // Batch processing\n  maxBatchSize: number;\n  batchTimeoutMs: number;\n  \n  // Performance monitoring\n  enableMetrics: boolean;\n  metricsRetentionMs: number;\n}\n\nconst DEFAULT_PERFORMANCE_CONFIG: AuthPerformanceConfig = {\n  permissionCacheSize: 1000,\n  permissionCacheTTL: 5 * 60 * 1000, // 5 minutes\n  roleCacheSize: 100,\n  roleCacheTTL: 10 * 60 * 1000, // 10 minutes\n  tokenValidationCacheSize: 500,\n  tokenValidationCacheTTL: 1 * 60 * 1000, // 1 minute\n  maxBatchSize: 10,\n  batchTimeoutMs: 50,\n  enableMetrics: true,\n  metricsRetentionMs: 24 * 60 * 60 * 1000, // 24 hours\n};\n\nexport interface AuthPerformanceMetrics {\n  permissionChecks: {\n    total: number;\n    cached: number;\n    cacheHitRate: number;\n    avgResponseTime: number;\n  };\n  roleComputations: {\n    total: number;\n    cached: number;\n    cacheHitRate: number;\n    avgResponseTime: number;\n  };\n  tokenValidations: {\n    total: number;\n    cached: number;\n    cacheHitRate: number;\n    avgResponseTime: number;\n  };\n  batchOperations: {\n    totalBatches: number;\n    avgBatchSize: number;\n    avgBatchTime: number;\n  };\n  memoryUsage: {\n    totalCacheSize: number;\n    permissionCacheSize: number;\n    roleCacheSize: number;\n    tokenCacheSize: number;\n  };\n}\n\n/**\n * High-performance authentication operations with intelligent caching and batching\n */\nexport class AuthPerformanceOptimizer {\n  private config: AuthPerformanceConfig;\n  \n  // Permission caching\n  private permissionCache: LRUCache<string, PermissionResult>;\n  private roleCache: LRUCache<string, UserRole[]>;\n  private tokenValidationCache: LRUCache<string, boolean>;\n  \n  // Batch processing\n  private pendingPermissionChecks: Map<string, {\n    checks: Array<{\n      permission: PermissionCheck;\n      resolve: (result: PermissionResult) => void;\n      reject: (error: Error) => void;\n    }>;\n    timer: NodeJS.Timeout;\n  }> = new Map();\n  \n  // Performance metrics\n  private metrics: AuthPerformanceMetrics = this.createEmptyMetrics();\n  \n  constructor(config: Partial<AuthPerformanceConfig> = {}) {\n    this.config = { ...DEFAULT_PERFORMANCE_CONFIG, ...config };\n    \n    // Initialize caches\n    this.permissionCache = new LRUCache({\n      max: this.config.permissionCacheSize,\n      ttl: this.config.permissionCacheTTL,\n      updateAgeOnGet: true,\n      updateAgeOnHas: true,\n    });\n    \n    this.roleCache = new LRUCache({\n      max: this.config.roleCacheSize,\n      ttl: this.config.roleCacheTTL,\n      updateAgeOnGet: true,\n      updateAgeOnHas: true,\n    });\n    \n    this.tokenValidationCache = new LRUCache({\n      max: this.config.tokenValidationCacheSize,\n      ttl: this.config.tokenValidationCacheTTL,\n      updateAgeOnGet: true,\n      updateAgeOnHas: true,\n    });\n    \n    // Initialize metrics\n    this.resetMetrics();\n    \n    // Setup cache cleanup\n    this.setupCacheCleanup();\n  }\n  \n  /**\n   * Cache-aware permission checking with intelligent batching\n   */\n  async checkPermissionOptimized(\n    user: AuthUser,\n    permission: PermissionCheck,\n    checkFn: (permission: PermissionCheck) => Promise<PermissionResult>\n  ): Promise<PermissionResult> {\n    const startTime = performance.now();\n    \n    // Generate cache key\n    const cacheKey = this.generatePermissionCacheKey(user, permission);\n    \n    // Check cache first\n    const cached = this.permissionCache.get(cacheKey);\n    if (cached) {\n      this.updateMetrics('permissionChecks', startTime, true);\n      return cached;\n    }\n    \n    // Add to batch for processing\n    return new Promise((resolve, reject) => {\n      const userKey = user.id;\n      \n      if (!this.pendingPermissionChecks.has(userKey)) {\n        this.pendingPermissionChecks.set(userKey, {\n          checks: [],\n          timer: setTimeout(() => {\n            this.processPendingPermissionChecks(userKey, checkFn);\n          }, this.config.batchTimeoutMs) as unknown as NodeJS.Timeout,\n        });\n      }\n      \n      const pending = this.pendingPermissionChecks.get(userKey)!;\n      pending.checks.push({ permission, resolve, reject });\n      \n      // Process immediately if batch is full\n      if (pending.checks.length >= this.config.maxBatchSize) {\n        clearTimeout(pending.timer);\n        this.processPendingPermissionChecks(userKey, checkFn);\n      }\n    });\n  }\n  \n  /**\n   * Cache-aware role computation with memoization\n   */\n  getEffectiveRolesOptimized(\n    user: AuthUser,\n    getRolesFn: (user: AuthUser) => UserRole[]\n  ): UserRole[] {\n    const startTime = performance.now();\n    \n    // Generate cache key based on user roles and context\n    const cacheKey = this.generateRoleCacheKey(user);\n    \n    // Check cache first\n    const cached = this.roleCache.get(cacheKey);\n    if (cached) {\n      this.updateMetrics('roleComputations', startTime, true);\n      return cached;\n    }\n    \n    // Compute roles\n    const roles = getRolesFn(user);\n    \n    // Cache result\n    this.roleCache.set(cacheKey, roles);\n    this.updateMetrics('roleComputations', startTime, false);\n    \n    return roles;\n  }\n  \n  /**\n   * Optimized token validation with caching\n   */\n  async validateTokenOptimized(\n    token: string,\n    validateFn: (token: string) => Promise<boolean>\n  ): Promise<boolean> {\n    const startTime = performance.now();\n    \n    // Generate cache key (hash the token for security)\n    const cacheKey = this.hashToken(token);\n    \n    // Check cache first\n    const cached = this.tokenValidationCache.get(cacheKey);\n    if (cached !== undefined) {\n      this.updateMetrics('tokenValidations', startTime, true);\n      return cached;\n    }\n    \n    // Validate token\n    const isValid = await validateFn(token);\n    \n    // Cache result\n    this.tokenValidationCache.set(cacheKey, isValid);\n    this.updateMetrics('tokenValidations', startTime, false);\n    \n    return isValid;\n  }\n  \n  /**\n   * Preload common permissions for a user\n   */\n  async preloadUserPermissions(\n    user: AuthUser,\n    commonPermissions: PermissionCheck[],\n    checkFn: (permission: PermissionCheck) => Promise<PermissionResult>\n  ): Promise<void> {\n    const uncachedPermissions = commonPermissions.filter(permission => {\n      const cacheKey = this.generatePermissionCacheKey(user, permission);\n      return !this.permissionCache.has(cacheKey);\n    });\n    \n    if (uncachedPermissions.length === 0) return;\n    \n    // Batch preload permissions\n    const results = await Promise.allSettled(\n      uncachedPermissions.map(permission => checkFn(permission))\n    );\n    \n    // Cache results\n    results.forEach((result, index) => {\n      const permission = uncachedPermissions[index];\n      if (result.status === 'fulfilled' && permission) {\n        const cacheKey = this.generatePermissionCacheKey(user, permission);\n        this.permissionCache.set(cacheKey, result.value);\n      }\n    });\n  }\n  \n  /**\n   * Clear user-specific caches (on logout, role change, etc.)\n   */\n  clearUserCaches(userId: string): void {\n    // Clear permission cache entries for user\n    for (const [key] of this.permissionCache.entries()) {\n      if (key.startsWith(`user:${userId}:`)) {\n        this.permissionCache.delete(key);\n      }\n    }\n    \n    // Clear role cache entries for user\n    for (const [key] of this.roleCache.entries()) {\n      if (key.startsWith(`user:${userId}:`)) {\n        this.roleCache.delete(key);\n      }\n    }\n  }\n  \n  /**\n   * Get current performance metrics\n   */\n  getMetrics(): AuthPerformanceMetrics {\n    return {\n      ...this.metrics,\n      memoryUsage: {\n        totalCacheSize: this.permissionCache.size + this.roleCache.size + this.tokenValidationCache.size,\n        permissionCacheSize: this.permissionCache.size,\n        roleCacheSize: this.roleCache.size,\n        tokenCacheSize: this.tokenValidationCache.size,\n      },\n    };\n  }\n  \n  /**\n   * Create empty metrics object\n   */\n  private createEmptyMetrics(): AuthPerformanceMetrics {\n    return {\n      permissionChecks: {\n        total: 0,\n        cached: 0,\n        cacheHitRate: 0,\n        avgResponseTime: 0,\n      },\n      roleComputations: {\n        total: 0,\n        cached: 0,\n        cacheHitRate: 0,\n        avgResponseTime: 0,\n      },\n      tokenValidations: {\n        total: 0,\n        cached: 0,\n        cacheHitRate: 0,\n        avgResponseTime: 0,\n      },\n      batchOperations: {\n        totalBatches: 0,\n        avgBatchSize: 0,\n        avgBatchTime: 0,\n      },\n      memoryUsage: {\n        totalCacheSize: 0,\n        permissionCacheSize: 0,\n        roleCacheSize: 0,\n        tokenCacheSize: 0,\n      },\n    };\n  }\n\n  /**\n   * Reset performance metrics\n   */\n  resetMetrics(): void {\n    this.metrics = this.createEmptyMetrics();\n  }\n  \n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    // Clear all pending batch operations\n    for (const [, pending] of this.pendingPermissionChecks) {\n      clearTimeout(pending.timer);\n      pending.checks.forEach(({ reject }) => {\n        reject(new Error('AuthPerformanceOptimizer destroyed'));\n      });\n    }\n    this.pendingPermissionChecks.clear();\n    \n    // Clear caches\n    this.permissionCache.clear();\n    this.roleCache.clear();\n    this.tokenValidationCache.clear();\n  }\n  \n  // Private methods\n  \n  private async processPendingPermissionChecks(\n    userKey: string,\n    checkFn: (permission: PermissionCheck) => Promise<PermissionResult>\n  ): Promise<void> {\n    const pending = this.pendingPermissionChecks.get(userKey);\n    if (!pending) return;\n    \n    this.pendingPermissionChecks.delete(userKey);\n    clearTimeout(pending.timer);\n    \n    const batchStartTime = performance.now();\n    \n    try {\n      // Process batch\n      const results = await Promise.allSettled(\n        pending.checks.map(({ permission }) => checkFn(permission))\n      );\n      \n      // Update metrics\n      this.metrics.batchOperations.totalBatches++;\n      this.metrics.batchOperations.avgBatchSize = \n        (this.metrics.batchOperations.avgBatchSize * (this.metrics.batchOperations.totalBatches - 1) + \n         pending.checks.length) / this.metrics.batchOperations.totalBatches;\n      \n      const batchTime = performance.now() - batchStartTime;\n      this.metrics.batchOperations.avgBatchTime = \n        (this.metrics.batchOperations.avgBatchTime * (this.metrics.batchOperations.totalBatches - 1) + \n         batchTime) / this.metrics.batchOperations.totalBatches;\n      \n      // Resolve individual promises and cache results\n      results.forEach((result, index) => {\n        const check = pending.checks[index];\n        if (!check) return;\n        \n        const { permission, resolve, reject } = check;\n        \n        if (result.status === 'fulfilled') {\n          // Cache the result\n          const cacheKey = this.generatePermissionCacheKey(\n            { id: userKey } as AuthUser, \n            permission\n          );\n          this.permissionCache.set(cacheKey, result.value);\n          \n          resolve(result.value);\n        } else {\n          reject(result.reason);\n        }\n      });\n    } catch (error) {\n      // Reject all pending checks\n      pending.checks.forEach(({ reject }) => {\n        reject(error as Error);\n      });\n    }\n  }\n  \n  private generatePermissionCacheKey(user: AuthUser, permission: PermissionCheck): string {\n    // Include user context that affects permissions\n    const context = [\n      user.id,\n      user.merchant_id || '',\n      user.cashier_id || '',\n      JSON.stringify(user.roles.sort()),\n      permission.resource,\n      permission.action,\n      JSON.stringify(permission.context || {}),\n    ].join(':');\n    \n    return `perm:${this.hashString(context)}`;\n  }\n  \n  private generateRoleCacheKey(user: AuthUser): string {\n    // Include user context that affects role computation\n    const context = [\n      user.id,\n      user.merchant_id || '',\n      user.cashier_id || '',\n      JSON.stringify(user.roles.sort()),\n      user.attributes?.primaryRole || '',\n    ].join(':');\n    \n    return `role:${this.hashString(context)}`;\n  }\n  \n  private hashToken(token: string): string {\n    // Simple hash for caching (not cryptographic)\n    return `token:${this.hashString(token)}`;\n  }\n  \n  private hashString(str: string): string {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(36);\n  }\n  \n  private updateMetrics(\n    type: 'permissionChecks' | 'roleComputations' | 'tokenValidations',\n    startTime: number,\n    fromCache: boolean\n  ): void {\n    if (!this.config.enableMetrics) return;\n    \n    const responseTime = performance.now() - startTime;\n    const metric = this.metrics[type];\n    \n    metric.total++;\n    if (fromCache) {\n      metric.cached++;\n    }\n    \n    // Update cache hit rate\n    metric.cacheHitRate = metric.cached / metric.total;\n    \n    // Update average response time\n    metric.avgResponseTime = \n      (metric.avgResponseTime * (metric.total - 1) + responseTime) / metric.total;\n  }\n  \n  private setupCacheCleanup(): void {\n    // Periodic cache cleanup to prevent memory leaks\n    setInterval(() => {\n      this.permissionCache.purgeStale();\n      this.roleCache.purgeStale();\n      this.tokenValidationCache.purgeStale();\n    }, 5 * 60 * 1000) as unknown as NodeJS.Timeout; // Every 5 minutes\n  }\n}\n\n/**\n * Common permission sets for preloading\n */\nexport const COMMON_PERMISSION_SETS = {\n  CASHIER: [\n    { resource: 'receipts', action: 'create' },\n    { resource: 'receipts', action: 'read' },\n    { resource: 'receipts', action: 'void' },\n    { resource: 'pointOfSales', action: 'read' },\n  ] as PermissionCheck[],\n  \n  MERCHANT: [\n    { resource: 'receipts', action: 'create' },\n    { resource: 'receipts', action: 'read' },\n    { resource: 'receipts', action: 'void' },\n    { resource: 'receipts', action: 'return' },\n    { resource: 'pointOfSales', action: 'read' },\n    { resource: 'pointOfSales', action: 'update' },\n    { resource: 'cashiers', action: 'read' },\n    { resource: 'merchants', action: 'read' },\n    { resource: 'merchants', action: 'update' },\n  ] as PermissionCheck[],\n  \n  SUPPLIER: [\n    { resource: 'receipts', action: 'create' },\n    { resource: 'receipts', action: 'read' },\n    { resource: 'receipts', action: 'void' },\n    { resource: 'receipts', action: 'return' },\n    { resource: 'pointOfSales', action: 'create' },\n    { resource: 'pointOfSales', action: 'read' },\n    { resource: 'pointOfSales', action: 'update' },\n    { resource: 'pointOfSales', action: 'delete' },\n    { resource: 'cashiers', action: 'create' },\n    { resource: 'cashiers', action: 'read' },\n    { resource: 'cashiers', action: 'update' },\n    { resource: 'cashiers', action: 'delete' },\n    { resource: 'merchants', action: 'create' },\n    { resource: 'merchants', action: 'read' },\n    { resource: 'merchants', action: 'update' },\n    { resource: 'merchants', action: 'delete' },\n  ] as PermissionCheck[],\n} as const;","/**\n * Authentication Service\n * Main service for handling OAuth2 authentication, session management, and user state\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport { HttpClient } from '@/http/client';\nimport { AccessControlManager } from '@/compliance/access-control';\nimport { TokenManager } from './token-manager';\nimport { AuthStorage } from './auth-storage';\nimport type {\n  LoginCredentials,\n  OAuth2TokenResponse,\n  AuthUser,\n  AuthState,\n  AuthError,\n  AuthErrorType,\n  AuthConfig,\n  LogoutOptions,\n  PermissionCheck,\n  PermissionResult,\n  SessionInfo,\n  SimpleUserRole,\n  StoredAuthData,\n  JWTPayload\n} from './types';\nimport { UserRole } from './types';\nimport {\n  hasRole,\n  hasAnyRole,\n  getEffectiveRoles,\n  getPrimaryRole,\n  toSimpleRole,\n  autoDetectRole,\n  canSwitchToRole,\n  ROLE_TO_SIMPLE\n} from './types';\nimport type { MerchantId, CashierId, PointOfSaleId } from '@/types/branded';\nimport {\n  AuthEventType,\n  createAuthEvent,\n  type LoginStartEvent,\n  type LoginSuccessEvent,\n  type LoginFailureEvent,\n  type LogoutEvent,\n  type SessionCreatedEvent,\n  type SessionRestoredEvent,\n} from './auth-events';\nimport { \n  AuthPerformanceOptimizer, \n  COMMON_PERMISSION_SETS,\n  type AuthPerformanceMetrics\n} from './auth-performance';\n\nconst DEFAULT_CONFIG: AuthConfig = {\n  loginUrl: '/login',\n  refreshUrl: '/token/refresh',\n  tokenRefreshBuffer: 5,\n  maxRefreshAttempts: 3,\n  refreshRetryDelay: 1000,\n  storageKey: 'acube_auth',\n  storageEncryption: true,\n  sessionTimeout: 8 * 60 * 60 * 1000, // 8 hours\n  maxConcurrentSessions: 3,\n  requireReauth: false,\n  enableDeviceBinding: true,\n  enableSessionValidation: true,\n  enableTokenRotation: true,\n  enablePerformanceOptimization: true,\n  performanceConfig: {\n    permissionCacheSize: 1000,\n    permissionCacheTTL: 5 * 60 * 1000, // 5 minutes\n    roleCacheSize: 100,\n    roleCacheTTL: 10 * 60 * 1000, // 10 minutes\n    tokenValidationCacheSize: 500,\n    tokenValidationCacheTTL: 1 * 60 * 1000, // 1 minute\n    maxBatchSize: 10,\n    batchTimeoutMs: 50,\n    enableMetrics: true,\n  },\n};\n\n/**\n * Enterprise authentication service with OAuth2, role-based access, and session management\n */\nexport class AuthService extends EventEmitter {\n  private config: AuthConfig;\n  private httpClient: HttpClient;\n  private tokenManager: TokenManager;\n  private storage: AuthStorage;\n  private accessControl: AccessControlManager;\n  private currentState: AuthState;\n  private deviceId: string;\n  private sessionCleanupInterval: NodeJS.Timeout | null = null;\n  private performanceOptimizer: AuthPerformanceOptimizer;\n\n  constructor(\n    httpClient: HttpClient,\n    config: Partial<AuthConfig> = {},\n    accessControl?: AccessControlManager,\n    storage?: AuthStorage,\n    tokenManager?: TokenManager\n  ) {\n    super();\n    \n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.httpClient = httpClient;\n    \n    // Use provided token manager or create a new one\n    if (tokenManager) {\n      this.tokenManager = tokenManager;\n    } else {\n      this.tokenManager = new TokenManager(httpClient, {\n        refreshUrl: this.config.refreshUrl,\n        tokenRefreshBuffer: this.config.tokenRefreshBuffer,\n        maxRefreshAttempts: this.config.maxRefreshAttempts,\n        refreshRetryDelay: this.config.refreshRetryDelay,\n        enableTokenRotation: this.config.enableTokenRotation,\n        ...(this.config.onTokenRefresh && { onTokenRefresh: this.config.onTokenRefresh }),\n        onTokenExpired: this.handleTokenExpired.bind(this),\n      });\n    }\n    \n    // Initialize storage\n    this.storage = storage || new AuthStorage({\n      storageKey: this.config.storageKey,\n      enableEncryption: this.config.storageEncryption,\n    });\n    \n    // Initialize access control\n    this.accessControl = accessControl || new AccessControlManager({\n      enabled: true,\n      model: 'HYBRID',\n      session: {\n        timeout: this.config.sessionTimeout,\n        maxConcurrentSessions: this.config.maxConcurrentSessions,\n        requireReauth: this.config.requireReauth,\n      },\n    });\n\n    // Initialize state\n    this.currentState = {\n      isAuthenticated: false,\n      isLoading: false,\n      user: null,\n      accessToken: null,\n      refreshToken: null,\n      expiresAt: null,\n      error: null,\n    };\n\n    // Generate device ID\n    this.deviceId = this.generateDeviceId();\n\n    // Initialize performance optimizer\n    this.performanceOptimizer = new AuthPerformanceOptimizer(\n      this.config.enablePerformanceOptimization ? this.config.performanceConfig : { enableMetrics: false }\n    );\n\n    // Set up event listeners\n    this.setupEventListeners();\n\n    // Start session cleanup\n    this.startSessionCleanup();\n  }\n\n  /**\n   * Initialize the auth service and restore session if available\n   */\n  async initialize(): Promise<void> {\n    try {\n      await this.storage.initialize();\n      await this.restoreSession();\n    } catch (error) {\n      console.error('Auth service initialization failed:', error);\n      // Don't throw - service should work without persistent session\n    }\n  }\n\n  /**\n   * Login with username and password\n   */\n  async login(credentials: LoginCredentials): Promise<AuthUser> {\n    // Update loading state\n    this.updateState({ isLoading: true, error: null });\n\n    // Emit login start\n    this.emitLoginStart(credentials);\n\n    try {\n      // Prepare login request with correct JSON format\n      const requestData = {\n        email: credentials.username, // API expects 'email' field instead of 'username'\n        password: credentials.password,\n      };\n\n      // Make login request\n      const response = await this.httpClient.post<{ token: string }>(\n        this.config.loginUrl,\n        requestData,\n        {\n          headers: {\n            'Content-Type': 'application/json',\n            'Accept': 'application/json',\n          },\n          skipRetry: false,\n          metadata: { isAuthentication: true },\n        }\n      );\n\n      const tokens = response.data;\n\n      // Parse user from token (API returns { token: string } format)\n      const rawTokenPayload = this.tokenManager.parseToken(tokens.token);\n      if (!rawTokenPayload) {\n        throw this.createAuthError(\n          'TOKEN_INVALID',\n          'Invalid access token received'\n        );\n      }\n\n      // Convert API token format to expected format\n      const tokenPayload: JWTPayload = {\n        sub: String((rawTokenPayload as any).uid || (rawTokenPayload as any).sub || 'unknown'),\n        email: (rawTokenPayload as any).username || (rawTokenPayload as any).email || credentials.username,\n        roles: [], // Will be populated below\n        permissions: [],\n        iat: rawTokenPayload.iat,\n        exp: rawTokenPayload.exp,\n        ...((rawTokenPayload as any).merchant_id && { merchant_id: (rawTokenPayload as any).merchant_id }),\n        ...((rawTokenPayload as any).cashier_id && { cashier_id: (rawTokenPayload as any).cashier_id }),\n        ...((rawTokenPayload as any).point_of_sale_id && { point_of_sale_id: (rawTokenPayload as any).point_of_sale_id }),\n      };\n\n      // Extract roles from nested API format\n      let apiRoles: string[] = [];\n      if ((rawTokenPayload as any).roles && typeof (rawTokenPayload as any).roles === 'object') {\n        // API returns roles as: {\"ereceipts-it.acubeapi.com\": [\"ROLE_MERCHANT\"]}\n        const domainRoles = Object.values((rawTokenPayload as any).roles)[0] as unknown;\n        apiRoles = Array.isArray(domainRoles) ? domainRoles as string[] : [];\n      }\n\n      // Convert API role strings to UserRole enum values\n      const tokenRoles = apiRoles.map(role => {\n        switch (role) {\n          case 'ROLE_MERCHANT': return UserRole.ROLE_MERCHANT;\n          case 'ROLE_CASHIER': return UserRole.ROLE_CASHIER;\n          case 'ROLE_SUPPLIER': return UserRole.ROLE_SUPPLIER;\n          case 'ROLE_ADMIN': return UserRole.ROLE_ADMIN;\n          default: return UserRole.ROLE_CASHIER; // Default fallback\n        }\n      });\n\n      tokenPayload.roles = tokenRoles;\n      const effectiveRoles = getEffectiveRoles(tokenRoles);\n      \n      // Auto-detect primary role based on context and preferences\n      const contextForDetection: {\n        merchantId?: MerchantId;\n        cashierId?: CashierId;\n        pointOfSaleId?: PointOfSaleId;\n        preferredRole?: UserRole | SimpleUserRole;\n        userRoles?: UserRole[];\n      } = {\n        userRoles: effectiveRoles,\n      };\n      \n      if (tokenPayload.merchant_id) {\n        contextForDetection.merchantId = tokenPayload.merchant_id;\n      }\n      if (tokenPayload.cashier_id) {\n        contextForDetection.cashierId = tokenPayload.cashier_id;\n      }\n      if (tokenPayload.point_of_sale_id) {\n        contextForDetection.pointOfSaleId = tokenPayload.point_of_sale_id;\n      }\n      if (credentials.preferred_role) {\n        contextForDetection.preferredRole = credentials.preferred_role;\n      }\n      \n      const primaryRole = autoDetectRole(contextForDetection);\n      \n      // Create user object with enhanced role information\n      const user: AuthUser = {\n        id: tokenPayload.sub,\n        email: tokenPayload.email,\n        name: (rawTokenPayload as any).username || tokenPayload.email || 'Unknown User',\n        roles: effectiveRoles,\n        permissions: tokenPayload.permissions || [],\n        ...(tokenPayload.cashier_id && { cashier_id: tokenPayload.cashier_id }),\n        ...(tokenPayload.merchant_id && { merchant_id: tokenPayload.merchant_id }),\n        ...(tokenPayload.point_of_sale_id && { point_of_sale_id: tokenPayload.point_of_sale_id }),\n        session_id: this.generateSessionId(),\n        last_login: new Date(),\n        attributes: {\n          deviceId: this.deviceId,\n          loginMethod: 'password',\n          primaryRole,\n          simpleRole: toSimpleRole(effectiveRoles),\n          originalRoles: tokenRoles,\n          contextDetected: {\n            merchant: !!tokenPayload.merchant_id,\n            cashier: !!tokenPayload.cashier_id,\n            pointOfSale: !!tokenPayload.point_of_sale_id,\n          },\n        },\n      };\n\n      // Set tokens in token manager (convert to OAuth2 format for compatibility)\n      const oauth2Tokens: OAuth2TokenResponse = {\n        access_token: tokens.token,\n        refresh_token: '', // API doesn't provide refresh token in this format\n        token_type: 'Bearer' as const,\n        expires_in: tokenPayload.exp ? Math.floor((tokenPayload.exp * 1000 - Date.now()) / 1000) : 3600,\n      };\n      this.tokenManager.setTokens(oauth2Tokens);\n\n      // Create session in access control (skip for CLI usage if it fails)\n      try {\n        const clientIP = await this.getClientIP();\n        const userAgent = this.getUserAgent();\n        \n        const { sessionId } = await this.accessControl.authenticate(user.id, {\n          timestamp: Date.now(),\n          deviceId: this.deviceId,\n          ipAddress: clientIP || 'unknown',\n          userAgent: userAgent || 'unknown',\n        });\n\n        user.session_id = sessionId;\n      } catch (accessControlError) {\n        // For CLI usage, we can skip access control and just use the generated session ID\n        // This is expected behavior for CLI - no need to warn\n        // user.session_id is already set above\n      }\n\n      // Store auth data\n      const authData: StoredAuthData = {\n        accessToken: tokens.token,\n        refreshToken: '', // No refresh token available\n        expiresAt: tokenPayload.exp * 1000,\n        tokenType: 'Bearer',\n        user,\n        encryptedAt: Date.now(),\n        version: '1.0',\n        deviceId: this.deviceId,\n      };\n\n      await this.storage.store(authData);\n\n      // Update state\n      this.updateState({\n        isAuthenticated: true,\n        isLoading: false,\n        user,\n        accessToken: tokens.token,\n        refreshToken: '', // No refresh token available\n        expiresAt: tokenPayload.exp * 1000,\n        error: null,\n      });\n\n      // Emit success events\n      this.emitLoginSuccess(user, oauth2Tokens);\n      this.emitSessionCreated(user);\n\n      // Preload common permissions for performance\n      if (this.config.enablePerformanceOptimization) {\n        this.preloadCommonPermissions(user).catch(error => {\n          console.warn('Failed to preload permissions:', error);\n        });\n      }\n\n      return user;\n    } catch (error) {\n      const authError = this.handleLoginError(error, credentials);\n      this.updateState({\n        isLoading: false,\n        error: authError,\n      });\n      \n      this.emitLoginFailure(authError, credentials);\n      throw authError;\n    }\n  }\n\n  /**\n   * Logout user and clear session\n   */\n  async logout(options: LogoutOptions = {}): Promise<void> {\n    const user = this.currentState.user;\n    const sessionId = user?.session_id;\n\n    try {\n      // Call logout endpoint if configured\n      if (this.config.logoutUrl && this.currentState.accessToken) {\n        try {\n          await this.httpClient.post(this.config.logoutUrl, {\n            refresh_token: this.currentState.refreshToken,\n            clear_all_sessions: options.clearAllSessions || false,\n          });\n        } catch (error) {\n          // Don't fail logout if server call fails\n          console.warn('Server logout failed:', error);\n        }\n      }\n\n      // Terminate session in access control\n      if (sessionId) {\n        await this.accessControl.terminateSession(sessionId);\n      }\n\n      // Clear tokens\n      this.tokenManager.clearTokens();\n\n      // Clear storage\n      if (options.clearLocalData !== false) {\n        await this.storage.clear();\n      }\n\n      // Clear performance caches\n      this.clearUserCaches();\n\n      // Emit logout event\n      this.emitLogout(user?.id || 'unknown', options);\n\n      // Reset state\n      this.updateState({\n        isAuthenticated: false,\n        isLoading: false,\n        user: null,\n        accessToken: null,\n        refreshToken: null,\n        expiresAt: null,\n        error: null,\n      });\n\n      // Call callback if provided\n      if (this.config.onLogout) {\n        this.config.onLogout(options.reason);\n      }\n    } catch (error) {\n      console.error('Logout error:', error);\n      // Still clear local state even if server operations fail\n      this.updateState({\n        isAuthenticated: false,\n        isLoading: false,\n        user: null,\n        accessToken: null,\n        refreshToken: null,\n        expiresAt: null,\n        error: null,\n      });\n    }\n  }\n\n  /**\n   * Get current authentication state\n   */\n  getState(): AuthState {\n    return { ...this.currentState };\n  }\n\n  /**\n   * Get current user\n   */\n  getCurrentUser(): AuthUser | null {\n    return this.currentState.user;\n  }\n\n  /**\n   * Check if user has permission (optimized with caching and batching)\n   */\n  async checkPermission(permission: PermissionCheck): Promise<PermissionResult> {\n    const user = this.currentState.user;\n    if (!user || !user.session_id) {\n      return {\n        granted: false,\n        reason: 'User not authenticated',\n      };\n    }\n\n    // Use performance optimizer if enabled\n    if (this.config.enablePerformanceOptimization) {\n      return this.performanceOptimizer.checkPermissionOptimized(\n        user,\n        permission,\n        async (perm) => this.checkPermissionDirect(perm)\n      );\n    }\n\n    return this.checkPermissionDirect(permission);\n  }\n\n  /**\n   * Direct permission check without optimization (used by optimizer)\n   */\n  private async checkPermissionDirect(permission: PermissionCheck): Promise<PermissionResult> {\n    const user = this.currentState.user;\n    if (!user || !user.session_id) {\n      return {\n        granted: false,\n        reason: 'User not authenticated',\n      };\n    }\n\n    try {\n      const result = await this.accessControl.checkAccess(\n        user.session_id,\n        permission.resource,\n        permission.action,\n        {\n          timestamp: Date.now(),\n          deviceId: this.deviceId,\n          attributes: permission.context || {},\n        }\n      );\n\n      return {\n        granted: result.granted,\n        reason: result.reason || 'Permission check completed',\n        requiresApproval: result.requiresApproval || false,\n      };\n    } catch (error) {\n      return {\n        granted: false,\n        reason: 'Permission check failed',\n      };\n    }\n  }\n\n  /**\n   * Check if user has specific role (including inherited roles)\n   */\n  hasRole(role: UserRole): boolean {\n    const userRoles = this.currentState.user?.roles || [];\n    return hasRole(userRoles, role);\n  }\n\n  /**\n   * Check if user has any of the specified roles (including inherited roles)\n   */\n  hasAnyRole(roles: UserRole[]): boolean {\n    const userRoles = this.currentState.user?.roles || [];\n    return hasAnyRole(userRoles, roles);\n  }\n\n  /**\n   * Get user's effective roles (including inherited roles) - optimized with caching\n   */\n  getEffectiveRoles(): UserRole[] {\n    const user = this.currentState.user;\n    if (!user) return [];\n    \n    // Use performance optimizer if enabled\n    if (this.config.enablePerformanceOptimization) {\n      return this.performanceOptimizer.getEffectiveRolesOptimized(\n        user,\n        (u) => getEffectiveRoles(u.roles || [])\n      );\n    }\n\n    return getEffectiveRoles(user.roles || []);\n  }\n\n  /**\n   * Get user's primary role for display purposes\n   */\n  getPrimaryRole(): UserRole | null {\n    const userRoles = this.currentState.user?.roles || [];\n    return getPrimaryRole(userRoles);\n  }\n\n  /**\n   * Get user's simple role for external APIs\n   */\n  getSimpleRole(): SimpleUserRole {\n    const userRoles = this.currentState.user?.roles || [];\n    return toSimpleRole(userRoles);\n  }\n\n  /**\n   * Switch to a different role context during session\n   */\n  async switchRole(\n    targetRole: UserRole,\n    context?: {\n      merchant_id?: import('@/types/branded').MerchantId;\n      cashier_id?: import('@/types/branded').CashierId;\n      point_of_sale_id?: import('@/types/branded').PointOfSaleId;\n    }\n  ): Promise<boolean> {\n    const userRoles = this.currentState.user?.roles || [];\n    \n    // Validate if user can switch to this role\n    const switchContext = context ? (() => {\n      const ctx: {\n        merchantId?: MerchantId;\n        cashierId?: CashierId;\n        pointOfSaleId?: PointOfSaleId;\n      } = {};\n      \n      if (context.merchant_id) ctx.merchantId = context.merchant_id;\n      if (context.cashier_id) ctx.cashierId = context.cashier_id;\n      if (context.point_of_sale_id) ctx.pointOfSaleId = context.point_of_sale_id;\n      \n      return ctx;\n    })() : undefined;\n    \n    if (!canSwitchToRole(userRoles, targetRole, switchContext)) {\n      return false;\n    }\n\n    // Update user's current context\n    if (this.currentState.user) {\n      this.currentState.user.attributes = {\n        ...this.currentState.user.attributes,\n        primaryRole: targetRole,\n        simpleRole: ROLE_TO_SIMPLE[targetRole] || 'cashier',\n        contextSwitched: true,\n        previousRole: this.currentState.user.attributes?.primaryRole,\n      };\n\n      // Update context-specific IDs if provided\n      if (context) {\n        if (context.merchant_id) this.currentState.user.merchant_id = context.merchant_id;\n        if (context.cashier_id) this.currentState.user.cashier_id = context.cashier_id;\n        if (context.point_of_sale_id) this.currentState.user.point_of_sale_id = context.point_of_sale_id;\n      }\n\n      // Update stored auth data\n      try {\n        await this.storage.update({\n          user: this.currentState.user,\n        });\n      } catch (error) {\n        console.warn('Failed to update stored auth data after role switch:', error);\n      }\n\n      // Emit role change event\n      this.emit(AuthEventType.ROLE_CHANGED, createAuthEvent(\n        AuthEventType.ROLE_CHANGED,\n        {\n          userId: this.currentState.user.id,\n          oldRoles: [this.currentState.user.attributes?.previousRole || targetRole],\n          newRoles: [targetRole],\n          changedBy: this.currentState.user.id,\n          reason: 'user_initiated_switch',\n        }\n      ));\n    }\n\n    return true;\n  }\n\n  /**\n   * Get current session info\n   */\n  async getSessionInfo(): Promise<SessionInfo | null> {\n    const user = this.currentState.user;\n    if (!user || !user.session_id) {\n      return null;\n    }\n\n    // This would typically come from the access control manager\n    // For now, construct from available data\n    const clientIP = await this.getClientIP();\n    const userAgent = this.getUserAgent();\n    \n    return {\n      id: user.session_id,\n      userId: user.id,\n      createdAt: user.last_login,\n      lastActivity: new Date(),\n      expiresAt: new Date(this.currentState.expiresAt || Date.now() + this.config.sessionTimeout),\n      deviceId: this.deviceId,\n      deviceName: this.getDeviceName(),\n      deviceType: this.getDeviceType(),\n      ipAddress: clientIP || 'unknown',\n      userAgent: userAgent || 'unknown',\n      active: this.currentState.isAuthenticated,\n    };\n  }\n\n  /**\n   * Refresh current session\n   */\n  async refreshSession(): Promise<void> {\n    if (!this.currentState.isAuthenticated || !this.tokenManager.getRefreshToken()) {\n      throw this.createAuthError(\n        'SESSION_EXPIRED',\n        'No active session to refresh'\n      );\n    }\n\n    try {\n      const tokens = await this.tokenManager.refreshTokens();\n      \n      // Update stored data\n      await this.storage.update({\n        accessToken: tokens.access_token,\n        refreshToken: tokens.refresh_token,\n        expiresAt: this.tokenManager.parseToken(tokens.access_token)?.exp! * 1000,\n      });\n\n      // Update state\n      this.updateState({\n        accessToken: tokens.access_token,\n        refreshToken: tokens.refresh_token,\n        expiresAt: this.tokenManager.parseToken(tokens.access_token)?.exp! * 1000,\n      });\n    } catch (error) {\n      // Refresh failed - logout user\n      await this.logout({\n        reason: 'token_invalid',\n        clearLocalData: true,\n      });\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Restore session from storage\n   */\n  private async restoreSession(): Promise<void> {\n    try {\n      const storedData = await this.storage.retrieve();\n      if (!storedData || storedData.expiresAt <= Date.now()) {\n        return; // No valid session to restore\n      }\n\n      // Validate token\n      const tokenValidation = this.tokenManager.validateToken(storedData.accessToken);\n      if (!tokenValidation.valid) {\n        // Try to refresh if we have a refresh token\n        if (storedData.refreshToken) {\n          this.tokenManager.setTokens({\n            access_token: storedData.accessToken,\n            refresh_token: storedData.refreshToken,\n            token_type: 'Bearer',\n            expires_in: Math.floor((storedData.expiresAt - Date.now()) / 1000),\n          });\n\n          try {\n            await this.refreshSession();\n            return; // Successfully refreshed\n          } catch {\n            // Refresh failed, continue to clear invalid session\n          }\n        }\n\n        // Clear invalid session\n        await this.storage.clear();\n        return;\n      }\n\n      // Set tokens\n      this.tokenManager.setTokens({\n        access_token: storedData.accessToken,\n        refresh_token: storedData.refreshToken,\n        token_type: 'Bearer',\n        expires_in: Math.floor((storedData.expiresAt - Date.now()) / 1000),\n      });\n\n      // Restore state\n      this.updateState({\n        isAuthenticated: true,\n        user: storedData.user,\n        accessToken: storedData.accessToken,\n        refreshToken: storedData.refreshToken,\n        expiresAt: storedData.expiresAt,\n        error: null,\n      });\n\n      // Emit session restored\n      this.emitSessionRestored(storedData.user);\n    } catch (error) {\n      console.error('Session restoration failed:', error);\n      // Clear potentially corrupted data\n      await this.storage.clear();\n    }\n  }\n\n  /**\n   * Handle token expiration\n   */\n  private async handleTokenExpired(): Promise<void> {\n    // Emit session expired event\n    this.emit(AuthEventType.SESSION_EXPIRED, createAuthEvent(\n      AuthEventType.SESSION_EXPIRED,\n      {\n        sessionId: this.currentState.user?.session_id || 'unknown',\n        userId: this.currentState.user?.id || 'unknown',\n        expiredAt: new Date(),\n        reason: 'timeout',\n      }\n    ));\n\n    // Call callback if provided\n    if (this.config.onTokenExpired) {\n      this.config.onTokenExpired();\n    }\n\n    // Auto-logout\n    await this.logout({\n      reason: 'session_expired',\n      clearLocalData: true,\n    });\n  }\n\n  /**\n   * Handle login errors\n   */\n  private handleLoginError(error: unknown, _credentials: LoginCredentials): AuthError {\n    let authError: AuthError;\n\n    if (error instanceof Error && 'statusCode' in error) {\n      const statusCode = (error as any).statusCode;\n      \n      switch (statusCode) {\n        case 401:\n          authError = this.createAuthError(\n            'INVALID_CREDENTIALS',\n            'Invalid username or password',\n            error\n          );\n          break;\n        case 403:\n          authError = this.createAuthError(\n            'PERMISSION_DENIED',\n            'Account is locked or suspended',\n            error\n          );\n          break;\n        case 429:\n          authError = this.createAuthError(\n            'NETWORK_ERROR',\n            'Too many login attempts. Please try again later.',\n            error\n          );\n          break;\n        default:\n          authError = this.createAuthError(\n            'NETWORK_ERROR',\n            'Login failed due to network error',\n            error\n          );\n      }\n    } else {\n      authError = this.createAuthError(\n        'UNKNOWN_ERROR',\n        'Login failed due to unknown error',\n        error\n      );\n    }\n\n    return authError;\n  }\n\n  /**\n   * Update authentication state\n   */\n  private updateState(updates: Partial<AuthState>): void {\n    this.currentState = { ...this.currentState, ...updates };\n    \n    // Emit state change event\n    this.emit('stateChange', this.currentState);\n  }\n\n  /**\n   * Setup event listeners\n   */\n  private setupEventListeners(): void {\n    // Forward token manager events\n    this.tokenManager.on(AuthEventType.TOKEN_REFRESH_SUCCESS, (event) => {\n      this.emit(AuthEventType.TOKEN_REFRESH_SUCCESS, event);\n    });\n\n    this.tokenManager.on(AuthEventType.TOKEN_REFRESH_FAILURE, (event) => {\n      this.emit(AuthEventType.TOKEN_REFRESH_FAILURE, event);\n    });\n\n    this.tokenManager.on(AuthEventType.TOKEN_EXPIRED, (event) => {\n      this.emit(AuthEventType.TOKEN_EXPIRED, event);\n    });\n\n    // Forward storage events\n    this.storage.on(AuthEventType.STORAGE_ERROR, (event) => {\n      this.emit(AuthEventType.STORAGE_ERROR, event);\n    });\n  }\n\n  /**\n   * Start session cleanup timer\n   */\n  private startSessionCleanup(): void {\n    // Clean up expired sessions every hour\n    this.sessionCleanupInterval = setInterval(() => {\n      this.cleanupExpiredSessions();\n    }, 60 * 60 * 1000) as unknown as NodeJS.Timeout;\n  }\n\n  /**\n   * Clean up expired sessions\n   */\n  private async cleanupExpiredSessions(): Promise<void> {\n    try {\n      const stats = await this.storage.getStats();\n      if (stats.isExpired) {\n        await this.storage.clear();\n      }\n    } catch (error) {\n      console.error('Session cleanup failed:', error);\n    }\n  }\n\n  /**\n   * Event emitters\n   */\n  private emitLoginStart(credentials: LoginCredentials): void {\n    const event = createAuthEvent<LoginStartEvent>(\n      AuthEventType.LOGIN_START,\n      {\n        username: credentials.username,\n        hasPassword: !!credentials.password,\n        hasMFA: !!credentials.mfa_code,\n        deviceId: this.deviceId,\n      }\n    );\n    this.emit(AuthEventType.LOGIN_START, event);\n  }\n\n  private emitLoginSuccess(user: AuthUser, tokens: OAuth2TokenResponse): void {\n    const event = createAuthEvent<LoginSuccessEvent>(\n      AuthEventType.LOGIN_SUCCESS,\n      {\n        user,\n        tokens,\n        isFirstLogin: !user.last_login || user.last_login.getTime() === Date.now(),\n        loginMethod: 'password',\n      }\n    );\n    this.emit(AuthEventType.LOGIN_SUCCESS, event);\n  }\n\n  private emitLoginFailure(error: AuthError, credentials: LoginCredentials): void {\n    const event = createAuthEvent<LoginFailureEvent>(\n      AuthEventType.LOGIN_FAILURE,\n      {\n        error,\n        username: credentials.username,\n        attemptNumber: 1, // Would track this in real implementation\n      }\n    );\n    this.emit(AuthEventType.LOGIN_FAILURE, event);\n  }\n\n  private emitLogout(userId: string, options: LogoutOptions): void {\n    const event = createAuthEvent<LogoutEvent>(\n      AuthEventType.LOGOUT,\n      {\n        userId,\n        reason: options.reason || 'user_initiated',\n        ...(options.message && { message: options.message }),\n        clearAllSessions: options.clearAllSessions || false,\n      }\n    );\n    this.emit(AuthEventType.LOGOUT, event);\n  }\n\n  private emitSessionCreated(user: AuthUser): void {\n    const event = createAuthEvent<SessionCreatedEvent>(\n      AuthEventType.SESSION_CREATED,\n      {\n        sessionId: user.session_id,\n        userId: user.id,\n        expiresAt: new Date(this.currentState.expiresAt || Date.now() + this.config.sessionTimeout),\n        deviceId: this.deviceId,\n      }\n    );\n    this.emit(AuthEventType.SESSION_CREATED, event);\n  }\n\n  private emitSessionRestored(user: AuthUser): void {\n    const event = createAuthEvent<SessionRestoredEvent>(\n      AuthEventType.SESSION_RESTORED,\n      {\n        sessionId: user.session_id,\n        user,\n        remainingTime: (this.currentState.expiresAt || 0) - Date.now(),\n        source: 'storage',\n      }\n    );\n    this.emit(AuthEventType.SESSION_RESTORED, event);\n  }\n\n  /**\n   * Utility methods\n   */\n  private generateDeviceId(): string {\n    // Use localStorage if available for persistence across sessions\n    if (typeof window !== 'undefined' && window.localStorage) {\n      let deviceId = window.localStorage.getItem('acube_device_id');\n      if (!deviceId) {\n        deviceId = `device_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n        window.localStorage.setItem('acube_device_id', deviceId);\n      }\n      return deviceId;\n    }\n    \n    // Generate new ID\n    return `device_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private generateSessionId(): string {\n    return `session_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private getDeviceName(): string {\n    if (typeof navigator !== 'undefined') {\n      return navigator.userAgent.split(' ')[0] || 'Unknown Device';\n    }\n    return 'Unknown Device';\n  }\n\n  private getDeviceType(): 'web' | 'mobile' | 'desktop' {\n    if (typeof navigator === 'undefined') return 'desktop';\n    \n    if (navigator.product === 'ReactNative') return 'mobile';\n    \n    const userAgent = navigator.userAgent.toLowerCase();\n    if (/mobile|android|iphone|ipad/.test(userAgent)) return 'mobile';\n    \n    return 'web';\n  }\n\n  private async getClientIP(): Promise<string | undefined> {\n    // In a real implementation, this would come from the server or a service\n    // For now, return undefined as IP detection is complex and privacy-sensitive\n    return undefined;\n  }\n\n  private getUserAgent(): string | undefined {\n    return typeof navigator !== 'undefined' ? navigator.userAgent : undefined;\n  }\n\n  private createAuthError(\n    type: AuthErrorType,\n    message: string,\n    cause?: unknown\n  ): AuthError {\n    return {\n      name: 'AuthError',\n      type,\n      message,\n      details: cause instanceof Error ? { cause: cause.message } : {},\n      timestamp: Date.now(),\n      recoverable: false,\n    };\n  }\n\n  /**\n   * Preload common permissions for the current user\n   */\n  private async preloadCommonPermissions(user: AuthUser): Promise<void> {\n    if (!this.config.enablePerformanceOptimization) return;\n\n    // Determine common permissions based on user's primary role\n    // const primaryRole = getPrimaryRole(user.roles || []);\n    let commonPermissions = COMMON_PERMISSION_SETS.CASHIER; // Default\n\n    if (hasRole(user.roles || [], UserRole.ROLE_SUPPLIER)) {\n      commonPermissions = COMMON_PERMISSION_SETS.SUPPLIER;\n    } else if (hasRole(user.roles || [], UserRole.ROLE_MERCHANT)) {\n      commonPermissions = COMMON_PERMISSION_SETS.MERCHANT;\n    }\n\n    await this.performanceOptimizer.preloadUserPermissions(\n      user,\n      commonPermissions,\n      async (permission) => this.checkPermissionDirect(permission)\n    );\n  }\n\n  /**\n   * Clear user-specific performance caches (call on role change, logout, etc.)\n   */\n  clearUserCaches(): void {\n    if (this.config.enablePerformanceOptimization && this.currentState.user) {\n      this.performanceOptimizer.clearUserCaches(this.currentState.user.id);\n    }\n  }\n\n  /**\n   * Get performance metrics for monitoring\n   */\n  getPerformanceMetrics(): AuthPerformanceMetrics | null {\n    if (!this.config.enablePerformanceOptimization) return null;\n    \n    return this.performanceOptimizer.getMetrics();\n  }\n\n  /**\n   * Reset performance metrics\n   */\n  resetPerformanceMetrics(): void {\n    if (this.config.enablePerformanceOptimization) {\n      this.performanceOptimizer.resetMetrics();\n    }\n  }\n\n  /**\n   * Destroy auth service\n   */\n  async destroy(): Promise<void> {\n    // Clear timers\n    if (this.sessionCleanupInterval) {\n      clearInterval(this.sessionCleanupInterval);\n    }\n\n    // Destroy components\n    this.tokenManager.destroy();\n    await this.storage.destroy();\n    \n    // Destroy performance optimizer\n    if (this.performanceOptimizer) {\n      this.performanceOptimizer.destroy();\n    }\n\n    // Clear listeners\n    this.removeAllListeners();\n  }\n}","/**\n * Enhanced Authentication Middleware\n * Advanced middleware with automatic token refresh, role-based headers, and request queuing\n */\n\nimport type { Middleware, RequestContext, ResponseContext } from '@/http/middleware';\nimport { AuthService } from './auth-service';\nimport { TokenManager } from './token-manager';\nimport type { AuthMiddlewareConfig, AuthError, UserRole } from './types';\nimport { AuthErrorType } from './types';\nimport { AuthEventType, createAuthEvent } from './auth-events';\nimport { EventEmitter } from 'eventemitter3';\n\ninterface QueuedRequest {\n  context: RequestContext;\n  resolve: (context: RequestContext) => void;\n  reject: (error: Error) => void;\n  timestamp: number;\n}\n\nconst DEFAULT_CONFIG: Required<AuthMiddlewareConfig> = {\n  enableRetry: true,\n  maxRetries: 2,\n  retryDelay: 1000,\n  authHeaderName: 'Authorization',\n  authScheme: 'Bearer',\n  includeRoleHeaders: true,\n  roleHeaderName: 'X-User-Role',\n  includePermissionHeaders: true,\n  permissionHeaderName: 'X-User-Permissions',\n  includeRequestContext: true,\n  contextHeaders: {\n    'X-Device-ID': 'deviceId',\n    'X-Session-ID': 'sessionId',\n    'X-Request-Context': 'requestContext',\n  },\n};\n\n/**\n * Enhanced authentication middleware with automatic token refresh and role-based access\n */\nexport class EnhancedAuthMiddleware extends EventEmitter implements Middleware {\n  readonly name = 'enhanced-auth';\n  readonly priority = 100; // Highest priority for auth\n\n  private config: Required<AuthMiddlewareConfig>;\n  private authService: AuthService;\n  private tokenManager: TokenManager;\n  private isRefreshing = false;\n  private requestQueue: QueuedRequest[] = [];\n  private readonly queueTimeout = 30000; // 30 seconds\n\n  constructor(\n    authService: AuthService,\n    tokenManager: TokenManager,\n    config: Partial<AuthMiddlewareConfig> = {}\n  ) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.authService = authService;\n    this.tokenManager = tokenManager;\n\n    // Set up event listeners\n    this.setupEventListeners();\n  }\n\n  /**\n   * Before request: Add authentication headers and user context\n   */\n  async beforeRequest(context: RequestContext): Promise<RequestContext> {\n    // Skip auth for authentication endpoints\n    if (this.isAuthEndpoint(context.url)) {\n      return context;\n    }\n\n    // Check if we're currently refreshing tokens\n    if (this.isRefreshing) {\n      return this.queueRequest(context);\n    }\n\n    // Get current authentication state\n    const authState = this.authService.getState();\n    \n    // If not authenticated, return as-is (let the endpoint decide how to handle)\n    if (!authState.isAuthenticated || !authState.accessToken) {\n      return context;\n    }\n\n    // Check if token needs refresh before request\n    const tokenStatus = this.tokenManager.getTokenStatus();\n    if (tokenStatus.needsRefresh && !tokenStatus.isRefreshing) {\n      try {\n        await this.refreshTokensWithQueue();\n      } catch (error) {\n        // If refresh fails, continue with current token\n        console.warn('Pre-request token refresh failed:', error);\n      }\n    }\n\n    // Add authentication headers\n    const updatedContext = await this.addAuthHeaders(context);\n    \n    return updatedContext;\n  }\n\n  /**\n   * After response: Handle token expiration and refresh\n   */\n  async afterResponse(\n    context: RequestContext,\n    response: ResponseContext\n  ): Promise<ResponseContext> {\n    // Handle 401 Unauthorized responses\n    if (response.status === 401 && this.shouldRetryWithRefresh(context)) {\n      try {\n        // Attempt token refresh\n        await this.refreshTokensWithQueue();\n        \n        // Retry the original request with new token\n        return this.retryRequestWithNewToken(context, response);\n      } catch (refreshError) {\n        // Token refresh failed - user needs to re-authenticate\n        this.handleAuthenticationFailure(refreshError as AuthError);\n        return response;\n      }\n    }\n\n    // Handle 403 Forbidden responses\n    if (response.status === 403) {\n      this.handleAuthorizationFailure(context, response);\n    }\n\n    return response;\n  }\n\n  /**\n   * Error handler: Process authentication-related errors\n   */\n  async onError(context: RequestContext, error: Error): Promise<Error> {\n    // Handle network errors that might be auth-related\n    if (this.isAuthRelatedError(error)) {\n      const authError = this.createAuthError(error, context);\n      \n      // Emit auth error event\n      this.emit(AuthEventType.NETWORK_ERROR, createAuthEvent(\n        AuthEventType.NETWORK_ERROR,\n        {\n          operation: 'request',\n          error: authError,\n          endpoint: context.url,\n          statusCode: (error as any).statusCode,\n          willRetry: false,\n        }\n      ));\n\n      return authError;\n    }\n\n    return error;\n  }\n\n  /**\n   * Add authentication and context headers to request\n   */\n  private async addAuthHeaders(context: RequestContext): Promise<RequestContext> {\n    const authState = this.authService.getState();\n    const updatedContext = { ...context };\n\n    // Add authorization header\n    if (authState.accessToken) {\n      const authHeader = `${this.config.authScheme} ${authState.accessToken}`;\n      updatedContext.headers[this.config.authHeaderName] = authHeader;\n      \n      /* // Debug: Log request headers for API server debugging\n      console.log(' API Request Debug:', {\n        url: `${context.method} ${context.url}`,\n        authHeaderName: this.config.authHeaderName,\n        authScheme: this.config.authScheme,\n        tokenLength: authState.accessToken.length,\n        tokenPreview: `${authState.accessToken.substring(0, 20)}...`,\n        hasToken: !!authState.accessToken,\n        isAuthenticated: authState.isAuthenticated\n      }); */\n    } else {\n      console.log('  No access token available for request:', {\n        url: `${context.method} ${context.url}`,\n        authState: {\n          isAuthenticated: authState.isAuthenticated,\n          hasUser: !!authState.user,\n          hasToken: !!authState.accessToken\n        }\n      });\n    }\n\n    // Add role headers\n    if (this.config.includeRoleHeaders && authState.user?.roles) {\n      updatedContext.headers[this.config.roleHeaderName] = \n        authState.user.roles.join(',');\n    }\n\n    // Add permission headers\n    if (this.config.includePermissionHeaders && authState.user?.permissions) {\n      updatedContext.headers[this.config.permissionHeaderName] = \n        authState.user.permissions.join(',');\n    }\n\n    // Add context headers\n    if (this.config.includeRequestContext && authState.user) {\n      Object.entries(this.config.contextHeaders).forEach(([headerName, contextKey]) => {\n        let value: string | undefined;\n        \n        switch (contextKey) {\n          case 'deviceId':\n            value = authState.user?.attributes?.deviceId as string;\n            break;\n          case 'sessionId':\n            value = authState.user?.session_id;\n            break;\n          case 'requestContext':\n            value = JSON.stringify({\n              userId: authState.user?.id,\n              roles: authState.user?.roles,\n              timestamp: Date.now(),\n            });\n            break;\n          default:\n            value = (authState.user as any)?.[contextKey];\n        }\n\n        if (value) {\n          updatedContext.headers[headerName] = value;\n        }\n      });\n    }\n\n    // Add request metadata\n    updatedContext.metadata = {\n      ...updatedContext.metadata,\n      isAuthenticated: authState.isAuthenticated,\n      userId: authState.user?.id,\n      roles: authState.user?.roles,\n      permissions: authState.user?.permissions,\n    };\n\n    /* // Debug: Log ALL headers being sent to API server  \n    const allHeaders: Record<string, string> = {};\n    Object.entries(updatedContext.headers).forEach(([key, value]) => {\n      if (typeof value === 'string') {\n        // Truncate Authorization header for security, show others in full\n        if (key.toLowerCase() === 'authorization') {\n          allHeaders[key] = `${value.substring(0, 30)}...`;\n        } else {\n          allHeaders[key] = value;\n        }\n      }\n    });\n    \n    if (Object.keys(allHeaders).length > 0) {\n      console.log(' ALL Request Headers:', allHeaders);\n    } */\n\n    return updatedContext;\n  }\n\n  /**\n   * Queue request during token refresh\n   */\n  private async queueRequest(context: RequestContext): Promise<RequestContext> {\n    return new Promise<RequestContext>((resolve, reject) => {\n      const queuedRequest: QueuedRequest = {\n        context,\n        resolve,\n        reject,\n        timestamp: Date.now(),\n      };\n\n      this.requestQueue.push(queuedRequest);\n\n      // Set timeout for queued request\n      setTimeout(() => {\n        const index = this.requestQueue.indexOf(queuedRequest);\n        if (index !== -1) {\n          this.requestQueue.splice(index, 1);\n          reject(new Error('Request queue timeout'));\n        }\n      }, this.queueTimeout);\n    });\n  }\n\n  /**\n   * Refresh tokens with request queuing\n   */\n  private async refreshTokensWithQueue(): Promise<void> {\n    if (this.isRefreshing) {\n      // Wait for existing refresh to complete\n      return new Promise((resolve, reject) => {\n        const checkRefresh = () => {\n          if (!this.isRefreshing) {\n            resolve();\n          } else {\n            setTimeout(checkRefresh, 100);\n          }\n        };\n        \n        setTimeout(() => reject(new Error('Token refresh timeout')), this.queueTimeout);\n        checkRefresh();\n      });\n    }\n\n    this.isRefreshing = true;\n\n    try {\n      // Perform token refresh\n      await this.authService.refreshSession();\n      \n      // Process queued requests\n      await this.processQueuedRequests();\n    } finally {\n      this.isRefreshing = false;\n    }\n  }\n\n  /**\n   * Process all queued requests after token refresh\n   */\n  private async processQueuedRequests(): Promise<void> {\n    const queue = [...this.requestQueue];\n    this.requestQueue = [];\n\n    for (const queuedRequest of queue) {\n      try {\n        // Update request with new auth headers\n        const updatedContext = await this.addAuthHeaders(queuedRequest.context);\n        queuedRequest.resolve(updatedContext);\n      } catch (error) {\n        queuedRequest.reject(error as Error);\n      }\n    }\n  }\n\n  /**\n   * Retry request with new token after 401 response\n   */\n  private async retryRequestWithNewToken(\n    _context: RequestContext,\n    originalResponse: ResponseContext\n  ): Promise<ResponseContext> {\n    // This would typically involve re-executing the HTTP request\n    // For now, we'll return a modified response indicating retry should happen\n    // The actual retry logic would be handled by the HTTP client\n    \n    const retryResponse: ResponseContext = {\n      ...originalResponse,\n      status: 200, // Assume retry would succeed\n      statusText: 'OK',\n      metadata: {\n        ...originalResponse.metadata,\n        wasRetried: true,\n        retryReason: 'token_refresh',\n      },\n    };\n\n    return retryResponse;\n  }\n\n  /**\n   * Handle authentication failure (401 after refresh attempt)\n   */\n  private handleAuthenticationFailure(_error: AuthError): void {\n    // Emit unauthorized access event\n    this.emit(AuthEventType.UNAUTHORIZED_ACCESS, createAuthEvent(\n      AuthEventType.UNAUTHORIZED_ACCESS,\n      {\n        userId: this.authService.getCurrentUser()?.id,\n        resource: 'api',\n        action: 'request',\n        reason: 'Token refresh failed',\n      }\n    ));\n\n    // Auto-logout user\n    this.authService.logout({\n      reason: 'token_invalid',\n      clearLocalData: true,\n    }).catch(logoutError => {\n      console.error('Auto-logout failed:', logoutError);\n    });\n  }\n\n  /**\n   * Handle authorization failure (403 responses)\n   */\n  private handleAuthorizationFailure(\n    context: RequestContext,\n    _response: ResponseContext\n  ): void {\n    const user = this.authService.getCurrentUser();\n    \n    // Emit unauthorized access event\n    this.emit(AuthEventType.UNAUTHORIZED_ACCESS, createAuthEvent(\n      AuthEventType.UNAUTHORIZED_ACCESS,\n      {\n        userId: user?.id,\n        resource: context.url,\n        action: context.method,\n        reason: 'Insufficient permissions',\n      }\n    ));\n\n    // Check if this indicates role/permission changes\n    if (user) {\n      this.checkForRoleChanges(user.roles);\n    }\n  }\n\n  /**\n   * Check for role changes that might explain authorization failure\n   */\n  private async checkForRoleChanges(currentRoles: UserRole[]): Promise<void> {\n    try {\n      // In a real implementation, you might fetch fresh user info here\n      // For now, we'll just log the potential role change\n      const user = this.authService.getCurrentUser();\n\n      // check if user roles have changed\n      if (!user || !user.roles || user.roles.length === 0) {\n        console.warn('User roles are empty or user is not authenticated');\n        return;\n      }\n\n      const hasRoleChanged = !currentRoles.every(role => user.roles.includes(role));\n\n      if (hasRoleChanged) {\n        console.warn('Authorization failure - possible role changes detected');\n      }\n    } catch (error) {\n      console.error('Failed to check role changes:', error);\n    }\n  }\n\n  /**\n   * Setup event listeners for auth service\n   */\n  private setupEventListeners(): void {\n    // Listen for token refresh events\n    this.tokenManager.on(AuthEventType.TOKEN_REFRESH_SUCCESS, () => {\n      // Process any queued requests\n      if (this.requestQueue.length > 0) {\n        this.processQueuedRequests().catch(error => {\n          console.error('Failed to process queued requests:', error);\n        });\n      }\n    });\n\n    // Listen for token expiration\n    this.tokenManager.on(AuthEventType.TOKEN_EXPIRED, () => {\n      // Clear request queue on token expiration\n      this.requestQueue.forEach(request => {\n        request.reject(new Error('Token expired'));\n      });\n      this.requestQueue = [];\n    });\n  }\n\n  /**\n   * Check if URL is an authentication endpoint\n   */\n  private isAuthEndpoint(url: string): boolean {\n    const authEndpoints = ['/mf1/login', '/mf1/token/refresh', '/mf1/logout'];\n    return authEndpoints.some(endpoint => url.includes(endpoint));\n  }\n\n  /**\n   * Check if request should be retried with token refresh\n   */\n  private shouldRetryWithRefresh(context: RequestContext): boolean {\n    // Don't retry if retries are disabled\n    if (!this.config.enableRetry) {\n      return false;\n    }\n\n    // Don't retry auth endpoints\n    if (this.isAuthEndpoint(context.url)) {\n      return false;\n    }\n\n    // Don't retry if already retried too many times\n    const retryCount = (context.metadata.retryCount as number) || 0;\n    if (retryCount >= this.config.maxRetries) {\n      return false;\n    }\n\n    // Don't retry if no refresh token available\n    const tokenStatus = this.tokenManager.getTokenStatus();\n    if (!tokenStatus || !tokenStatus.isValid || !tokenStatus.isRefreshing) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if error is authentication-related\n   */\n  private isAuthRelatedError(error: Error): boolean {\n    const authStatusCodes = [401, 403];\n    const statusCode = (error as any).statusCode;\n    \n    return authStatusCodes.includes(statusCode) ||\n           error.message.toLowerCase().includes('auth') ||\n           error.message.toLowerCase().includes('token') ||\n           error.message.toLowerCase().includes('unauthorized');\n  }\n\n  /**\n   * Create auth error from generic error\n   */\n  private createAuthError(error: Error, context: RequestContext): AuthError {\n    const statusCode = (error as any).statusCode;\n    \n    let type: AuthErrorType;\n    let message = error.message;\n    \n    switch (statusCode) {\n      case 401:\n        type = AuthErrorType.TOKEN_EXPIRED;\n        message = 'Authentication token expired or invalid';\n        break;\n      case 403:\n        type = AuthErrorType.PERMISSION_DENIED;\n        message = 'Insufficient permissions for this operation';\n        break;\n      default:\n        type = AuthErrorType.NETWORK_ERROR;\n        message = `Network error during authentication: ${error.message}`;\n    }\n\n    return {\n      name: 'AuthError',\n      type,\n      message,\n      code: `HTTP_${statusCode}`,\n      statusCode,\n      details: {\n        originalError: error.message,\n        url: context.url,\n        method: context.method,\n      },\n      timestamp: Date.now(),\n      recoverable: statusCode === 401, // 401 is recoverable via token refresh\n    };\n  }\n\n  /**\n   * Get middleware statistics\n   */\n  getStats(): {\n    queuedRequests: number;\n    isRefreshing: boolean;\n    totalRetries: number;\n    averageQueueTime: number;\n  } {\n    const queueTimes = this.requestQueue.map(req => Date.now() - req.timestamp);\n    const averageQueueTime = queueTimes.length > 0 \n      ? queueTimes.reduce((sum, time) => sum + time, 0) / queueTimes.length \n      : 0;\n\n    return {\n      queuedRequests: this.requestQueue.length,\n      isRefreshing: this.isRefreshing,\n      totalRetries: 0, // Would track this in real implementation\n      averageQueueTime,\n    };\n  }\n\n  /**\n   * Clear request queue and reset state\n   */\n  clearQueue(): void {\n    this.requestQueue.forEach(request => {\n      request.reject(new Error('Queue cleared'));\n    });\n    this.requestQueue = [];\n    this.isRefreshing = false;\n  }\n\n  /**\n   * Destroy middleware and clean up resources\n   */\n  destroy(): void {\n    this.clearQueue();\n    this.removeAllListeners();\n  }\n}\n\n/**\n * Factory function to create enhanced auth middleware\n */\nexport function createEnhancedAuthMiddleware(\n  authService: AuthService,\n  tokenManager: TokenManager,\n  config?: Partial<AuthMiddlewareConfig>\n): EnhancedAuthMiddleware {\n  return new EnhancedAuthMiddleware(authService, tokenManager, config);\n}\n\n/**\n * Helper to check if user has required role for request\n */\nexport function hasRequiredRole(\n  userRoles: UserRole[],\n  requiredRoles: UserRole | UserRole[]\n): boolean {\n  const required = Array.isArray(requiredRoles) ? requiredRoles : [requiredRoles];\n  return required.some(role => userRoles.includes(role));\n}\n\n/**\n * Helper to check if user has required permission\n */\nexport function hasRequiredPermission(\n  userPermissions: string[],\n  requiredPermission: string | string[]\n): boolean {\n  const required = Array.isArray(requiredPermission) ? requiredPermission : [requiredPermission];\n  return required.some(permission => userPermissions.includes(permission));\n}","/**\n * Core ACube SDK - Stripe-style Resource-Based Architecture\n * Main entry point with lazy resource loading and configuration management\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport { HttpClient, type HttpClientConfig, DEFAULT_HTTP_CONFIG, AUTH_HTTP_CONFIG } from '@/http/client';\nimport type { EventTypeMap } from '@/types/events';\n\n// Resource imports (lazy loaded)\nimport type { CashiersResource } from '@/resources/cashiers';\nimport type { ReceiptsResource } from '@/resources/receipts';\nimport type { PointOfSalesResource } from '@/resources/point-of-sales';\nimport type { CashRegistersResource } from '@/resources/cash-registers';\nimport type { MerchantsResource } from '@/resources/merchants';\nimport type { PEMsResource } from '@/resources/pems';\n\n// Sync system imports (lazy loaded)\nimport type { ProgressiveSyncEngine, SyncEngineConfig } from '@/sync/sync-engine';\nimport type { UnifiedStorage } from '@/storage/unified-storage';\nimport type { EnterpriseQueueManager } from '@/storage/queue/queue-manager';\n\n// Auth system imports (lazy loaded)\nimport type { AuthService } from '@/auth/auth-service';\nimport type { TokenManager } from '@/auth/token-manager';\nimport type { AuthStorage } from '@/auth/auth-storage';\nimport type { EnhancedAuthMiddleware } from '@/auth/auth-middleware';\nimport type { AuthConfig, AuthState, LoginCredentials, AuthUser, LogoutOptions, UserRole, SimpleUserRole } from '@/auth/types';\n\n// PWA system imports (lazy loaded)\nimport type { PWAManager, PWAManagerConfig } from '@/pwa/pwa-manager';\nimport type { ManifestGenerator, PWAManifestConfig } from '@/pwa/manifest-generator';\n\n// React Native optimization imports (lazy loaded)\nimport type { OptimizedReactNativeStorageAdapter } from '@/storage/adapters/optimized-react-native-storage';\nimport type { ConnectivityManager } from '@/react-native/connectivity-manager';\nimport type { BackgroundProcessor } from '@/react-native/background-processor';\nimport type { PerformanceMonitor } from '@/react-native/performance-monitor';\n\nexport interface ACubeSDKConfig {\n  /**\n   * API environment\n   */\n  environment: 'sandbox' | 'production' | 'development';\n  \n  /**\n   * API key for authentication\n   */\n  apiKey?: string;\n  \n  /**\n   * Custom base URLs for different environments\n   */\n  baseUrls?: {\n    api?: string;\n    auth?: string;\n  };\n  \n  /**\n   * HTTP client configuration\n   */\n  httpConfig?: Partial<HttpClientConfig>;\n  \n  /**\n   * Authentication configuration\n   */\n  auth?: {\n    // Legacy simple auth (deprecated)\n    getToken?: () => Promise<string | null>;\n    onTokenExpired?: () => Promise<void>;\n    autoRefresh?: boolean;\n    \n    // Enhanced enterprise auth system\n    enabled?: boolean;\n    config?: Partial<AuthConfig>;\n    credentials?: {\n      username?: string;\n      password?: string;\n      autoLogin?: boolean;\n    };\n    storage?: {\n      enableEncryption?: boolean;\n      storageKey?: string;\n      storageAdapter?: 'indexeddb' | 'localstorage' | 'asyncstorage' | 'filesystem' | 'memory';\n    };\n    middleware?: {\n      enableRetry?: boolean;\n      maxRetries?: number;\n      includeRoleHeaders?: boolean;\n      includePermissionHeaders?: boolean;\n      includeRequestContext?: boolean;\n    };\n  };\n  \n  /**\n   * Logging configuration\n   */\n  logging?: {\n    enabled: boolean;\n    level: 'debug' | 'info' | 'warn' | 'error';\n    sanitize: boolean;\n  };\n  \n  /**\n   * Feature flags\n   */\n  features?: {\n    enableRetry?: boolean;\n    enableCircuitBreaker?: boolean;\n    enableMetrics?: boolean;\n    enableOfflineQueue?: boolean;\n    enableSync?: boolean;\n    enableRealTimeSync?: boolean;\n  };\n  \n  /**\n   * Offline and sync configuration\n   */\n  offline?: {\n    enabled?: boolean;\n    storage?: {\n      adapter?: 'indexeddb' | 'localstorage' | 'asyncstorage' | 'filesystem' | 'memory';\n      encryptionKey?: string;\n      maxSize?: number; // bytes\n    };\n    queue?: {\n      maxItems?: number;\n      maxRetries?: number;\n      retryDelay?: number;\n      batchSize?: number;\n    };\n    sync?: Partial<SyncEngineConfig>;\n  };\n  \n  /**\n   * Progressive Web App configuration\n   */\n  pwa?: {\n    enabled?: boolean;\n    manager?: Partial<PWAManagerConfig>;\n    manifest?: Partial<PWAManifestConfig>;\n    autoRegister?: boolean;\n    enableInstallPrompts?: boolean;\n    enablePushNotifications?: boolean;\n    vapidPublicKey?: string;\n    appInstaller?: {\n      enabled?: boolean;\n      autoShow?: boolean;\n      criteria?: {\n        minEngagementTime?: number;\n        minPageViews?: number;\n        minReceiptsCreated?: number;\n        daysSinceFirstVisit?: number;\n        requireReturnVisit?: boolean;\n      };\n    };\n  };\n  \n  /**\n   * React Native mobile optimizations\n   */\n  reactNative?: {\n    enabled?: boolean;\n    storage?: {\n      enableOptimizedAdapter?: boolean;\n      cacheSize?: number;\n      enableCompression?: boolean;\n      enableBatching?: boolean;\n      batchDelay?: number;\n    };\n    connectivity?: {\n      enableQualityMonitoring?: boolean;\n      enableAdaptiveRetry?: boolean;\n      enableDataOptimization?: boolean;\n      healthCheckUrl?: string;\n    };\n    backgroundProcessor?: {\n      enabled?: boolean;\n      maxConcurrentTasks?: number;\n      enableBatteryOptimization?: boolean;\n      enableAppStateManagement?: boolean;\n      enableTaskPersistence?: boolean;\n    };\n    performanceMonitor?: {\n      enabled?: boolean;\n      enableMemoryMonitoring?: boolean;\n      enableFrameRateMonitoring?: boolean;\n      enableBatteryMonitoring?: boolean;\n      enableRemoteReporting?: boolean;\n    };\n  };\n  \n  /**\n   * Development options\n   */\n  dev?: {\n    enableMocking?: boolean;\n    mockDelay?: number;\n  };\n}\n\nconst DEFAULT_SDK_CONFIG: Required<ACubeSDKConfig> = {\n  environment: 'sandbox',\n  apiKey: '',\n  baseUrls: {},\n  httpConfig: {},\n  auth: {\n    autoRefresh: true,\n    enabled: true,\n    config: {\n      loginUrl: '/login',\n      refreshUrl: '/token/refresh',\n      tokenRefreshBuffer: 5,\n      maxRefreshAttempts: 3,\n      refreshRetryDelay: 1000,\n      storageKey: 'acube_auth',\n      storageEncryption: true,\n      sessionTimeout: 8 * 60 * 60 * 1000, // 8 hours\n      enableDeviceBinding: true,\n      enableSessionValidation: true,\n      enableTokenRotation: true,\n    },\n    storage: {\n      enableEncryption: true,\n      storageKey: 'acube_auth',\n    },\n    middleware: {\n      enableRetry: true,\n      maxRetries: 2,\n      includeRoleHeaders: true,\n      includePermissionHeaders: true,\n      includeRequestContext: true,\n    },\n  },\n  logging: {\n    enabled: true,\n    level: 'warn',\n    sanitize: true,\n  },\n  features: {\n    enableRetry: true,\n    enableCircuitBreaker: true,\n    enableMetrics: true,\n    enableOfflineQueue: false,\n    enableSync: false,\n    enableRealTimeSync: false,\n  },\n  offline: {\n    enabled: false,\n    storage: {\n      adapter: 'indexeddb',\n      maxSize: 100 * 1024 * 1024, // 100MB\n    },\n    queue: {\n      maxItems: 1000,\n      maxRetries: 3,\n      retryDelay: 5000,\n      batchSize: 50,\n    },\n    sync: {\n      maxConcurrentSyncs: 3,\n      defaultTimeout: 30000,\n      defaultRetries: 3,\n      batchSize: 100,\n      enableRollback: true,\n      enableDeltaSync: true,\n      enableCompression: true,\n      checkpointInterval: 5000,\n    },\n  },\n  pwa: {\n    enabled: true,\n    manager: {\n      autoRegister: true,\n      enableInstallPrompts: true,\n      serviceWorkerPath: '/sw.js',\n      appInstaller: {\n        enabled: true,\n        autoShow: true,\n        criteria: {\n          minEngagementTime: 2 * 60 * 1000, // 2 minutes\n          minPageViews: 3,\n          minReceiptsCreated: 1,\n          daysSinceFirstVisit: 0,\n          requireReturnVisit: false,\n        },\n      },\n    },\n    manifest: {\n      name: 'A-Cube E-Receipt',\n      shortName: 'A-Cube',\n      themeColor: '#1976d2',\n      backgroundColor: '#ffffff',\n      lang: 'it',\n    },\n    autoRegister: true,\n    enableInstallPrompts: true,\n    enablePushNotifications: false,\n    vapidPublicKey: '',\n    appInstaller: {\n      enabled: true,\n      autoShow: true,\n      criteria: {\n        minEngagementTime: 2 * 60 * 1000, // 2 minutes\n        minPageViews: 3,\n        minReceiptsCreated: 1,\n        daysSinceFirstVisit: 0,\n        requireReturnVisit: false,\n      },\n    },\n  },\n  reactNative: {\n    enabled: false,\n    storage: {\n      enableOptimizedAdapter: true,\n      cacheSize: 1000,\n      enableCompression: true,\n      enableBatching: true,\n      batchDelay: 50,\n    },\n    connectivity: {\n      enableQualityMonitoring: true,\n      enableAdaptiveRetry: true,\n      enableDataOptimization: true,\n      healthCheckUrl: 'https://ereceipts-it.acubeapi.com/health',\n    },\n    backgroundProcessor: {\n      enabled: true,\n      maxConcurrentTasks: 3,\n      enableBatteryOptimization: true,\n      enableAppStateManagement: true,\n      enableTaskPersistence: true,\n    },\n    performanceMonitor: {\n      enabled: true,\n      enableMemoryMonitoring: true,\n      enableFrameRateMonitoring: true,\n      enableBatteryMonitoring: true,\n      enableRemoteReporting: false,\n    },\n  },\n  dev: {\n    enableMocking: false,\n    mockDelay: 0,\n  },\n};\n\nexport class ACubeSDK extends EventEmitter<EventTypeMap> {\n  private config: Required<ACubeSDKConfig>;\n  private apiClient: HttpClient;\n  private authClient: HttpClient;\n  private isInitialized = false;\n  \n  // Lazy-loaded resources\n  private _cashiers?: CashiersResource;\n  private _receipts?: ReceiptsResource;\n  private _pointOfSales?: PointOfSalesResource;\n  private _cashRegisters?: CashRegistersResource;\n  private _merchants?: MerchantsResource;\n  private _pems?: PEMsResource;\n  \n  // Lazy-loaded offline systems\n  private _syncManager?: ProgressiveSyncEngine;\n  private _storage?: UnifiedStorage;\n  private _queueManager?: EnterpriseQueueManager;\n  \n  // Lazy-loaded auth systems\n  private _authService?: AuthService;\n  private _tokenManager?: TokenManager;\n  private _authStorage?: AuthStorage;\n  private _authMiddleware?: EnhancedAuthMiddleware;\n  \n  // Lazy-loaded PWA systems\n  private _pwaManager?: PWAManager;\n  private _manifestGenerator?: ManifestGenerator;\n  \n  // Lazy-loaded React Native optimization systems\n  private _optimizedStorage?: OptimizedReactNativeStorageAdapter;\n  private _connectivityManager?: ConnectivityManager;\n  private _backgroundProcessor?: BackgroundProcessor;\n  private _performanceMonitor?: PerformanceMonitor;\n\n  constructor(config: ACubeSDKConfig) {\n    super();\n    \n    this.config = this.mergeConfig(config);\n    \n    // Initialize HTTP clients\n    this.apiClient = this.createHttpClient('api');\n    this.authClient = this.createHttpClient('auth');\n    \n    this.setupEventHandlers();\n  }\n\n  private mergeConfig(userConfig: ACubeSDKConfig): Required<ACubeSDKConfig> {\n    return {\n      ...DEFAULT_SDK_CONFIG,\n      ...userConfig,\n      baseUrls: {\n        ...DEFAULT_SDK_CONFIG.baseUrls,\n        ...userConfig.baseUrls,\n      },\n      httpConfig: {\n        ...DEFAULT_SDK_CONFIG.httpConfig,\n        ...userConfig.httpConfig,\n      },\n      auth: {\n        ...DEFAULT_SDK_CONFIG.auth,\n        ...userConfig.auth,\n      },\n      logging: {\n        ...DEFAULT_SDK_CONFIG.logging,\n        ...userConfig.logging,\n      },\n      features: {\n        ...DEFAULT_SDK_CONFIG.features,\n        ...userConfig.features,\n      },\n      offline: {\n        ...DEFAULT_SDK_CONFIG.offline,\n        ...userConfig.offline,\n        storage: {\n          ...DEFAULT_SDK_CONFIG.offline.storage,\n          ...userConfig.offline?.storage,\n        },\n        queue: {\n          ...DEFAULT_SDK_CONFIG.offline.queue,\n          ...userConfig.offline?.queue,\n        },\n        sync: {\n          ...DEFAULT_SDK_CONFIG.offline.sync,\n          ...userConfig.offline?.sync,\n        },\n      },\n      dev: {\n        ...DEFAULT_SDK_CONFIG.dev,\n        ...userConfig.dev,\n      },\n    };\n  }\n\n  private createHttpClient(type: 'api' | 'auth'): HttpClient {\n    const baseConfig = type === 'api' ? DEFAULT_HTTP_CONFIG : AUTH_HTTP_CONFIG;\n    \n    // Determine base URL\n    let baseUrl: string;\n    if (type === 'api') {\n      baseUrl = this.config.baseUrls.api || this.getDefaultApiUrl();\n    } else {\n      baseUrl = this.config.baseUrls.auth || this.getDefaultAuthUrl();\n    }\n    \n    const config: HttpClientConfig = {\n      ...baseConfig,\n      ...this.config.httpConfig,\n      baseUrl,\n      enableRetry: this.config.features.enableRetry ?? true,\n      enableCircuitBreaker: this.config.features.enableCircuitBreaker ?? true,\n      enableLogging: this.config.logging.enabled,\n      ...(this.config.auth.getToken && { getAuthToken: this.config.auth.getToken }),\n      userAgent: `ACube-SDK/2.0.0 (${this.config.environment})`,\n    };\n    \n    return new HttpClient(config);\n  }\n\n  private getDefaultApiUrl(): string {\n    switch (this.config.environment) {\n      case 'production':\n        return 'https://ereceipts-it.acubeapi.com';\n      case 'development':\n        return 'https://ereceipts-it.dev.acubeapi.com';\n      case 'sandbox':\n      default:\n        return 'https://ereceipts-it-sandbox.acubeapi.com';\n    }\n  }\n\n  private getDefaultAuthUrl(): string {\n    switch (this.config.environment) {\n      case 'production':\n        return 'https://common.api.acubeapi.com';\n      case 'development':\n      case 'sandbox':\n      default:\n        return 'https://common-sandbox.api.acubeapi.com';\n    }\n  }\n\n  private setupEventHandlers(): void {\n    // Forward HTTP client events\n    this.apiClient.on('requestError', (event) => {\n      this.emit('error', {\n        type: 'error',\n        timestamp: new Date(),\n        requestId: event.requestId,\n        data: {\n          errorCode: 'HTTP_REQUEST_FAILED',\n          errorMessage: event.error,\n          operation: `${event.method} ${event.url}`,\n          retry: false,\n          context: { client: 'api', ...event },\n        },\n      });\n    });\n\n    this.authClient.on('requestError', (event) => {\n      this.emit('error', {\n        type: 'error',\n        timestamp: new Date(),\n        requestId: event.requestId,\n        data: {\n          errorCode: 'AUTH_REQUEST_FAILED',\n          errorMessage: event.error,\n          operation: `${event.method} ${event.url}`,\n          retry: false,\n          context: { client: 'auth', ...event },\n        },\n      });\n    });\n\n    // Handle authentication events\n    if (this.config.auth.onTokenExpired) {\n      this.on('auth.expired', this.config.auth.onTokenExpired);\n    }\n  }\n\n  /**\n   * Initialize the SDK (optional - resources are lazy loaded)\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    try {\n      // Validate configuration\n      this.validateConfig();\n      \n      // Initialize auth system if enabled\n      if (this.config.auth.enabled) {\n        await this.initializeAuthSystem();\n      }\n      \n      // Initialize React Native optimizations if enabled\n      if (this.config.reactNative.enabled) {\n        await this.initializeReactNativeOptimizations();\n      }\n      \n      // Test connectivity (optional health check)\n      if (this.config.features.enableMetrics) {\n        await this.performHealthCheck();\n      }\n      \n      this.isInitialized = true;\n      \n      this.emit('error', {\n        type: 'error',\n        timestamp: new Date(),\n        requestId: `init_success_${Date.now()}`,\n        data: {\n          errorCode: 'SDK_INITIALIZED',\n          errorMessage: 'SDK initialized successfully',\n          operation: 'initialize',\n          retry: false,\n          context: {\n            environment: this.config.environment,\n            features: this.config.features,\n          },\n        },\n      });\n    } catch (error) {\n      this.emit('error', {\n        type: 'error',\n        timestamp: new Date(),\n        requestId: `init_${Date.now()}`,\n        data: {\n          errorCode: 'SDK_INITIALIZATION_FAILED',\n          errorMessage: error instanceof Error ? error.message : 'Unknown error',\n          operation: 'initialize',\n          retry: false,\n        },\n      });\n      throw error;\n    }\n  }\n\n  private validateConfig(): void {\n    // Validate environment\n    if (!['sandbox', 'production', 'development'].includes(this.config.environment)) {\n      throw new Error(`Invalid environment: ${this.config.environment}`);\n    }\n\n    // Validate auth configuration if provided\n    if (this.config.auth.getToken && typeof this.config.auth.getToken !== 'function') {\n      throw new Error('auth.getToken must be a function');\n    }\n  }\n\n  private async performHealthCheck(): Promise<void> {\n    // Simple health check - can be expanded\n    try {\n      const healthStatus = this.apiClient.getHealthStatus();\n      this.emit('error', {\n        type: 'error',\n        timestamp: new Date(),\n        requestId: `health_${Date.now()}`,\n        data: {\n          errorCode: 'HEALTH_CHECK_COMPLETED',\n          errorMessage: 'Health check completed',\n          operation: 'health-check',\n          retry: false,\n          context: { healthStatus },\n        },\n      });\n    } catch (error) {\n      this.emit('error', {\n        type: 'error',\n        timestamp: new Date(),\n        requestId: `health_failed_${Date.now()}`,\n        data: {\n          errorCode: 'HEALTH_CHECK_FAILED',\n          errorMessage: 'Health check failed',\n          operation: 'health-check',\n          retry: false,\n          context: { error },\n        },\n      });\n      // Don't throw - health check failure shouldn't prevent initialization\n    }\n  }\n\n  /**\n   * Initialize the enterprise authentication system\n   */\n  private async initializeAuthSystem(): Promise<void> {\n    try {\n      // Initialize auth storage\n      this._authStorage = this.authStorage;\n      await this._authStorage.initialize();\n\n      // Initialize token manager\n      this._tokenManager = this.tokenManager;\n\n      // Initialize auth service\n      this._authService = this.authService;\n      await this._authService.initialize();\n\n      // Initialize and add auth middleware to HTTP clients\n      this._authMiddleware = this.authMiddleware;\n      this.apiClient.addMiddleware(this._authMiddleware);\n      this.authClient.addMiddleware(this._authMiddleware);\n\n      // Set up auth event forwarding\n      this.setupAuthEventForwarding();\n\n      // Auto-login if credentials provided\n      if (this.config.auth.credentials?.autoLogin && \n          this.config.auth.credentials.username && \n          this.config.auth.credentials.password) {\n        try {\n          await this._authService.login({\n            username: this.config.auth.credentials.username,\n            password: this.config.auth.credentials.password,\n          });\n        } catch (loginError) {\n          // Don't fail initialization if auto-login fails\n          console.warn('Auto-login failed during initialization:', loginError);\n        }\n      }\n\n      this.emit('error', {\n        type: 'error',\n        timestamp: new Date(),\n        requestId: `auth_init_${Date.now()}`,\n        data: {\n          errorCode: 'AUTH_SYSTEM_INITIALIZED',\n          errorMessage: 'Authentication system initialized',\n          operation: 'auth-init',\n          retry: false,\n        },\n      });\n    } catch (error) {\n      this.emit('error', {\n        type: 'error',\n        timestamp: new Date(),\n        requestId: `auth_init_failed_${Date.now()}`,\n        data: {\n          errorCode: 'AUTH_INITIALIZATION_FAILED',\n          errorMessage: error instanceof Error ? error.message : 'Unknown auth error',\n          operation: 'auth-init',\n          retry: false,\n          context: { error },\n        },\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize React Native optimization systems\n   */\n  private async initializeReactNativeOptimizations(): Promise<void> {\n    const isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';\n    \n    if (!isReactNative) {\n      console.warn('React Native optimizations requested but not in React Native environment');\n      return;\n    }\n    \n    try {\n      // Initialize optimized storage adapter if enabled\n      if (this.config.reactNative?.storage?.enableOptimizedAdapter) {\n        const { OptimizedReactNativeStorageAdapter } = await import('@/storage/adapters/optimized-react-native-storage');\n        this._optimizedStorage = new OptimizedReactNativeStorageAdapter({\n          cacheSize: this.config.reactNative?.storage?.cacheSize ?? 1000,\n          enableCompression: this.config.reactNative?.storage?.enableCompression ?? true,\n          enableBatching: this.config.reactNative?.storage?.enableBatching ?? true,\n          batchDelay: this.config.reactNative?.storage?.batchDelay ?? 50,\n        });\n      }\n\n      // Initialize connectivity manager\n      const { ConnectivityManager } = await import('@/react-native/connectivity-manager');\n      this._connectivityManager = new ConnectivityManager({\n        enableQualityMonitoring: this.config.reactNative?.connectivity?.enableQualityMonitoring ?? true,\n        enableAdaptiveRetry: this.config.reactNative?.connectivity?.enableAdaptiveRetry ?? true,\n        enableDataOptimization: this.config.reactNative?.connectivity?.enableDataOptimization ?? true,\n        healthCheckUrl: this.config.reactNative?.connectivity?.healthCheckUrl ?? 'https://ereceipts-it.acubeapi.com/health',\n      });\n\n      // Initialize background processor if enabled\n      if (this.config.reactNative?.backgroundProcessor?.enabled) {\n        const { BackgroundProcessor } = await import('@/react-native/background-processor');\n        this._backgroundProcessor = new BackgroundProcessor({\n          maxConcurrentTasks: this.config.reactNative?.backgroundProcessor?.maxConcurrentTasks ?? 3,\n          enableBatteryOptimization: this.config.reactNative?.backgroundProcessor?.enableBatteryOptimization ?? true,\n          enableAppStateManagement: this.config.reactNative?.backgroundProcessor?.enableAppStateManagement ?? true,\n          enableTaskPersistence: this.config.reactNative?.backgroundProcessor?.enableTaskPersistence ?? true,\n        });\n      }\n\n      // Initialize performance monitor if enabled\n      if (this.config.reactNative?.performanceMonitor?.enabled) {\n        const { PerformanceMonitor } = await import('@/react-native/performance-monitor');\n        this._performanceMonitor = new PerformanceMonitor({\n          enableMemoryMonitoring: this.config.reactNative?.performanceMonitor?.enableMemoryMonitoring ?? true,\n          enableFrameRateMonitoring: this.config.reactNative?.performanceMonitor?.enableFrameRateMonitoring ?? true,\n          enableBatteryMonitoring: this.config.reactNative?.performanceMonitor?.enableBatteryMonitoring ?? true,\n          enableRemoteReporting: this.config.reactNative?.performanceMonitor?.enableRemoteReporting ?? false,\n        });\n      }\n\n      this.emit('error', {\n        type: 'error',\n        timestamp: new Date(),\n        requestId: `rn_init_${Date.now()}`,\n        data: {\n          errorCode: 'REACT_NATIVE_OPTIMIZATIONS_INITIALIZED',\n          errorMessage: 'React Native optimizations initialized',\n          operation: 'rn-init',\n          retry: false,\n        },\n      });\n    } catch (error) {\n      this.emit('error', {\n        type: 'error',\n        timestamp: new Date(),\n        requestId: `rn_init_failed_${Date.now()}`,\n        data: {\n          errorCode: 'REACT_NATIVE_INITIALIZATION_FAILED',\n          errorMessage: error instanceof Error ? error.message : 'Unknown React Native error',\n          operation: 'rn-init',\n          retry: false,\n          context: { error },\n        },\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Set up auth event forwarding to SDK events\n   */\n  private setupAuthEventForwarding(): void {\n    if (!this._authService) return;\n\n    // Forward auth events to SDK events\n    this._authService.on('auth:login:success', (event) => {\n      (this as any).emit('auth.success', {\n        userId: event.data.user.id,\n        role: event.data.user.attributes?.simpleRole || 'cashier',\n        user: event.data.user,\n        expiresAt: event.data.user.last_login ? new Date(Date.now() + (this.config.auth?.config?.sessionTimeout || 3600000)) : undefined,\n      });\n    });\n\n    this._authService.on('auth:login:failure', (event) => {\n      (this as any).emit('auth.error', {\n        error: event.data.error.message,\n        errorCode: event.data.error.type,\n        errorMessage: event.data.error.message,\n        retry: event.data.error.recoverable || false,\n        operation: 'login',\n      });\n    });\n\n    this._authService.on('auth:logout', (event) => {\n      (this as any).emit('auth.logout', {\n        userId: event.data.userId,\n        reason: event.data.reason,\n        operation: 'logout',\n      });\n    });\n\n    this._authService.on('auth:session:expired', (event) => {\n      (this as any).emit('auth.expired', {\n        userId: event.data.userId,\n        sessionId: event.data.sessionId,\n        operation: 'session_expired',\n      });\n\n      // Call legacy callback if provided\n      if (this.config.auth?.onTokenExpired) {\n        this.config.auth.onTokenExpired().catch(error => {\n          console.error('Legacy onTokenExpired callback failed:', error);\n        });\n      }\n    });\n  }\n\n  // Lazy-loaded resource getters (Stripe-style)\n  \n  /**\n   * Cashiers resource - user management\n   * Enhanced with offline capabilities when enabled\n   */\n  get cashiers(): CashiersResource {\n    if (!this._cashiers) {\n      const { CashiersResource } = require('@/resources/cashiers');\n      this._cashiers = new CashiersResource(\n        this.apiClient,\n        this.config.offline?.enabled ? this.storage : undefined,\n        this.config.features?.enableOfflineQueue ? this.queue : undefined\n      );\n    }\n    return this._cashiers!;\n  }\n\n  /**\n   * Receipts resource - e-receipt management\n   * Enhanced with offline capabilities when enabled\n   */\n  get receipts(): ReceiptsResource {\n    if (!this._receipts) {\n      const { ReceiptsResource } = require('@/resources/receipts');\n      this._receipts = new ReceiptsResource(\n        this.apiClient,\n        this.config.offline?.enabled ? this.storage : undefined,\n        this.config.features?.enableOfflineQueue ? this.queue : undefined\n      );\n    }\n    return this._receipts!;\n  }\n\n  /**\n   * Point of Sales resource - POS device management\n   * Enhanced with offline capabilities when enabled\n   */\n  get pointOfSales(): PointOfSalesResource {\n    if (!this._pointOfSales) {\n      const { PointOfSalesResource } = require('@/resources/point-of-sales');\n      this._pointOfSales = new PointOfSalesResource(\n        this.apiClient,\n        this.config.offline?.enabled ? this.storage : undefined,\n        this.config.features?.enableOfflineQueue ? this.queue : undefined\n      );\n    }\n    return this._pointOfSales!;\n  }\n\n  /**\n   * Cash Registers resource - device registration\n   * Enhanced with offline capabilities when enabled\n   */\n  get cashRegisters(): CashRegistersResource {\n    if (!this._cashRegisters) {\n      const { CashRegistersResource } = require('@/resources/cash-registers');\n      this._cashRegisters = new CashRegistersResource(\n        this.apiClient,\n        this.config.offline?.enabled ? this.storage : undefined,\n        this.config.features?.enableOfflineQueue ? this.queue : undefined\n      );\n    }\n    return this._cashRegisters!;\n  }\n\n  /**\n   * Merchants resource - business entity management\n   * Enhanced with offline capabilities when enabled\n   */\n  get merchants(): MerchantsResource {\n    if (!this._merchants) {\n      const { MerchantsResource } = require('@/resources/merchants');\n      this._merchants = new MerchantsResource(\n        this.apiClient,\n        this.config.offline?.enabled ? this.storage : undefined,\n        this.config.features?.enableOfflineQueue ? this.queue : undefined\n      );\n    }\n    return this._merchants!;\n  }\n\n  /**\n   * PEMs resource - electronic memorization device management\n   * Enhanced with offline capabilities when enabled\n   */\n  get pems(): PEMsResource {\n    if (!this._pems) {\n      const { PEMsResource } = require('@/resources/pems');\n      this._pems = new PEMsResource(\n        this.apiClient,\n        this.config.offline?.enabled ? this.storage : undefined,\n        this.config.features?.enableOfflineQueue ? this.queue : undefined\n      );\n    }\n    return this._pems!;\n  }\n\n  // PWA System getters\n\n  /**\n   * PWA Manager - Progressive Web App functionality\n   * Handles service worker registration, caching, and offline capabilities\n   */\n  get pwa(): PWAManager {\n    if (!this._pwaManager) {\n      const { PWAManager } = require('@/pwa/pwa-manager');\n      const pwaConfig: PWAManagerConfig = {\n        ...this.config.pwa.manager,\n        serviceWorkerPath: this.config.pwa.manager?.serviceWorkerPath || '/sw.js',\n        autoRegister: this.config.pwa.autoRegister ?? true,\n        enableInstallPrompts: this.config.pwa.enableInstallPrompts ?? true,\n        pushNotifications: {\n          enabled: this.config.pwa.enablePushNotifications ?? false,\n          vapidPublicKey: this.config.pwa.vapidPublicKey ?? '',\n        },\n      };\n      \n      this._pwaManager = new PWAManager(pwaConfig);\n    }\n    return this._pwaManager!;\n  }\n\n  /**\n   * Manifest Generator - PWA manifest creation and management\n   * Creates web app manifests with Italian e-receipt specific configuration\n   */\n  get manifest(): ManifestGenerator {\n    if (!this._manifestGenerator) {\n      const { ManifestGenerator } = require('@/pwa/manifest-generator');\n      this._manifestGenerator = new ManifestGenerator(this.config.pwa.manifest);\n    }\n    return this._manifestGenerator!;\n  }\n\n  // Offline system getters (only available when offline features are enabled)\n\n  /**\n   * Progressive sync manager - smart synchronization with partial failure recovery\n   * Only available when features.enableSync is true\n   */\n  get sync(): ProgressiveSyncEngine {\n    if (!this.config.features.enableSync) {\n      throw new Error('Sync is not enabled. Set features.enableSync to true in configuration.');\n    }\n    \n    if (!this._syncManager) {\n      const { ProgressiveSyncEngine } = require('@/sync/sync-engine');\n      this._syncManager = new ProgressiveSyncEngine(this.config.offline?.sync || {});\n    }\n    return this._syncManager!;\n  }\n\n  /**\n   * Unified storage system - cross-platform storage with encryption\n   * Only available when offline.enabled is true\n   */\n  get storage(): UnifiedStorage {\n    if (!this.config.offline?.enabled) {\n      throw new Error('Offline storage is not enabled. Set offline.enabled to true in configuration.');\n    }\n    \n    if (!this._storage) {\n      const { UnifiedStorage } = require('@/storage/unified-storage');\n      this._storage = new UnifiedStorage({\n        adapter: this.config.offline.storage?.adapter || 'indexeddb',\n        encryptionKey: this.config.offline.storage?.encryptionKey,\n        maxSize: this.config.offline.storage?.maxSize || 100 * 1024 * 1024,\n      });\n    }\n    return this._storage!;\n  }\n\n  /**\n   * Enterprise queue manager - advanced operation queuing with retry logic\n   * Only available when features.enableOfflineQueue is true\n   */\n  get queue(): EnterpriseQueueManager {\n    if (!this.config.features.enableOfflineQueue) {\n      throw new Error('Offline queue is not enabled. Set features.enableOfflineQueue to true in configuration.');\n    }\n    \n    if (!this._queueManager) {\n      const { EnterpriseQueueManager } = require('@/storage/queue/queue-manager');\n      this._queueManager = new EnterpriseQueueManager({\n        storage: this.storage, // Use unified storage\n        maxItems: this.config.offline?.queue?.maxItems || 1000,\n        maxRetries: this.config.offline?.queue?.maxRetries || 3,\n        retryDelay: this.config.offline?.queue?.retryDelay || 5000,\n        batchSize: this.config.offline?.queue?.batchSize || 50,\n      });\n    }\n    return this._queueManager!;\n  }\n\n  // Authentication system getters (only available when auth.enabled is true)\n\n  /**\n   * JWT token manager - automatic refresh, validation, parsing\n   * Only available when auth.enabled is true\n   */\n  get tokenManager(): TokenManager {\n    if (!this.config.auth.enabled) {\n      throw new Error('Enterprise auth is not enabled. Set auth.enabled to true in configuration.');\n    }\n    \n    if (!this._tokenManager) {\n      const { TokenManager } = require('@/auth/token-manager');\n      this._tokenManager = new TokenManager(\n        this.authClient,\n        {\n          refreshUrl: this.config.auth.config?.refreshUrl || '/mf1/token/refresh',\n          tokenRefreshBuffer: this.config.auth.config?.tokenRefreshBuffer || 5,\n          maxRefreshAttempts: this.config.auth.config?.maxRefreshAttempts || 3,\n          refreshRetryDelay: this.config.auth.config?.refreshRetryDelay || 1000,\n          enableTokenRotation: this.config.auth.config?.enableTokenRotation ?? true,\n          onTokenRefresh: this.config.auth.config?.onTokenRefresh,\n          onTokenExpired: this.config.auth.config?.onTokenExpired,\n        }\n      );\n    }\n    return this._tokenManager!;\n  }\n\n  /**\n   * Enterprise authentication service - OAuth2, role-based access, session management\n   * Only available when auth.enabled is true\n   */\n  get authService(): AuthService {\n    if (!this.config.auth.enabled) {\n      throw new Error('Enterprise auth is not enabled. Set auth.enabled to true in configuration.');\n    }\n    \n    if (!this._authService) {\n      const { AuthService } = require('@/auth/auth-service');\n      // Pass the shared tokenManager instance to AuthService\n      this._authService = new AuthService(\n        this.authClient,\n        this.config.auth.config || {},\n        undefined, // AccessControlManager - could be injected\n        this._authStorage,\n        this.tokenManager // Pass the shared token manager\n      );\n    }\n    return this._authService!;\n  }\n\n  /**\n   * Secure cross-platform auth storage - encrypted token storage\n   * Only available when auth.enabled is true\n   */\n  get authStorage(): AuthStorage {\n    if (!this.config.auth.enabled) {\n      throw new Error('Enterprise auth is not enabled. Set auth.enabled to true in configuration.');\n    }\n    \n    if (!this._authStorage) {\n      const { AuthStorage } = require('@/auth/auth-storage');\n      this._authStorage = new AuthStorage({\n        storageKey: this.config.auth.storage?.storageKey || 'acube_auth',\n        enableEncryption: this.config.auth.storage?.enableEncryption ?? true,\n        storageAdapter: this.config.auth.storage?.storageAdapter,\n        autoMigrate: true,\n      });\n    }\n    return this._authStorage!;\n  }\n\n  /**\n   * Enhanced authentication middleware - automatic token refresh, role headers\n   * Only available when auth.enabled is true\n   */\n  get authMiddleware(): EnhancedAuthMiddleware {\n    if (!this.config.auth.enabled) {\n      throw new Error('Enterprise auth is not enabled. Set auth.enabled to true in configuration.');\n    }\n    \n    if (!this._authMiddleware) {\n      const { EnhancedAuthMiddleware } = require('@/auth/auth-middleware');\n      this._authMiddleware = new EnhancedAuthMiddleware(\n        this.authService,\n        this.tokenManager,\n        {\n          enableRetry: this.config.auth.middleware?.enableRetry ?? true,\n          maxRetries: this.config.auth.middleware?.maxRetries || 2,\n          authHeaderName: 'Authorization',\n          authScheme: 'Bearer',\n          includeRoleHeaders: this.config.auth.middleware?.includeRoleHeaders ?? true,\n          roleHeaderName: 'X-User-Role',\n          includePermissionHeaders: this.config.auth.middleware?.includePermissionHeaders ?? true,\n          permissionHeaderName: 'X-User-Permissions',\n          includeRequestContext: this.config.auth.middleware?.includeRequestContext ?? true,\n          contextHeaders: {\n            'X-Device-ID': 'deviceId',\n            'X-Session-ID': 'sessionId',\n            'X-Request-Context': 'requestContext',\n          },\n        }\n      );\n    }\n    return this._authMiddleware!;\n  }\n\n  // Authentication methods\n\n  /**\n   * Login with username and password\n   */\n  async login(credentials: LoginCredentials): Promise<AuthUser> {\n    if (!this.config.auth.enabled) {\n      throw new Error('Enterprise auth is not enabled. Set auth.enabled to true in configuration.');\n    }\n    \n    return this.authService.login(credentials);\n  }\n\n  /**\n   * Logout current user\n   */\n  async logout(options?: LogoutOptions): Promise<void> {\n    if (!this.config.auth.enabled) {\n      throw new Error('Enterprise auth is not enabled. Set auth.enabled to true in configuration.');\n    }\n    \n    return this.authService.logout(options);\n  }\n\n  /**\n   * Get current authentication state\n   */\n  getAuthState(): AuthState | null {\n    if (!this.config.auth.enabled || !this._authService) {\n      return null;\n    }\n    \n    return this.authService.getState();\n  }\n\n  /**\n   * Get current authenticated user\n   */\n  getCurrentUser(): AuthUser | null {\n    if (!this.config.auth.enabled || !this._authService) {\n      return null;\n    }\n    \n    return this.authService.getCurrentUser();\n  }\n\n  /**\n   * Check if user is authenticated\n   */\n  isAuthenticated(): boolean {\n    const authState = this.getAuthState();\n    return authState?.isAuthenticated ?? false;\n  }\n\n  /**\n   * Check if user has specific role (including inherited roles from hierarchy)\n   */\n  hasRole(role: UserRole): boolean {\n    if (!this.config.auth.enabled || !this._authService) {\n      return false;\n    }\n    \n    return this.authService.hasRole(role);\n  }\n\n  /**\n   * Check if user has any of the specified roles (including inherited roles)\n   */\n  hasAnyRole(roles: UserRole[]): boolean {\n    if (!this.config.auth.enabled || !this._authService) {\n      return false;\n    }\n    \n    return this.authService.hasAnyRole(roles);\n  }\n\n  /**\n   * Get user's effective roles (including inherited roles from hierarchy)\n   */\n  getEffectiveRoles(): UserRole[] {\n    if (!this.config.auth.enabled || !this._authService) {\n      return [];\n    }\n    \n    return this.authService.getEffectiveRoles();\n  }\n\n  /**\n   * Get user's primary role for display purposes\n   */\n  getPrimaryRole(): UserRole | null {\n    if (!this.config.auth.enabled || !this._authService) {\n      return null;\n    }\n    \n    return this.authService.getPrimaryRole();\n  }\n\n  /**\n   * Get user's simple role for external APIs\n   */\n  getSimpleRole(): SimpleUserRole {\n    if (!this.config.auth.enabled || !this._authService) {\n      return 'cashier';\n    }\n    \n    return this.authService.getSimpleRole();\n  }\n\n  /**\n   * Switch to a different role context during session\n   */\n  async switchRole(\n    targetRole: UserRole,\n    context?: {\n      merchant_id?: import('@/types/branded').MerchantId;\n      cashier_id?: import('@/types/branded').CashierId;\n      point_of_sale_id?: import('@/types/branded').PointOfSaleId;\n    }\n  ): Promise<boolean> {\n    if (!this.config.auth.enabled) {\n      throw new Error('Enterprise auth is not enabled. Set auth.enabled to true in configuration.');\n    }\n    \n    return this.authService.switchRole(targetRole, context);\n  }\n\n  // Configuration and management methods\n\n  /**\n   * Update SDK configuration\n   */\n  updateConfig(updates: Partial<ACubeSDKConfig>): void {\n    const newConfig = this.mergeConfig({ ...this.config, ...updates });\n    \n    // Update HTTP clients if necessary\n    if (updates.httpConfig || updates.baseUrls || updates.environment) {\n      this.apiClient.updateConfig(this.createHttpClient('api')['config']);\n      this.authClient.updateConfig(this.createHttpClient('auth')['config']);\n    }\n    \n    this.config = newConfig;\n    \n    this.emit('error', {\n      type: 'error',\n      timestamp: new Date(),\n      requestId: `config_${Date.now()}`,\n      data: {\n        errorCode: 'CONFIG_UPDATED',\n        errorMessage: 'Configuration updated',\n        operation: 'update-config',\n        retry: false,\n        context: { updates },\n      },\n    });\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): Readonly<Required<ACubeSDKConfig>> {\n    return { ...this.config };\n  }\n\n  /**\n   * Get SDK metrics and health status\n   */\n  getMetrics() {\n    return {\n      api: this.apiClient.getHealthStatus(),\n      auth: this.authClient.getHealthStatus(),\n      isInitialized: this.isInitialized,\n      environment: this.config.environment,\n    };\n  }\n\n  /**\n   * Get HTTP clients (for advanced usage)\n   */\n  getClients() {\n    return {\n      api: this.apiClient,\n      auth: this.authClient,\n    };\n  }\n\n  // React Native Optimization getters (only available when reactNative.enabled is true)\n\n  /**\n   * Optimized React Native Storage Adapter - High-performance AsyncStorage with caching\n   * Only available when reactNative.enabled is true and enableOptimizedAdapter is true\n   */\n  get optimizedStorage(): OptimizedReactNativeStorageAdapter {\n    if (!this.config.reactNative.enabled) {\n      throw new Error('React Native optimizations are not enabled. Set reactNative.enabled to true in configuration.');\n    }\n    \n    if (!this.config.reactNative?.storage?.enableOptimizedAdapter) {\n      throw new Error('Optimized storage adapter is not enabled. Set reactNative.storage.enableOptimizedAdapter to true.');\n    }\n    \n    if (!this._optimizedStorage) {\n      throw new Error('Optimized storage not initialized. Make sure SDK is initialized first.');\n    }\n    \n    return this._optimizedStorage;\n  }\n\n  /**\n   * Connectivity Manager - Intelligent network handling and retry strategies\n   * Only available when reactNative.enabled is true\n   */\n  get connectivity(): ConnectivityManager {\n    if (!this.config.reactNative.enabled) {\n      throw new Error('React Native optimizations are not enabled. Set reactNative.enabled to true in configuration.');\n    }\n    \n    if (!this._connectivityManager) {\n      throw new Error('Connectivity manager not initialized. Make sure SDK is initialized first.');\n    }\n    \n    return this._connectivityManager;\n  }\n\n  /**\n   * Background Processor - Task scheduling and app lifecycle management\n   * Only available when reactNative.enabled is true and backgroundProcessor.enabled is true\n   */\n  get backgroundProcessor(): BackgroundProcessor {\n    if (!this.config.reactNative.enabled) {\n      throw new Error('React Native optimizations are not enabled. Set reactNative.enabled to true in configuration.');\n    }\n    \n    if (!this.config.reactNative?.backgroundProcessor?.enabled) {\n      throw new Error('Background processor is not enabled. Set reactNative.backgroundProcessor.enabled to true.');\n    }\n    \n    if (!this._backgroundProcessor) {\n      throw new Error('Background processor not initialized. Make sure SDK is initialized first.');\n    }\n    \n    return this._backgroundProcessor;\n  }\n\n  /**\n   * Performance Monitor - Mobile performance metrics and optimization\n   * Only available when reactNative.enabled is true and performanceMonitor.enabled is true\n   */\n  get performanceMonitor(): PerformanceMonitor {\n    if (!this.config.reactNative.enabled) {\n      throw new Error('React Native optimizations are not enabled. Set reactNative.enabled to true in configuration.');\n    }\n    \n    if (!this.config.reactNative?.performanceMonitor?.enabled) {\n      throw new Error('Performance monitor is not enabled. Set reactNative.performanceMonitor.enabled to true.');\n    }\n    \n    if (!this._performanceMonitor) {\n      throw new Error('Performance monitor not initialized. Make sure SDK is initialized first.');\n    }\n    \n    return this._performanceMonitor;\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async destroy(): Promise<void> {\n    // Cleanup HTTP clients\n    this.apiClient.destroy();\n    this.authClient.destroy();\n    \n    // Cleanup auth systems if they were initialized\n    if (this._authService) {\n      await this._authService.destroy();\n    }\n    \n    if (this._tokenManager) {\n      this._tokenManager.destroy();\n    }\n    \n    if (this._authStorage) {\n      await this._authStorage.destroy();\n    }\n    \n    if (this._authMiddleware) {\n      this._authMiddleware.destroy();\n    }\n    \n    // Cleanup offline systems if they were initialized\n    if (this._syncManager) {\n      await this._syncManager.cancelAllSyncs();\n    }\n    \n    if (this._queueManager) {\n      await this._queueManager.destroy();\n    }\n    \n    if (this._storage) {\n      await this._storage.destroy();\n    }\n    \n    // Cleanup React Native optimizations if they were initialized\n    if (this._optimizedStorage) {\n      await this._optimizedStorage.destroy();\n    }\n    \n    if (this._connectivityManager) {\n      this._connectivityManager.destroy();\n    }\n    \n    if (this._backgroundProcessor) {\n      this._backgroundProcessor.destroy();\n    }\n    \n    if (this._performanceMonitor) {\n      this._performanceMonitor.destroy();\n    }\n    \n    this.removeAllListeners();\n    this.isInitialized = false;\n    \n    this.emit('error', {\n      type: 'error',\n      timestamp: new Date(),\n      requestId: `destroy_${Date.now()}`,\n      data: {\n        errorCode: 'SDK_DESTROYED',\n        errorMessage: 'SDK destroyed',\n        operation: 'destroy',\n        retry: false,\n      },\n    });\n  }\n\n}\n\n// Export convenience function for creating SDK instances\nexport function createACubeSDK(config: ACubeSDKConfig): ACubeSDK {\n  return new ACubeSDK(config);\n}\n\n// Export default configuration\nexport { DEFAULT_SDK_CONFIG };","/**\n * Branded types for type-safe IDs and values\n * Prevents mixing different types of IDs at compile time\n */\n\n// Base branded type utility\ndeclare const __brand: unique symbol;\ntype Brand<T, TBrand> = T & { [__brand]: TBrand };\n\n// ID Types\nexport type ReceiptId = Brand<string, 'ReceiptId'>;\nexport type CashierId = Brand<number, 'CashierId'>;\nexport type PEMId = Brand<string, 'PEMId'>;\nexport type MerchantId = Brand<string, 'MerchantId'>;\nexport type PointOfSaleId = Brand<string, 'PointOfSaleId'>;\nexport type CashRegisterId = Brand<string, 'CashRegisterId'>;\nexport type SerialNumber = Brand<string, 'SerialNumber'>;\nexport type FiscalId = Brand<string, 'FiscalId'>;\nexport type DocumentNumber = Brand<string, 'DocumentNumber'>;\n\n// Value Types\nexport type Amount = Brand<string, 'Amount'>;\nexport type VATRate = Brand<string, 'VATRate'>;\nexport type Quantity = Brand<string, 'Quantity'>;\n\n// Utility functions to create branded types\nexport const createReceiptId = (id: string): ReceiptId => id as ReceiptId;\nexport const createCashierId = (id: number): CashierId => id as CashierId;\nexport const createPEMId = (id: string): PEMId => id as PEMId;\nexport const createMerchantId = (id: string): MerchantId => id as MerchantId;\nexport const createPointOfSaleId = (id: string): PointOfSaleId => id as PointOfSaleId;\nexport const createCashRegisterId = (id: string): CashRegisterId => id as CashRegisterId;\nexport const createSerialNumber = (sn: string): SerialNumber => sn as SerialNumber;\nexport const createFiscalId = (id: string): FiscalId => id as FiscalId;\nexport const createDocumentNumber = (dn: string): DocumentNumber => dn as DocumentNumber;\n\nexport const createAmount = (amount: string): Amount => amount as Amount;\nexport const createVATRate = (rate: string): VATRate => rate as VATRate;\nexport const createQuantity = (qty: string): Quantity => qty as Quantity;\n\n// Type guards\nexport const isReceiptId = (value: unknown): value is ReceiptId => \n  typeof value === 'string' && value.length > 0;\n\nexport const isCashierId = (value: unknown): value is CashierId => \n  typeof value === 'number' && value > 0;\n\nexport const isFiscalId = (value: unknown): value is FiscalId => \n  typeof value === 'string' && /^\\d{11}$/.test(value);\n\nexport const isAmount = (value: unknown): value is Amount => \n  typeof value === 'string' && /^\\d+\\.\\d{2,8}$/.test(value);\n\nexport const isMerchantId = (value: unknown): value is MerchantId => \n  typeof value === 'string' && value.length > 0;\n\nexport const isPointOfSaleId = (value: unknown): value is PointOfSaleId => \n  typeof value === 'string' && value.length > 0;\n\nexport const isSerialNumber = (value: unknown): value is SerialNumber => \n  typeof value === 'string' && value.length > 0;\n\nexport const isPEMId = (value: unknown): value is PEMId => \n  typeof value === 'string' && value.length > 0;\n\nexport const isQuantity = (value: unknown): value is Quantity => \n  typeof value === 'string' && /^\\d+(\\.\\d{1,6})?$/.test(value);","/**\n * Type-safe event system for SDK\n * Discriminated unions ensure type safety for event payloads\n */\n\nimport type { \n  ReceiptId, \n  CashierId, \n  PEMId, \n  MerchantId, \n  DocumentNumber,\n  SerialNumber \n} from './branded.js';\n\n// Core event base\ninterface BaseEvent {\n  timestamp: Date;\n  requestId: string;\n}\n\n// Receipt Events\nexport interface ReceiptCreatedEvent extends BaseEvent {\n  type: 'receipt.created';\n  data: {\n    receiptId: ReceiptId;\n    amount: string;\n    fiscalId: string;\n    cashierId?: CashierId;\n    pemId?: PEMId;\n  };\n}\n\nexport interface ReceiptVoidedEvent extends BaseEvent {\n  type: 'receipt.voided';\n  data: {\n    receiptId: ReceiptId;\n    originalReceiptId: ReceiptId;\n    reason: string;\n    documentNumber?: DocumentNumber;\n  };\n}\n\nexport interface ReceiptReturnedEvent extends BaseEvent {\n  type: 'receipt.returned';\n  data: {\n    receiptId: ReceiptId;\n    originalReceiptId: ReceiptId;\n    returnedItems: Array<{\n      description: string;\n      quantity: string;\n      amount: string;\n    }>;\n  };\n}\n\nexport interface ReceiptTransmittedEvent extends BaseEvent {\n  type: 'receipt.transmitted';\n  data: {\n    receiptId: ReceiptId;\n    documentNumber: DocumentNumber;\n    transmissionDate: Date;\n    fiscalResponse: unknown;\n  };\n}\n\n// PEM Events\nexport interface PEMActivatedEvent extends BaseEvent {\n  type: 'pem.activated';\n  data: {\n    pemId: PEMId;\n    serialNumber: SerialNumber;\n    activationKey: string;\n    status: 'ACTIVE';\n  };\n}\n\nexport interface PEMStatusChangedEvent extends BaseEvent {\n  type: 'pem.status_changed';\n  data: {\n    pemId: PEMId;\n    serialNumber: SerialNumber;\n    previousStatus: string;\n    newStatus: string;\n    reason?: string;\n  };\n}\n\n// Cashier Events\nexport interface CashierCreatedEvent extends BaseEvent {\n  type: 'cashier.created';\n  data: {\n    cashierId: CashierId;\n    email: string;\n    merchantId: MerchantId;\n  };\n}\n\nexport interface CashierDeletedEvent extends BaseEvent {\n  type: 'cashier.deleted';\n  data: {\n    cashierId: CashierId;\n    email: string;\n  };\n}\n\n// Merchant Events\nexport interface MerchantCreatedEvent extends BaseEvent {\n  type: 'merchant.created';\n  data: {\n    merchantId: MerchantId;\n    fiscalId: string;\n    name: string;\n    email: string;\n  };\n}\n\nexport interface MerchantUpdatedEvent extends BaseEvent {\n  type: 'merchant.updated';\n  data: {\n    merchantId: MerchantId;\n    changes: Record<string, unknown>;\n  };\n}\n\n// Error Events\nexport interface ErrorEvent extends BaseEvent {\n  type: 'error';\n  data: {\n    errorCode: string;\n    errorMessage: string;\n    operation: string;\n    retry: boolean;\n    context?: Record<string, unknown>;\n  };\n}\n\n// Authentication Events\nexport interface AuthenticationEvent extends BaseEvent {\n  type: 'auth.success' | 'auth.failed' | 'auth.expired' | 'auth.refreshed' | 'auth.error' | 'auth.logout';\n  data: {\n    userId?: string;\n    role?: 'provider' | 'merchant' | 'cashier';\n    expiresAt?: Date;\n    error?: string;\n    errorCode?: string;\n    errorMessage?: string;\n    operation?: string;\n    retry?: boolean;\n    context?: Record<string, unknown>;\n    reason?: string;\n    user?: unknown;\n    sessionId?: string;\n  };\n}\n\n// Union type of all events\nexport type ACubeSDKEvent = \n  | ReceiptCreatedEvent\n  | ReceiptVoidedEvent\n  | ReceiptReturnedEvent\n  | ReceiptTransmittedEvent\n  | PEMActivatedEvent\n  | PEMStatusChangedEvent\n  | CashierCreatedEvent\n  | CashierDeletedEvent\n  | MerchantCreatedEvent\n  | MerchantUpdatedEvent\n  | ErrorEvent\n  | AuthenticationEvent;\n\n// Event type map for type-safe event emission/listening\nexport type EventTypeMap = {\n  [K in ACubeSDKEvent['type']]: Extract<ACubeSDKEvent, { type: K }>['data'];\n};\n\n// Webhook event (subset of SDK events that come from server)\nexport type WebhookEvent = Extract<\n  ACubeSDKEvent,\n  | ReceiptTransmittedEvent\n  | PEMActivatedEvent\n  | PEMStatusChangedEvent\n  | ErrorEvent\n>;\n\n// Client event (events generated by SDK locally)\nexport type ClientEvent = Exclude<ACubeSDKEvent, WebhookEvent>;","/**\n * Base Storage Adapter Interface\n * Provides cross-platform storage abstraction for the queue system\n */\n\nexport interface StorageAdapter {\n  /**\n   * Initialize the storage adapter\n   */\n  initialize(): Promise<void>;\n\n  /**\n   * Store data with optional expiration\n   */\n  set(key: string, value: any, options?: StorageOptions): Promise<void>;\n\n  /**\n   * Retrieve data\n   */\n  get<T = any>(key: string): Promise<T | null>;\n\n  /**\n   * Check if key exists\n   */\n  has(key: string): Promise<boolean>;\n\n  /**\n   * Remove data\n   */\n  remove(key: string): Promise<void>;\n\n  /**\n   * Clear all data (optionally by prefix)\n   */\n  clear(prefix?: string): Promise<void>;\n\n  /**\n   * Get all keys (optionally by prefix)\n   */\n  keys(prefix?: string): Promise<string[]>;\n\n  /**\n   * Get multiple values by keys\n   */\n  getMany<T = any>(keys: string[]): Promise<(T | null)[]>;\n\n  /**\n   * Set multiple key-value pairs atomically\n   */\n  setMany(items: Array<{ key: string; value: any; options?: StorageOptions }>): Promise<void>;\n\n  /**\n   * Remove multiple keys atomically\n   */\n  removeMany(keys: string[]): Promise<void>;\n\n  /**\n   * Get storage statistics\n   */\n  getStats(): Promise<StorageStats>;\n\n  /**\n   * Cleanup expired entries\n   */\n  cleanup(): Promise<void>;\n\n  /**\n   * Destroy the storage adapter\n   */\n  destroy(): Promise<void>;\n}\n\nexport interface StorageOptions {\n  /**\n   * Expiration time in milliseconds\n   */\n  expiresIn?: number;\n\n  /**\n   * Custom serialization\n   */\n  serialize?: boolean;\n\n  /**\n   * Storage priority (affects cleanup order)\n   */\n  priority?: 'low' | 'normal' | 'high' | 'critical';\n}\n\nexport interface StorageStats {\n  totalKeys: number;\n  totalSize: number;\n  availableSpace?: number;\n  lastCleanup: number;\n  expiredKeys: number;\n}\n\nexport interface StorageItem<T = any> {\n  value: T;\n  createdAt: number;\n  updatedAt: number;\n  expiresAt?: number;\n  priority: StorageOptions['priority'];\n  size: number;\n}\n\n/**\n * Abstract base class for storage adapters\n */\nexport abstract class BaseStorageAdapter implements StorageAdapter {\n  protected isInitialized = false;\n  protected stats: StorageStats = {\n    totalKeys: 0,\n    totalSize: 0,\n    lastCleanup: 0,\n    expiredKeys: 0,\n  };\n\n  abstract initialize(): Promise<void>;\n  abstract set(key: string, value: any, options?: StorageOptions): Promise<void>;\n  abstract get<T = any>(key: string): Promise<T | null>;\n  abstract has(key: string): Promise<boolean>;\n  abstract remove(key: string): Promise<void>;\n  abstract clear(prefix?: string): Promise<void>;\n  abstract keys(prefix?: string): Promise<string[]>;\n  abstract getMany<T = any>(keys: string[]): Promise<(T | null)[]>;\n  abstract setMany(items: Array<{ key: string; value: any; options?: StorageOptions }>): Promise<void>;\n  abstract removeMany(keys: string[]): Promise<void>;\n  abstract cleanup(): Promise<void>;\n  abstract destroy(): Promise<void>;\n\n  async getStats(): Promise<StorageStats> {\n    return { ...this.stats };\n  }\n\n  protected ensureInitialized(): void {\n    if (!this.isInitialized) {\n      throw new Error('Storage adapter not initialized. Call initialize() first.');\n    }\n  }\n\n  protected createStorageItem<T>(value: T, options: StorageOptions = {}): StorageItem<T> {\n    const now = Date.now();\n    const item: StorageItem<T> = {\n      value,\n      createdAt: now,\n      updatedAt: now,\n      priority: options.priority ?? 'normal',\n      size: this.calculateSize(value),\n    };\n    \n    // Only add expiresAt if we have a value (exactOptionalPropertyTypes compliance)\n    if (options.expiresIn) {\n      item.expiresAt = now + options.expiresIn;\n    }\n    \n    return item;\n  }\n\n  protected isExpired(item: StorageItem): boolean {\n    return item.expiresAt ? Date.now() > item.expiresAt : false;\n  }\n\n  protected calculateSize(value: any): number {\n    try {\n      return JSON.stringify(value).length * 2; // Rough estimate (UTF-16)\n    } catch {\n      return 0;\n    }\n  }\n\n  protected updateStats(keyDelta: number, sizeDelta: number): void {\n    this.stats.totalKeys = Math.max(0, this.stats.totalKeys + keyDelta);\n    this.stats.totalSize = Math.max(0, this.stats.totalSize + sizeDelta);\n  }\n}","/**\n * Web Storage Adapter - IndexedDB with localStorage fallback\n * Enterprise-grade storage for web environments\n */\n\nimport { BaseStorageAdapter, StorageOptions } from '@/storage/base/storage-adapter';\n\nexport interface WebStorageConfig {\n  dbName: string;\n  dbVersion: number;\n  storeName: string;\n  fallbackToLocalStorage: boolean;\n  quota?: number;\n}\n\nconst DEFAULT_CONFIG: Required<WebStorageConfig> = {\n  dbName: 'acube-queue-storage',\n  dbVersion: 1,\n  storeName: 'queue-items',\n  fallbackToLocalStorage: true,\n  quota: 100 * 1024 * 1024, // 100MB\n};\n\nexport class WebStorageAdapter extends BaseStorageAdapter {\n  private config: Required<WebStorageConfig>;\n  private db: IDBDatabase | null = null;\n  private useIndexedDB = false;\n\n  constructor(config: Partial<WebStorageConfig> = {}) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      // Try IndexedDB first\n      await this.initializeIndexedDB();\n      this.useIndexedDB = true;\n    } catch (error) {\n      console.warn('IndexedDB initialization failed, falling back to localStorage:', error);\n      \n      if (this.config.fallbackToLocalStorage && typeof localStorage !== 'undefined') {\n        await this.initializeLocalStorage();\n        this.useIndexedDB = false;\n      } else {\n        throw new Error('No storage backend available');\n      }\n    }\n\n    this.isInitialized = true;\n    await this.loadStats();\n  }\n\n  private async initializeIndexedDB(): Promise<void> {\n    if (typeof indexedDB === 'undefined') {\n      throw new Error('IndexedDB not available');\n    }\n\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.config.dbName, this.config.dbVersion);\n\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve();\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        \n        // Create object store if it doesn't exist\n        if (!db.objectStoreNames.contains(this.config.storeName)) {\n          const store = db.createObjectStore(this.config.storeName, { keyPath: 'key' });\n          store.createIndex('expiresAt', 'expiresAt', { unique: false });\n          store.createIndex('priority', 'priority', { unique: false });\n          store.createIndex('createdAt', 'createdAt', { unique: false });\n        }\n      };\n    });\n  }\n\n  private async initializeLocalStorage(): Promise<void> {\n    if (typeof localStorage === 'undefined') {\n      throw new Error('localStorage not available');\n    }\n    // localStorage is synchronous, so no initialization needed\n  }\n\n  async set(key: string, value: any, options: StorageOptions = {}): Promise<void> {\n    this.ensureInitialized();\n\n    const item = this.createStorageItem(value, options);\n    const storageItem = { key, ...item };\n\n    if (this.useIndexedDB) {\n      await this.setIndexedDB(key, storageItem);\n    } else {\n      await this.setLocalStorage(key, storageItem);\n    }\n\n    this.updateStats(1, item.size);\n  }\n\n  private async setIndexedDB(key: string, item: any): Promise<void> {\n    if (!this.db) throw new Error('IndexedDB not initialized');\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.config.storeName], 'readwrite');\n      const store = transaction.objectStore(this.config.storeName);\n      const request = store.put(item, key);\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  private async setLocalStorage(key: string, item: any): Promise<void> {\n    try {\n      const serialized = JSON.stringify(item);\n      localStorage.setItem(`${this.config.dbName}:${key}`, serialized);\n    } catch (error) {\n      if (error instanceof DOMException && error.name === 'QuotaExceededError') {\n        await this.cleanup();\n        // Retry once after cleanup\n        const serialized = JSON.stringify(item);\n        localStorage.setItem(`${this.config.dbName}:${key}`, serialized);\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async get<T = any>(key: string): Promise<T | null> {\n    this.ensureInitialized();\n\n    if (this.useIndexedDB) {\n      return this.getIndexedDB<T>(key);\n    } else {\n      return this.getLocalStorage<T>(key);\n    }\n  }\n\n  private async getIndexedDB<T>(key: string): Promise<T | null> {\n    if (!this.db) throw new Error('IndexedDB not initialized');\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.config.storeName], 'readonly');\n      const store = transaction.objectStore(this.config.storeName);\n      const request = store.get(key);\n\n      request.onsuccess = () => {\n        const result = request.result;\n        if (!result) {\n          resolve(null);\n          return;\n        }\n\n        if (this.isExpired(result)) {\n          // Remove expired item\n          this.remove(key);\n          resolve(null);\n          return;\n        }\n\n        resolve(result.value);\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  private async getLocalStorage<T>(key: string): Promise<T | null> {\n    try {\n      const serialized = localStorage.getItem(`${this.config.dbName}:${key}`);\n      if (!serialized) return null;\n\n      const item = JSON.parse(serialized);\n      if (this.isExpired(item)) {\n        await this.remove(key);\n        return null;\n      }\n\n      return item.value;\n    } catch {\n      return null;\n    }\n  }\n\n  async has(key: string): Promise<boolean> {\n    this.ensureInitialized();\n\n    if (this.useIndexedDB) {\n      return this.hasIndexedDB(key);\n    } else {\n      return this.hasLocalStorage(key);\n    }\n  }\n\n  private async hasIndexedDB(key: string): Promise<boolean> {\n    const value = await this.getIndexedDB(key);\n    return value !== null;\n  }\n\n  private async hasLocalStorage(key: string): Promise<boolean> {\n    const value = await this.getLocalStorage(key);\n    return value !== null;\n  }\n\n  async remove(key: string): Promise<void> {\n    this.ensureInitialized();\n\n    if (this.useIndexedDB) {\n      await this.removeIndexedDB(key);\n    } else {\n      await this.removeLocalStorage(key);\n    }\n\n    this.updateStats(-1, 0);\n  }\n\n  private async removeIndexedDB(key: string): Promise<void> {\n    if (!this.db) throw new Error('IndexedDB not initialized');\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.config.storeName], 'readwrite');\n      const store = transaction.objectStore(this.config.storeName);\n      const request = store.delete(key);\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  private async removeLocalStorage(key: string): Promise<void> {\n    localStorage.removeItem(`${this.config.dbName}:${key}`);\n  }\n\n  async clear(prefix?: string): Promise<void> {\n    this.ensureInitialized();\n\n    if (this.useIndexedDB) {\n      await this.clearIndexedDB(prefix);\n    } else {\n      await this.clearLocalStorage(prefix);\n    }\n\n    this.stats.totalKeys = 0;\n    this.stats.totalSize = 0;\n  }\n\n  private async clearIndexedDB(prefix?: string): Promise<void> {\n    if (!this.db) throw new Error('IndexedDB not initialized');\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.config.storeName], 'readwrite');\n      const store = transaction.objectStore(this.config.storeName);\n\n      if (!prefix) {\n        const request = store.clear();\n        request.onsuccess = () => resolve();\n        request.onerror = () => reject(request.error);\n      } else {\n        const request = store.openCursor();\n        request.onsuccess = (event) => {\n          const cursor = (event.target as IDBRequest).result;\n          if (cursor) {\n            if (cursor.key.toString().startsWith(prefix)) {\n              cursor.delete();\n            }\n            cursor.continue();\n          } else {\n            resolve();\n          }\n        };\n        request.onerror = () => reject(request.error);\n      }\n    });\n  }\n\n  private async clearLocalStorage(prefix?: string): Promise<void> {\n    const keysToRemove: string[] = [];\n    \n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && key.startsWith(`${this.config.dbName}:`)) {\n        if (!prefix || key.substring(this.config.dbName.length + 1).startsWith(prefix)) {\n          keysToRemove.push(key);\n        }\n      }\n    }\n\n    keysToRemove.forEach(key => localStorage.removeItem(key));\n  }\n\n  async keys(prefix?: string): Promise<string[]> {\n    this.ensureInitialized();\n\n    if (this.useIndexedDB) {\n      return this.keysIndexedDB(prefix);\n    } else {\n      return this.keysLocalStorage(prefix);\n    }\n  }\n\n  private async keysIndexedDB(prefix?: string): Promise<string[]> {\n    if (!this.db) throw new Error('IndexedDB not initialized');\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.config.storeName], 'readonly');\n      const store = transaction.objectStore(this.config.storeName);\n      const request = store.getAllKeys();\n\n      request.onsuccess = () => {\n        let keys = request.result.map(k => k.toString());\n        if (prefix) {\n          keys = keys.filter(key => key.startsWith(prefix));\n        }\n        resolve(keys);\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  private async keysLocalStorage(prefix?: string): Promise<string[]> {\n    const keys: string[] = [];\n    \n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && key.startsWith(`${this.config.dbName}:`)) {\n        const actualKey = key.substring(this.config.dbName.length + 1);\n        if (!prefix || actualKey.startsWith(prefix)) {\n          keys.push(actualKey);\n        }\n      }\n    }\n\n    return keys;\n  }\n\n  async getMany<T = any>(keys: string[]): Promise<(T | null)[]> {\n    this.ensureInitialized();\n    return Promise.all(keys.map(key => this.get<T>(key)));\n  }\n\n  async setMany(items: Array<{ key: string; value: any; options?: StorageOptions }>): Promise<void> {\n    this.ensureInitialized();\n    await Promise.all(items.map(item => this.set(item.key, item.value, item.options)));\n  }\n\n  async removeMany(keys: string[]): Promise<void> {\n    this.ensureInitialized();\n    await Promise.all(keys.map(key => this.remove(key)));\n  }\n\n  async cleanup(): Promise<void> {\n    this.ensureInitialized();\n\n    const now = Date.now();\n    let cleanedCount = 0;\n\n    if (this.useIndexedDB) {\n      cleanedCount = await this.cleanupIndexedDB();\n    } else {\n      cleanedCount = await this.cleanupLocalStorage();\n    }\n\n    this.stats.lastCleanup = now;\n    this.stats.expiredKeys = cleanedCount;\n  }\n\n  private async cleanupIndexedDB(): Promise<number> {\n    if (!this.db) throw new Error('IndexedDB not initialized');\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.config.storeName], 'readwrite');\n      const store = transaction.objectStore(this.config.storeName);\n      const index = store.index('expiresAt');\n      const now = Date.now();\n      let cleanedCount = 0;\n\n      const request = index.openCursor(IDBKeyRange.upperBound(now));\n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor) {\n          cursor.delete();\n          cleanedCount++;\n          cursor.continue();\n        } else {\n          resolve(cleanedCount);\n        }\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  private async cleanupLocalStorage(): Promise<number> {\n    const keys = await this.keysLocalStorage();\n    let cleanedCount = 0;\n\n    for (const key of keys) {\n      try {\n        const serialized = localStorage.getItem(`${this.config.dbName}:${key}`);\n        if (serialized) {\n          const item = JSON.parse(serialized);\n          if (this.isExpired(item)) {\n            localStorage.removeItem(`${this.config.dbName}:${key}`);\n            cleanedCount++;\n          }\n        }\n      } catch {\n        // Remove corrupted items\n        localStorage.removeItem(`${this.config.dbName}:${key}`);\n        cleanedCount++;\n      }\n    }\n\n    return cleanedCount;\n  }\n\n  private async loadStats(): Promise<void> {\n    try {\n      const keys = await this.keys();\n      this.stats.totalKeys = keys.length;\n      \n      // Calculate total size (approximation)\n      let totalSize = 0;\n      for (const key of keys.slice(0, 100)) { // Sample first 100 keys\n        const value = await this.get(key);\n        if (value) {\n          totalSize += this.calculateSize(value);\n        }\n      }\n      \n      // Extrapolate for all keys\n      this.stats.totalSize = Math.round((totalSize / Math.min(keys.length, 100)) * keys.length);\n    } catch (error) {\n      console.warn('Failed to load storage stats:', error);\n    }\n  }\n\n  async destroy(): Promise<void> {\n    if (this.db) {\n      this.db.close();\n      this.db = null;\n    }\n    \n    if (!this.useIndexedDB) {\n      await this.clearLocalStorage();\n    }\n\n    this.isInitialized = false;\n  }\n}","/**\n * React Native Storage Adapter - AsyncStorage with Keychain integration\n * Enterprise-grade storage for React Native environments\n */\n\nimport { BaseStorageAdapter, StorageOptions, StorageItem } from '@/storage/base/storage-adapter';\n\n// Platform detection\nconst isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';\n\nexport interface ReactNativeStorageConfig {\n  keyPrefix: string;\n  useKeychain: boolean;\n  keychainService: string;\n  quota?: number;\n  encryptSensitiveData: boolean;\n}\n\nconst DEFAULT_CONFIG: Required<ReactNativeStorageConfig> = {\n  keyPrefix: 'acube-queue',\n  useKeychain: false,\n  keychainService: 'acube-sdk',\n  quota: 50 * 1024 * 1024, // 50MB\n  encryptSensitiveData: true,\n};\n\nexport class ReactNativeStorageAdapter extends BaseStorageAdapter {\n  private config: Required<ReactNativeStorageConfig>;\n  private AsyncStorage: any;\n  private Keychain: any;\n\n  constructor(config: Partial<ReactNativeStorageConfig> = {}) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    if (!isReactNative) {\n      throw new Error('ReactNativeStorageAdapter can only be used in React Native environment');\n    }\n\n    try {\n      // Dynamically import React Native modules\n      const AsyncStorageModule = await import('@react-native-async-storage/async-storage');\n      this.AsyncStorage = AsyncStorageModule.default;\n\n      if (this.config.useKeychain) {\n        const KeychainModule = await import('react-native-keychain');\n        this.Keychain = KeychainModule;\n      }\n    } catch (error) {\n      throw new Error(`Failed to initialize React Native storage modules: ${error}`);\n    }\n\n    this.isInitialized = true;\n    await this.loadStats();\n  }\n\n  async set(key: string, value: any, options: StorageOptions = {}): Promise<void> {\n    this.ensureInitialized();\n\n    const item = this.createStorageItem(value, options);\n    const storageKey = this.getPrefixedKey(key);\n\n    try {\n      if (this.shouldUseKeychain(key, options)) {\n        await this.setKeychain(storageKey, item);\n      } else {\n        await this.setAsyncStorage(storageKey, item);\n      }\n\n      this.updateStats(1, item.size);\n    } catch (error) {\n      throw new Error(`Failed to store item: ${error}`);\n    }\n  }\n\n  private shouldUseKeychain(_key: string, options: StorageOptions): boolean {\n    return (\n      this.config.useKeychain &&\n      this.Keychain &&\n      (this.config.encryptSensitiveData || options.priority === 'critical')\n    );\n  }\n\n  private async setKeychain(key: string, item: StorageItem): Promise<void> {\n    if (!this.Keychain) throw new Error('Keychain not available');\n\n    const serialized = JSON.stringify(item);\n    await this.Keychain.setInternetCredentials(\n      this.config.keychainService,\n      key,\n      serialized\n    );\n  }\n\n  private async setAsyncStorage(key: string, item: StorageItem): Promise<void> {\n    const serialized = JSON.stringify(item);\n    await this.AsyncStorage.setItem(key, serialized);\n  }\n\n  async get<T = any>(key: string): Promise<T | null> {\n    this.ensureInitialized();\n\n    const storageKey = this.getPrefixedKey(key);\n\n    try {\n      let item: StorageItem | null = null;\n\n      // Try keychain first if available\n      if (this.config.useKeychain && this.Keychain) {\n        try {\n          const credentials = await this.Keychain.getInternetCredentials(this.config.keychainService);\n          if (credentials && credentials.username === storageKey) {\n            item = JSON.parse(credentials.password);\n          }\n        } catch {\n          // Fall through to AsyncStorage\n        }\n      }\n\n      // Try AsyncStorage if not found in keychain\n      if (!item) {\n        const serialized = await this.AsyncStorage.getItem(storageKey);\n        if (serialized) {\n          item = JSON.parse(serialized);\n        }\n      }\n\n      if (!item) return null;\n\n      if (this.isExpired(item)) {\n        await this.remove(key);\n        return null;\n      }\n\n      return item.value;\n    } catch (error) {\n      console.warn(`Failed to get item ${key}:`, error);\n      return null;\n    }\n  }\n\n  async has(key: string): Promise<boolean> {\n    const value = await this.get(key);\n    return value !== null;\n  }\n\n  async remove(key: string): Promise<void> {\n    this.ensureInitialized();\n\n    const storageKey = this.getPrefixedKey(key);\n\n    try {\n      // Remove from both keychain and AsyncStorage\n      if (this.config.useKeychain && this.Keychain) {\n        try {\n          await this.Keychain.resetInternetCredentials(this.config.keychainService);\n        } catch {\n          // Ignore keychain errors\n        }\n      }\n\n      await this.AsyncStorage.removeItem(storageKey);\n      this.updateStats(-1, 0);\n    } catch (error) {\n      throw new Error(`Failed to remove item: ${error}`);\n    }\n  }\n\n  async clear(prefix?: string): Promise<void> {\n    this.ensureInitialized();\n\n    try {\n      const keys = await this.keys(prefix);\n      await this.removeMany(keys);\n\n      // Clear keychain if used\n      if (this.config.useKeychain && this.Keychain) {\n        try {\n          await this.Keychain.resetInternetCredentials(this.config.keychainService);\n        } catch {\n          // Ignore keychain errors\n        }\n      }\n\n      this.stats.totalKeys = 0;\n      this.stats.totalSize = 0;\n    } catch (error) {\n      throw new Error(`Failed to clear storage: ${error}`);\n    }\n  }\n\n  async keys(prefix?: string): Promise<string[]> {\n    this.ensureInitialized();\n\n    try {\n      const allKeys = await this.AsyncStorage.getAllKeys();\n      let filteredKeys = allKeys.filter((key: string) => \n        key.startsWith(this.config.keyPrefix)\n      );\n\n      // Remove prefix from keys\n      filteredKeys = filteredKeys.map((key: string) => \n        key.substring(this.config.keyPrefix.length + 1)\n      );\n\n      if (prefix) {\n        filteredKeys = filteredKeys.filter((key: string) => key.startsWith(prefix));\n      }\n\n      return filteredKeys;\n    } catch (error) {\n      throw new Error(`Failed to get keys: ${error}`);\n    }\n  }\n\n  async getMany<T = any>(keys: string[]): Promise<(T | null)[]> {\n    this.ensureInitialized();\n\n    try {\n      const prefixedKeys = keys.map(key => this.getPrefixedKey(key));\n      const results = await this.AsyncStorage.multiGet(prefixedKeys);\n\n      return results.map(([key, value]: [string, string | null]) => {\n        if (!value) return null;\n\n        try {\n          const item: StorageItem = JSON.parse(value);\n          if (this.isExpired(item)) {\n            // Remove expired item asynchronously\n            const originalKey = key.substring(this.config.keyPrefix.length + 1);\n            this.remove(originalKey);\n            return null;\n          }\n          return item.value;\n        } catch {\n          return null;\n        }\n      });\n    } catch (error) {\n      throw new Error(`Failed to get multiple items: ${error}`);\n    }\n  }\n\n  async setMany(items: Array<{ key: string; value: any; options?: StorageOptions }>): Promise<void> {\n    this.ensureInitialized();\n\n    try {\n      const asyncStorageItems: Array<[string, string]> = [];\n      const keychainItems: Array<{ key: string; item: StorageItem }> = [];\n\n      for (const { key, value, options = {} } of items) {\n        const item = this.createStorageItem(value, options);\n        const storageKey = this.getPrefixedKey(key);\n\n        if (this.shouldUseKeychain(key, options)) {\n          keychainItems.push({ key: storageKey, item });\n        } else {\n          asyncStorageItems.push([storageKey, JSON.stringify(item)]);\n        }\n\n        this.updateStats(1, item.size);\n      }\n\n      // Set AsyncStorage items\n      if (asyncStorageItems.length > 0) {\n        await this.AsyncStorage.multiSet(asyncStorageItems);\n      }\n\n      // Set Keychain items\n      for (const { key, item } of keychainItems) {\n        await this.setKeychain(key, item);\n      }\n    } catch (error) {\n      throw new Error(`Failed to set multiple items: ${error}`);\n    }\n  }\n\n  async removeMany(keys: string[]): Promise<void> {\n    this.ensureInitialized();\n\n    try {\n      const prefixedKeys = keys.map(key => this.getPrefixedKey(key));\n      await this.AsyncStorage.multiRemove(prefixedKeys);\n\n      // Clear keychain for these keys if used\n      if (this.config.useKeychain && this.Keychain) {\n        try {\n          await this.Keychain.resetInternetCredentials(this.config.keychainService);\n        } catch {\n          // Ignore keychain errors\n        }\n      }\n\n      this.updateStats(-keys.length, 0);\n    } catch (error) {\n      throw new Error(`Failed to remove multiple items: ${error}`);\n    }\n  }\n\n  async cleanup(): Promise<void> {\n    this.ensureInitialized();\n\n    const now = Date.now();\n    let cleanedCount = 0;\n\n    try {\n      const keys = await this.keys();\n      const expiredKeys: string[] = [];\n\n      for (const key of keys) {\n        try {\n          const storageKey = this.getPrefixedKey(key);\n          const serialized = await this.AsyncStorage.getItem(storageKey);\n          \n          if (serialized) {\n            const item: StorageItem = JSON.parse(serialized);\n            if (this.isExpired(item)) {\n              expiredKeys.push(key);\n            }\n          }\n        } catch {\n          // Remove corrupted items\n          expiredKeys.push(key);\n        }\n      }\n\n      if (expiredKeys.length > 0) {\n        await this.removeMany(expiredKeys);\n        cleanedCount = expiredKeys.length;\n      }\n\n      this.stats.lastCleanup = now;\n      this.stats.expiredKeys = cleanedCount;\n    } catch (error) {\n      console.warn('Cleanup failed:', error);\n    }\n  }\n\n  private async loadStats(): Promise<void> {\n    try {\n      const keys = await this.keys();\n      this.stats.totalKeys = keys.length;\n\n      // Calculate total size (sample approach for performance)\n      let totalSize = 0;\n      const sampleSize = Math.min(keys.length, 50);\n      \n      for (let i = 0; i < sampleSize; i++) {\n        const key = keys[i];\n        if (!key) continue;\n        const value = await this.get(key);\n        if (value) {\n          totalSize += this.calculateSize(value);\n        }\n      }\n\n      // Extrapolate total size\n      this.stats.totalSize = Math.round((totalSize / sampleSize) * keys.length);\n    } catch (error) {\n      console.warn('Failed to load storage stats:', error);\n    }\n  }\n\n  private getPrefixedKey(key: string): string {\n    return `${this.config.keyPrefix}:${key}`;\n  }\n\n  async destroy(): Promise<void> {\n    await this.clear();\n    this.isInitialized = false;\n  }\n}","/**\n * Conflict Resolution System\n * Enterprise-grade conflict resolution for offline-first operations\n */\n\nimport type { \n  QueueItem, \n  ConflictResolutionStrategy, \n  ConflictResolver,\n  ResourceType,\n  QueueOperationType \n} from './types';\n\nexport interface ConflictContext {\n  resource: ResourceType;\n  operation: QueueOperationType;\n  localTimestamp: number;\n  serverTimestamp: number;\n  clientId: string;\n  conflictType: ConflictType;\n}\n\nexport type ConflictType = \n  | 'version-mismatch'      // Local and server versions differ\n  | 'concurrent-modification' // Multiple clients modified same resource\n  | 'stale-data'           // Local data is outdated\n  | 'missing-dependency'   // Required dependency not found\n  | 'validation-error'     // Data doesn't pass server validation\n  | 'permission-denied'    // Insufficient permissions\n  | 'resource-locked'      // Resource is locked by another operation\n  | 'schema-incompatible'; // Data schema incompatible with server\n\nexport interface ConflictResolution<T = any> {\n  strategy: ConflictResolutionStrategy;\n  resolvedData: T;\n  requiresUserInput: boolean;\n  metadata: {\n    conflictType: ConflictType;\n    resolutionReason: string;\n    dataSource: 'client' | 'server' | 'merged' | 'manual';\n    confidence: number; // 0-1, how confident we are in the resolution\n    preservedFields?: string[];\n    discardedFields?: string[];\n  };\n}\n\nexport interface MergeRule {\n  field: string;\n  strategy: 'client' | 'server' | 'latest' | 'merge-array' | 'custom';\n  customResolver?: (clientValue: any, serverValue: any, context: ConflictContext) => any;\n}\n\nexport interface ConflictResolverConfig {\n  defaultStrategy: ConflictResolutionStrategy;\n  mergeRules: Record<ResourceType, MergeRule[]>;\n  userInputTimeout: number;\n  maxResolutionAttempts: number;\n  enableAutoResolution: boolean;\n  confidenceThreshold: number;\n}\n\nexport class ConflictResolverManager {\n  private config: ConflictResolverConfig;\n  private customResolvers: Map<string, ConflictResolver> = new Map();\n  private pendingUserInputs: Map<string, ConflictResolution> = new Map();\n  private resolutionHistory: ConflictResolution[] = [];\n\n  constructor(config: Partial<ConflictResolverConfig> = {}) {\n    this.config = {\n      defaultStrategy: 'server-wins',\n      mergeRules: this.getDefaultMergeRules(),\n      userInputTimeout: 300000, // 5 minutes\n      maxResolutionAttempts: 3,\n      enableAutoResolution: true,\n      confidenceThreshold: 0.8,\n      ...config,\n    };\n  }\n\n  /**\n   * Resolve conflict between local and server data\n   */\n  async resolveConflict<T = any>(\n    localItem: QueueItem,\n    serverData: T,\n    context: ConflictContext\n  ): Promise<ConflictResolution<T>> {\n    // Check if we have a custom resolver for this resource/operation\n    const resolverKey = `${context.resource}:${context.operation}`;\n    const customResolver = this.customResolvers.get(resolverKey);\n\n    if (customResolver) {\n      try {\n        const resolved = await customResolver(localItem, serverData, context);\n        return this.createResolution('manual', resolved as T, context, 'Custom resolver applied', 1.0);\n      } catch (error) {\n        console.warn(`Custom resolver failed for ${resolverKey}:`, error);\n        // Fall back to default strategy\n      }\n    }\n\n    // Use configured strategy for this item\n    const strategy = localItem.conflictResolution || this.config.defaultStrategy;\n    \n    switch (strategy) {\n      case 'client-wins':\n        return this.resolveClientWins(localItem, serverData, context);\n      \n      case 'server-wins':\n        return this.resolveServerWins(localItem, serverData, context);\n      \n      case 'merge':\n        return this.resolveMerge(localItem, serverData, context);\n      \n      case 'manual':\n        return this.resolveManual(localItem, serverData, context);\n      \n      default:\n        return this.resolveServerWins(localItem, serverData, context);\n    }\n  }\n\n  /**\n   * Register custom conflict resolver\n   */\n  registerResolver(\n    resource: ResourceType,\n    operation: QueueOperationType,\n    resolver: ConflictResolver\n  ): void {\n    const key = `${resource}:${operation}`;\n    this.customResolvers.set(key, resolver);\n  }\n\n  /**\n   * Get conflict resolution suggestions based on context\n   */\n  getResolutionSuggestions(context: ConflictContext): ConflictResolutionStrategy[] {\n    const suggestions: ConflictResolutionStrategy[] = [];\n\n    switch (context.conflictType) {\n      case 'version-mismatch':\n        if (Math.abs(context.localTimestamp - context.serverTimestamp) < 60000) {\n          suggestions.push('merge', 'client-wins', 'server-wins');\n        } else {\n          suggestions.push('server-wins', 'merge');\n        }\n        break;\n\n      case 'concurrent-modification':\n        suggestions.push('merge', 'manual', 'server-wins');\n        break;\n\n      case 'stale-data':\n        suggestions.push('server-wins', 'merge');\n        break;\n\n      case 'validation-error':\n        suggestions.push('server-wins', 'manual');\n        break;\n\n      case 'permission-denied':\n        suggestions.push('server-wins');\n        break;\n\n      default:\n        suggestions.push('server-wins', 'merge', 'client-wins');\n    }\n\n    return suggestions;\n  }\n\n  /**\n   * Analyze conflict to determine type and severity\n   */\n  analyzeConflict(localItem: QueueItem, serverData: any): ConflictContext {\n    const now = Date.now();\n    \n    // Determine conflict type based on available information\n    let conflictType: ConflictType = 'version-mismatch';\n    \n    // Check for timestamp differences\n    const timeDiff = Math.abs(localItem.updatedAt - now);\n    if (timeDiff > 300000) { // 5 minutes\n      conflictType = 'stale-data';\n    }\n\n    // Check for validation-related errors\n    if (this.hasValidationIssues(localItem.data, serverData)) {\n      conflictType = 'validation-error';\n    }\n\n    // Check for schema compatibility\n    if (this.hasSchemaIssues(localItem.data, serverData)) {\n      conflictType = 'schema-incompatible';\n    }\n\n    return {\n      resource: localItem.resource,\n      operation: localItem.operation,\n      localTimestamp: localItem.updatedAt,\n      serverTimestamp: now,\n      clientId: this.getClientId(),\n      conflictType,\n    };\n  }\n\n  /**\n   * Get resolution history for analytics\n   */\n  getResolutionHistory(): ConflictResolution[] {\n    return [...this.resolutionHistory];\n  }\n\n  /**\n   * Clear resolution history\n   */\n  clearHistory(): void {\n    this.resolutionHistory = [];\n  }\n\n  // Private resolution methods\n\n  private async resolveClientWins<T>(\n    localItem: QueueItem,\n    _serverData: T,\n    context: ConflictContext\n  ): Promise<ConflictResolution<T>> {\n    return this.createResolution(\n      'client-wins',\n      localItem.data as T,\n      context,\n      'Client data takes precedence',\n      0.7\n    );\n  }\n\n  private async resolveServerWins<T>(\n    _localItem: QueueItem,\n    serverData: T,\n    context: ConflictContext\n  ): Promise<ConflictResolution<T>> {\n    return this.createResolution(\n      'server-wins',\n      serverData,\n      context,\n      'Server data takes precedence',\n      0.9\n    );\n  }\n\n  private async resolveMerge<T>(\n    localItem: QueueItem,\n    serverData: T,\n    context: ConflictContext\n  ): Promise<ConflictResolution<T>> {\n    const mergeRules = this.config.mergeRules[context.resource] || [];\n    const merged = await this.performMerge(\n      localItem.data,\n      serverData,\n      mergeRules,\n      context\n    );\n\n    const confidence = this.calculateMergeConfidence(mergeRules, context);\n    \n    return this.createResolution(\n      'merge',\n      merged as T,\n      context,\n      'Data merged using configured rules',\n      confidence\n    );\n  }\n\n  private async resolveManual<T>(\n    _localItem: QueueItem,\n    serverData: T,\n    context: ConflictContext\n  ): Promise<ConflictResolution<T>> {\n    // For now, default to server wins but mark as requiring user input\n    const resolution = this.createResolution(\n      'manual',\n      serverData,\n      context,\n      'Manual resolution required - defaulting to server data',\n      0.3\n    );\n\n    resolution.requiresUserInput = true;\n    \n    // Store for user input handling\n    const resolutionId = `manual_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n    this.pendingUserInputs.set(resolutionId, resolution);\n\n    // Set timeout for user input\n    setTimeout(() => {\n      if (this.pendingUserInputs.has(resolutionId)) {\n        console.warn(`Manual conflict resolution timed out for ${context.resource}:${context.operation}`);\n        this.pendingUserInputs.delete(resolutionId);\n      }\n    }, this.config.userInputTimeout);\n\n    return resolution;\n  }\n\n  private async performMerge(\n    clientData: any,\n    serverData: any,\n    mergeRules: MergeRule[],\n    context: ConflictContext\n  ): Promise<any> {\n    const result = { ...serverData }; // Start with server data as base\n    const preservedFields: string[] = [];\n    const discardedFields: string[] = [];\n\n    for (const rule of mergeRules) {\n      try {\n        const clientValue = this.getNestedProperty(clientData, rule.field);\n        const serverValue = this.getNestedProperty(serverData, rule.field);\n\n        let resolvedValue;\n\n        switch (rule.strategy) {\n          case 'client':\n            resolvedValue = clientValue;\n            preservedFields.push(rule.field);\n            break;\n\n          case 'server':\n            resolvedValue = serverValue;\n            break;\n\n          case 'latest':\n            resolvedValue = context.localTimestamp > context.serverTimestamp \n              ? clientValue \n              : serverValue;\n            break;\n\n          case 'merge-array':\n            if (Array.isArray(clientValue) && Array.isArray(serverValue)) {\n              resolvedValue = this.mergeArrays(clientValue, serverValue);\n              preservedFields.push(rule.field);\n            } else {\n              resolvedValue = serverValue;\n            }\n            break;\n\n          case 'custom':\n            if (rule.customResolver) {\n              resolvedValue = rule.customResolver(clientValue, serverValue, context);\n              preservedFields.push(rule.field);\n            } else {\n              resolvedValue = serverValue;\n            }\n            break;\n\n          default:\n            resolvedValue = serverValue;\n        }\n\n        this.setNestedProperty(result, rule.field, resolvedValue);\n\n      } catch (error) {\n        console.warn(`Failed to apply merge rule for field ${rule.field}:`, error);\n        discardedFields.push(rule.field);\n      }\n    }\n\n    // Store merge metadata\n    result._mergeMetadata = {\n      preservedFields,\n      discardedFields,\n      mergedAt: Date.now(),\n    };\n\n    return result;\n  }\n\n  private createResolution<T>(\n    strategy: ConflictResolutionStrategy,\n    data: T,\n    context: ConflictContext,\n    reason: string,\n    confidence: number\n  ): ConflictResolution<T> {\n    const resolution: ConflictResolution<T> = {\n      strategy,\n      resolvedData: data,\n      requiresUserInput: false,\n      metadata: {\n        conflictType: context.conflictType,\n        resolutionReason: reason,\n        dataSource: this.getDataSource(strategy),\n        confidence,\n      },\n    };\n\n    // Store in history\n    this.resolutionHistory.push(resolution);\n\n    // Keep history size manageable\n    if (this.resolutionHistory.length > 1000) {\n      this.resolutionHistory = this.resolutionHistory.slice(-500);\n    }\n\n    return resolution;\n  }\n\n  private getDataSource(strategy: ConflictResolutionStrategy): 'client' | 'server' | 'merged' | 'manual' {\n    switch (strategy) {\n      case 'client-wins': return 'client';\n      case 'server-wins': return 'server';\n      case 'merge': return 'merged';\n      case 'manual': return 'manual';\n      default: return 'server';\n    }\n  }\n\n  private calculateMergeConfidence(mergeRules: MergeRule[], context: ConflictContext): number {\n    if (mergeRules.length === 0) return 0.3;\n\n    let confidence = 0.8;\n\n    // Reduce confidence for complex conflicts\n    if (context.conflictType === 'concurrent-modification') {\n      confidence -= 0.2;\n    }\n\n    // Reduce confidence for old data\n    const timeDiff = Math.abs(context.localTimestamp - context.serverTimestamp);\n    if (timeDiff > 600000) { // 10 minutes\n      confidence -= 0.3;\n    }\n\n    return Math.max(0.1, Math.min(1.0, confidence));\n  }\n\n  private getDefaultMergeRules(): Record<ResourceType, MergeRule[]> {\n    return {\n      receipts: [\n        { field: 'items', strategy: 'merge-array' },\n        { field: 'notes', strategy: 'client' },\n        { field: 'status', strategy: 'server' },\n        { field: 'updatedAt', strategy: 'latest' },\n      ],\n      cashiers: [\n        { field: 'name', strategy: 'client' },\n        { field: 'email', strategy: 'client' },\n        { field: 'role', strategy: 'server' },\n        { field: 'permissions', strategy: 'server' },\n      ],\n      merchants: [\n        { field: 'businessInfo', strategy: 'client' },\n        { field: 'taxInfo', strategy: 'server' },\n        { field: 'settings', strategy: 'merge-array' },\n      ],\n      'cash-registers': [\n        { field: 'configuration', strategy: 'client' },\n        { field: 'status', strategy: 'server' },\n        { field: 'lastSync', strategy: 'latest' },\n      ],\n      'point-of-sales': [\n        { field: 'configuration', strategy: 'client' },\n        { field: 'status', strategy: 'server' },\n      ],\n      pems: [\n        { field: 'configuration', strategy: 'server' },\n        { field: 'status', strategy: 'server' },\n      ],\n    };\n  }\n\n  private hasValidationIssues(_localData: any, _serverData: any): boolean {\n    // Simple heuristic - more sophisticated validation would be implemented\n    // based on specific business rules\n    return false;\n  }\n\n  private hasSchemaIssues(localData: any, serverData: any): boolean {\n    // Check if data structures are fundamentally incompatible\n    return typeof localData !== typeof serverData;\n  }\n\n  private getClientId(): string {\n    // Generate or retrieve client ID\n    return `client_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private getNestedProperty(obj: any, path: string): any {\n    return path.split('.').reduce((current, key) => current?.[key], obj);\n  }\n\n  private setNestedProperty(obj: any, path: string, value: any): void {\n    const keys = path.split('.');\n    const lastKey = keys.pop()!;\n    const target = keys.reduce((current, key) => {\n      if (!(key in current)) current[key] = {};\n      return current[key];\n    }, obj);\n    target[lastKey] = value;\n  }\n\n  private mergeArrays(clientArray: any[], serverArray: any[]): any[] {\n    // Simple merge strategy - remove duplicates and combine\n    const merged = [...serverArray];\n    \n    for (const item of clientArray) {\n      const exists = merged.some(existing => \n        JSON.stringify(existing) === JSON.stringify(item)\n      );\n      if (!exists) {\n        merged.push(item);\n      }\n    }\n    \n    return merged;\n  }\n}","/**\n * @license React\n * react.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n  REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n  REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n  REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n  REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n  REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n  REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n  REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n  REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nfunction getIteratorFn(maybeIterable) {\n  if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n  maybeIterable =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[\"@@iterator\"];\n  return \"function\" === typeof maybeIterable ? maybeIterable : null;\n}\nvar ReactNoopUpdateQueue = {\n    isMounted: function () {\n      return !1;\n    },\n    enqueueForceUpdate: function () {},\n    enqueueReplaceState: function () {},\n    enqueueSetState: function () {}\n  },\n  assign = Object.assign,\n  emptyObject = {};\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\nComponent.prototype.isReactComponent = {};\nComponent.prototype.setState = function (partialState, callback) {\n  if (\n    \"object\" !== typeof partialState &&\n    \"function\" !== typeof partialState &&\n    null != partialState\n  )\n    throw Error(\n      \"takes an object of state variables to update or a function which returns an object of state variables.\"\n    );\n  this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n};\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n};\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\nvar pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());\npureComponentPrototype.constructor = PureComponent;\nassign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = !0;\nvar isArrayImpl = Array.isArray,\n  ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null },\n  hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction ReactElement(type, key, self, source, owner, props) {\n  self = props.ref;\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: void 0 !== self ? self : null,\n    props: props\n  };\n}\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  return ReactElement(\n    oldElement.type,\n    newKey,\n    void 0,\n    void 0,\n    void 0,\n    oldElement.props\n  );\n}\nfunction isValidElement(object) {\n  return (\n    \"object\" === typeof object &&\n    null !== object &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\nfunction escape(key) {\n  var escaperLookup = { \"=\": \"=0\", \":\": \"=2\" };\n  return (\n    \"$\" +\n    key.replace(/[=:]/g, function (match) {\n      return escaperLookup[match];\n    })\n  );\n}\nvar userProvidedKeyEscapeRegex = /\\/+/g;\nfunction getElementKey(element, index) {\n  return \"object\" === typeof element && null !== element && null != element.key\n    ? escape(\"\" + element.key)\n    : index.toString(36);\n}\nfunction noop$1() {}\nfunction resolveThenable(thenable) {\n  switch (thenable.status) {\n    case \"fulfilled\":\n      return thenable.value;\n    case \"rejected\":\n      throw thenable.reason;\n    default:\n      switch (\n        (\"string\" === typeof thenable.status\n          ? thenable.then(noop$1, noop$1)\n          : ((thenable.status = \"pending\"),\n            thenable.then(\n              function (fulfilledValue) {\n                \"pending\" === thenable.status &&\n                  ((thenable.status = \"fulfilled\"),\n                  (thenable.value = fulfilledValue));\n              },\n              function (error) {\n                \"pending\" === thenable.status &&\n                  ((thenable.status = \"rejected\"), (thenable.reason = error));\n              }\n            )),\n        thenable.status)\n      ) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n      }\n  }\n  throw thenable;\n}\nfunction mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n  var type = typeof children;\n  if (\"undefined\" === type || \"boolean\" === type) children = null;\n  var invokeCallback = !1;\n  if (null === children) invokeCallback = !0;\n  else\n    switch (type) {\n      case \"bigint\":\n      case \"string\":\n      case \"number\":\n        invokeCallback = !0;\n        break;\n      case \"object\":\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = !0;\n            break;\n          case REACT_LAZY_TYPE:\n            return (\n              (invokeCallback = children._init),\n              mapIntoArray(\n                invokeCallback(children._payload),\n                array,\n                escapedPrefix,\n                nameSoFar,\n                callback\n              )\n            );\n        }\n    }\n  if (invokeCallback)\n    return (\n      (callback = callback(children)),\n      (invokeCallback =\n        \"\" === nameSoFar ? \".\" + getElementKey(children, 0) : nameSoFar),\n      isArrayImpl(callback)\n        ? ((escapedPrefix = \"\"),\n          null != invokeCallback &&\n            (escapedPrefix =\n              invokeCallback.replace(userProvidedKeyEscapeRegex, \"$&/\") + \"/\"),\n          mapIntoArray(callback, array, escapedPrefix, \"\", function (c) {\n            return c;\n          }))\n        : null != callback &&\n          (isValidElement(callback) &&\n            (callback = cloneAndReplaceKey(\n              callback,\n              escapedPrefix +\n                (null == callback.key ||\n                (children && children.key === callback.key)\n                  ? \"\"\n                  : (\"\" + callback.key).replace(\n                      userProvidedKeyEscapeRegex,\n                      \"$&/\"\n                    ) + \"/\") +\n                invokeCallback\n            )),\n          array.push(callback)),\n      1\n    );\n  invokeCallback = 0;\n  var nextNamePrefix = \"\" === nameSoFar ? \".\" : nameSoFar + \":\";\n  if (isArrayImpl(children))\n    for (var i = 0; i < children.length; i++)\n      (nameSoFar = children[i]),\n        (type = nextNamePrefix + getElementKey(nameSoFar, i)),\n        (invokeCallback += mapIntoArray(\n          nameSoFar,\n          array,\n          escapedPrefix,\n          type,\n          callback\n        ));\n  else if (((i = getIteratorFn(children)), \"function\" === typeof i))\n    for (\n      children = i.call(children), i = 0;\n      !(nameSoFar = children.next()).done;\n\n    )\n      (nameSoFar = nameSoFar.value),\n        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),\n        (invokeCallback += mapIntoArray(\n          nameSoFar,\n          array,\n          escapedPrefix,\n          type,\n          callback\n        ));\n  else if (\"object\" === type) {\n    if (\"function\" === typeof children.then)\n      return mapIntoArray(\n        resolveThenable(children),\n        array,\n        escapedPrefix,\n        nameSoFar,\n        callback\n      );\n    array = String(children);\n    throw Error(\n      \"Objects are not valid as a React child (found: \" +\n        (\"[object Object]\" === array\n          ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\"\n          : array) +\n        \"). If you meant to render a collection of children, use an array instead.\"\n    );\n  }\n  return invokeCallback;\n}\nfunction mapChildren(children, func, context) {\n  if (null == children) return children;\n  var result = [],\n    count = 0;\n  mapIntoArray(children, result, \"\", \"\", function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\nfunction lazyInitializer(payload) {\n  if (-1 === payload._status) {\n    var ctor = payload._result;\n    ctor = ctor();\n    ctor.then(\n      function (moduleObject) {\n        if (0 === payload._status || -1 === payload._status)\n          (payload._status = 1), (payload._result = moduleObject);\n      },\n      function (error) {\n        if (0 === payload._status || -1 === payload._status)\n          (payload._status = 2), (payload._result = error);\n      }\n    );\n    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));\n  }\n  if (1 === payload._status) return payload._result.default;\n  throw payload._result;\n}\nvar reportGlobalError =\n  \"function\" === typeof reportError\n    ? reportError\n    : function (error) {\n        if (\n          \"object\" === typeof window &&\n          \"function\" === typeof window.ErrorEvent\n        ) {\n          var event = new window.ErrorEvent(\"error\", {\n            bubbles: !0,\n            cancelable: !0,\n            message:\n              \"object\" === typeof error &&\n              null !== error &&\n              \"string\" === typeof error.message\n                ? String(error.message)\n                : String(error),\n            error: error\n          });\n          if (!window.dispatchEvent(event)) return;\n        } else if (\n          \"object\" === typeof process &&\n          \"function\" === typeof process.emit\n        ) {\n          process.emit(\"uncaughtException\", error);\n          return;\n        }\n        console.error(error);\n      };\nfunction noop() {}\nexports.Children = {\n  map: mapChildren,\n  forEach: function (children, forEachFunc, forEachContext) {\n    mapChildren(\n      children,\n      function () {\n        forEachFunc.apply(this, arguments);\n      },\n      forEachContext\n    );\n  },\n  count: function (children) {\n    var n = 0;\n    mapChildren(children, function () {\n      n++;\n    });\n    return n;\n  },\n  toArray: function (children) {\n    return (\n      mapChildren(children, function (child) {\n        return child;\n      }) || []\n    );\n  },\n  only: function (children) {\n    if (!isValidElement(children))\n      throw Error(\n        \"React.Children.only expected to receive a single React element child.\"\n      );\n    return children;\n  }\n};\nexports.Component = Component;\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.Profiler = REACT_PROFILER_TYPE;\nexports.PureComponent = PureComponent;\nexports.StrictMode = REACT_STRICT_MODE_TYPE;\nexports.Suspense = REACT_SUSPENSE_TYPE;\nexports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n  ReactSharedInternals;\nexports.__COMPILER_RUNTIME = {\n  __proto__: null,\n  c: function (size) {\n    return ReactSharedInternals.H.useMemoCache(size);\n  }\n};\nexports.cache = function (fn) {\n  return function () {\n    return fn.apply(null, arguments);\n  };\n};\nexports.cloneElement = function (element, config, children) {\n  if (null === element || void 0 === element)\n    throw Error(\n      \"The argument must be a React element, but you passed \" + element + \".\"\n    );\n  var props = assign({}, element.props),\n    key = element.key,\n    owner = void 0;\n  if (null != config)\n    for (propName in (void 0 !== config.ref && (owner = void 0),\n    void 0 !== config.key && (key = \"\" + config.key),\n    config))\n      !hasOwnProperty.call(config, propName) ||\n        \"key\" === propName ||\n        \"__self\" === propName ||\n        \"__source\" === propName ||\n        (\"ref\" === propName && void 0 === config.ref) ||\n        (props[propName] = config[propName]);\n  var propName = arguments.length - 2;\n  if (1 === propName) props.children = children;\n  else if (1 < propName) {\n    for (var childArray = Array(propName), i = 0; i < propName; i++)\n      childArray[i] = arguments[i + 2];\n    props.children = childArray;\n  }\n  return ReactElement(element.type, key, void 0, void 0, owner, props);\n};\nexports.createContext = function (defaultValue) {\n  defaultValue = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    _threadCount: 0,\n    Provider: null,\n    Consumer: null\n  };\n  defaultValue.Provider = defaultValue;\n  defaultValue.Consumer = {\n    $$typeof: REACT_CONSUMER_TYPE,\n    _context: defaultValue\n  };\n  return defaultValue;\n};\nexports.createElement = function (type, config, children) {\n  var propName,\n    props = {},\n    key = null;\n  if (null != config)\n    for (propName in (void 0 !== config.key && (key = \"\" + config.key), config))\n      hasOwnProperty.call(config, propName) &&\n        \"key\" !== propName &&\n        \"__self\" !== propName &&\n        \"__source\" !== propName &&\n        (props[propName] = config[propName]);\n  var childrenLength = arguments.length - 2;\n  if (1 === childrenLength) props.children = children;\n  else if (1 < childrenLength) {\n    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)\n      childArray[i] = arguments[i + 2];\n    props.children = childArray;\n  }\n  if (type && type.defaultProps)\n    for (propName in ((childrenLength = type.defaultProps), childrenLength))\n      void 0 === props[propName] &&\n        (props[propName] = childrenLength[propName]);\n  return ReactElement(type, key, void 0, void 0, null, props);\n};\nexports.createRef = function () {\n  return { current: null };\n};\nexports.forwardRef = function (render) {\n  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };\n};\nexports.isValidElement = isValidElement;\nexports.lazy = function (ctor) {\n  return {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: { _status: -1, _result: ctor },\n    _init: lazyInitializer\n  };\n};\nexports.memo = function (type, compare) {\n  return {\n    $$typeof: REACT_MEMO_TYPE,\n    type: type,\n    compare: void 0 === compare ? null : compare\n  };\n};\nexports.startTransition = function (scope) {\n  var prevTransition = ReactSharedInternals.T,\n    currentTransition = {};\n  ReactSharedInternals.T = currentTransition;\n  try {\n    var returnValue = scope(),\n      onStartTransitionFinish = ReactSharedInternals.S;\n    null !== onStartTransitionFinish &&\n      onStartTransitionFinish(currentTransition, returnValue);\n    \"object\" === typeof returnValue &&\n      null !== returnValue &&\n      \"function\" === typeof returnValue.then &&\n      returnValue.then(noop, reportGlobalError);\n  } catch (error) {\n    reportGlobalError(error);\n  } finally {\n    ReactSharedInternals.T = prevTransition;\n  }\n};\nexports.unstable_useCacheRefresh = function () {\n  return ReactSharedInternals.H.useCacheRefresh();\n};\nexports.use = function (usable) {\n  return ReactSharedInternals.H.use(usable);\n};\nexports.useActionState = function (action, initialState, permalink) {\n  return ReactSharedInternals.H.useActionState(action, initialState, permalink);\n};\nexports.useCallback = function (callback, deps) {\n  return ReactSharedInternals.H.useCallback(callback, deps);\n};\nexports.useContext = function (Context) {\n  return ReactSharedInternals.H.useContext(Context);\n};\nexports.useDebugValue = function () {};\nexports.useDeferredValue = function (value, initialValue) {\n  return ReactSharedInternals.H.useDeferredValue(value, initialValue);\n};\nexports.useEffect = function (create, createDeps, update) {\n  var dispatcher = ReactSharedInternals.H;\n  if (\"function\" === typeof update)\n    throw Error(\n      \"useEffect CRUD overload is not enabled in this build of React.\"\n    );\n  return dispatcher.useEffect(create, createDeps);\n};\nexports.useId = function () {\n  return ReactSharedInternals.H.useId();\n};\nexports.useImperativeHandle = function (ref, create, deps) {\n  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);\n};\nexports.useInsertionEffect = function (create, deps) {\n  return ReactSharedInternals.H.useInsertionEffect(create, deps);\n};\nexports.useLayoutEffect = function (create, deps) {\n  return ReactSharedInternals.H.useLayoutEffect(create, deps);\n};\nexports.useMemo = function (create, deps) {\n  return ReactSharedInternals.H.useMemo(create, deps);\n};\nexports.useOptimistic = function (passthrough, reducer) {\n  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);\n};\nexports.useReducer = function (reducer, initialArg, init) {\n  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);\n};\nexports.useRef = function (initialValue) {\n  return ReactSharedInternals.H.useRef(initialValue);\n};\nexports.useState = function (initialState) {\n  return ReactSharedInternals.H.useState(initialState);\n};\nexports.useSyncExternalStore = function (\n  subscribe,\n  getSnapshot,\n  getServerSnapshot\n) {\n  return ReactSharedInternals.H.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot\n  );\n};\nexports.useTransition = function () {\n  return ReactSharedInternals.H.useTransition();\n};\nexports.version = \"19.1.1\";\n","/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function defineDeprecationWarning(methodName, info) {\n      Object.defineProperty(Component.prototype, methodName, {\n        get: function () {\n          console.warn(\n            \"%s(...) is deprecated in plain JavaScript React classes. %s\",\n            info[0],\n            info[1]\n          );\n        }\n      });\n    }\n    function getIteratorFn(maybeIterable) {\n      if (null === maybeIterable || \"object\" !== typeof maybeIterable)\n        return null;\n      maybeIterable =\n        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n        maybeIterable[\"@@iterator\"];\n      return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function warnNoop(publicInstance, callerName) {\n      publicInstance =\n        ((publicInstance = publicInstance.constructor) &&\n          (publicInstance.displayName || publicInstance.name)) ||\n        \"ReactClass\";\n      var warningKey = publicInstance + \".\" + callerName;\n      didWarnStateUpdateForUnmountedComponent[warningKey] ||\n        (console.error(\n          \"Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.\",\n          callerName,\n          publicInstance\n        ),\n        (didWarnStateUpdateForUnmountedComponent[warningKey] = !0));\n    }\n    function Component(props, context, updater) {\n      this.props = props;\n      this.context = context;\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    function ComponentDummy() {}\n    function PureComponent(props, context, updater) {\n      this.props = props;\n      this.context = context;\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function cloneAndReplaceKey(oldElement, newKey) {\n      newKey = ReactElement(\n        oldElement.type,\n        newKey,\n        void 0,\n        void 0,\n        oldElement._owner,\n        oldElement.props,\n        oldElement._debugStack,\n        oldElement._debugTask\n      );\n      oldElement._store &&\n        (newKey._store.validated = oldElement._store.validated);\n      return newKey;\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function escape(key) {\n      var escaperLookup = { \"=\": \"=0\", \":\": \"=2\" };\n      return (\n        \"$\" +\n        key.replace(/[=:]/g, function (match) {\n          return escaperLookup[match];\n        })\n      );\n    }\n    function getElementKey(element, index) {\n      return \"object\" === typeof element &&\n        null !== element &&\n        null != element.key\n        ? (checkKeyStringCoercion(element.key), escape(\"\" + element.key))\n        : index.toString(36);\n    }\n    function noop$1() {}\n    function resolveThenable(thenable) {\n      switch (thenable.status) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n        default:\n          switch (\n            (\"string\" === typeof thenable.status\n              ? thenable.then(noop$1, noop$1)\n              : ((thenable.status = \"pending\"),\n                thenable.then(\n                  function (fulfilledValue) {\n                    \"pending\" === thenable.status &&\n                      ((thenable.status = \"fulfilled\"),\n                      (thenable.value = fulfilledValue));\n                  },\n                  function (error) {\n                    \"pending\" === thenable.status &&\n                      ((thenable.status = \"rejected\"),\n                      (thenable.reason = error));\n                  }\n                )),\n            thenable.status)\n          ) {\n            case \"fulfilled\":\n              return thenable.value;\n            case \"rejected\":\n              throw thenable.reason;\n          }\n      }\n      throw thenable;\n    }\n    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n      var type = typeof children;\n      if (\"undefined\" === type || \"boolean\" === type) children = null;\n      var invokeCallback = !1;\n      if (null === children) invokeCallback = !0;\n      else\n        switch (type) {\n          case \"bigint\":\n          case \"string\":\n          case \"number\":\n            invokeCallback = !0;\n            break;\n          case \"object\":\n            switch (children.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                invokeCallback = !0;\n                break;\n              case REACT_LAZY_TYPE:\n                return (\n                  (invokeCallback = children._init),\n                  mapIntoArray(\n                    invokeCallback(children._payload),\n                    array,\n                    escapedPrefix,\n                    nameSoFar,\n                    callback\n                  )\n                );\n            }\n        }\n      if (invokeCallback) {\n        invokeCallback = children;\n        callback = callback(invokeCallback);\n        var childKey =\n          \"\" === nameSoFar ? \".\" + getElementKey(invokeCallback, 0) : nameSoFar;\n        isArrayImpl(callback)\n          ? ((escapedPrefix = \"\"),\n            null != childKey &&\n              (escapedPrefix =\n                childKey.replace(userProvidedKeyEscapeRegex, \"$&/\") + \"/\"),\n            mapIntoArray(callback, array, escapedPrefix, \"\", function (c) {\n              return c;\n            }))\n          : null != callback &&\n            (isValidElement(callback) &&\n              (null != callback.key &&\n                ((invokeCallback && invokeCallback.key === callback.key) ||\n                  checkKeyStringCoercion(callback.key)),\n              (escapedPrefix = cloneAndReplaceKey(\n                callback,\n                escapedPrefix +\n                  (null == callback.key ||\n                  (invokeCallback && invokeCallback.key === callback.key)\n                    ? \"\"\n                    : (\"\" + callback.key).replace(\n                        userProvidedKeyEscapeRegex,\n                        \"$&/\"\n                      ) + \"/\") +\n                  childKey\n              )),\n              \"\" !== nameSoFar &&\n                null != invokeCallback &&\n                isValidElement(invokeCallback) &&\n                null == invokeCallback.key &&\n                invokeCallback._store &&\n                !invokeCallback._store.validated &&\n                (escapedPrefix._store.validated = 2),\n              (callback = escapedPrefix)),\n            array.push(callback));\n        return 1;\n      }\n      invokeCallback = 0;\n      childKey = \"\" === nameSoFar ? \".\" : nameSoFar + \":\";\n      if (isArrayImpl(children))\n        for (var i = 0; i < children.length; i++)\n          (nameSoFar = children[i]),\n            (type = childKey + getElementKey(nameSoFar, i)),\n            (invokeCallback += mapIntoArray(\n              nameSoFar,\n              array,\n              escapedPrefix,\n              type,\n              callback\n            ));\n      else if (((i = getIteratorFn(children)), \"function\" === typeof i))\n        for (\n          i === children.entries &&\n            (didWarnAboutMaps ||\n              console.warn(\n                \"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"\n              ),\n            (didWarnAboutMaps = !0)),\n            children = i.call(children),\n            i = 0;\n          !(nameSoFar = children.next()).done;\n\n        )\n          (nameSoFar = nameSoFar.value),\n            (type = childKey + getElementKey(nameSoFar, i++)),\n            (invokeCallback += mapIntoArray(\n              nameSoFar,\n              array,\n              escapedPrefix,\n              type,\n              callback\n            ));\n      else if (\"object\" === type) {\n        if (\"function\" === typeof children.then)\n          return mapIntoArray(\n            resolveThenable(children),\n            array,\n            escapedPrefix,\n            nameSoFar,\n            callback\n          );\n        array = String(children);\n        throw Error(\n          \"Objects are not valid as a React child (found: \" +\n            (\"[object Object]\" === array\n              ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\"\n              : array) +\n            \"). If you meant to render a collection of children, use an array instead.\"\n        );\n      }\n      return invokeCallback;\n    }\n    function mapChildren(children, func, context) {\n      if (null == children) return children;\n      var result = [],\n        count = 0;\n      mapIntoArray(children, result, \"\", \"\", function (child) {\n        return func.call(context, child, count++);\n      });\n      return result;\n    }\n    function lazyInitializer(payload) {\n      if (-1 === payload._status) {\n        var ctor = payload._result;\n        ctor = ctor();\n        ctor.then(\n          function (moduleObject) {\n            if (0 === payload._status || -1 === payload._status)\n              (payload._status = 1), (payload._result = moduleObject);\n          },\n          function (error) {\n            if (0 === payload._status || -1 === payload._status)\n              (payload._status = 2), (payload._result = error);\n          }\n        );\n        -1 === payload._status &&\n          ((payload._status = 0), (payload._result = ctor));\n      }\n      if (1 === payload._status)\n        return (\n          (ctor = payload._result),\n          void 0 === ctor &&\n            console.error(\n              \"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\\n\\nDid you accidentally put curly braces around the import?\",\n              ctor\n            ),\n          \"default\" in ctor ||\n            console.error(\n              \"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\",\n              ctor\n            ),\n          ctor.default\n        );\n      throw payload._result;\n    }\n    function resolveDispatcher() {\n      var dispatcher = ReactSharedInternals.H;\n      null === dispatcher &&\n        console.error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      return dispatcher;\n    }\n    function noop() {}\n    function enqueueTask(task) {\n      if (null === enqueueTaskImpl)\n        try {\n          var requireString = (\"require\" + Math.random()).slice(0, 7);\n          enqueueTaskImpl = (module && module[requireString]).call(\n            module,\n            \"timers\"\n          ).setImmediate;\n        } catch (_err) {\n          enqueueTaskImpl = function (callback) {\n            !1 === didWarnAboutMessageChannel &&\n              ((didWarnAboutMessageChannel = !0),\n              \"undefined\" === typeof MessageChannel &&\n                console.error(\n                  \"This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.\"\n                ));\n            var channel = new MessageChannel();\n            channel.port1.onmessage = callback;\n            channel.port2.postMessage(void 0);\n          };\n        }\n      return enqueueTaskImpl(task);\n    }\n    function aggregateErrors(errors) {\n      return 1 < errors.length && \"function\" === typeof AggregateError\n        ? new AggregateError(errors)\n        : errors[0];\n    }\n    function popActScope(prevActQueue, prevActScopeDepth) {\n      prevActScopeDepth !== actScopeDepth - 1 &&\n        console.error(\n          \"You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. \"\n        );\n      actScopeDepth = prevActScopeDepth;\n    }\n    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n      var queue = ReactSharedInternals.actQueue;\n      if (null !== queue)\n        if (0 !== queue.length)\n          try {\n            flushActQueue(queue);\n            enqueueTask(function () {\n              return recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            });\n            return;\n          } catch (error) {\n            ReactSharedInternals.thrownErrors.push(error);\n          }\n        else ReactSharedInternals.actQueue = null;\n      0 < ReactSharedInternals.thrownErrors.length\n        ? ((queue = aggregateErrors(ReactSharedInternals.thrownErrors)),\n          (ReactSharedInternals.thrownErrors.length = 0),\n          reject(queue))\n        : resolve(returnValue);\n    }\n    function flushActQueue(queue) {\n      if (!isFlushing) {\n        isFlushing = !0;\n        var i = 0;\n        try {\n          for (; i < queue.length; i++) {\n            var callback = queue[i];\n            do {\n              ReactSharedInternals.didUsePromise = !1;\n              var continuation = callback(!1);\n              if (null !== continuation) {\n                if (ReactSharedInternals.didUsePromise) {\n                  queue[i] = callback;\n                  queue.splice(0, i);\n                  return;\n                }\n                callback = continuation;\n              } else break;\n            } while (1);\n          }\n          queue.length = 0;\n        } catch (error) {\n          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);\n        } finally {\n          isFlushing = !1;\n        }\n      }\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      didWarnStateUpdateForUnmountedComponent = {},\n      ReactNoopUpdateQueue = {\n        isMounted: function () {\n          return !1;\n        },\n        enqueueForceUpdate: function (publicInstance) {\n          warnNoop(publicInstance, \"forceUpdate\");\n        },\n        enqueueReplaceState: function (publicInstance) {\n          warnNoop(publicInstance, \"replaceState\");\n        },\n        enqueueSetState: function (publicInstance) {\n          warnNoop(publicInstance, \"setState\");\n        }\n      },\n      assign = Object.assign,\n      emptyObject = {};\n    Object.freeze(emptyObject);\n    Component.prototype.isReactComponent = {};\n    Component.prototype.setState = function (partialState, callback) {\n      if (\n        \"object\" !== typeof partialState &&\n        \"function\" !== typeof partialState &&\n        null != partialState\n      )\n        throw Error(\n          \"takes an object of state variables to update or a function which returns an object of state variables.\"\n        );\n      this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n    };\n    Component.prototype.forceUpdate = function (callback) {\n      this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n    };\n    var deprecatedAPIs = {\n        isMounted: [\n          \"isMounted\",\n          \"Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.\"\n        ],\n        replaceState: [\n          \"replaceState\",\n          \"Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).\"\n        ]\n      },\n      fnName;\n    for (fnName in deprecatedAPIs)\n      deprecatedAPIs.hasOwnProperty(fnName) &&\n        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    ComponentDummy.prototype = Component.prototype;\n    deprecatedAPIs = PureComponent.prototype = new ComponentDummy();\n    deprecatedAPIs.constructor = PureComponent;\n    assign(deprecatedAPIs, Component.prototype);\n    deprecatedAPIs.isPureReactComponent = !0;\n    var isArrayImpl = Array.isArray,\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals = {\n        H: null,\n        A: null,\n        T: null,\n        S: null,\n        V: null,\n        actQueue: null,\n        isBatchingLegacy: !1,\n        didScheduleLegacyUpdate: !1,\n        didUsePromise: !1,\n        thrownErrors: [],\n        getCurrentStack: null,\n        recentlyCreatedOwnerStacks: 0\n      },\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    deprecatedAPIs = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(\n      deprecatedAPIs,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutMaps = !1,\n      userProvidedKeyEscapeRegex = /\\/+/g,\n      reportGlobalError =\n        \"function\" === typeof reportError\n          ? reportError\n          : function (error) {\n              if (\n                \"object\" === typeof window &&\n                \"function\" === typeof window.ErrorEvent\n              ) {\n                var event = new window.ErrorEvent(\"error\", {\n                  bubbles: !0,\n                  cancelable: !0,\n                  message:\n                    \"object\" === typeof error &&\n                    null !== error &&\n                    \"string\" === typeof error.message\n                      ? String(error.message)\n                      : String(error),\n                  error: error\n                });\n                if (!window.dispatchEvent(event)) return;\n              } else if (\n                \"object\" === typeof process &&\n                \"function\" === typeof process.emit\n              ) {\n                process.emit(\"uncaughtException\", error);\n                return;\n              }\n              console.error(error);\n            },\n      didWarnAboutMessageChannel = !1,\n      enqueueTaskImpl = null,\n      actScopeDepth = 0,\n      didWarnNoAwaitAct = !1,\n      isFlushing = !1,\n      queueSeveralMicrotasks =\n        \"function\" === typeof queueMicrotask\n          ? function (callback) {\n              queueMicrotask(function () {\n                return queueMicrotask(callback);\n              });\n            }\n          : enqueueTask;\n    deprecatedAPIs = Object.freeze({\n      __proto__: null,\n      c: function (size) {\n        return resolveDispatcher().useMemoCache(size);\n      }\n    });\n    exports.Children = {\n      map: mapChildren,\n      forEach: function (children, forEachFunc, forEachContext) {\n        mapChildren(\n          children,\n          function () {\n            forEachFunc.apply(this, arguments);\n          },\n          forEachContext\n        );\n      },\n      count: function (children) {\n        var n = 0;\n        mapChildren(children, function () {\n          n++;\n        });\n        return n;\n      },\n      toArray: function (children) {\n        return (\n          mapChildren(children, function (child) {\n            return child;\n          }) || []\n        );\n      },\n      only: function (children) {\n        if (!isValidElement(children))\n          throw Error(\n            \"React.Children.only expected to receive a single React element child.\"\n          );\n        return children;\n      }\n    };\n    exports.Component = Component;\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.Profiler = REACT_PROFILER_TYPE;\n    exports.PureComponent = PureComponent;\n    exports.StrictMode = REACT_STRICT_MODE_TYPE;\n    exports.Suspense = REACT_SUSPENSE_TYPE;\n    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n      ReactSharedInternals;\n    exports.__COMPILER_RUNTIME = deprecatedAPIs;\n    exports.act = function (callback) {\n      var prevActQueue = ReactSharedInternals.actQueue,\n        prevActScopeDepth = actScopeDepth;\n      actScopeDepth++;\n      var queue = (ReactSharedInternals.actQueue =\n          null !== prevActQueue ? prevActQueue : []),\n        didAwaitActCall = !1;\n      try {\n        var result = callback();\n      } catch (error) {\n        ReactSharedInternals.thrownErrors.push(error);\n      }\n      if (0 < ReactSharedInternals.thrownErrors.length)\n        throw (\n          (popActScope(prevActQueue, prevActScopeDepth),\n          (callback = aggregateErrors(ReactSharedInternals.thrownErrors)),\n          (ReactSharedInternals.thrownErrors.length = 0),\n          callback)\n        );\n      if (\n        null !== result &&\n        \"object\" === typeof result &&\n        \"function\" === typeof result.then\n      ) {\n        var thenable = result;\n        queueSeveralMicrotasks(function () {\n          didAwaitActCall ||\n            didWarnNoAwaitAct ||\n            ((didWarnNoAwaitAct = !0),\n            console.error(\n              \"You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);\"\n            ));\n        });\n        return {\n          then: function (resolve, reject) {\n            didAwaitActCall = !0;\n            thenable.then(\n              function (returnValue) {\n                popActScope(prevActQueue, prevActScopeDepth);\n                if (0 === prevActScopeDepth) {\n                  try {\n                    flushActQueue(queue),\n                      enqueueTask(function () {\n                        return recursivelyFlushAsyncActWork(\n                          returnValue,\n                          resolve,\n                          reject\n                        );\n                      });\n                  } catch (error$0) {\n                    ReactSharedInternals.thrownErrors.push(error$0);\n                  }\n                  if (0 < ReactSharedInternals.thrownErrors.length) {\n                    var _thrownError = aggregateErrors(\n                      ReactSharedInternals.thrownErrors\n                    );\n                    ReactSharedInternals.thrownErrors.length = 0;\n                    reject(_thrownError);\n                  }\n                } else resolve(returnValue);\n              },\n              function (error) {\n                popActScope(prevActQueue, prevActScopeDepth);\n                0 < ReactSharedInternals.thrownErrors.length\n                  ? ((error = aggregateErrors(\n                      ReactSharedInternals.thrownErrors\n                    )),\n                    (ReactSharedInternals.thrownErrors.length = 0),\n                    reject(error))\n                  : reject(error);\n              }\n            );\n          }\n        };\n      }\n      var returnValue$jscomp$0 = result;\n      popActScope(prevActQueue, prevActScopeDepth);\n      0 === prevActScopeDepth &&\n        (flushActQueue(queue),\n        0 !== queue.length &&\n          queueSeveralMicrotasks(function () {\n            didAwaitActCall ||\n              didWarnNoAwaitAct ||\n              ((didWarnNoAwaitAct = !0),\n              console.error(\n                \"A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\\n\\nawait act(() => ...)\"\n              ));\n          }),\n        (ReactSharedInternals.actQueue = null));\n      if (0 < ReactSharedInternals.thrownErrors.length)\n        throw (\n          ((callback = aggregateErrors(ReactSharedInternals.thrownErrors)),\n          (ReactSharedInternals.thrownErrors.length = 0),\n          callback)\n        );\n      return {\n        then: function (resolve, reject) {\n          didAwaitActCall = !0;\n          0 === prevActScopeDepth\n            ? ((ReactSharedInternals.actQueue = queue),\n              enqueueTask(function () {\n                return recursivelyFlushAsyncActWork(\n                  returnValue$jscomp$0,\n                  resolve,\n                  reject\n                );\n              }))\n            : resolve(returnValue$jscomp$0);\n        }\n      };\n    };\n    exports.cache = function (fn) {\n      return function () {\n        return fn.apply(null, arguments);\n      };\n    };\n    exports.captureOwnerStack = function () {\n      var getCurrentStack = ReactSharedInternals.getCurrentStack;\n      return null === getCurrentStack ? null : getCurrentStack();\n    };\n    exports.cloneElement = function (element, config, children) {\n      if (null === element || void 0 === element)\n        throw Error(\n          \"The argument must be a React element, but you passed \" +\n            element +\n            \".\"\n        );\n      var props = assign({}, element.props),\n        key = element.key,\n        owner = element._owner;\n      if (null != config) {\n        var JSCompiler_inline_result;\n        a: {\n          if (\n            hasOwnProperty.call(config, \"ref\") &&\n            (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(\n              config,\n              \"ref\"\n            ).get) &&\n            JSCompiler_inline_result.isReactWarning\n          ) {\n            JSCompiler_inline_result = !1;\n            break a;\n          }\n          JSCompiler_inline_result = void 0 !== config.ref;\n        }\n        JSCompiler_inline_result && (owner = getOwner());\n        hasValidKey(config) &&\n          (checkKeyStringCoercion(config.key), (key = \"\" + config.key));\n        for (propName in config)\n          !hasOwnProperty.call(config, propName) ||\n            \"key\" === propName ||\n            \"__self\" === propName ||\n            \"__source\" === propName ||\n            (\"ref\" === propName && void 0 === config.ref) ||\n            (props[propName] = config[propName]);\n      }\n      var propName = arguments.length - 2;\n      if (1 === propName) props.children = children;\n      else if (1 < propName) {\n        JSCompiler_inline_result = Array(propName);\n        for (var i = 0; i < propName; i++)\n          JSCompiler_inline_result[i] = arguments[i + 2];\n        props.children = JSCompiler_inline_result;\n      }\n      props = ReactElement(\n        element.type,\n        key,\n        void 0,\n        void 0,\n        owner,\n        props,\n        element._debugStack,\n        element._debugTask\n      );\n      for (key = 2; key < arguments.length; key++)\n        (owner = arguments[key]),\n          isValidElement(owner) && owner._store && (owner._store.validated = 1);\n      return props;\n    };\n    exports.createContext = function (defaultValue) {\n      defaultValue = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        _currentValue: defaultValue,\n        _currentValue2: defaultValue,\n        _threadCount: 0,\n        Provider: null,\n        Consumer: null\n      };\n      defaultValue.Provider = defaultValue;\n      defaultValue.Consumer = {\n        $$typeof: REACT_CONSUMER_TYPE,\n        _context: defaultValue\n      };\n      defaultValue._currentRenderer = null;\n      defaultValue._currentRenderer2 = null;\n      return defaultValue;\n    };\n    exports.createElement = function (type, config, children) {\n      for (var i = 2; i < arguments.length; i++) {\n        var node = arguments[i];\n        isValidElement(node) && node._store && (node._store.validated = 1);\n      }\n      i = {};\n      node = null;\n      if (null != config)\n        for (propName in (didWarnAboutOldJSXRuntime ||\n          !(\"__self\" in config) ||\n          \"key\" in config ||\n          ((didWarnAboutOldJSXRuntime = !0),\n          console.warn(\n            \"Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform\"\n          )),\n        hasValidKey(config) &&\n          (checkKeyStringCoercion(config.key), (node = \"\" + config.key)),\n        config))\n          hasOwnProperty.call(config, propName) &&\n            \"key\" !== propName &&\n            \"__self\" !== propName &&\n            \"__source\" !== propName &&\n            (i[propName] = config[propName]);\n      var childrenLength = arguments.length - 2;\n      if (1 === childrenLength) i.children = children;\n      else if (1 < childrenLength) {\n        for (\n          var childArray = Array(childrenLength), _i = 0;\n          _i < childrenLength;\n          _i++\n        )\n          childArray[_i] = arguments[_i + 2];\n        Object.freeze && Object.freeze(childArray);\n        i.children = childArray;\n      }\n      if (type && type.defaultProps)\n        for (propName in ((childrenLength = type.defaultProps), childrenLength))\n          void 0 === i[propName] && (i[propName] = childrenLength[propName]);\n      node &&\n        defineKeyPropWarningGetter(\n          i,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return ReactElement(\n        type,\n        node,\n        void 0,\n        void 0,\n        getOwner(),\n        i,\n        propName ? Error(\"react-stack-top-frame\") : unknownOwnerDebugStack,\n        propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n    exports.createRef = function () {\n      var refObject = { current: null };\n      Object.seal(refObject);\n      return refObject;\n    };\n    exports.forwardRef = function (render) {\n      null != render && render.$$typeof === REACT_MEMO_TYPE\n        ? console.error(\n            \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).\"\n          )\n        : \"function\" !== typeof render\n          ? console.error(\n              \"forwardRef requires a render function but was given %s.\",\n              null === render ? \"null\" : typeof render\n            )\n          : 0 !== render.length &&\n            2 !== render.length &&\n            console.error(\n              \"forwardRef render functions accept exactly two parameters: props and ref. %s\",\n              1 === render.length\n                ? \"Did you forget to use the ref parameter?\"\n                : \"Any additional parameter will be undefined.\"\n            );\n      null != render &&\n        null != render.defaultProps &&\n        console.error(\n          \"forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?\"\n        );\n      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render: render },\n        ownName;\n      Object.defineProperty(elementType, \"displayName\", {\n        enumerable: !1,\n        configurable: !0,\n        get: function () {\n          return ownName;\n        },\n        set: function (name) {\n          ownName = name;\n          render.name ||\n            render.displayName ||\n            (Object.defineProperty(render, \"name\", { value: name }),\n            (render.displayName = name));\n        }\n      });\n      return elementType;\n    };\n    exports.isValidElement = isValidElement;\n    exports.lazy = function (ctor) {\n      return {\n        $$typeof: REACT_LAZY_TYPE,\n        _payload: { _status: -1, _result: ctor },\n        _init: lazyInitializer\n      };\n    };\n    exports.memo = function (type, compare) {\n      null == type &&\n        console.error(\n          \"memo: The first argument must be a component. Instead received: %s\",\n          null === type ? \"null\" : typeof type\n        );\n      compare = {\n        $$typeof: REACT_MEMO_TYPE,\n        type: type,\n        compare: void 0 === compare ? null : compare\n      };\n      var ownName;\n      Object.defineProperty(compare, \"displayName\", {\n        enumerable: !1,\n        configurable: !0,\n        get: function () {\n          return ownName;\n        },\n        set: function (name) {\n          ownName = name;\n          type.name ||\n            type.displayName ||\n            (Object.defineProperty(type, \"name\", { value: name }),\n            (type.displayName = name));\n        }\n      });\n      return compare;\n    };\n    exports.startTransition = function (scope) {\n      var prevTransition = ReactSharedInternals.T,\n        currentTransition = {};\n      ReactSharedInternals.T = currentTransition;\n      currentTransition._updatedFibers = new Set();\n      try {\n        var returnValue = scope(),\n          onStartTransitionFinish = ReactSharedInternals.S;\n        null !== onStartTransitionFinish &&\n          onStartTransitionFinish(currentTransition, returnValue);\n        \"object\" === typeof returnValue &&\n          null !== returnValue &&\n          \"function\" === typeof returnValue.then &&\n          returnValue.then(noop, reportGlobalError);\n      } catch (error) {\n        reportGlobalError(error);\n      } finally {\n        null === prevTransition &&\n          currentTransition._updatedFibers &&\n          ((scope = currentTransition._updatedFibers.size),\n          currentTransition._updatedFibers.clear(),\n          10 < scope &&\n            console.warn(\n              \"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"\n            )),\n          (ReactSharedInternals.T = prevTransition);\n      }\n    };\n    exports.unstable_useCacheRefresh = function () {\n      return resolveDispatcher().useCacheRefresh();\n    };\n    exports.use = function (usable) {\n      return resolveDispatcher().use(usable);\n    };\n    exports.useActionState = function (action, initialState, permalink) {\n      return resolveDispatcher().useActionState(\n        action,\n        initialState,\n        permalink\n      );\n    };\n    exports.useCallback = function (callback, deps) {\n      return resolveDispatcher().useCallback(callback, deps);\n    };\n    exports.useContext = function (Context) {\n      var dispatcher = resolveDispatcher();\n      Context.$$typeof === REACT_CONSUMER_TYPE &&\n        console.error(\n          \"Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?\"\n        );\n      return dispatcher.useContext(Context);\n    };\n    exports.useDebugValue = function (value, formatterFn) {\n      return resolveDispatcher().useDebugValue(value, formatterFn);\n    };\n    exports.useDeferredValue = function (value, initialValue) {\n      return resolveDispatcher().useDeferredValue(value, initialValue);\n    };\n    exports.useEffect = function (create, createDeps, update) {\n      null == create &&\n        console.warn(\n          \"React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?\"\n        );\n      var dispatcher = resolveDispatcher();\n      if (\"function\" === typeof update)\n        throw Error(\n          \"useEffect CRUD overload is not enabled in this build of React.\"\n        );\n      return dispatcher.useEffect(create, createDeps);\n    };\n    exports.useId = function () {\n      return resolveDispatcher().useId();\n    };\n    exports.useImperativeHandle = function (ref, create, deps) {\n      return resolveDispatcher().useImperativeHandle(ref, create, deps);\n    };\n    exports.useInsertionEffect = function (create, deps) {\n      null == create &&\n        console.warn(\n          \"React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?\"\n        );\n      return resolveDispatcher().useInsertionEffect(create, deps);\n    };\n    exports.useLayoutEffect = function (create, deps) {\n      null == create &&\n        console.warn(\n          \"React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?\"\n        );\n      return resolveDispatcher().useLayoutEffect(create, deps);\n    };\n    exports.useMemo = function (create, deps) {\n      return resolveDispatcher().useMemo(create, deps);\n    };\n    exports.useOptimistic = function (passthrough, reducer) {\n      return resolveDispatcher().useOptimistic(passthrough, reducer);\n    };\n    exports.useReducer = function (reducer, initialArg, init) {\n      return resolveDispatcher().useReducer(reducer, initialArg, init);\n    };\n    exports.useRef = function (initialValue) {\n      return resolveDispatcher().useRef(initialValue);\n    };\n    exports.useState = function (initialState) {\n      return resolveDispatcher().useState(initialState);\n    };\n    exports.useSyncExternalStore = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot\n    ) {\n      return resolveDispatcher().useSyncExternalStore(\n        subscribe,\n        getSnapshot,\n        getServerSnapshot\n      );\n    };\n    exports.useTransition = function () {\n      return resolveDispatcher().useTransition();\n    };\n    exports.version = \"19.1.1\";\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n","/**\n * Enhanced useACubeOffline Hook\n * Enterprise-grade offline state management with the new queue system\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { EnterpriseQueueManager } from './queue-manager';\nimport type { ACubeSDK } from '@/core/sdk';\nimport type { \n  QueueItemId, \n  QueuePriority, \n  ResourceType, \n  QueueOperationType,\n  QueueStats\n} from './types';\n\nexport interface ProcessingResult {\n  id: QueueItemId;\n  success: boolean;\n  error?: Error;\n  retryCount?: number;\n  processingTime?: number;\n}\n\nexport interface EnhancedOfflineOptions {\n  enabled?: boolean;\n  maxQueueSize?: number;\n  maxRetries?: number;\n  retryDelay?: number;\n  persistQueue?: boolean;\n  syncOnReconnect?: boolean;\n  conflictResolution?: 'client-wins' | 'server-wins' | 'merge' | 'manual';\n  enableBatching?: boolean;\n  batchSize?: number;\n  batchTimeout?: number;\n  enableAnalytics?: boolean;\n  autoProcessing?: boolean;\n  processingInterval?: number;\n  priorityMapping?: Record<string, QueuePriority>;\n}\n\nexport interface EnhancedOfflineResult {\n  // Connection state\n  isOnline: boolean;\n  isOffline: boolean;\n  \n  // Queue state\n  queueSize: number;\n  queueStats: QueueStats;\n  processingStatus: {\n    isProcessing: boolean;\n    processingItems: number;\n    autoProcessing: boolean;\n    readyItems: number;\n  };\n  \n  // Queue operations\n  addToQueue: (\n    operation: QueueOperationType,\n    resource: ResourceType,\n    data: any,\n    options?: {\n      priority?: QueuePriority;\n      optimisticId?: string;\n      metadata?: Record<string, unknown>;\n      scheduledAt?: number;\n    }\n  ) => Promise<QueueItemId>;\n  \n  removeFromQueue: (id: QueueItemId) => Promise<boolean>;\n  getQueuedOperation: (id: QueueItemId) => any;\n  clearQueue: () => Promise<void>;\n  \n  // Processing control\n  sync: () => Promise<ProcessingResult[]>;\n  pause: () => void;\n  resume: () => void;\n  \n  // Analytics and insights\n  getInsights: () => any;\n  getTrendAnalysis: () => any;\n  \n  // Advanced features\n  scheduleOperation: (\n    operation: QueueOperationType,\n    resource: ResourceType,\n    data: any,\n    scheduledAt: number,\n    options?: { priority?: QueuePriority }\n  ) => Promise<QueueItemId>;\n  \n  batchOperations: (\n    operations: Array<{\n      operation: QueueOperationType;\n      resource: ResourceType;\n      data: any;\n      priority?: QueuePriority;\n    }>\n  ) => Promise<QueueItemId[]>;\n  \n  // Event subscriptions\n  onQueueEvent: (event: string, handler: Function) => void;\n  offQueueEvent: (event: string, handler: Function) => void;\n}\n\nconst DEFAULT_OPTIONS: Required<EnhancedOfflineOptions> = {\n  enabled: true,\n  maxQueueSize: 1000,\n  maxRetries: 3,\n  retryDelay: 1000,\n  persistQueue: true,\n  syncOnReconnect: true,\n  conflictResolution: 'server-wins',\n  enableBatching: true,\n  batchSize: 20,\n  batchTimeout: 5000,\n  enableAnalytics: true,\n  autoProcessing: true,\n  processingInterval: 2000,\n  priorityMapping: {\n    payment: 'critical',\n    receipt: 'high',\n    cashier: 'normal',\n    settings: 'low',\n  },\n};\n\nexport function useEnhancedACubeOffline(\n  options: EnhancedOfflineOptions = {}\n): EnhancedOfflineResult {\n  const config = { ...DEFAULT_OPTIONS, ...options };\n  \n  const [state, setState] = useState(() => ({\n    isOnline: typeof navigator !== 'undefined' ? navigator.onLine : true,\n    queueStats: {\n      totalItems: 0,\n      pendingItems: 0,\n      processingItems: 0,\n      completedItems: 0,\n      failedItems: 0,\n      deadItems: 0,\n      averageProcessingTime: 0,\n      successRate: 0,\n      lastProcessedAt: null,\n      throughputPerMinute: 0,\n      priorityDistribution: { critical: 0, high: 0, normal: 0, low: 0 },\n      resourceDistribution: { \n        receipts: 0, \n        cashiers: 0, \n        merchants: 0, \n        'cash-registers': 0, \n        'point-of-sales': 0, \n        pems: 0 \n      },\n    } as QueueStats,\n    processingStatus: {\n      isProcessing: false,\n      processingItems: 0,\n      autoProcessing: config.autoProcessing,\n      readyItems: 0,\n    },\n  }));\n\n  const queueManagerRef = useRef<EnterpriseQueueManager | null>(null);\n  const sdk = useACubeSDK();\n\n  // Initialize queue manager\n  useEffect(() => {\n    if (!config.enabled || !sdk) return;\n\n    const queueManager = new EnterpriseQueueManager({\n      maxSize: config.maxQueueSize,\n      maxRetries: config.maxRetries,\n      defaultConflictResolution: config.conflictResolution,\n      batchingEnabled: config.enableBatching,\n      batchSize: config.batchSize,\n      batchTimeout: config.batchTimeout,\n      analyticsEnabled: config.enableAnalytics,\n      autoProcessing: config.autoProcessing,\n      processingInterval: config.processingInterval,\n      enablePersistence: config.persistQueue,\n    });\n\n    // Register processors for each resource\n    registerSDKProcessors(queueManager, sdk);\n\n    // Set up event listeners\n    setupQueueEventListeners(queueManager, setState);\n\n    queueManagerRef.current = queueManager;\n\n    return () => {\n      queueManager.destroy();\n      queueManagerRef.current = null;\n    };\n  }, [config, sdk]);\n\n  // Monitor online/offline status\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n\n    const handleOnline = () => {\n      setState(prev => ({ ...prev, isOnline: true }));\n      \n      if (config.syncOnReconnect && queueManagerRef.current) {\n        // Delay sync to allow connection to stabilize\n        setTimeout(() => {\n          queueManagerRef.current?.resume();\n        }, 1000);\n      }\n    };\n\n    const handleOffline = () => {\n      setState(prev => ({ ...prev, isOnline: false }));\n      \n      // Pause auto-processing when offline\n      if (queueManagerRef.current) {\n        queueManagerRef.current.pause();\n      }\n    };\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, [config.syncOnReconnect]);\n\n  // Queue operations\n  const addToQueue = useCallback(async (\n    operation: QueueOperationType,\n    resource: ResourceType,\n    data: any,\n    options: {\n      priority?: QueuePriority;\n      optimisticId?: string;\n      metadata?: Record<string, unknown>;\n      scheduledAt?: number;\n    } = {}\n  ): Promise<QueueItemId> => {\n    if (!queueManagerRef.current) {\n      throw new Error('Queue manager not initialized');\n    }\n\n    // Auto-determine priority if not specified\n    const priority = options.priority || \n      config.priorityMapping[operation] || \n      config.priorityMapping[resource] || \n      'normal';\n\n    return queueManagerRef.current.enqueue(operation, resource, data, {\n      ...options,\n      priority,\n    });\n  }, [config.priorityMapping]);\n\n  const removeFromQueue = useCallback(async (id: QueueItemId): Promise<boolean> => {\n    if (!queueManagerRef.current) return false;\n    return queueManagerRef.current.dequeue(id);\n  }, []);\n\n  const getQueuedOperation = useCallback((id: QueueItemId) => {\n    if (!queueManagerRef.current) return null;\n    return queueManagerRef.current.getItem(id);\n  }, []);\n\n  const clearQueue = useCallback(async (): Promise<void> => {\n    if (!queueManagerRef.current) return;\n    await queueManagerRef.current.clear();\n  }, []);\n\n  // Processing control\n  const sync = useCallback(async (): Promise<ProcessingResult[]> => {\n    if (!queueManagerRef.current || !state.isOnline) {\n      return [];\n    }\n\n    const results = await queueManagerRef.current.processAll();\n    // Transform queue-manager results to match expected interface\n    return results.map((result, index) => ({\n      id: `sync_${Date.now()}_${index}` as QueueItemId,\n      success: result.success,\n      ...(result.error && { error: new Error(result.error) }),\n      ...(result.processingTime !== undefined && { processingTime: result.processingTime }),\n    }));\n  }, [state.isOnline]);\n\n  const pause = useCallback(() => {\n    if (!queueManagerRef.current) return;\n    queueManagerRef.current.pause();\n  }, []);\n\n  const resume = useCallback(() => {\n    if (!queueManagerRef.current) return;\n    queueManagerRef.current.resume();\n  }, []);\n\n  // Analytics\n  const getInsights = useCallback(() => {\n    if (!queueManagerRef.current) return null;\n    return queueManagerRef.current.getInsights();\n  }, []);\n\n  const getTrendAnalysis = useCallback(() => {\n    if (!queueManagerRef.current) return null;\n    return queueManagerRef.current.getTrendAnalysis();\n  }, []);\n\n  // Advanced features\n  const scheduleOperation = useCallback(async (\n    operation: QueueOperationType,\n    resource: ResourceType,\n    data: any,\n    scheduledAt: number,\n    options: { priority?: QueuePriority } = {}\n  ): Promise<QueueItemId> => {\n    return addToQueue(operation, resource, data, {\n      ...options,\n      scheduledAt,\n    });\n  }, [addToQueue]);\n\n  const batchOperations = useCallback(async (\n    operations: Array<{\n      operation: QueueOperationType;\n      resource: ResourceType;\n      data: any;\n      priority?: QueuePriority;\n    }>\n  ): Promise<QueueItemId[]> => {\n    // Generate batch ID for tracking (not currently used but reserved for future batch operations)\n    // const batchId = `batch_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n    \n    const ids = await Promise.all(\n      operations.map(op => \n        addToQueue(op.operation, op.resource, op.data, {\n          ...(op.priority && { priority: op.priority }),\n        })\n      )\n    );\n\n    return ids;\n  }, [addToQueue]);\n\n  // Event subscriptions\n  const onQueueEvent = useCallback((event: string, handler: Function) => {\n    if (!queueManagerRef.current) return;\n    queueManagerRef.current.on(event as any, handler as any);\n  }, []);\n\n  const offQueueEvent = useCallback((event: string, handler: Function) => {\n    if (!queueManagerRef.current) return;\n    queueManagerRef.current.off(event as any, handler as any);\n  }, []);\n\n  return {\n    isOnline: state.isOnline,\n    isOffline: !state.isOnline,\n    queueSize: state.queueStats.totalItems,\n    queueStats: state.queueStats,\n    processingStatus: state.processingStatus,\n    addToQueue,\n    removeFromQueue,\n    getQueuedOperation,\n    clearQueue,\n    sync,\n    pause,\n    resume,\n    getInsights,\n    getTrendAnalysis,\n    scheduleOperation,\n    batchOperations,\n    onQueueEvent,\n    offQueueEvent,\n  };\n}\n\n// Helper functions\nfunction registerSDKProcessors(queueManager: EnterpriseQueueManager, sdk: ACubeSDK): void {\n  // Register processors for each resource type\n  \n  // Receipts\n  queueManager.registerProcessor('receipts', 'create', async (item) => {\n    return sdk.receipts.create(item.data as any);\n  });\n  \n  queueManager.registerProcessor('receipts', 'update', async (item) => {\n    const data = item.data as any;\n    return sdk.receipts.update(data.id, data);\n  });\n  \n  queueManager.registerProcessor('receipts', 'delete', async (item) => {\n    const data = item.data as any;\n    return sdk.receipts.delete(data.id);\n  });\n\n  // Cashiers\n  queueManager.registerProcessor('cashiers', 'create', async (item) => {\n    return sdk.cashiers.create(item.data as any);\n  });\n  \n  queueManager.registerProcessor('cashiers', 'update', async (item) => {\n    const data = item.data as any;\n    return sdk.cashiers.update(data.id, data);\n  });\n  \n  queueManager.registerProcessor('cashiers', 'delete', async (item) => {\n    const data = item.data as any;\n    return sdk.cashiers.delete(data.id);\n  });\n\n  // Merchants\n  queueManager.registerProcessor('merchants', 'create', async (item) => {\n    return sdk.merchants.create(item.data as any);\n  });\n  \n  queueManager.registerProcessor('merchants', 'update', async (item) => {\n    const data = item.data as any;\n    return sdk.merchants.update(data.id, data);\n  });\n\n  // Add other resources as needed...\n}\n\nfunction setupQueueEventListeners(\n  queueManager: EnterpriseQueueManager, \n  setState: React.Dispatch<React.SetStateAction<any>>\n): void {\n  // Update stats on queue changes\n  const updateStats = () => {\n    setState((prev: any) => ({\n      ...prev,\n      queueStats: queueManager.getStats(),\n      processingStatus: queueManager.getProcessingStatus(),\n    }));\n  };\n\n  queueManager.on('item:added', updateStats);\n  queueManager.on('item:completed', updateStats);\n  queueManager.on('item:failed', updateStats);\n  queueManager.on('item:processing', updateStats);\n  queueManager.on('queue:drained', updateStats);\n}\n\n// Placeholder for SDK context hook\nfunction useACubeSDK(): ACubeSDK {\n  throw new Error('useACubeSDK must be used within ACubeProvider');\n}","/**\n * Enterprise Queue Management System\n * \n * A comprehensive, enterprise-grade queue management system for handling offline operations\n * with priority-based processing, intelligent batching, conflict resolution, and advanced analytics.\n * \n * @author Claude (Sub-Agent 8: Advanced Queue Management System)\n * @version 1.0.0\n */\n\n// Core Types and Interfaces\nexport * from './types';\nexport type { BottleneckAnalysis } from './queue-analytics';\n\n// Storage Adapters\nexport { BaseStorageAdapter } from '../base/storage-adapter';\nexport { WebStorageAdapter } from '../adapters/web-storage';\nexport { ReactNativeStorageAdapter } from '../adapters/react-native-storage';\n\n// Core Queue Components\nexport { PriorityQueue } from './priority-queue';\nexport { BatchProcessor } from './batch-processor';\nexport { ConflictResolverManager } from './conflict-resolver';\nexport { RetryManager } from './retry-manager';\nexport { QueueAnalytics } from './queue-analytics';\n\n// Main Queue Manager\nexport { EnterpriseQueueManager } from './queue-manager';\n// Import for local usage\nimport { EnterpriseQueueManager } from './queue-manager';\nimport type { BottleneckAnalysis } from './queue-analytics';\n\n// Enhanced React Hook\nexport { useEnhancedACubeOffline } from './enhanced-offline-hook';\nexport type { EnhancedOfflineOptions, EnhancedOfflineResult } from './enhanced-offline-hook';\n\n// Utility functions for creating branded types\nexport { \n  createQueueItemId,\n  isQueueItemId,\n  isValidPriority,\n  isValidOperation,\n  isValidResource\n} from './types';\n\n/**\n * ENTERPRISE QUEUE SYSTEM OVERVIEW\n * =================================\n * \n * This system provides enterprise-grade queue management for offline-first applications\n * with the following key features:\n * \n * 1. PRIORITY-BASED PROCESSING\n *    - Four priority levels: Critical, High, Normal, Low\n *    - Intelligent scheduling based on priority and time\n *    - Resource-aware processing with load balancing\n * \n * 2. INTELLIGENT BATCHING\n *    - Groups related operations by resource, time, or custom criteria\n *    - Configurable batch sizes and timeout windows\n *    - Parallel and sequential processing strategies\n * \n * 3. ADVANCED CONFLICT RESOLUTION\n *    - Multiple strategies: Client-wins, Server-wins, Merge, Manual\n *    - Field-level merge rules with custom resolvers\n *    - Intelligent conflict detection and resolution\n * \n * 4. SOPHISTICATED RETRY LOGIC\n *    - Exponential backoff with jitter\n *    - Circuit breaker pattern for failing services\n *    - Configurable retry policies per resource/operation\n * \n * 5. COMPREHENSIVE ANALYTICS\n *    - Real-time performance metrics\n *    - Trend analysis and forecasting\n *    - Bottleneck detection and optimization suggestions\n *    - Health scoring and anomaly detection\n * \n * 6. ENTERPRISE FEATURES\n *    - Cross-platform storage (Web/React Native)\n *    - Type-safe operations with branded types\n *    - Event-driven architecture with subscriptions\n *    - Configurable persistence and recovery\n * \n * USAGE EXAMPLE\n * =============\n * \n * ```typescript\n * import { useEnhancedACubeOffline } from './storage/queue';\n * \n * function MyComponent() {\n *   const {\n *     addToQueue,\n *     queueStats,\n *     sync,\n *     getInsights\n *   } = useEnhancedACubeOffline({\n *     enableBatching: true,\n *     enableAnalytics: true,\n *     maxRetries: 3,\n *     conflictResolution: 'merge'\n *   });\n * \n *   const createReceipt = async (receiptData) => {\n *     const queueId = await addToQueue(\n *       'create',\n *       'receipts', \n *       receiptData,\n *       { priority: 'high' }\n *     );\n *     \n *     return queueId;\n *   };\n * \n *   const syncOfflineOperations = async () => {\n *     const results = await sync();\n *     console.log('Sync results:', results);\n *   };\n * \n *   return (\n *     <div>\n *       <p>Queue Size: {queueStats.totalItems}</p>\n *       <p>Success Rate: {queueStats.successRate}%</p>\n *       <button onClick={syncOfflineOperations}>\n *         Sync ({queueStats.pendingItems} pending)\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n * \n * ARCHITECTURE COMPONENTS\n * =======================\n * \n * 1. **EnterpriseQueueManager**: Main orchestrator that coordinates all components\n * 2. **PriorityQueue**: Efficient priority-based queue with indexing and metrics\n * 3. **BatchProcessor**: Groups operations for efficient batch processing\n * 4. **ConflictResolverManager**: Handles data conflicts with multiple strategies\n * 5. **RetryManager**: Manages retries with circuit breaker and exponential backoff\n * 6. **QueueAnalytics**: Provides insights, metrics, and performance monitoring\n * 7. **StorageAdapters**: Cross-platform storage abstraction layer\n * 8. **Enhanced Hook**: React integration with enterprise queue features\n * \n * PERFORMANCE CHARACTERISTICS\n * ===========================\n * \n * - Queue Operations: O(log n) enqueue/dequeue with priority indexing\n * - Memory Usage: Optimized with configurable retention and cleanup\n * - Throughput: Supports thousands of operations per minute\n * - Latency: Sub-millisecond queue operations, configurable processing intervals\n * - Scalability: Horizontal scaling through batching and parallel processing\n * \n * RELIABILITY FEATURES\n * ====================\n * \n * - Persistent storage with automatic recovery\n * - Dead letter queue for failed operations\n * - Circuit breaker prevents cascading failures\n * - Operation deduplication prevents duplicate processing\n * - Comprehensive error handling and logging\n * - Health monitoring with automated alerts\n * \n * SECURITY CONSIDERATIONS\n * =======================\n * \n * - Encrypted storage for sensitive operations\n * - Type-safe operations prevent injection attacks\n * - Configurable data sanitization\n * - Audit trail for all queue operations\n * - Access control integration points\n */\n\n// Default configurations for different use cases\nexport const QUEUE_CONFIGS = {\n  /**\n   * High-performance configuration for critical business operations\n   */\n  ENTERPRISE: {\n    maxSize: 10000,\n    maxRetries: 5,\n    defaultPriority: 'high' as const,\n    batchingEnabled: true,\n    batchSize: 50,\n    batchTimeout: 2000,\n    enableAnalytics: true,\n    autoProcessing: true,\n    processingInterval: 500,\n    circuitBreakerEnabled: true,\n    deduplicationEnabled: true,\n  },\n\n  /**\n   * Balanced configuration for standard applications\n   */\n  STANDARD: {\n    maxSize: 5000,\n    maxRetries: 3,\n    defaultPriority: 'normal' as const,\n    batchingEnabled: true,\n    batchSize: 20,\n    batchTimeout: 5000,\n    enableAnalytics: true,\n    autoProcessing: true,\n    processingInterval: 2000,\n    circuitBreakerEnabled: true,\n    deduplicationEnabled: true,\n  },\n\n  /**\n   * Lightweight configuration for simple use cases\n   */\n  LIGHTWEIGHT: {\n    maxSize: 1000,\n    maxRetries: 2,\n    defaultPriority: 'normal' as const,\n    batchingEnabled: false,\n    enableAnalytics: false,\n    autoProcessing: true,\n    processingInterval: 5000,\n    circuitBreakerEnabled: false,\n    deduplicationEnabled: false,\n  },\n\n  /**\n   * Development configuration with extensive debugging\n   */\n  DEVELOPMENT: {\n    maxSize: 100,\n    maxRetries: 1,\n    defaultPriority: 'normal' as const,\n    batchingEnabled: true,\n    batchSize: 5,\n    batchTimeout: 1000,\n    enableAnalytics: true,\n    autoProcessing: false, // Manual processing for debugging\n    processingInterval: 10000,\n    circuitBreakerEnabled: false,\n    deduplicationEnabled: true,\n  },\n} as const;\n\n/**\n * Factory function to create a configured queue manager\n */\nexport function createEnterpriseQueue(\n  preset: keyof typeof QUEUE_CONFIGS = 'STANDARD',\n  overrides: Partial<any> = {}\n) {\n  const config = { ...QUEUE_CONFIGS[preset], ...overrides };\n  return new EnterpriseQueueManager(config);\n}\n\n/**\n * Queue health checker utility\n */\nexport function assessQueueHealth(queueManager: EnterpriseQueueManager) {\n  const stats = queueManager.getStats();\n  const insights = queueManager.getInsights();\n  \n  return {\n    overall: insights.healthScore,\n    recommendations: insights.bottlenecks.map((b: BottleneckAnalysis) => b.suggestion),\n    criticalIssues: insights.bottlenecks.filter((b: BottleneckAnalysis) => b.severity === 'critical'),\n    performance: {\n      throughput: stats.throughputPerMinute,\n      successRate: stats.successRate,\n      averageProcessingTime: stats.averageProcessingTime,\n    },\n    queueStatus: {\n      size: stats.totalItems,\n      pending: stats.pendingItems,\n      processing: stats.processingItems,\n      failed: stats.failedItems,\n    },\n  };\n}","/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\nfunction jsxProd(type, config, maybeKey) {\n  var key = null;\n  void 0 !== maybeKey && (key = \"\" + maybeKey);\n  void 0 !== config.key && (key = \"\" + config.key);\n  if (\"key\" in config) {\n    maybeKey = {};\n    for (var propName in config)\n      \"key\" !== propName && (maybeKey[propName] = config[propName]);\n  } else maybeKey = config;\n  config = maybeKey.ref;\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: void 0 !== config ? config : null,\n    props: maybeKey\n  };\n}\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsxProd;\nexports.jsxs = jsxProd;\n","/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = require(\"react\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsx = function (type, config, maybeKey, source, self) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        !1,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n    exports.jsxs = function (type, config, maybeKey, source, self) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        !0,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","/**\n * ACubeProvider - React Context System for A-Cube SDK\n * Enterprise-grade provider with offline capabilities, sync management, and error boundaries\n */\n\nimport React, { createContext, useContext, useEffect, useState, useRef, ReactNode } from 'react';\nimport { ACubeSDK, type ACubeSDKConfig } from '@/core/sdk';\nimport type { ProgressiveSyncEngine } from '@/sync/sync-engine';\nimport type { UnifiedStorage } from '@/storage/unified-storage';\nimport type { EnterpriseQueueManager } from '@/storage/queue/queue-manager';\nimport type { NetworkManager } from '@/sync/network-manager-simple';\n\nexport interface ACubeContextValue {\n  sdk: ACubeSDK;\n  storage?: UnifiedStorage | undefined;\n  queueManager?: EnterpriseQueueManager | undefined;\n  syncEngine?: ProgressiveSyncEngine | undefined;\n  networkManager?: NetworkManager | undefined;\n  isInitialized: boolean;\n  isOnline: boolean;\n  isOfflineEnabled: boolean;\n  isSyncEnabled: boolean;\n  initializationError?: Error | undefined;\n  \n  // Utility methods\n  enableOffline: () => Promise<void>;\n  enableSync: () => Promise<void>;\n  getOfflineStatus: () => {\n    queuedOperations: number;\n    lastSyncTime?: Date;\n    pendingSyncOperations: number;\n  };\n}\n\nconst ACubeContext = createContext<ACubeContextValue | undefined>(undefined);\n\nexport interface ACubeProviderProps {\n  config: ACubeSDKConfig;\n  children: ReactNode;\n  fallback?: ReactNode;\n  onInitializationError?: (error: Error) => void;\n  autoInitialize?: boolean;\n}\n\n/**\n * Enhanced error boundary for ACube SDK initialization and runtime errors\n */\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error?: Error;\n}\n\nclass ACubeErrorBoundary extends React.Component<\n  { children: ReactNode; fallback?: ReactNode; onError?: (error: Error) => void },\n  ErrorBoundaryState\n> {\n  constructor(props: any) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error };\n  }\n\n  override componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('ACube SDK Error:', error, errorInfo);\n    this.props.onError?.(error);\n  }\n\n  override render() {\n    if (this.state.hasError) {\n      return this.props.fallback || (\n        <div role=\"alert\" style={{ padding: '20px', textAlign: 'center' }}>\n          <h2>Something went wrong with the ACube SDK</h2>\n          <details style={{ whiteSpace: 'pre-wrap', marginTop: '10px' }}>\n            {this.state.error?.toString()}\n          </details>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n/**\n * ACubeProvider - Main provider component for the A-Cube SDK\n * Provides SDK instance, offline storage, queue management, and sync capabilities\n */\nexport const ACubeProvider: React.FC<ACubeProviderProps> = ({\n  config,\n  children,\n  fallback,\n  onInitializationError,\n  autoInitialize = true,\n}) => {\n  // Core state\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [isOnline, setIsOnline] = useState(typeof navigator !== 'undefined' ? navigator.onLine : true);\n  const [initializationError, setInitializationError] = useState<Error>();\n  \n  // SDK instance (created once)\n  const sdkRef = useRef<ACubeSDK | undefined>(undefined);\n  const networkManagerRef = useRef<NetworkManager | undefined>(undefined);\n  \n  // Initialize SDK instance\n  if (!sdkRef.current) {\n    sdkRef.current = new ACubeSDK(config);\n  }\n  \n  const sdk = sdkRef.current;\n\n  // Initialize network manager\n  useEffect(() => {\n    const initializeNetworkManager = async () => {\n      if (!networkManagerRef.current) {\n        try {\n          const { NetworkManager } = await import('@/sync/network-manager-simple');\n          networkManagerRef.current = new NetworkManager();\n          await networkManagerRef.current.initialize?.();\n          \n          // Listen for network changes\n          networkManagerRef.current.onConnectionChange?.((info: any) => {\n            setIsOnline(info.isOnline);\n          });\n        } catch (error) {\n          console.warn('Failed to initialize network manager:', error);\n        }\n      }\n    };\n\n    initializeNetworkManager();\n    \n    return () => {\n      if (networkManagerRef.current) {\n        networkManagerRef.current.destroy?.();\n      }\n    };\n  }, []);\n\n  // Handle browser online/offline events\n  useEffect(() => {\n    const handleOnline = () => setIsOnline(true);\n    const handleOffline = () => setIsOnline(false);\n\n    if (typeof window !== 'undefined') {\n      window.addEventListener('online', handleOnline);\n      window.addEventListener('offline', handleOffline);\n\n      return () => {\n        window.removeEventListener('online', handleOnline);\n        window.removeEventListener('offline', handleOffline);\n      };\n    }\n    \n    return undefined;\n  }, []);\n\n  // SDK initialization\n  useEffect(() => {\n    let mounted = true;\n\n    const initializeSDK = async () => {\n      if (!autoInitialize) return;\n\n      try {\n        await sdk.initialize();\n        \n        if (mounted) {\n          setIsInitialized(true);\n          setInitializationError(undefined);\n        }\n      } catch (error) {\n        const initError = error instanceof Error ? error : new Error('SDK initialization failed');\n        \n        if (mounted) {\n          setInitializationError(initError);\n          onInitializationError?.(initError);\n        }\n      }\n    };\n\n    initializeSDK();\n\n    return () => {\n      mounted = false;\n    };\n  }, [sdk, autoInitialize, onInitializationError]);\n\n  // Utility methods\n  const enableOffline = async (): Promise<void> => {\n    try {\n      // Update configuration to enable offline\n      sdk.updateConfig({\n        ...config,\n        offline: { ...config.offline, enabled: true },\n        features: { ...config.features, enableOfflineQueue: true },\n      });\n      \n      // Initialize storage and queue if not already done\n      if (sdk.storage && sdk.queue) {\n        await sdk.storage.initialize?.();\n        await sdk.queue.initialize?.();\n      }\n    } catch (error) {\n      throw new Error(`Failed to enable offline mode: ${error}`);\n    }\n  };\n\n  const enableSync = async (): Promise<void> => {\n    try {\n      // Update configuration to enable sync\n      sdk.updateConfig({\n        ...config,\n        features: { ...config.features, enableSync: true },\n      });\n      \n      // Initialize sync engine\n      if (sdk.sync) {\n        await sdk.sync.initialize?.();\n      }\n    } catch (error) {\n      throw new Error(`Failed to enable sync: ${error}`);\n    }\n  };\n\n  const getOfflineStatus = () => {\n    let queuedOperations = 0;\n    let pendingSyncOperations = 0;\n    let lastSyncTime: Date | undefined;\n\n    try {\n      if (config.features?.enableOfflineQueue && sdk.queue) {\n        const stats = sdk.queue.getStats();\n        queuedOperations = stats.totalItems;\n      }\n\n      if (config.features?.enableSync && sdk.sync) {\n        const status = sdk.sync.getStatus();\n        pendingSyncOperations = status.activeSyncs + status.queuedSyncs;\n        lastSyncTime = status.lastSync || undefined;\n      }\n    } catch (error) {\n      console.warn('Failed to get offline status:', error);\n    }\n\n    return {\n      queuedOperations,\n      ...(lastSyncTime && { lastSyncTime }),\n      pendingSyncOperations,\n    };\n  };\n\n  // Context value\n  const contextValue: ACubeContextValue = {\n    sdk,\n    storage: config.offline?.enabled ? sdk.storage : undefined,\n    queueManager: config.features?.enableOfflineQueue ? sdk.queue : undefined,\n    syncEngine: config.features?.enableSync ? sdk.sync : undefined,\n    networkManager: networkManagerRef.current || undefined,\n    isInitialized,\n    isOnline,\n    isOfflineEnabled: Boolean(config.offline?.enabled),\n    isSyncEnabled: Boolean(config.features?.enableSync),\n    initializationError: initializationError || undefined,\n    enableOffline,\n    enableSync,\n    getOfflineStatus,\n  };\n\n  const errorBoundaryProps = {\n    fallback,\n    ...(onInitializationError && { onError: onInitializationError }),\n  };\n\n  return (\n    <ACubeErrorBoundary {...errorBoundaryProps}>\n      <ACubeContext.Provider value={contextValue}>\n        {children}\n      </ACubeContext.Provider>\n    </ACubeErrorBoundary>\n  );\n};\n\n/**\n * Hook to access the ACube SDK context\n * Throws an error if used outside of ACubeProvider\n */\nexport const useACube = (): ACubeContextValue => {\n  const context = useContext(ACubeContext);\n  \n  if (context === undefined) {\n    throw new Error('useACube must be used within an ACubeProvider');\n  }\n  \n  return context;\n};\n\n/**\n * Hook to access just the SDK instance\n */\nexport const useACubeSDK = (): ACubeSDK => {\n  const { sdk } = useACube();\n  return sdk;\n};\n\n/**\n * Hook to access offline storage\n */\nexport const useACubeStorage = (): UnifiedStorage => {\n  const { storage } = useACube();\n  \n  if (!storage) {\n    throw new Error('Offline storage is not enabled. Set offline.enabled to true in ACubeProvider config.');\n  }\n  \n  return storage;\n};\n\n/**\n * Hook to access queue manager\n */\nexport const useACubeQueueManager = (): EnterpriseQueueManager => {\n  const { queueManager } = useACube();\n  \n  if (!queueManager) {\n    throw new Error('Offline queue is not enabled. Set features.enableOfflineQueue to true in ACubeProvider config.');\n  }\n  \n  return queueManager;\n};\n\n/**\n * Hook to access sync engine\n */\nexport const useACubeSyncEngine = (): ProgressiveSyncEngine => {\n  const { syncEngine } = useACube();\n  \n  if (!syncEngine) {\n    throw new Error('Sync is not enabled. Set features.enableSync to true in ACubeProvider config.');\n  }\n  \n  return syncEngine;\n};\n\n/**\n * Hook to access network manager\n */\nexport const useACubeNetworkManager = (): NetworkManager | undefined => {\n  const { networkManager } = useACube();\n  return networkManager;\n};\n\n/**\n * Hook for network status\n */\nexport const useACubeNetworkStatus = () => {\n  const { isOnline, networkManager } = useACube();\n  const [connectionInfo, setConnectionInfo] = useState({\n    isOnline,\n    quality: 'unknown' as 'excellent' | 'good' | 'fair' | 'poor' | 'unknown',\n    type: 'unknown' as 'wifi' | 'cellular' | 'ethernet' | 'unknown',\n  });\n\n  useEffect(() => {\n    if (networkManager) {\n      const updateConnectionInfo = (info: any) => {\n        setConnectionInfo({\n          isOnline: info.isOnline,\n          quality: info.quality || 'unknown',\n          type: info.type || 'unknown',\n        });\n      };\n\n      networkManager.onConnectionChange(updateConnectionInfo);\n      \n      // Get initial status\n      const currentInfo = networkManager.getConnectionInfo();\n      updateConnectionInfo(currentInfo);\n    }\n  }, [networkManager]);\n\n  return connectionInfo;\n};\n\nexport default ACubeProvider;","/**\n * useACubeQuery - Enhanced data fetching hook with caching and optimistic updates\n * Inspired by React Query but tailored for A-Cube SDK\n */\n\nimport { useState, useEffect, useRef, useCallback } from 'react';\nimport { useACube } from './ACubeProvider';\nimport type { ACubeSDK } from '@/core/sdk';\n\nexport interface QueryOptions<TData> {\n  enabled?: boolean;\n  refetchOnWindowFocus?: boolean;\n  refetchOnReconnect?: boolean;\n  refetchInterval?: number;\n  staleTime?: number;\n  cacheTime?: number;\n  retry?: boolean | number | ((failureCount: number, error: Error) => boolean);\n  retryDelay?: number | ((retryAttempt: number) => number);\n  onSuccess?: (data: TData) => void;\n  onError?: (error: Error) => void;\n  select?: (data: TData) => any;\n  initialData?: TData;\n  placeholderData?: TData;\n  // Offline-first enhancements\n  offlineFallback?: boolean;\n  persistToStorage?: boolean;\n  storageKey?: string;\n  networkPolicy?: 'cache-first' | 'network-first' | 'offline-first';\n  syncOnReconnect?: boolean;\n}\n\nexport interface QueryResult<TData> {\n  data: TData | undefined;\n  error: Error | null;\n  isLoading: boolean;\n  isFetching: boolean;\n  isError: boolean;\n  isSuccess: boolean;\n  isStale: boolean;\n  refetch: () => Promise<void>;\n  remove: () => void;\n  dataUpdatedAt: number;\n  errorUpdatedAt: number;\n  failureCount: number;\n  isPaused: boolean;\n  status: 'idle' | 'loading' | 'error' | 'success';\n  // Offline-first enhancements\n  isOffline: boolean;\n  isCached: boolean;\n  isFromCache: boolean;\n  syncStatus: 'synced' | 'pending' | 'failed' | 'unknown';\n  offlineDataAvailable: boolean;\n}\n\ninterface QueryCache<TData> {\n  data: TData;\n  timestamp: number;\n  error: Error | null;\n  isStale: boolean;\n}\n\n// Global query cache\nconst queryCache = new Map<string, QueryCache<any>>();\n\n// Global cache garbage collection\nlet cacheCleanupInterval: NodeJS.Timeout | null = null;\n\nfunction startCacheCleanup() {\n  if (cacheCleanupInterval) return;\n  \n  cacheCleanupInterval = setInterval(() => {\n    const now = Date.now();\n    const staleEntries: string[] = [];\n    \n    queryCache.forEach((cache, key) => {\n      // Remove entries older than default cache time (5 minutes)\n      if (now - cache.timestamp > 300000) {\n        staleEntries.push(key);\n      }\n    });\n    \n    staleEntries.forEach(key => queryCache.delete(key));\n  }, 60000) as unknown as NodeJS.Timeout; // Run every minute\n}\n\n// Start cleanup when module loads\nstartCacheCleanup();\n\nexport function useACubeQuery<TData = unknown>(\n  queryKey: string | string[],\n  queryFn: (sdk: ACubeSDK) => Promise<TData>,\n  options: QueryOptions<TData> = {}\n): QueryResult<TData> {\n  const {\n    enabled = true,\n    refetchOnWindowFocus = true,\n    refetchOnReconnect = true,\n    refetchInterval,\n    staleTime = 0,\n    cacheTime = 300000, // 5 minutes - used for cache cleanup logic\n    retry = 3,\n    retryDelay = (attempt) => Math.min(1000 * 2 ** attempt, 30000),\n    onSuccess,\n    onError,\n    select,\n    initialData,\n    placeholderData,\n  } = options;\n\n  const key = Array.isArray(queryKey) ? queryKey.join(':') : queryKey;\n  \n  const [state, setState] = useState<{\n    data: TData | undefined;\n    error: Error | null;\n    isLoading: boolean;\n    isFetching: boolean;\n    isStale: boolean;\n    dataUpdatedAt: number;\n    errorUpdatedAt: number;\n    failureCount: number;\n    status: 'idle' | 'loading' | 'error' | 'success';\n    isFromCache: boolean;\n    syncStatus: 'synced' | 'pending' | 'failed' | 'unknown';\n  }>(() => {\n    const cached = queryCache.get(key);\n    const now = Date.now();\n    \n    if (cached && (now - cached.timestamp) < staleTime) {\n      return {\n        data: select ? select(cached.data) : cached.data,\n        error: cached.error,\n        isLoading: false,\n        isFetching: false,\n        isStale: false,\n        dataUpdatedAt: cached.timestamp,\n        errorUpdatedAt: cached.error ? cached.timestamp : 0,\n        failureCount: 0,\n        status: cached.error ? 'error' : 'success',\n        isFromCache: true,\n        syncStatus: 'synced',\n      };\n    }\n    \n    return {\n      data: initialData || placeholderData,\n      error: null,\n      isLoading: enabled,\n      isFetching: enabled,\n      isStale: false,\n      dataUpdatedAt: 0,\n      errorUpdatedAt: 0,\n      failureCount: 0,\n      status: enabled ? 'loading' : 'idle',\n      isFromCache: false,\n      syncStatus: 'unknown',\n    };\n  });\n\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const refetchIntervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Get SDK and offline systems from context\n  const { \n    sdk, \n    storage, \n    isOnline, \n    isOfflineEnabled \n  } = useACube();\n\n  const fetchData = useCallback(async (isRefetch = false, forceNetwork = false) => {\n    if (!enabled || !sdk) return;\n\n    const {\n      offlineFallback = true,\n      persistToStorage = true,\n      storageKey,\n      networkPolicy = 'cache-first',\n    } = options;\n\n    // Cancel previous request\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n\n    abortControllerRef.current = new AbortController();\n\n    setState(prev => ({\n      ...prev,\n      isFetching: true,\n      isLoading: prev.data === undefined,\n      ...(isRefetch && { isStale: false }),\n      syncStatus: 'pending',\n    }));\n\n    // Offline-first data retrieval strategy\n    let shouldTryNetwork = true;\n    let cacheData: TData | undefined;\n    let isFromCache = false;\n    let isFromOfflineStorage = false;\n\n    // 1. Check memory cache first\n    const cached = queryCache.get(key);\n    if (cached && !forceNetwork) {\n      const now = Date.now();\n      const isCacheValid = (now - cached.timestamp) < staleTime;\n      \n      if (isCacheValid || (networkPolicy === 'cache-first' && !isOnline)) {\n        cacheData = cached.data;\n        isFromCache = true;\n        shouldTryNetwork = networkPolicy === 'network-first' || isRefetch;\n      }\n    }\n\n    // 2. Check offline storage if no valid cache and offline enabled\n    if (!cacheData && isOfflineEnabled && storage && offlineFallback) {\n      try {\n        const offlineKey = storageKey || `query:${key}`;\n        const offlineEntry = await storage.get(offlineKey as any);\n        if (offlineEntry?.data) {\n          cacheData = offlineEntry.data as TData;\n          isFromOfflineStorage = true;\n          shouldTryNetwork = isOnline && (networkPolicy !== 'offline-first' || isRefetch);\n        }\n      } catch (error) {\n        console.warn('Failed to load offline data:', error);\n      }\n    }\n\n    // 3. Return cached/offline data if network unavailable or policy dictates\n    if (cacheData && (!isOnline || !shouldTryNetwork)) {\n      const processedData = select ? select(cacheData) : cacheData;\n      const now = Date.now();\n      \n      setState({\n        data: processedData,\n        error: null,\n        isLoading: false,\n        isFetching: false,\n        isStale: isFromOfflineStorage && isOnline,\n        dataUpdatedAt: cached?.timestamp || now,\n        errorUpdatedAt: 0,\n        failureCount: 0,\n        status: 'success',\n        isFromCache: isFromCache || isFromOfflineStorage,\n        syncStatus: isFromOfflineStorage && isOnline ? 'pending' : 'synced',\n      });\n\n      // Update memory cache if data came from storage\n      if (isFromOfflineStorage) {\n        queryCache.set(key, {\n          data: cacheData,\n          timestamp: now,\n          error: null,\n          isStale: false,\n        });\n      }\n\n      onSuccess?.(cacheData);\n      return;\n    }\n\n    // 4. Attempt network request\n    if (shouldTryNetwork && isOnline) {\n      try {\n        const data = await queryFn(sdk);\n        const now = Date.now();\n        \n        // Update memory cache\n        queryCache.set(key, {\n          data,\n          timestamp: now,\n          error: null,\n          isStale: false,\n        });\n\n        // Persist to storage if enabled\n        if (persistToStorage && isOfflineEnabled && storage) {\n          try {\n            const offlineKey = storageKey || `query:${key}`;\n            await storage.set(offlineKey as any, data as any);\n          } catch (error) {\n            console.warn('Failed to persist query data:', error);\n          }\n        }\n\n        const processedData = select ? select(data) : data;\n\n        setState({\n          data: processedData,\n          error: null,\n          isLoading: false,\n          isFetching: false,\n          isStale: false,\n          dataUpdatedAt: now,\n          errorUpdatedAt: 0,\n          failureCount: 0,\n          status: 'success',\n          isFromCache: false,\n          syncStatus: 'synced',\n        });\n\n        onSuccess?.(data);\n      } catch (error) {\n        const now = Date.now();\n        const err = error instanceof Error ? error : new Error(String(error));\n        \n        // Try to fall back to cached/offline data on network error\n        if (cacheData && offlineFallback) {\n          const processedData = select ? select(cacheData) : cacheData;\n          \n          setState({\n            data: processedData,\n            error: err,\n            isLoading: false,\n            isFetching: false,\n            isStale: true,\n            dataUpdatedAt: cached?.timestamp || now,\n            errorUpdatedAt: now,\n            failureCount: 0,\n            status: 'success', // Success with stale data\n            isFromCache: true,\n            syncStatus: 'failed',\n          });\n\n          onSuccess?.(cacheData);\n          return;\n        }\n        \n        setState(prev => {\n          const newFailureCount = prev.failureCount + 1;\n          const shouldRetry = typeof retry === 'function' \n            ? retry(newFailureCount, err)\n            : typeof retry === 'number' \n              ? newFailureCount < retry\n              : retry && newFailureCount < 3;\n\n          if (shouldRetry && isOnline) {\n            const delay = typeof retryDelay === 'function' \n              ? retryDelay(newFailureCount) \n              : retryDelay;\n            \n            retryTimeoutRef.current = setTimeout(() => {\n              fetchData(true);\n            }, delay) as unknown as NodeJS.Timeout;\n\n            return {\n              ...prev,\n              failureCount: newFailureCount,\n              isFetching: false,\n              isLoading: false,\n              syncStatus: 'pending',\n            };\n          }\n\n          // Update cache with error\n          queryCache.set(key, {\n            data: prev.data as TData,\n            timestamp: now,\n            error: err,\n            isStale: true,\n          });\n\n          onError?.(err);\n\n          return {\n            ...prev,\n            error: err,\n            isLoading: false,\n            isFetching: false,\n            errorUpdatedAt: now,\n            failureCount: newFailureCount,\n            status: 'error',\n            syncStatus: 'failed',\n          };\n        });\n      }\n    } else if (cacheData) {\n      // Offline but have cached data\n      const processedData = select ? select(cacheData) : cacheData;\n      const now = Date.now();\n      \n      setState({\n        data: processedData,\n        error: null,\n        isLoading: false,\n        isFetching: false,\n        isStale: true,\n        dataUpdatedAt: cached?.timestamp || now,\n        errorUpdatedAt: 0,\n        failureCount: 0,\n        status: 'success',\n        isFromCache: true,\n        syncStatus: 'pending',\n      });\n\n      onSuccess?.(cacheData);\n    } else {\n      // No data available and offline\n      setState(prev => ({\n        ...prev,\n        error: new Error('No data available offline'),\n        isLoading: false,\n        isFetching: false,\n        status: 'error',\n        syncStatus: 'failed',\n      }));\n    }\n  }, [enabled, sdk, queryFn, key, retry, retryDelay, select, onSuccess, onError, options, storage, isOnline, isOfflineEnabled, staleTime]);\n\n  const refetch = useCallback(async () => {\n    await fetchData(true);\n  }, [fetchData]);\n\n  const remove = useCallback(() => {\n    queryCache.delete(key);\n    setState(prev => ({\n      ...prev,\n      data: undefined,\n      error: null,\n      isStale: false,\n      dataUpdatedAt: 0,\n      errorUpdatedAt: 0,\n      failureCount: 0,\n      status: 'idle',\n      isFromCache: false,\n      syncStatus: 'unknown',\n    }));\n  }, [key]);\n\n  // Initial fetch\n  useEffect(() => {\n    if (enabled) {\n      fetchData();\n    }\n    \n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n      }\n    };\n  }, [fetchData, enabled]);\n\n  // Refetch interval\n  useEffect(() => {\n    if (refetchInterval && enabled && state.status === 'success') {\n      refetchIntervalRef.current = setInterval(() => {\n        fetchData(true);\n      }, refetchInterval) as unknown as NodeJS.Timeout;\n    }\n\n    return () => {\n      if (refetchIntervalRef.current) {\n        clearInterval(refetchIntervalRef.current);\n      }\n    };\n  }, [refetchInterval, enabled, state.status, fetchData]);\n\n  // Window focus refetch\n  useEffect(() => {\n    if (!refetchOnWindowFocus) return;\n\n    const handleFocus = () => {\n      if (enabled && state.status === 'success') {\n        fetchData(true);\n      }\n    };\n\n    window.addEventListener('focus', handleFocus);\n    return () => window.removeEventListener('focus', handleFocus);\n  }, [refetchOnWindowFocus, enabled, state.status, fetchData]);\n\n  // Network reconnect refetch\n  useEffect(() => {\n    if (!refetchOnReconnect) return;\n\n    const handleOnline = () => {\n      if (enabled && state.status === 'success') {\n        fetchData(true);\n      }\n    };\n\n    window.addEventListener('online', handleOnline);\n    return () => window.removeEventListener('online', handleOnline);\n  }, [refetchOnReconnect, enabled, state.status, fetchData]);\n\n  // Mark data as stale after staleTime and manage cache cleanup\n  useEffect(() => {\n    if (staleTime && state.data && state.status === 'success') {\n      const timeout = setTimeout(() => {\n        setState(prev => ({ ...prev, isStale: true }));\n      }, staleTime) as unknown as NodeJS.Timeout;\n      \n      return () => clearTimeout(timeout);\n    }\n    // Schedule cache cleanup based on cacheTime\n    if (cacheTime && state.data && state.status === 'success') {\n      const cleanupTimeout = setTimeout(() => {\n        queryCache.delete(key);\n      }, cacheTime) as unknown as NodeJS.Timeout;\n      \n      return () => clearTimeout(cleanupTimeout);\n    }\n    // Return empty cleanup function for all code paths\n    return () => {};\n  }, [staleTime, cacheTime, state.data, state.status, key]);\n\n  return {\n    ...state,\n    isError: state.status === 'error',\n    isSuccess: state.status === 'success',\n    isPaused: false, // Could be implemented for network-aware pausing\n    isOffline: !isOnline,\n    isCached: Boolean(queryCache.get(key)),\n    offlineDataAvailable: Boolean(state.data),\n    refetch,\n    remove,\n  };\n}\n\n\n// Export cache utilities for advanced usage\nexport const queryUtils = {\n  getQueryData: <T>(key: string | string[]): T | undefined => {\n    const cacheKey = Array.isArray(key) ? key.join(':') : key;\n    return queryCache.get(cacheKey)?.data;\n  },\n  \n  setQueryData: <T>(key: string | string[], data: T): void => {\n    const cacheKey = Array.isArray(key) ? key.join(':') : key;\n    queryCache.set(cacheKey, {\n      data,\n      timestamp: Date.now(),\n      error: null,\n      isStale: false,\n    });\n  },\n  \n  invalidateQueries: (keyPrefix?: string): void => {\n    if (keyPrefix) {\n      queryCache.forEach((_, key) => {\n        if (key.startsWith(keyPrefix)) {\n          queryCache.delete(key);\n        }\n      });\n    } else {\n      queryCache.clear();\n    }\n  },\n  \n  removeQuery: (key: string | string[]): void => {\n    const cacheKey = Array.isArray(key) ? key.join(':') : key;\n    queryCache.delete(cacheKey);\n  },\n};","/**\n * useACubeMutation - Enhanced mutation hook with optimistic updates and offline support\n * Handles create, update, delete operations with automatic cache invalidation and queue management\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport type { ACubeSDK } from '@/core/sdk';\nimport { queryUtils } from './useACubeQuery';\nimport { useACube } from './ACubeProvider';\nimport type { QueueItem } from '@/storage/queue/queue-manager';\nimport { createQueueItemId } from '@/storage/queue/types';\n\nexport interface MutationOptions<TData, TVariables> {\n  onSuccess?: (data: TData, variables: TVariables) => void;\n  onError?: (error: Error, variables: TVariables) => void;\n  onSettled?: (data: TData | undefined, error: Error | null, variables: TVariables) => void;\n  onMutate?: (variables: TVariables) => Promise<void> | void;\n  retry?: boolean | number | ((failureCount: number, error: Error) => boolean);\n  retryDelay?: number | ((retryAttempt: number) => number);\n  optimisticUpdate?: (variables: TVariables) => any;\n  invalidateQueries?: string | string[];\n  updateQueries?: Record<string, (oldData: any, newData: TData, variables: TVariables) => any>;\n  // Offline-first enhancements\n  queueIfOffline?: boolean;\n  optimisticUpdateDuration?: number; // ms\n  rollbackOnError?: boolean;\n  persistOptimisticUpdates?: boolean;\n  mutationType?: 'create' | 'update' | 'delete' | 'custom';\n  priority?: 'critical' | 'high' | 'normal' | 'low';\n  resourceType?: string;\n  conflictResolution?: 'client-wins' | 'server-wins' | 'merge' | 'manual';\n  onQueued?: (queueId: string) => void;\n  onOptimisticUpdate?: (optimisticData: any) => void;\n  onOptimisticRevert?: (originalData: any) => void;\n}\n\nexport interface MutationResult<TData, TVariables> {\n  data: TData | undefined;\n  error: Error | null;\n  isLoading: boolean;\n  isError: boolean;\n  isSuccess: boolean;\n  isIdle: boolean;\n  failureCount: number;\n  status: 'idle' | 'loading' | 'error' | 'success';\n  mutate: (variables: TVariables) => Promise<TData>;\n  mutateAsync: (variables: TVariables) => Promise<TData>;\n  reset: () => void;\n  context: any;\n  // Offline-first enhancements\n  isOptimistic: boolean;\n  isQueued: boolean;\n  queueId?: string;\n  syncStatus: 'synced' | 'pending' | 'failed' | 'queued' | 'unknown';\n  isOffline: boolean;\n  canRetryOffline: boolean;\n  // Actions\n  revertOptimistic: () => void;\n  forceSync: () => Promise<void>;\n}\n\nexport function useACubeMutation<TData = unknown, TVariables = void>(\n  mutationFn: (variables: TVariables, sdk: ACubeSDK) => Promise<TData>,\n  options: MutationOptions<TData, TVariables> = {}\n): MutationResult<TData, TVariables> {\n  const {\n    onSuccess,\n    onError,\n    onSettled,\n    onMutate,\n    retry = false,\n    retryDelay = (attempt) => Math.min(1000 * 2 ** attempt, 30000),\n    optimisticUpdate,\n    invalidateQueries,\n    updateQueries = {},\n    // Offline-first options\n    queueIfOffline = true,\n    optimisticUpdateDuration = 30000, // 30 seconds\n    rollbackOnError = true,\n    persistOptimisticUpdates = false,\n    mutationType = 'custom',\n    priority = 'normal',\n    resourceType = 'default',\n    conflictResolution = 'client-wins',\n    onQueued,\n    onOptimisticUpdate,\n    onOptimisticRevert,\n  } = options;\n\n  const [state, setState] = useState<{\n    data: TData | undefined;\n    error: Error | null;\n    isLoading: boolean;\n    failureCount: number;\n    status: 'idle' | 'loading' | 'error' | 'success';\n    context: any;\n    isOptimistic: boolean;\n    isQueued: boolean;\n    queueId?: string;\n    syncStatus: 'synced' | 'pending' | 'failed' | 'queued' | 'unknown';\n    originalData?: any;\n  }>({\n    data: undefined,\n    error: null,\n    isLoading: false,\n    failureCount: 0,\n    status: 'idle',\n    context: undefined,\n    isOptimistic: false,\n    isQueued: false,\n    syncStatus: 'unknown',\n  });\n\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const optimisticTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Get SDK and offline systems from context\n  const { \n    sdk, \n    storage, \n    queueManager, \n    isOnline, \n    isOfflineEnabled \n  } = useACube();\n\n  const executeMutation = useCallback(async (variables: TVariables, isRetry = false): Promise<TData> => {\n    if (!sdk) {\n      throw new Error('SDK not available');\n    }\n\n    // Cancel previous request\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    if (optimisticTimeoutRef.current) {\n      clearTimeout(optimisticTimeoutRef.current);\n    }\n\n    abortControllerRef.current = new AbortController();\n\n    if (!isRetry) {\n      setState(prev => ({\n        ...prev,\n        isLoading: true,\n        status: 'loading',\n        error: null,\n        syncStatus: 'pending',\n      }));\n    }\n\n    let context: any;\n    let optimisticData: any;\n    let originalQueryData: Record<string, any> = {};\n    \n    try {\n      // Call onMutate for optimistic updates\n      if (onMutate) {\n        context = await onMutate(variables);\n        setState(prev => ({ ...prev, context }));\n      }\n\n      // Apply optimistic update to cache\n      if (optimisticUpdate) {\n        optimisticData = optimisticUpdate(variables);\n        \n        // Store original data for rollback\n        if (invalidateQueries) {\n          const keys = Array.isArray(invalidateQueries) ? invalidateQueries : [invalidateQueries];\n          keys.forEach(key => {\n            originalQueryData[key] = queryUtils.getQueryData(key);\n            queryUtils.setQueryData(key, optimisticData);\n          });\n        }\n\n        // Update state to reflect optimistic update\n        setState(prev => ({\n          ...prev,\n          data: optimisticData,\n          isOptimistic: true,\n          originalData: originalQueryData,\n          syncStatus: 'pending',\n        }));\n\n        onOptimisticUpdate?.(optimisticData);\n\n        // Set timeout to revert optimistic update if mutation takes too long\n        if (optimisticUpdateDuration > 0) {\n          optimisticTimeoutRef.current = setTimeout(() => {\n            if (rollbackOnError) {\n              revertOptimisticUpdates(originalQueryData);\n            }\n          }, optimisticUpdateDuration) as unknown as NodeJS.Timeout;\n        }\n      }\n\n      // Check if we should go offline-first\n      if (!isOnline && queueIfOffline && isOfflineEnabled && queueManager) {\n        return await queueMutation(variables, context, optimisticData);\n      }\n\n      // Execute the mutation online\n      const data = await mutationFn(variables, sdk);\n\n      // Clear optimistic timeout since we got real data\n      if (optimisticTimeoutRef.current) {\n        clearTimeout(optimisticTimeoutRef.current);\n      }\n\n      setState(prev => ({\n        ...prev,\n        data,\n        error: null,\n        isLoading: false,\n        failureCount: 0,\n        status: 'success',\n        isOptimistic: false,\n        syncStatus: 'synced',\n        originalData: undefined,\n      }));\n\n      // Update cache with real data\n      if (queryUtils) {\n        // Invalidate specified queries\n        if (invalidateQueries) {\n          if (Array.isArray(invalidateQueries)) {\n            invalidateQueries.forEach(key => queryUtils.invalidateQueries(key));\n          } else {\n            queryUtils.invalidateQueries(invalidateQueries);\n          }\n        }\n\n        // Update specific queries\n        Object.entries(updateQueries).forEach(([queryKey, updateFn]) => {\n          const oldData = queryUtils.getQueryData(queryKey);\n          if (oldData !== undefined) {\n            const newData = updateFn(oldData, data, variables);\n            queryUtils.setQueryData(queryKey, newData);\n          }\n        });\n      }\n\n      // Persist to storage if enabled\n      if (persistOptimisticUpdates && storage && isOfflineEnabled) {\n        try {\n          const storageKey = `mutation:${mutationType}:${Date.now()}`;\n          await storage.set(storageKey as any, { data, variables, timestamp: Date.now() } as any);\n        } catch (error) {\n          console.warn('Failed to persist mutation result:', error);\n        }\n      }\n\n      // Call success callback\n      onSuccess?.(data, variables);\n      onSettled?.(data, null, variables);\n\n      return data;\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      \n      // Clear optimistic timeout\n      if (optimisticTimeoutRef.current) {\n        clearTimeout(optimisticTimeoutRef.current);\n      }\n\n      // Handle offline scenario\n      if (!isOnline && queueIfOffline && isOfflineEnabled && queueManager) {\n        try {\n          return await queueMutation(variables, context, optimisticData);\n        } catch (queueError) {\n          // If queuing fails, continue with error handling\n          console.warn('Failed to queue mutation:', queueError);\n        }\n      }\n\n      // Revert optimistic updates on error\n      if (rollbackOnError && optimisticUpdate && Object.keys(originalQueryData).length > 0) {\n        revertOptimisticUpdates(originalQueryData);\n        onOptimisticRevert?.(originalQueryData);\n      }\n\n      setState(prev => {\n        const newFailureCount = prev.failureCount + 1;\n        const shouldRetry = typeof retry === 'function' \n          ? retry(newFailureCount, err)\n          : typeof retry === 'number' \n            ? newFailureCount < retry\n            : retry && newFailureCount < 3;\n\n        if (shouldRetry && isOnline) {\n          const delay = typeof retryDelay === 'function' \n            ? retryDelay(newFailureCount) \n            : retryDelay;\n          \n          retryTimeoutRef.current = setTimeout(() => {\n            executeMutation(variables, true);\n          }, delay) as unknown as NodeJS.Timeout;\n\n          return {\n            ...prev,\n            failureCount: newFailureCount,\n            syncStatus: 'pending',\n          };\n        }\n\n        return {\n          ...prev,\n          data: optimisticData || undefined,\n          error: err,\n          isLoading: false,\n          failureCount: newFailureCount,\n          status: 'error',\n          isOptimistic: Boolean(optimisticData),\n          syncStatus: 'failed',\n          context,\n        };\n      });\n\n      // Call error callbacks\n      onError?.(err, variables);\n      onSettled?.(undefined, err, variables);\n\n      throw err;\n    }\n  }, [sdk, mutationFn, onMutate, onSuccess, onError, onSettled, retry, retryDelay, optimisticUpdate, invalidateQueries, updateQueries, isOnline, queueIfOffline, isOfflineEnabled, queueManager, rollbackOnError, optimisticUpdateDuration, persistOptimisticUpdates, storage, mutationType, onOptimisticUpdate, onOptimisticRevert]);\n\n  // Helper function to queue mutations for offline execution\n  const queueMutation = useCallback(async (\n    variables: TVariables, \n    context: any, \n    optimisticData: any\n  ): Promise<TData> => {\n    if (!queueManager) {\n      throw new Error('Queue manager not available');\n    }\n\n    const queueId = createQueueItemId(`mutation_${Date.now()}_${Math.random().toString(36).substring(2)}`);\n    \n    const queueItem: QueueItem = {\n      id: queueId,\n      operation: mutationType === 'create' ? 'create' : mutationType === 'update' ? 'update' : mutationType === 'delete' ? 'delete' : 'custom',\n      resource: resourceType as any,\n      data: {\n        variables,\n        context,\n        mutationFn: mutationFn.toString(), // Note: This won't work for complex functions\n        options: { ...options },\n      },\n      priority,\n      status: 'pending',\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n      retryCount: 0,\n      maxRetries: 3,\n      retryStrategy: 'exponential',\n      conflictResolution,\n    };\n\n    await queueManager.add(queueItem);\n\n    setState(prev => ({\n      ...prev,\n      isQueued: true,\n      queueId,\n      syncStatus: 'queued',\n      data: optimisticData,\n      isLoading: false,\n      status: 'success', // Success in the sense that it's queued\n    }));\n\n    onQueued?.(queueId);\n    onSuccess?.(optimisticData, variables);\n    onSettled?.(optimisticData, null, variables);\n\n    return optimisticData;\n  }, [queueManager, mutationType, resourceType, priority, conflictResolution, options, onQueued, onSuccess, onSettled]);\n\n  // Helper function to revert optimistic updates\n  const revertOptimisticUpdates = useCallback((originalQueryData: Record<string, any>) => {\n    Object.entries(originalQueryData).forEach(([key, data]) => {\n      if (data !== undefined) {\n        queryUtils.setQueryData(key, data);\n      } else {\n        queryUtils.removeQuery(key);\n      }\n    });\n\n    setState(prev => ({\n      ...prev,\n      isOptimistic: false,\n      data: undefined,\n      ...(prev.originalData && { originalData: undefined }),\n    }));\n  }, []);\n\n  // Helper function to force sync a queued mutation\n  const forceSync = useCallback(async (): Promise<void> => {\n    if (!state.queueId || !queueManager) {\n      return;\n    }\n\n    try {\n      const queueItems = queueManager.getQueueItems();\n      const item = queueItems.find(item => item.id === state.queueId);\n      \n      if (item) {\n        await queueManager.processItem(item);\n        setState(prev => {\n          const newState = {\n            ...prev,\n            isQueued: false,\n            syncStatus: 'synced' as const,\n          };\n          delete (newState as any).queueId;\n          return newState;\n        });\n      }\n    } catch (error) {\n      setState(prev => ({\n        ...prev,\n        syncStatus: 'failed',\n        error: error instanceof Error ? error : new Error('Force sync failed'),\n      }));\n      throw error;\n    }\n  }, [state.queueId, queueManager]);\n\n  // Helper function to revert optimistic updates manually\n  const revertOptimistic = useCallback(() => {\n    if (state.originalData) {\n      revertOptimisticUpdates(state.originalData);\n      onOptimisticRevert?.(state.originalData);\n    }\n  }, [state.originalData, revertOptimisticUpdates, onOptimisticRevert]);\n\n  const mutate = useCallback(async (variables: TVariables): Promise<TData> => {\n    try {\n      return await executeMutation(variables);\n    } catch (error) {\n      // Mutation errors are handled in executeMutation\n      // This is for the async version\n      throw error;\n    }\n  }, [executeMutation]);\n\n  const mutateAsync = useCallback(async (variables: TVariables): Promise<TData> => {\n    return await executeMutation(variables);\n  }, [executeMutation]);\n\n  const reset = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    if (retryTimeoutRef.current) {\n      clearTimeout(retryTimeoutRef.current);\n    }\n    if (optimisticTimeoutRef.current) {\n      clearTimeout(optimisticTimeoutRef.current);\n    }\n    \n    setState({\n      data: undefined,\n      error: null,\n      isLoading: false,\n      failureCount: 0,\n      status: 'idle',\n      context: undefined,\n      isOptimistic: false,\n      isQueued: false,\n      syncStatus: 'unknown',\n    });\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n      }\n      if (optimisticTimeoutRef.current) {\n        clearTimeout(optimisticTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    ...state,\n    isError: state.status === 'error',\n    isSuccess: state.status === 'success',\n    isIdle: state.status === 'idle',\n    isOffline: !isOnline,\n    canRetryOffline: Boolean(queueIfOffline && isOfflineEnabled && queueManager),\n    mutate,\n    mutateAsync,\n    reset,\n    revertOptimistic,\n    forceSync,\n  };\n}\n\n","/**\n * useACubeSubscription - Real-time data subscriptions\n * Handles WebSocket connections and real-time updates\n */\n\nimport { useState, useEffect, useRef, useCallback } from 'react';\nimport type { ACubeSDK } from '@/core/sdk';\n\nexport interface SubscriptionOptions<TData> {\n  enabled?: boolean;\n  reconnect?: boolean;\n  reconnectDelay?: number;\n  maxReconnectAttempts?: number;\n  onData?: (data: TData) => void;\n  onError?: (error: Error) => void;\n  onConnect?: () => void;\n  onDisconnect?: () => void;\n  filter?: (data: TData) => boolean;\n  transform?: (data: any) => TData;\n}\n\nexport interface SubscriptionResult<TData> {\n  data: TData | null;\n  error: Error | null;\n  isConnected: boolean;\n  isConnecting: boolean;\n  isError: boolean;\n  connectionStatus: 'idle' | 'connecting' | 'connected' | 'disconnected' | 'error';\n  reconnectCount: number;\n  subscribe: () => void;\n  unsubscribe: () => void;\n  send: (message: any) => void;\n}\n\nexport function useACubeSubscription<TData = unknown>(\n  subscriptionKey: string,\n  options: SubscriptionOptions<TData> = {}\n): SubscriptionResult<TData> {\n  const {\n    enabled = true,\n    reconnect = true,\n    reconnectDelay = 1000,\n    maxReconnectAttempts = 5,\n    onData,\n    onError,\n    onConnect,\n    onDisconnect,\n    filter,\n    transform,\n  } = options;\n\n  const [state, setState] = useState<{\n    data: TData | null;\n    error: Error | null;\n    isConnected: boolean;\n    isConnecting: boolean;\n    connectionStatus: 'idle' | 'connecting' | 'connected' | 'disconnected' | 'error';\n    reconnectCount: number;\n  }>({\n    data: null,\n    error: null,\n    isConnected: false,\n    isConnecting: false,\n    connectionStatus: 'idle',\n    reconnectCount: 0,\n  });\n\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const isManuallyDisconnected = useRef(false);\n\n  const sdk = useACubeSDK(); // Would need to be implemented\n\n  const connect = useCallback(() => {\n    if (!sdk || !enabled) return;\n\n    setState(prev => ({\n      ...prev,\n      isConnecting: true,\n      connectionStatus: 'connecting',\n      error: null,\n    }));\n\n    try {\n      // Create WebSocket connection\n      const wsUrl = getWebSocketUrl(sdk, subscriptionKey);\n      const ws = new WebSocket(wsUrl);\n      wsRef.current = ws;\n\n      ws.onopen = () => {\n        setState(prev => ({\n          ...prev,\n          isConnected: true,\n          isConnecting: false,\n          connectionStatus: 'connected',\n          error: null,\n          reconnectCount: 0,\n        }));\n        onConnect?.();\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const rawData = JSON.parse(event.data);\n          const processedData = transform ? transform(rawData) : rawData;\n          \n          // Apply filter if provided\n          if (filter && !filter(processedData)) {\n            return;\n          }\n\n          setState(prev => ({\n            ...prev,\n            data: processedData,\n            error: null,\n          }));\n\n          onData?.(processedData);\n        } catch (error) {\n          const err = error instanceof Error ? error : new Error('Failed to parse message');\n          setState(prev => ({ ...prev, error: err }));\n          onError?.(err);\n        }\n      };\n\n      ws.onclose = (event) => {\n        setState(prev => ({\n          ...prev,\n          isConnected: false,\n          isConnecting: false,\n          connectionStatus: event.wasClean ? 'disconnected' : 'error',\n        }));\n\n        onDisconnect?.();\n\n        // Attempt reconnection if not manually disconnected\n        if (!isManuallyDisconnected.current && reconnect && state.reconnectCount < maxReconnectAttempts) {\n          const delay = reconnectDelay * Math.pow(2, state.reconnectCount);\n          \n          reconnectTimeoutRef.current = setTimeout(() => {\n            setState(prev => ({\n              ...prev,\n              reconnectCount: prev.reconnectCount + 1,\n            }));\n            connect();\n          }, delay) as unknown as NodeJS.Timeout;\n        }\n      };\n\n      ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        const err = new Error('WebSocket connection error');\n        setState(prev => ({\n          ...prev,\n          error: err,\n          isConnecting: false,\n          connectionStatus: 'error',\n        }));\n        onError?.(err);\n      };\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Failed to create WebSocket connection');\n      setState(prev => ({\n        ...prev,\n        error: err,\n        isConnecting: false,\n        connectionStatus: 'error',\n      }));\n      onError?.(err);\n    }\n  }, [sdk, enabled, subscriptionKey, reconnect, reconnectDelay, maxReconnectAttempts, onConnect, onDisconnect, onData, onError, filter, transform, state.reconnectCount]);\n\n  const disconnect = useCallback(() => {\n    isManuallyDisconnected.current = true;\n    \n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n\n    setState(prev => ({\n      ...prev,\n      isConnected: false,\n      isConnecting: false,\n      connectionStatus: 'disconnected',\n      reconnectCount: 0,\n    }));\n  }, []);\n\n  const send = useCallback((message: any) => {\n    if (wsRef.current && state.isConnected) {\n      wsRef.current.send(JSON.stringify(message));\n    } else {\n      console.warn('WebSocket is not connected');\n    }\n  }, [state.isConnected]);\n\n  const subscribe = useCallback(() => {\n    isManuallyDisconnected.current = false;\n    connect();\n  }, [connect]);\n\n  const unsubscribe = useCallback(() => {\n    disconnect();\n  }, [disconnect]);\n\n  // Auto-connect when enabled\n  useEffect(() => {\n    if (enabled) {\n      connect();\n    } else {\n      disconnect();\n    }\n\n    return () => {\n      disconnect();\n    };\n  }, [enabled, connect, disconnect]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      disconnect();\n    };\n  }, [disconnect]);\n\n  return {\n    ...state,\n    isError: state.connectionStatus === 'error',\n    subscribe,\n    unsubscribe,\n    send,\n  };\n}\n\n// Helper function to get WebSocket URL\nfunction getWebSocketUrl(sdk: ACubeSDK, subscriptionKey: string): string {\n  // This would be implemented based on SDK configuration\n  const config = sdk.getConfig();\n  const baseUrl = config.baseUrls?.api || 'wss://ereceipts-it-sandbox.acubeapi.com';\n  const wsUrl = baseUrl.replace('https://', 'wss://').replace('http://', 'ws://');\n  return `${wsUrl}/ws/${subscriptionKey}`;\n}\n\n// Placeholder for SDK context hook\nfunction useACubeSDK(): ACubeSDK {\n  throw new Error('useACubeSDK must be used within ACubeProvider');\n}","/**\n * useACubeCache - Advanced cache management hook with TTL, compression, and offline integration\n * Provides enterprise-grade cache management with intelligent compression and storage optimization\n */\n\nimport { useCallback, useEffect, useState, useRef } from 'react';\nimport { useACube } from './ACubeProvider';\n\nexport interface CacheOptions {\n  staleTime?: number;\n  cacheTime?: number;\n  backgroundRefetch?: boolean;\n  persistToStorage?: boolean;\n  storageKey?: string;\n  // Enhanced TTL and compression options\n  maxSize?: number; // Maximum cache size in bytes\n  maxEntries?: number; // Maximum number of entries\n  compressionThreshold?: number; // Compress entries larger than this (bytes)\n  enableCompression?: boolean;\n  compressionLevel?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9; // 1=fastest, 9=best compression\n  ttlStrategy?: 'sliding' | 'absolute' | 'adaptive';\n  evictionStrategy?: 'lru' | 'lfu' | 'fifo' | 'random';\n  enableMetrics?: boolean;\n  syncWithStorage?: boolean; // Sync with UnifiedStorage\n  storageNamespace?: string;\n}\n\nexport interface CacheResult<TData> {\n  data: TData | undefined;\n  isStale: boolean;\n  isCached: boolean;\n  lastUpdated: number | null;\n  cacheSize: number;\n  // Enhanced properties\n  totalSize: number; // Total size in bytes\n  compressionRatio: number; // Compression ratio (original/compressed)\n  hitRate: number; // Cache hit rate percentage\n  isCompressed: boolean; // Whether current data is compressed\n  metrics: CacheMetrics;\n  // Enhanced methods\n  set: (key: string, data: TData, options?: CacheSetOptions) => Promise<void>;\n  get: (key: string) => Promise<TData | undefined>;\n  remove: (key: string) => Promise<void>;\n  clear: () => Promise<void>;\n  invalidate: (keyPrefix?: string) => Promise<void>;\n  prefetch: (key: string, fetcher: () => Promise<TData>) => Promise<void>;\n  gc: () => Promise<void>; // Garbage collection\n  // Advanced methods\n  compress: (key: string) => Promise<boolean>;\n  decompress: (key: string) => Promise<boolean>;\n  optimize: () => Promise<void>; // Optimize cache performance\n  export: () => Promise<string>; // Export cache data\n  import: (data: string) => Promise<void>; // Import cache data\n  getStats: () => CacheMetrics;\n  warmup: (keys: string[], fetcher: (key: string) => Promise<TData>) => Promise<void>;\n}\n\nexport interface CacheSetOptions {\n  ttl?: number;\n  compress?: boolean;\n  priority?: 'high' | 'normal' | 'low';\n  tags?: string[];\n}\n\nexport interface CacheMetrics {\n  totalEntries: number;\n  totalSize: number;\n  compressedEntries: number;\n  hits: number;\n  misses: number;\n  evictions: number;\n  compressionSavings: number;\n  averageAccessTime: number;\n  oldestEntry: number | undefined;\n  newestEntry: number | undefined;\n}\n\ninterface CacheEntry<T> {\n  data: T;\n  timestamp: number;\n  ttl?: number;\n  accessCount: number;\n  lastAccessed: number;\n  // Enhanced properties\n  size: number; // Size in bytes\n  isCompressed: boolean;\n  originalSize: number | undefined; // Original size before compression\n  priority: 'high' | 'normal' | 'low';\n  tags: string[] | undefined;\n  compressionLevel: number | undefined;\n  checksum: string | undefined; // For integrity checking\n}\n\n// Global cache instance\nconst globalCache = new Map<string, CacheEntry<any>>();\n\n// Global metrics tracking\nlet globalMetrics: CacheMetrics = {\n  totalEntries: 0,\n  totalSize: 0,\n  compressedEntries: 0,\n  hits: 0,\n  misses: 0,\n  evictions: 0,\n  compressionSavings: 0,\n  averageAccessTime: 0,\n  oldestEntry: undefined,\n  newestEntry: undefined,\n};\n\nexport function useACubeCache<TData = unknown>(\n  options: CacheOptions = {}\n): CacheResult<TData> {\n  const {\n    staleTime = 300000, // 5 minutes\n    cacheTime = 600000, // 10 minutes\n    backgroundRefetch = true,\n    persistToStorage = false,\n    storageKey = 'acube-cache',\n    // Enhanced options with defaults\n    maxSize = 50 * 1024 * 1024, // 50MB\n    maxEntries = 1000,\n    compressionThreshold = 1024, // 1KB\n    enableCompression = true,\n    compressionLevel = 6, // Balanced compression\n    ttlStrategy = 'absolute',\n    evictionStrategy = 'lru',\n    enableMetrics = true,\n    syncWithStorage = true,\n    storageNamespace = 'cache',\n  } = options;\n\n  const [cacheStats, setCacheStats] = useState({\n    size: globalCache.size,\n    lastUpdated: null as number | null,\n    totalSize: 0,\n    compressionRatio: 1,\n    hitRate: 0,\n    isCompressed: false,\n  });\n\n  // Performance tracking refs\n  const performanceRef = useRef({\n    lastAccessTime: 0,\n    accessTimes: [] as number[],\n  });\n\n  // Get offline systems from context\n  const { \n    storage: unifiedStorage, \n    isOfflineEnabled \n  } = useACube();\n\n  // Compression utilities\n  const compressData = useCallback(async (data: any, compressionLevelParam: number = compressionLevel): Promise<{ compressed: string; originalSize: number; compressedSize: number }> => {\n    try {\n      const jsonString = JSON.stringify(data);\n      const originalSize = new TextEncoder().encode(jsonString).length;\n      \n      // Simple compression simulation (in real implementation, use pako or similar)\n      // Higher compression levels provide better compression (simulated)\n      const compressionFactor = Math.max(0.1, 1 - (compressionLevelParam * 0.1));\n      const compressed = btoa(jsonString); // Base64 encoding as placeholder\n      const compressedSize = Math.floor(new TextEncoder().encode(compressed).length * compressionFactor);\n      \n      return {\n        compressed,\n        originalSize,\n        compressedSize,\n      };\n    } catch (error) {\n      throw new Error(`Compression failed: ${error}`);\n    }\n  }, [compressionLevel]);\n\n  const decompressData = useCallback(async (compressed: string): Promise<any> => {\n    try {\n      // Simple decompression simulation\n      const jsonString = atob(compressed); // Base64 decoding as placeholder\n      return JSON.parse(jsonString);\n    } catch (error) {\n      throw new Error(`Decompression failed: ${error}`);\n    }\n  }, []);\n\n  // Calculate data size in bytes\n  const calculateSize = useCallback((data: any): number => {\n    const jsonString = JSON.stringify(data);\n    return new TextEncoder().encode(jsonString).length;\n  }, []);\n\n  // Generate checksum for data integrity\n  const generateChecksum = useCallback(async (data: any): Promise<string> => {\n    const jsonString = JSON.stringify(data);\n    const encoder = new TextEncoder();\n    const dataBuffer = encoder.encode(jsonString);\n    \n    if (typeof crypto !== 'undefined' && crypto.subtle) {\n      const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\n      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n    }\n    \n    // Fallback simple checksum\n    let hash = 0;\n    for (let i = 0; i < jsonString.length; i++) {\n      const char = jsonString.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return hash.toString(16);\n  }, []);\n\n  // Update metrics\n  const updateMetrics = useCallback(() => {\n    let totalSize = 0;\n    let compressedCount = 0;\n    let compressionSavings = 0;\n    let oldestTimestamp = Date.now();\n    let newestTimestamp = 0;\n\n    globalCache.forEach(entry => {\n      totalSize += entry.size;\n      if (entry.isCompressed) {\n        compressedCount++;\n        if (entry.originalSize) {\n          compressionSavings += (entry.originalSize - entry.size);\n        }\n      }\n      if (entry.timestamp < oldestTimestamp) oldestTimestamp = entry.timestamp;\n      if (entry.timestamp > newestTimestamp) newestTimestamp = entry.timestamp;\n    });\n\n    const hitRate = globalMetrics.hits + globalMetrics.misses > 0 \n      ? (globalMetrics.hits / (globalMetrics.hits + globalMetrics.misses)) * 100 \n      : 0;\n\n    const averageAccessTime = performanceRef.current.accessTimes.length > 0\n      ? performanceRef.current.accessTimes.reduce((a, b) => a + b, 0) / performanceRef.current.accessTimes.length\n      : 0;\n\n    const oldestEntry = globalCache.size > 0 ? oldestTimestamp : undefined;\n    const newestEntry = globalCache.size > 0 ? newestTimestamp : undefined;\n\n    globalMetrics = {\n      ...globalMetrics,\n      totalEntries: globalCache.size,\n      totalSize,\n      compressedEntries: compressedCount,\n      compressionSavings,\n      averageAccessTime,\n      oldestEntry,\n      newestEntry,\n    };\n\n    setCacheStats({\n      size: globalCache.size,\n      lastUpdated: Date.now(),\n      totalSize,\n      compressionRatio: totalSize > 0 ? compressionSavings / totalSize : 1,\n      hitRate,\n      isCompressed: compressedCount > 0,\n    });\n  }, []);\n\n  // Load cache from storage on mount\n  useEffect(() => {\n    const loadFromStorage = async () => {\n      if (!persistToStorage) return;\n\n      try {\n        let stored: string | null = null;\n        \n        // Try unified storage first if available\n        if (syncWithStorage && unifiedStorage && isOfflineEnabled) {\n          try {\n            const storageResult = await unifiedStorage.get(`${storageNamespace}:${storageKey}` as any);\n            stored = storageResult?.data as string;\n          } catch (error) {\n            console.warn('Failed to load from unified storage, falling back to localStorage:', error);\n          }\n        }\n        \n        // Fallback to localStorage\n        if (!stored && typeof window !== 'undefined') {\n          stored = localStorage.getItem(storageKey);\n        }\n\n        if (stored) {\n          const data = JSON.parse(stored);\n          let loadedCount = 0;\n          \n          for (const [key, entry] of Object.entries(data)) {\n            const cacheEntry = entry as CacheEntry<any>;\n            \n            // Validate entry integrity\n            if (cacheEntry.checksum) {\n              const currentChecksum = await generateChecksum(cacheEntry.data);\n              if (currentChecksum !== cacheEntry.checksum) {\n                console.warn(`Cache entry ${key} failed integrity check, skipping`);\n                continue;\n              }\n            }\n            \n            // Check if entry is expired\n            const now = Date.now();\n            if (cacheEntry.ttl && (now - cacheEntry.timestamp) > cacheEntry.ttl) {\n              continue; // Skip expired entries\n            }\n            \n            globalCache.set(key, cacheEntry);\n            loadedCount++;\n          }\n          \n          console.log(`Loaded ${loadedCount} cache entries from storage`);\n          updateMetrics();\n        }\n      } catch (error) {\n        console.warn('Failed to load cache from storage:', error);\n      }\n    };\n\n    loadFromStorage();\n  }, [persistToStorage, storageKey, syncWithStorage, unifiedStorage, isOfflineEnabled, storageNamespace, updateMetrics, generateChecksum]);\n\n  // Enhanced save to storage method\n  const saveToStorage = useCallback(async () => {\n    if (!persistToStorage) return;\n\n    try {\n      const cacheData = Object.fromEntries(globalCache);\n      const serialized = JSON.stringify(cacheData);\n\n      // Try unified storage first if available\n      if (syncWithStorage && unifiedStorage && isOfflineEnabled) {\n        try {\n          await unifiedStorage.set(`${storageNamespace}:${storageKey}` as any, serialized as any);\n          return; // Success with unified storage\n        } catch (error) {\n          console.warn('Failed to save to unified storage, falling back to localStorage:', error);\n        }\n      }\n\n      // Fallback to localStorage\n      if (typeof window !== 'undefined') {\n        localStorage.setItem(storageKey, serialized);\n      }\n    } catch (error) {\n      console.warn('Failed to save cache to storage:', error);\n    }\n  }, [persistToStorage, storageKey, syncWithStorage, unifiedStorage, isOfflineEnabled, storageNamespace]);\n\n  // Eviction strategy implementation\n  const performEviction = useCallback(async (): Promise<void> => {\n    const entries = Array.from(globalCache.entries());\n    let evictedCount = 0;\n\n    switch (evictionStrategy) {\n      case 'lru': {\n        // Remove least recently used entries\n        entries.sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed);\n        const toEvict = Math.ceil(entries.length * 0.2); // Evict 20%\n        \n        for (let i = 0; i < toEvict && globalCache.size > 0; i++) {\n          const entry = entries[i];\n          if (entry) {\n            globalCache.delete(entry[0]);\n            evictedCount++;\n          }\n        }\n        break;\n      }\n      \n      case 'lfu': {\n        // Remove least frequently used entries\n        entries.sort(([, a], [, b]) => a.accessCount - b.accessCount);\n        const toEvict = Math.ceil(entries.length * 0.2);\n        \n        for (let i = 0; i < toEvict && globalCache.size > 0; i++) {\n          const entry = entries[i];\n          if (entry) {\n            globalCache.delete(entry[0]);\n            evictedCount++;\n          }\n        }\n        break;\n      }\n      \n      case 'fifo': {\n        // Remove oldest entries\n        entries.sort(([, a], [, b]) => a.timestamp - b.timestamp);\n        const toEvict = Math.ceil(entries.length * 0.2);\n        \n        for (let i = 0; i < toEvict && globalCache.size > 0; i++) {\n          const entry = entries[i];\n          if (entry) {\n            globalCache.delete(entry[0]);\n            evictedCount++;\n          }\n        }\n        break;\n      }\n      \n      case 'random':\n      default: {\n        // Remove random entries\n        const toEvict = Math.ceil(entries.length * 0.2);\n        const shuffled = entries.sort(() => Math.random() - 0.5);\n        \n        for (let i = 0; i < toEvict && globalCache.size > 0; i++) {\n          const entry = shuffled[i];\n          if (entry) {\n            globalCache.delete(entry[0]);\n            evictedCount++;\n          }\n        }\n        break;\n      }\n    }\n\n    if (evictedCount > 0) {\n      globalMetrics.evictions += evictedCount;\n      updateMetrics();\n      await saveToStorage();\n    }\n  }, [evictionStrategy, updateMetrics, saveToStorage]);\n\n  // Enhanced set method with compression and advanced TTL\n  const set = useCallback(async (key: string, data: TData, options?: CacheSetOptions): Promise<void> => {\n    const now = Date.now();\n    const {\n      ttl = cacheTime,\n      compress = enableCompression,\n      priority = 'normal',\n      tags = [],\n    } = options || {};\n\n    const startTime = performance.now();\n\n    try {\n      // Calculate original size\n      const originalSize = calculateSize(data);\n      let finalData = data;\n      let isCompressed = false;\n      let compressionLevel = 0;\n      let checksum: string | undefined;\n\n      // Apply compression if needed\n      if (compress && originalSize >= compressionThreshold) {\n        try {\n          const compressed = await compressData(data, compressionLevel);\n          if (compressed.compressedSize < originalSize) {\n            finalData = compressed.compressed as TData;\n            isCompressed = true;\n            compressionLevel = compressionLevel;\n            \n            // Update compression savings metric\n            globalMetrics.compressionSavings += (originalSize - compressed.compressedSize);\n          }\n        } catch (error) {\n          console.warn(`Compression failed for ${key}:`, error);\n        }\n      }\n\n      // Generate checksum for integrity\n      if (enableMetrics) {\n        checksum = await generateChecksum(data);\n      }\n\n      // Check cache size limits and evict if necessary\n      let currentSize = 0;\n      globalCache.forEach(entry => currentSize += entry.size);\n      \n      if (currentSize + originalSize > maxSize || globalCache.size >= maxEntries) {\n        await performEviction();\n      }\n\n      // Calculate effective TTL based on strategy\n      let effectiveTtl = ttl;\n      if (ttlStrategy === 'adaptive') {\n        // Adaptive TTL based on access patterns\n        const existingEntry = globalCache.get(key);\n        if (existingEntry && existingEntry.accessCount > 10) {\n          effectiveTtl = Math.min(ttl * 1.5, cacheTime * 2);\n        }\n      }\n\n      // Create cache entry\n      const entry: CacheEntry<TData> = {\n        data: finalData,\n        timestamp: now,\n        ttl: effectiveTtl,\n        accessCount: 1,\n        lastAccessed: now,\n        size: isCompressed ? (finalData as unknown as string).length : originalSize,\n        isCompressed,\n        originalSize: isCompressed ? originalSize : undefined,\n        priority,\n        tags: tags.length > 0 ? tags : undefined,\n        compressionLevel: isCompressed ? compressionLevel : undefined,\n        checksum,\n      };\n\n      globalCache.set(key, entry);\n\n      // Update metrics\n      if (enableMetrics) {\n        const accessTime = performance.now() - startTime;\n        performanceRef.current.accessTimes.push(accessTime);\n        if (performanceRef.current.accessTimes.length > 100) {\n          performanceRef.current.accessTimes = performanceRef.current.accessTimes.slice(-50);\n        }\n      }\n\n      updateMetrics();\n      await saveToStorage();\n\n    } catch (error) {\n      console.error(`Failed to set cache entry ${key}:`, error);\n      throw error;\n    }\n  }, [cacheTime, enableCompression, compressionThreshold, calculateSize, compressData, generateChecksum, enableMetrics, maxSize, maxEntries, ttlStrategy, updateMetrics, saveToStorage]);\n\n  // Enhanced get method with decompression and metrics\n  const get = useCallback(async (key: string): Promise<TData | undefined> => {\n    const startTime = performance.now();\n    const entry = globalCache.get(key);\n    \n    if (!entry) {\n      // Cache miss\n      if (enableMetrics) {\n        globalMetrics.misses++;\n      }\n      return undefined;\n    }\n\n    const now = Date.now();\n    \n    // Check TTL based on strategy\n    let isExpired = false;\n    if (entry.ttl) {\n      if (ttlStrategy === 'sliding') {\n        // Sliding TTL - extend on access\n        isExpired = (now - entry.lastAccessed) > entry.ttl;\n      } else {\n        // Absolute TTL - fixed expiration\n        isExpired = (now - entry.timestamp) > entry.ttl;\n      }\n    }\n    \n    if (isExpired) {\n      globalCache.delete(key);\n      updateMetrics();\n      await saveToStorage();\n      \n      if (enableMetrics) {\n        globalMetrics.misses++;\n      }\n      return undefined;\n    }\n\n    // Update access statistics\n    entry.accessCount++;\n    entry.lastAccessed = now;\n\n    // Cache hit\n    if (enableMetrics) {\n      globalMetrics.hits++;\n      const accessTime = performance.now() - startTime;\n      performanceRef.current.accessTimes.push(accessTime);\n      if (performanceRef.current.accessTimes.length > 100) {\n        performanceRef.current.accessTimes = performanceRef.current.accessTimes.slice(-50);\n      }\n    }\n\n    let data = entry.data;\n\n    // Decompress if needed\n    if (entry.isCompressed && typeof entry.data === 'string') {\n      try {\n        data = await decompressData(entry.data);\n      } catch (error) {\n        console.error(`Decompression failed for ${key}:`, error);\n        // Remove corrupted entry\n        globalCache.delete(key);\n        updateMetrics();\n        await saveToStorage();\n        return undefined;\n      }\n    }\n\n    // Validate checksum if available\n    if (entry.checksum && enableMetrics) {\n      try {\n        const currentChecksum = await generateChecksum(data);\n        if (currentChecksum !== entry.checksum) {\n          console.warn(`Cache entry ${key} failed integrity check, removing`);\n          globalCache.delete(key);\n          updateMetrics();\n          await saveToStorage();\n          return undefined;\n        }\n      } catch (error) {\n        console.warn(`Checksum validation failed for ${key}:`, error);\n      }\n    }\n\n    return data;\n  }, [enableMetrics, ttlStrategy, updateMetrics, saveToStorage, decompressData, generateChecksum]);\n\n  // Enhanced remove method\n  const remove = useCallback(async (key: string): Promise<void> => {\n    globalCache.delete(key);\n    updateMetrics();\n    await saveToStorage();\n  }, [updateMetrics, saveToStorage]);\n\n  // Enhanced clear method\n  const clear = useCallback(async (): Promise<void> => {\n    globalCache.clear();\n    \n    // Reset metrics\n    globalMetrics = {\n      totalEntries: 0,\n      totalSize: 0,\n      compressedEntries: 0,\n      hits: 0,\n      misses: 0,\n      evictions: 0,\n      compressionSavings: 0,\n      averageAccessTime: 0,\n      oldestEntry: undefined,\n      newestEntry: undefined,\n    };\n    \n    setCacheStats({\n      size: 0,\n      lastUpdated: Date.now(),\n      totalSize: 0,\n      compressionRatio: 1,\n      hitRate: 0,\n      isCompressed: false,\n    });\n    \n    await saveToStorage();\n  }, [saveToStorage]);\n\n  // Enhanced invalidate method\n  const invalidate = useCallback(async (keyPrefix?: string): Promise<void> => {\n    if (keyPrefix) {\n      const keysToDelete: string[] = [];\n      globalCache.forEach((_, key) => {\n        if (key.startsWith(keyPrefix)) {\n          keysToDelete.push(key);\n        }\n      });\n      keysToDelete.forEach(key => globalCache.delete(key));\n    } else {\n      globalCache.clear();\n    }\n    \n    updateMetrics();\n    await saveToStorage();\n  }, [updateMetrics, saveToStorage]);\n\n  // Enhanced prefetch method\n  const prefetch = useCallback(async (key: string, fetcher: () => Promise<TData>): Promise<void> => {\n    try {\n      // Check if already cached and not stale\n      const existing = await get(key);\n      if (existing) {\n        const entry = globalCache.get(key);\n        if (entry && (Date.now() - entry.timestamp) < staleTime) {\n          return; // Still fresh, no need to prefetch\n        }\n      }\n\n      const data = await fetcher();\n      await set(key, data);\n    } catch (error) {\n      console.warn(`Failed to prefetch ${key}:`, error);\n    }\n  }, [get, set, staleTime]);\n\n  // Enhanced garbage collection\n  const gc = useCallback(async (): Promise<void> => {\n    const now = Date.now();\n    const keysToDelete: string[] = [];\n\n    globalCache.forEach((entry, key) => {\n      // Remove expired entries based on TTL strategy\n      let isExpired = false;\n      if (entry.ttl) {\n        if (ttlStrategy === 'sliding') {\n          isExpired = (now - entry.lastAccessed) > entry.ttl;\n        } else {\n          isExpired = (now - entry.timestamp) > entry.ttl;\n        }\n      }\n      \n      if (isExpired) {\n        keysToDelete.push(key);\n      }\n      // Remove least recently used entries if cache is too large\n      else if (globalCache.size > maxEntries && (now - entry.lastAccessed) > 3600000) { // 1 hour\n        keysToDelete.push(key);\n      }\n    });\n\n    if (keysToDelete.length > 0) {\n      keysToDelete.forEach(key => globalCache.delete(key));\n      globalMetrics.evictions += keysToDelete.length;\n      updateMetrics();\n      await saveToStorage();\n    }\n  }, [ttlStrategy, maxEntries, updateMetrics, saveToStorage]);\n\n  // Advanced compression method\n  const compress = useCallback(async (key: string): Promise<boolean> => {\n    const entry = globalCache.get(key);\n    if (!entry || entry.isCompressed) {\n      return false;\n    }\n\n    try {\n      const originalSize = calculateSize(entry.data);\n      if (originalSize < compressionThreshold) {\n        return false; // Too small to compress\n      }\n\n      const compressed = await compressData(entry.data, compressionLevel);\n      if (compressed.compressedSize >= originalSize) {\n        return false; // Compression not beneficial\n      }\n\n      // Update entry with compressed data\n      const updatedEntry: CacheEntry<TData> = {\n        ...entry,\n        data: compressed.compressed as TData,\n        isCompressed: true,\n        originalSize,\n        size: compressed.compressedSize,\n        compressionLevel,\n      };\n\n      globalCache.set(key, updatedEntry);\n      globalMetrics.compressionSavings += (originalSize - compressed.compressedSize);\n      globalMetrics.compressedEntries++;\n      \n      updateMetrics();\n      await saveToStorage();\n      \n      return true;\n    } catch (error) {\n      console.error(`Failed to compress ${key}:`, error);\n      return false;\n    }\n  }, [calculateSize, compressionThreshold, compressData, compressionLevel, updateMetrics, saveToStorage]);\n\n  // Advanced decompression method\n  const decompress = useCallback(async (key: string): Promise<boolean> => {\n    const entry = globalCache.get(key);\n    if (!entry || !entry.isCompressed) {\n      return false;\n    }\n\n    try {\n      const decompressed = await decompressData(entry.data as unknown as string);\n      \n      // Update entry with decompressed data\n      const updatedEntry: CacheEntry<TData> = {\n        ...entry,\n        data: decompressed,\n        isCompressed: false,\n        size: entry.originalSize !== undefined ? entry.originalSize : calculateSize(decompressed),\n        originalSize: undefined,\n        compressionLevel: undefined,\n      };\n\n      globalCache.set(key, updatedEntry);\n      if (globalMetrics.compressedEntries > 0) {\n        globalMetrics.compressedEntries--;\n      }\n      \n      updateMetrics();\n      await saveToStorage();\n      \n      return true;\n    } catch (error) {\n      console.error(`Failed to decompress ${key}:`, error);\n      return false;\n    }\n  }, [decompressData, calculateSize, updateMetrics, saveToStorage]);\n\n  // Cache optimization method\n  const optimize = useCallback(async (): Promise<void> => {\n    let optimized = 0;\n\n    // 1. Run garbage collection\n    await gc();\n\n    // 2. Compress large uncompressed entries\n    const entries = Array.from(globalCache.entries());\n    for (const [key, entry] of entries) {\n      if (!entry.isCompressed && entry.size >= compressionThreshold) {\n        const success = await compress(key);\n        if (success) optimized++;\n      }\n    }\n\n    // 3. Remove low-priority entries if still over limit\n    if (globalCache.size > maxEntries * 0.8) {\n      const sortedEntries = entries\n        .filter(([, entry]) => entry.priority === 'low')\n        .sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed);\n      \n      const toRemove = Math.min(sortedEntries.length, Math.ceil(globalCache.size * 0.1));\n      for (let i = 0; i < toRemove; i++) {\n        const entryToDelete = sortedEntries[i];\n        if (entryToDelete) {\n          globalCache.delete(entryToDelete[0]);\n          optimized++;\n        }\n      }\n    }\n\n    if (optimized > 0) {\n      updateMetrics();\n      await saveToStorage();\n    }\n  }, [gc, compressionThreshold, compress, maxEntries, updateMetrics, saveToStorage]);\n\n  // Export cache data\n  const exportCache = useCallback(async (): Promise<string> => {\n    const exportData = {\n      version: '1.0',\n      timestamp: Date.now(),\n      metrics: globalMetrics,\n      entries: Object.fromEntries(globalCache),\n    };\n    \n    return JSON.stringify(exportData, null, 2);\n  }, []);\n\n  // Import cache data\n  const importCache = useCallback(async (data: string): Promise<void> => {\n    try {\n      const importData = JSON.parse(data);\n      \n      if (importData.version !== '1.0') {\n        throw new Error('Unsupported cache export version');\n      }\n\n      // Clear existing cache\n      await clear();\n      \n      // Import entries\n      for (const [key, entry] of Object.entries(importData.entries)) {\n        globalCache.set(key, entry as CacheEntry<any>);\n      }\n      \n      // Import metrics\n      if (importData.metrics) {\n        Object.assign(globalMetrics, importData.metrics);\n      }\n      \n      updateMetrics();\n      await saveToStorage();\n      \n    } catch (error) {\n      throw new Error(`Failed to import cache data: ${error}`);\n    }\n  }, [clear, updateMetrics, saveToStorage]);\n\n  // Get cache statistics\n  const getStats = useCallback((): CacheMetrics => {\n    return { ...globalMetrics };\n  }, []);\n\n  // Warmup cache with multiple keys\n  const warmup = useCallback(async (keys: string[], fetcher: (key: string) => Promise<TData>): Promise<void> => {\n    const promises = keys.map(async (key) => {\n      try {\n        const data = await fetcher(key);\n        await set(key, data, { priority: 'high' });\n      } catch (error) {\n        console.warn(`Failed to warmup ${key}:`, error);\n      }\n    });\n    \n    await Promise.allSettled(promises);\n  }, [set]);\n\n  // Automatic garbage collection\n  useEffect(() => {\n    const interval = setInterval(gc, 300000); // Every 5 minutes\n    return () => clearInterval(interval);\n  }, [gc]);\n\n  // Background refetch for stale data\n  useEffect(() => {\n    if (!backgroundRefetch) return;\n\n    const interval = setInterval(() => {\n      // This would trigger background refetches for stale queries\n      // Implementation would depend on query registration system\n    }, 60000); // Every minute\n\n    return () => clearInterval(interval);\n  }, [backgroundRefetch]);\n\n  return {\n    data: undefined, // This would be the current data for a specific key if provided\n    isStale: false, // Would be calculated based on staleTime\n    isCached: globalCache.size > 0,\n    lastUpdated: cacheStats.lastUpdated,\n    cacheSize: cacheStats.size,\n    totalSize: cacheStats.totalSize,\n    compressionRatio: cacheStats.compressionRatio,\n    hitRate: cacheStats.hitRate,\n    isCompressed: cacheStats.isCompressed,\n    metrics: globalMetrics,\n    // Enhanced methods (now async)\n    set,\n    get,\n    remove,\n    clear,\n    invalidate,\n    prefetch,\n    gc,\n    // Advanced methods\n    compress,\n    decompress,\n    optimize,\n    export: exportCache,\n    import: importCache,\n    getStats,\n    warmup,\n  };\n}","/**\n * useACubeOffline - Modern offline state management and queue synchronization\n * Enhanced with UnifiedStorage, enterprise queue management, and intelligent sync\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { useACube } from './ACubeProvider';\nimport type { QueueItem, QueueStats } from '@/storage/queue/queue-manager';\n\nexport interface OfflineOptions {\n  enabled?: boolean;\n  syncOnReconnect?: boolean;\n  backgroundSync?: boolean;\n  syncInterval?: number; // milliseconds\n  conflictResolution?: 'client' | 'server' | 'merge';\n  onSyncStart?: () => void;\n  onSyncComplete?: (results: SyncResults) => void;\n  onSyncError?: (error: Error) => void;\n  onOfflineChange?: (isOffline: boolean) => void;\n}\n\nexport interface SyncResults {\n  successful: number;\n  failed: number;\n  conflicts: number;\n  duration: number;\n}\n\nexport interface OfflineStatus {\n  queuedOperations: number;\n  cachedEntries: number;\n  offlineEntries: number;\n  lastSyncTime?: Date | undefined;\n  pendingSyncOperations: number;\n}\n\nexport interface OfflineResult {\n  // Network state\n  isOnline: boolean;\n  isOffline: boolean;\n  networkStatus: 'online' | 'offline' | 'reconnecting';\n  \n  // Queue state\n  queueStats: QueueStats;\n  queuedOperations: QueueItem[];\n  \n  // Sync state\n  isSyncing: boolean;\n  syncProgress: number;\n  lastSyncTime: Date | null;\n  lastSyncResults: SyncResults | null;\n  \n  // Storage state\n  storageStatus: OfflineStatus;\n  \n  // Actions\n  sync: () => Promise<SyncResults>;\n  clearQueue: () => Promise<void>;\n  clearCache: () => Promise<void>;\n  getQueuedOperation: (id: string) => QueueItem | undefined;\n  forceSync: (queueId?: string) => Promise<void>;\n  enableOfflineMode: () => Promise<void>;\n  disableOfflineMode: () => void;\n  \n  // Advanced features\n  exportOfflineData: () => Promise<string>;\n  importOfflineData: (data: string) => Promise<void>;\n  getOfflineReport: () => Promise<OfflineStatus>;\n}\n\nexport function useACubeOffline(options: OfflineOptions = {}): OfflineResult {\n  const {\n    enabled = true,\n    syncOnReconnect = true,\n    backgroundSync = false,\n    syncInterval = 30000, // 30 seconds\n    onSyncStart,\n    onSyncComplete,\n    onSyncError,\n    onOfflineChange,\n  } = options;\n\n  // Get SDK and offline systems from context\n  const { \n    storage, \n    queueManager, \n    syncEngine,\n    isOnline: contextIsOnline,\n    isOfflineEnabled,\n    isSyncEnabled \n  } = useACube();\n\n  // Local state\n  const [isOnline, setIsOnline] = useState(contextIsOnline);\n  const [networkStatus, setNetworkStatus] = useState<'online' | 'offline' | 'reconnecting'>(\n    contextIsOnline ? 'online' : 'offline'\n  );\n  const [isSyncing, setIsSyncing] = useState(false);\n  const [syncProgress, setSyncProgress] = useState(0);\n  const [lastSyncTime, setLastSyncTime] = useState<Date | null>(null);\n  const [lastSyncResults, setLastSyncResults] = useState<SyncResults | null>(null);\n  const [queueStats, setQueueStats] = useState<QueueStats>({\n    totalItems: 0,\n    pendingItems: 0,\n    processingItems: 0,\n    completedItems: 0,\n    failedItems: 0,\n    deadItems: 0,\n    averageProcessingTime: 0,\n    successRate: 0,\n    lastProcessedAt: null,\n    throughputPerMinute: 0,\n    priorityDistribution: {\n      critical: 0,\n      high: 0,\n      normal: 0,\n      low: 0,\n    },\n    resourceDistribution: {\n      receipts: 0,\n      cashiers: 0,\n      merchants: 0,\n      'cash-registers': 0,\n      'point-of-sales': 0,\n      pems: 0,\n    },\n  });\n  const [storageStatus, setStorageStatus] = useState<OfflineStatus>({\n    queuedOperations: 0,\n    cachedEntries: 0,\n    offlineEntries: 0,\n    pendingSyncOperations: 0,\n  });\n\n  // Refs for interval management\n  const syncIntervalRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const lastNetworkStatusRef = useRef(contextIsOnline);\n\n  // Update online status when context changes\n  useEffect(() => {\n    const newStatus = contextIsOnline;\n    setIsOnline(newStatus);\n    \n    // Handle status transitions\n    if (lastNetworkStatusRef.current !== newStatus) {\n      setNetworkStatus(newStatus ? 'online' : 'offline');\n      \n      // Reconnection logic\n      if (!lastNetworkStatusRef.current && newStatus && syncOnReconnect) {\n        setNetworkStatus('reconnecting');\n        sync().finally(() => {\n          setNetworkStatus('online');\n        });\n      }\n      \n      // Notify about offline changes\n      onOfflineChange?.(!newStatus);\n      lastNetworkStatusRef.current = newStatus;\n    }\n  }, [contextIsOnline, syncOnReconnect, onOfflineChange]);\n\n  // Update stats periodically\n  const updateStats = useCallback(async () => {\n    if (!enabled || !isOfflineEnabled) return;\n\n    try {\n      // Update queue stats\n      if (queueManager) {\n        const stats = queueManager.getStats();\n        setQueueStats(stats);\n      }\n\n      // Update storage status\n      if (storage) {\n        const offlineStatus: OfflineStatus = {\n          queuedOperations: queueStats.totalItems,\n          cachedEntries: 0,\n          offlineEntries: 0,\n          pendingSyncOperations: 0,\n        };\n\n        // Count cache entries\n        try {\n          const cacheEntries = await storage.query({ keyPrefix: 'api_cache:' });\n          offlineStatus.cachedEntries = cacheEntries.length;\n        } catch (error) {\n          console.warn('Failed to count cache entries:', error);\n        }\n\n        // Count offline entries\n        try {\n          const offlineEntries = await storage.query({ keyPrefix: 'offline:' });\n          offlineStatus.offlineEntries = offlineEntries.length;\n        } catch (error) {\n          console.warn('Failed to count offline entries:', error);\n        }\n\n        // Get sync status\n        if (syncEngine && isSyncEnabled) {\n          const syncStatus = syncEngine.getStatus();\n          offlineStatus.pendingSyncOperations = syncStatus.activeSyncs + syncStatus.queuedSyncs;\n          offlineStatus.lastSyncTime = syncStatus.lastSync ? new Date(syncStatus.lastSync) : undefined;\n          setLastSyncTime(syncStatus.lastSync ? new Date(syncStatus.lastSync) : null);\n        }\n\n        setStorageStatus(offlineStatus);\n      }\n    } catch (error) {\n      console.warn('Failed to update offline stats:', error);\n    }\n  }, [enabled, isOfflineEnabled, queueManager, storage, syncEngine, isSyncEnabled, queueStats.totalItems]);\n\n  // Setup background sync\n  useEffect(() => {\n    if (!enabled || !backgroundSync || !isOnline) return;\n\n    syncIntervalRef.current = setInterval(() => {\n      if (!isSyncing) {\n        sync().catch(console.warn);\n      }\n    }, syncInterval) as unknown as NodeJS.Timeout;\n\n    return () => {\n      if (syncIntervalRef.current) {\n        clearInterval(syncIntervalRef.current);\n      }\n    };\n  }, [enabled, backgroundSync, isOnline, isSyncing, syncInterval]);\n\n  // Update stats on mount and periodically\n  useEffect(() => {\n    updateStats();\n    const statsInterval = setInterval(updateStats, 5000); // Update every 5 seconds\n    return () => clearInterval(statsInterval);\n  }, [updateStats]);\n\n  // Core sync function\n  const sync = useCallback(async (): Promise<SyncResults> => {\n    if (!enabled || !isOfflineEnabled || isSyncing) {\n      return { successful: 0, failed: 0, conflicts: 0, duration: 0 };\n    }\n\n    const startTime = Date.now();\n    setIsSyncing(true);\n    setSyncProgress(0);\n    onSyncStart?.();\n\n    try {\n      const results: SyncResults = {\n        successful: 0,\n        failed: 0,\n        conflicts: 0,\n        duration: 0,\n      };\n\n      // Process queue if available\n      if (queueManager) {\n        setSyncProgress(25);\n        try {\n          await queueManager.processAll();\n          const newStats = queueManager.getStats();\n          results.successful += queueStats.totalItems - newStats.totalItems;\n          results.failed += newStats.failedItems;\n        } catch (error) {\n          console.warn('Queue sync failed:', error);\n          results.failed += queueStats.totalItems;\n        }\n      }\n\n      // Sync with server if sync engine available\n      if (syncEngine && isSyncEnabled) {\n        setSyncProgress(75);\n        try {\n          const syncResult = await syncEngine.executeSync({\n            operation: 'full',\n            direction: 'bidirectional',\n            strategy: 'immediate',\n          });\n          \n          results.successful += syncResult.statistics.recordsSynced;\n          results.conflicts += syncResult.statistics.conflictsDetected;\n          if (syncResult.errors.length > 0) {\n            results.failed += syncResult.errors.length;\n          }\n        } catch (error) {\n          console.warn('Sync engine failed:', error);\n          results.failed += 1;\n        }\n      }\n\n      setSyncProgress(100);\n      results.duration = Date.now() - startTime;\n      \n      setLastSyncTime(new Date());\n      setLastSyncResults(results);\n      await updateStats();\n      \n      onSyncComplete?.(results);\n      return results;\n\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error : new Error('Sync failed');\n      onSyncError?.(errorMessage);\n      throw errorMessage;\n    } finally {\n      setIsSyncing(false);\n      setSyncProgress(0);\n    }\n  }, [enabled, isOfflineEnabled, isSyncing, queueManager, syncEngine, isSyncEnabled, queueStats.totalItems, updateStats, onSyncStart, onSyncComplete, onSyncError]);\n\n  // Get queued operations\n  const getQueuedOperations = useCallback((): QueueItem[] => {\n    if (!queueManager) return [];\n    \n    try {\n      return queueManager.getQueueItems();\n    } catch (error) {\n      console.warn('Failed to get queued operations:', error);\n      return [];\n    }\n  }, [queueManager]);\n\n  // Clear queue\n  const clearQueue = useCallback(async (): Promise<void> => {\n    if (!queueManager) return;\n    \n    try {\n      await queueManager.clear();\n      await updateStats();\n    } catch (error) {\n      console.error('Failed to clear queue:', error);\n      throw error;\n    }\n  }, [queueManager, updateStats]);\n\n  // Clear cache\n  const clearCache = useCallback(async (): Promise<void> => {\n    if (!storage) return;\n    \n    try {\n      const cacheEntries = await storage.query({ keyPrefix: 'api_cache:' });\n      for (const entry of cacheEntries) {\n        await storage.delete(entry.key);\n      }\n      await updateStats();\n    } catch (error) {\n      console.error('Failed to clear cache:', error);\n      throw error;\n    }\n  }, [storage, updateStats]);\n\n  // Get specific queued operation\n  const getQueuedOperation = useCallback((id: string): QueueItem | undefined => {\n    if (!queueManager) return undefined;\n    \n    try {\n      const items = queueManager.getQueueItems();\n      return items.find(item => item.id === id);\n    } catch (error) {\n      console.warn('Failed to get queued operation:', error);\n      return undefined;\n    }\n  }, [queueManager]);\n\n  // Force sync specific item\n  const forceSync = useCallback(async (queueId?: string): Promise<void> => {\n    if (!queueManager) return;\n    \n    try {\n      if (queueId) {\n        const item = getQueuedOperation(queueId);\n        if (item) {\n          await queueManager.processItem(item);\n        }\n      } else {\n        await queueManager.processAll();\n      }\n      await updateStats();\n    } catch (error) {\n      console.error('Failed to force sync:', error);\n      throw error;\n    }\n  }, [queueManager, getQueuedOperation, updateStats]);\n\n  // Enable offline mode\n  const enableOfflineMode = useCallback(async (): Promise<void> => {\n    try {\n      // Initialize storage and queue if available\n      if (storage) {\n        await storage.initialize?.();\n      }\n      if (queueManager) {\n        await queueManager.initialize?.();\n      }\n      await updateStats();\n    } catch (error) {\n      console.error('Failed to enable offline mode:', error);\n      throw error;\n    }\n  }, [storage, queueManager, updateStats]);\n\n  // Disable offline mode\n  const disableOfflineMode = useCallback((): void => {\n    // Clear intervals\n    if (syncIntervalRef.current) {\n      clearInterval(syncIntervalRef.current);\n    }\n  }, []);\n\n  // Export offline data\n  const exportOfflineData = useCallback(async (): Promise<string> => {\n    if (!storage) throw new Error('Storage not available');\n    \n    try {\n      const offlineEntries = await storage.query({ keyPrefix: 'offline:' });\n      const cacheEntries = await storage.query({ keyPrefix: 'api_cache:' });\n      const queueItems = queueManager ? queueManager.getQueueItems() : [];\n      \n      const exportData = {\n        timestamp: new Date().toISOString(),\n        version: '2.0.0',\n        offline: offlineEntries,\n        cache: cacheEntries,\n        queue: queueItems,\n        stats: storageStatus,\n      };\n      \n      return JSON.stringify(exportData, null, 2);\n    } catch (error) {\n      console.error('Failed to export offline data:', error);\n      throw error;\n    }\n  }, [storage, queueManager, storageStatus]);\n\n  // Import offline data\n  const importOfflineData = useCallback(async (data: string): Promise<void> => {\n    if (!storage) throw new Error('Storage not available');\n    \n    try {\n      const importData = JSON.parse(data);\n      \n      // Import offline entries\n      for (const entry of importData.offline || []) {\n        await storage.set(entry.key, entry.value);\n      }\n      \n      // Import cache entries (with expiration check)\n      for (const entry of importData.cache || []) {\n        if (entry.value?.expiresAt && new Date(entry.value.expiresAt) > new Date()) {\n          await storage.set(entry.key, entry.value);\n        }\n      }\n      \n      // Import queue items\n      if (queueManager && importData.queue) {\n        for (const item of importData.queue) {\n          await queueManager.add(item);\n        }\n      }\n      \n      await updateStats();\n    } catch (error) {\n      console.error('Failed to import offline data:', error);\n      throw error;\n    }\n  }, [storage, queueManager, updateStats]);\n\n  // Get offline report\n  const getOfflineReport = useCallback(async (): Promise<OfflineStatus> => {\n    await updateStats();\n    return storageStatus;\n  }, [updateStats, storageStatus]);\n\n  return {\n    // Network state\n    isOnline,\n    isOffline: !isOnline,\n    networkStatus,\n    \n    // Queue state\n    queueStats,\n    queuedOperations: getQueuedOperations(),\n    \n    // Sync state\n    isSyncing,\n    syncProgress,\n    lastSyncTime,\n    lastSyncResults,\n    \n    // Storage state\n    storageStatus,\n    \n    // Actions\n    sync,\n    clearQueue,\n    clearCache,\n    getQueuedOperation,\n    forceSync,\n    enableOfflineMode,\n    disableOfflineMode,\n    \n    // Advanced features\n    exportOfflineData,\n    importOfflineData,\n    getOfflineReport,\n  };\n}","/**\n * React Auth Provider\n * Provides authentication context and state management for React applications\n */\n\nimport React, { createContext, useContext, useEffect, useReducer, useCallback, useRef } from 'react';\nimport type { ACubeSDK } from '@/core/sdk';\nimport type {\n  AuthState,\n  AuthUser,\n  LoginCredentials,\n  LogoutOptions,\n  UserRole,\n  SimpleUserRole,\n  AuthError,\n  PermissionCheck,\n  PermissionResult,\n  SessionInfo,\n} from '@/auth/types';\n\n// Auth Context Types\nexport interface AuthContextValue {\n  // State\n  state: AuthState;\n  user: AuthUser | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: AuthError | null;\n\n  // Actions\n  login: (credentials: LoginCredentials) => Promise<AuthUser>;\n  logout: (options?: LogoutOptions) => Promise<void>;\n  refreshSession: () => Promise<void>;\n  clearError: () => void;\n\n  // Role Management\n  hasRole: (role: UserRole) => boolean;\n  hasAnyRole: (roles: UserRole[]) => boolean;\n  getEffectiveRoles: () => UserRole[];\n  getPrimaryRole: () => UserRole | null;\n  getSimpleRole: () => SimpleUserRole;\n  switchRole: (\n    targetRole: UserRole,\n    context?: {\n      merchant_id?: import('@/types/branded').MerchantId;\n      cashier_id?: import('@/types/branded').CashierId;\n      point_of_sale_id?: import('@/types/branded').PointOfSaleId;\n    }\n  ) => Promise<boolean>;\n\n  // Permissions\n  checkPermission: (permission: PermissionCheck) => Promise<PermissionResult>;\n\n  // Session Management\n  getSessionInfo: () => Promise<SessionInfo | null>;\n}\n\n// Auth Provider Props\nexport interface AuthProviderProps {\n  children: React.ReactNode;\n  sdk: ACubeSDK;\n  autoInitialize?: boolean;\n  onAuthError?: (error: AuthError) => void;\n  onAuthSuccess?: (user: AuthUser) => void;\n  onLogout?: (reason?: string) => void;\n}\n\n// Auth State Management\ntype AuthAction =\n  | { type: 'AUTH_LOADING'; payload: boolean }\n  | { type: 'AUTH_SUCCESS'; payload: { user: AuthUser; accessToken: string; refreshToken: string; expiresAt: number } }\n  | { type: 'AUTH_ERROR'; payload: AuthError }\n  | { type: 'AUTH_LOGOUT' }\n  | { type: 'AUTH_REFRESH'; payload: { accessToken: string; refreshToken: string; expiresAt: number } }\n  | { type: 'AUTH_CLEAR_ERROR' }\n  | { type: 'AUTH_UPDATE_USER'; payload: AuthUser };\n\nfunction authReducer(state: AuthState, action: AuthAction): AuthState {\n  switch (action.type) {\n    case 'AUTH_LOADING':\n      return {\n        ...state,\n        isLoading: action.payload,\n        error: action.payload ? null : state.error, // Clear error when starting new operation\n      };\n\n    case 'AUTH_SUCCESS':\n      return {\n        ...state,\n        isAuthenticated: true,\n        isLoading: false,\n        user: action.payload.user,\n        accessToken: action.payload.accessToken,\n        refreshToken: action.payload.refreshToken,\n        expiresAt: action.payload.expiresAt,\n        error: null,\n      };\n\n    case 'AUTH_ERROR':\n      return {\n        ...state,\n        isAuthenticated: false,\n        isLoading: false,\n        user: null,\n        accessToken: null,\n        refreshToken: null,\n        expiresAt: null,\n        error: action.payload,\n      };\n\n    case 'AUTH_LOGOUT':\n      return {\n        ...state,\n        isAuthenticated: false,\n        isLoading: false,\n        user: null,\n        accessToken: null,\n        refreshToken: null,\n        expiresAt: null,\n        error: null,\n      };\n\n    case 'AUTH_REFRESH':\n      return {\n        ...state,\n        accessToken: action.payload.accessToken,\n        refreshToken: action.payload.refreshToken,\n        expiresAt: action.payload.expiresAt,\n        error: null,\n      };\n\n    case 'AUTH_CLEAR_ERROR':\n      return {\n        ...state,\n        error: null,\n      };\n\n    case 'AUTH_UPDATE_USER':\n      return {\n        ...state,\n        user: action.payload,\n      };\n\n    default:\n      return state;\n  }\n}\n\n// Initial auth state\nconst initialAuthState: AuthState = {\n  isAuthenticated: false,\n  isLoading: false,\n  user: null,\n  accessToken: null,\n  refreshToken: null,\n  expiresAt: null,\n  error: null,\n};\n\n// Create auth context\nconst AuthContext = createContext<AuthContextValue | null>(null);\n\n/**\n * Auth Provider Component\n */\nexport function AuthProvider({\n  children,\n  sdk,\n  autoInitialize = true,\n  onAuthError,\n  onAuthSuccess,\n  onLogout,\n}: AuthProviderProps) {\n  const [state, dispatch] = useReducer(authReducer, initialAuthState);\n  const sdkRef = useRef(sdk);\n\n  // Update SDK ref when it changes\n  useEffect(() => {\n    sdkRef.current = sdk;\n  }, [sdk]);\n\n  // Initialize auth state from SDK\n  const initializeAuth = useCallback(async () => {\n    try {\n      const authState = sdkRef.current.getAuthState();\n      if (authState?.isAuthenticated && authState.user) {\n        dispatch({\n          type: 'AUTH_SUCCESS',\n          payload: {\n            user: authState.user,\n            accessToken: authState.accessToken || '',\n            refreshToken: authState.refreshToken || '',\n            expiresAt: authState.expiresAt || 0,\n          },\n        });\n      }\n    } catch (error) {\n      console.error('Failed to initialize auth state:', error);\n    }\n  }, []);\n\n  // Set up SDK event listeners\n  useEffect(() => {\n    const currentSdk = sdkRef.current;\n\n    // Auth success handler\n    const handleAuthSuccess = (event: any) => {\n      const { user } = event.data;\n      if (user) {\n        const authState = currentSdk.getAuthState();\n        dispatch({\n          type: 'AUTH_SUCCESS',\n          payload: {\n            user,\n            accessToken: authState?.accessToken || '',\n            refreshToken: authState?.refreshToken || '',\n            expiresAt: authState?.expiresAt || 0,\n          },\n        });\n        onAuthSuccess?.(user);\n      }\n    };\n\n    // Auth error handler\n    const handleAuthError = (event: any) => {\n      const error: AuthError = {\n        name: 'AuthError',\n        type: event.data.errorCode || 'UNKNOWN_ERROR',\n        message: event.data.errorMessage || 'Authentication failed',\n        timestamp: Date.now(),\n        recoverable: event.data.retry || false,\n      };\n      dispatch({ type: 'AUTH_ERROR', payload: error });\n      onAuthError?.(error);\n    };\n\n    // Auth logout handler\n    const handleAuthLogout = (event: any) => {\n      dispatch({ type: 'AUTH_LOGOUT' });\n      onLogout?.(event.data.reason);\n    };\n\n    // Token refresh handler\n    const handleTokenRefresh = () => {\n      const authState = currentSdk.getAuthState();\n      if (authState?.accessToken) {\n        dispatch({\n          type: 'AUTH_REFRESH',\n          payload: {\n            accessToken: authState.accessToken,\n            refreshToken: authState.refreshToken || '',\n            expiresAt: authState.expiresAt || 0,\n          },\n        });\n      }\n    };\n\n    // Register event listeners\n    currentSdk.on('auth.success', handleAuthSuccess);\n    currentSdk.on('auth.error', handleAuthError);\n    currentSdk.on('auth.logout', handleAuthLogout);\n    currentSdk.on('auth.refreshed', handleTokenRefresh);\n\n    // Cleanup\n    return () => {\n      currentSdk.off('auth.success', handleAuthSuccess);\n      currentSdk.off('auth.error', handleAuthError);\n      currentSdk.off('auth.logout', handleAuthLogout);\n      currentSdk.off('auth.refreshed', handleTokenRefresh);\n    };\n  }, [onAuthError, onAuthSuccess, onLogout]);\n\n  // Auto-initialize on mount\n  useEffect(() => {\n    if (autoInitialize) {\n      initializeAuth();\n    }\n  }, [autoInitialize, initializeAuth]);\n\n  // Auth actions\n  const login = useCallback(async (credentials: LoginCredentials): Promise<AuthUser> => {\n    dispatch({ type: 'AUTH_LOADING', payload: true });\n    try {\n      const user = await sdkRef.current.login(credentials);\n      return user;\n    } catch (error) {\n      const authError: AuthError = {\n        name: 'AuthError',\n        type: error instanceof Error && 'type' in error ? (error as any).type : 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Login failed',\n        timestamp: Date.now(),\n        recoverable: false,\n      };\n      dispatch({ type: 'AUTH_ERROR', payload: authError });\n      throw error;\n    } finally {\n      dispatch({ type: 'AUTH_LOADING', payload: false });\n    }\n  }, []);\n\n  const logout = useCallback(async (options?: LogoutOptions): Promise<void> => {\n    dispatch({ type: 'AUTH_LOADING', payload: true });\n    try {\n      await sdkRef.current.logout(options);\n    } catch (error) {\n      console.error('Logout error:', error);\n      // Always clear local state even if logout fails\n      dispatch({ type: 'AUTH_LOGOUT' });\n    } finally {\n      dispatch({ type: 'AUTH_LOADING', payload: false });\n    }\n  }, []);\n\n  const refreshSession = useCallback(async (): Promise<void> => {\n    try {\n      const authService = sdkRef.current.authService;\n      await authService.refreshSession();\n    } catch (error) {\n      const authError: AuthError = {\n        name: 'AuthError',\n        type: 'SESSION_EXPIRED',\n        message: 'Failed to refresh session',\n        timestamp: Date.now(),\n        recoverable: false,\n      };\n      dispatch({ type: 'AUTH_ERROR', payload: authError });\n      throw error;\n    }\n  }, []);\n\n  const clearError = useCallback(() => {\n    dispatch({ type: 'AUTH_CLEAR_ERROR' });\n  }, []);\n\n  // Role management\n  const hasRole = useCallback((role: UserRole): boolean => {\n    return sdkRef.current.hasRole(role);\n  }, []);\n\n  const hasAnyRole = useCallback((roles: UserRole[]): boolean => {\n    return sdkRef.current.hasAnyRole(roles);\n  }, []);\n\n  const getEffectiveRoles = useCallback((): UserRole[] => {\n    return sdkRef.current.getEffectiveRoles();\n  }, []);\n\n  const getPrimaryRole = useCallback((): UserRole | null => {\n    return sdkRef.current.getPrimaryRole();\n  }, []);\n\n  const getSimpleRole = useCallback((): SimpleUserRole => {\n    return sdkRef.current.getSimpleRole();\n  }, []);\n\n  const switchRole = useCallback(async (\n    targetRole: UserRole,\n    context?: {\n      merchant_id?: import('@/types/branded').MerchantId;\n      cashier_id?: import('@/types/branded').CashierId;\n      point_of_sale_id?: import('@/types/branded').PointOfSaleId;\n    }\n  ): Promise<boolean> => {\n    try {\n      const success = await sdkRef.current.switchRole(targetRole, context);\n      if (success) {\n        // Update user in state\n        const updatedUser = sdkRef.current.getCurrentUser();\n        if (updatedUser) {\n          dispatch({ type: 'AUTH_UPDATE_USER', payload: updatedUser });\n        }\n      }\n      return success;\n    } catch (error) {\n      console.error('Role switch failed:', error);\n      return false;\n    }\n  }, []);\n\n  // Permission checking\n  const checkPermission = useCallback(async (permission: PermissionCheck): Promise<PermissionResult> => {\n    return sdkRef.current.authService.checkPermission(permission);\n  }, []);\n\n  // Session management\n  const getSessionInfo = useCallback(async (): Promise<SessionInfo | null> => {\n    return sdkRef.current.authService.getSessionInfo();\n  }, []);\n\n  // Context value\n  const contextValue: AuthContextValue = {\n    // State\n    state,\n    user: state.user,\n    isAuthenticated: state.isAuthenticated,\n    isLoading: state.isLoading,\n    error: state.error,\n\n    // Actions\n    login,\n    logout,\n    refreshSession,\n    clearError,\n\n    // Role Management\n    hasRole,\n    hasAnyRole,\n    getEffectiveRoles,\n    getPrimaryRole,\n    getSimpleRole,\n    switchRole,\n\n    // Permissions\n    checkPermission,\n\n    // Session Management\n    getSessionInfo,\n  };\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\n/**\n * Hook to use auth context\n */\nexport function useAuthContext(): AuthContextValue {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuthContext must be used within an AuthProvider');\n  }\n  return context;\n}\n\n/**\n * Hook to check if auth is available\n */\nexport function useAuthAvailable(): boolean {\n  return useContext(AuthContext) !== null;\n}","/**\n * React Auth Hooks\n * Convenient hooks for authentication functionality in React applications\n */\n\nimport { useState, useCallback, useEffect } from 'react';\nimport { useAuthContext } from './auth-provider';\nimport type {\n  LoginCredentials,\n  LogoutOptions,\n  AuthUser,\n  AuthError,\n  UserRole,\n  PermissionCheck,\n  PermissionResult,\n  SessionInfo,\n} from '@/auth/types';\n\n/**\n * Main authentication hook\n * Provides complete auth state and actions\n */\nexport function useAuth() {\n  const context = useAuthContext();\n  return {\n    // State\n    user: context.user,\n    isAuthenticated: context.isAuthenticated,\n    isLoading: context.isLoading,\n    error: context.error,\n    \n    // Actions\n    login: context.login,\n    logout: context.logout,\n    refreshSession: context.refreshSession,\n    clearError: context.clearError,\n    \n    // Role Management\n    hasRole: context.hasRole,\n    hasAnyRole: context.hasAnyRole,\n    getEffectiveRoles: context.getEffectiveRoles,\n    getPrimaryRole: context.getPrimaryRole,\n    getSimpleRole: context.getSimpleRole,\n    switchRole: context.switchRole,\n    \n    // Permissions\n    checkPermission: context.checkPermission,\n    \n    // Session\n    getSessionInfo: context.getSessionInfo,\n  };\n}\n\n/**\n * Hook for login functionality\n * Manages login state and provides login action\n */\nexport function useLogin() {\n  const { login: contextLogin, isLoading, error, clearError } = useAuthContext();\n  const [loginError, setLoginError] = useState<AuthError | null>(null);\n\n  const login = useCallback(async (credentials: LoginCredentials): Promise<AuthUser> => {\n    try {\n      setLoginError(null);\n      const user = await contextLogin(credentials);\n      return user;\n    } catch (error) {\n      const authError = error as AuthError;\n      setLoginError(authError);\n      throw error;\n    }\n  }, [contextLogin]);\n\n  const clearLoginError = useCallback(() => {\n    setLoginError(null);\n    clearError();\n  }, [clearError]);\n\n  return {\n    login,\n    isLogging: isLoading,\n    loginError: loginError || error,\n    clearLoginError,\n  };\n}\n\n/**\n * Hook for logout functionality\n * Manages logout state and provides logout action\n */\nexport function useLogout() {\n  const { logout: contextLogout, isLoading } = useAuthContext();\n  const [isLoggingOut, setIsLoggingOut] = useState(false);\n\n  const logout = useCallback(async (options?: LogoutOptions): Promise<void> => {\n    try {\n      setIsLoggingOut(true);\n      await contextLogout(options);\n    } finally {\n      setIsLoggingOut(false);\n    }\n  }, [contextLogout]);\n\n  return {\n    logout,\n    isLoggingOut: isLoggingOut || isLoading,\n  };\n}\n\n/**\n * Hook for user information\n * Provides current user data and user-related utilities\n */\nexport function useUser() {\n  const { user, isAuthenticated } = useAuthContext();\n\n  return {\n    user,\n    isAuthenticated,\n    userId: user?.id,\n    userEmail: user?.email,\n    userName: user?.name,\n    userRoles: user?.roles || [],\n    userPermissions: user?.permissions || [],\n    lastLogin: user?.last_login,\n    sessionId: user?.session_id,\n  };\n}\n\n/**\n * Hook for role management\n * Provides role checking and switching functionality\n */\nexport function useRoles() {\n  const {\n    hasRole,\n    hasAnyRole,\n    getEffectiveRoles,\n    getPrimaryRole,\n    getSimpleRole,\n    switchRole,\n    user,\n  } = useAuthContext();\n\n  const [isSwitchingRole, setIsSwitchingRole] = useState(false);\n\n  const switchToRole = useCallback(async (\n    targetRole: UserRole,\n    context?: {\n      merchant_id?: import('@/types/branded').MerchantId;\n      cashier_id?: import('@/types/branded').CashierId;\n      point_of_sale_id?: import('@/types/branded').PointOfSaleId;\n    }\n  ): Promise<boolean> => {\n    try {\n      setIsSwitchingRole(true);\n      return await switchRole(targetRole, context);\n    } finally {\n      setIsSwitchingRole(false);\n    }\n  }, [switchRole]);\n\n  const currentRoles = user?.roles || [];\n  const effectiveRoles = getEffectiveRoles();\n  const primaryRole = getPrimaryRole();\n  const simpleRole = getSimpleRole();\n\n  return {\n    currentRoles,\n    effectiveRoles,\n    primaryRole,\n    simpleRole,\n    hasRole,\n    hasAnyRole,\n    switchRole: switchToRole,\n    isSwitchingRole,\n  };\n}\n\n/**\n * Hook for permission checking\n * Provides permission checking functionality with caching\n */\nexport function usePermissions() {\n  const { checkPermission } = useAuthContext();\n  const [permissionCache, setPermissionCache] = useState<Map<string, PermissionResult>>(new Map());\n  const [checkingPermissions, setCheckingPermissions] = useState<Set<string>>(new Set());\n\n  const checkPermissionWithCache = useCallback(async (\n    permission: PermissionCheck,\n    useCache = true\n  ): Promise<PermissionResult> => {\n    const cacheKey = `${permission.resource}:${permission.action}:${JSON.stringify(permission.context || {})}`;\n    \n    // Return cached result if available and cache is enabled\n    if (useCache && permissionCache.has(cacheKey)) {\n      return permissionCache.get(cacheKey)!;\n    }\n\n    // Prevent duplicate requests\n    if (checkingPermissions.has(cacheKey)) {\n      // Wait for ongoing request\n      return new Promise((resolve) => {\n        const checkCache = () => {\n          if (permissionCache.has(cacheKey)) {\n            resolve(permissionCache.get(cacheKey)!);\n          } else {\n            setTimeout(checkCache, 50);\n          }\n        };\n        checkCache();\n      });\n    }\n\n    try {\n      setCheckingPermissions(prev => new Set(prev).add(cacheKey));\n      const result = await checkPermission(permission);\n      \n      // Cache successful results\n      if (useCache) {\n        setPermissionCache(prev => new Map(prev).set(cacheKey, result));\n      }\n      \n      return result;\n    } finally {\n      setCheckingPermissions(prev => {\n        const newSet = new Set(prev);\n        newSet.delete(cacheKey);\n        return newSet;\n      });\n    }\n  }, [checkPermission, permissionCache, checkingPermissions]);\n\n  const clearPermissionCache = useCallback(() => {\n    setPermissionCache(new Map());\n  }, []);\n\n  const isCheckingPermission = useCallback((permission: PermissionCheck): boolean => {\n    const cacheKey = `${permission.resource}:${permission.action}:${JSON.stringify(permission.context || {})}`;\n    return checkingPermissions.has(cacheKey);\n  }, [checkingPermissions]);\n\n  return {\n    checkPermission: checkPermissionWithCache,\n    clearPermissionCache,\n    isCheckingPermission,\n  };\n}\n\n/**\n * Hook for session management\n * Provides session information and management\n */\nexport function useSession() {\n  const { getSessionInfo, refreshSession, isAuthenticated } = useAuthContext();\n  const [sessionInfo, setSessionInfo] = useState<SessionInfo | null>(null);\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const [sessionError, setSessionError] = useState<string | null>(null);\n\n  // Load session info\n  const loadSessionInfo = useCallback(async () => {\n    if (!isAuthenticated) {\n      setSessionInfo(null);\n      return;\n    }\n\n    try {\n      const info = await getSessionInfo();\n      setSessionInfo(info);\n      setSessionError(null);\n    } catch (error) {\n      setSessionError(error instanceof Error ? error.message : 'Failed to load session info');\n    }\n  }, [getSessionInfo, isAuthenticated]);\n\n  // Refresh session\n  const refresh = useCallback(async (): Promise<void> => {\n    try {\n      setIsRefreshing(true);\n      setSessionError(null);\n      await refreshSession();\n      await loadSessionInfo(); // Reload session info after refresh\n    } catch (error) {\n      setSessionError(error instanceof Error ? error.message : 'Failed to refresh session');\n      throw error;\n    } finally {\n      setIsRefreshing(false);\n    }\n  }, [refreshSession, loadSessionInfo]);\n\n  // Load session info when authentication state changes\n  useEffect(() => {\n    loadSessionInfo();\n  }, [loadSessionInfo]);\n\n  // Auto-refresh session before expiration\n  useEffect(() => {\n    if (!sessionInfo?.expiresAt || !isAuthenticated) return;\n\n    const expiresAt = sessionInfo.expiresAt.getTime();\n    const now = Date.now();\n    const timeUntilExpiry = expiresAt - now;\n    const refreshBuffer = 5 * 60 * 1000; // 5 minutes before expiry\n\n    if (timeUntilExpiry > refreshBuffer) {\n      const refreshTimeout = setTimeout(() => {\n        refresh().catch(error => {\n          console.error('Auto-refresh failed:', error);\n        });\n      }, timeUntilExpiry - refreshBuffer);\n\n      return () => clearTimeout(refreshTimeout);\n    }\n    \n    return undefined;\n  }, [sessionInfo, isAuthenticated, refresh]);\n\n  return {\n    sessionInfo,\n    isRefreshing,\n    sessionError,\n    refreshSession: refresh,\n    reloadSessionInfo: loadSessionInfo,\n    isSessionExpired: sessionInfo ? sessionInfo.expiresAt.getTime() < Date.now() : false,\n    timeUntilExpiry: sessionInfo ? Math.max(0, sessionInfo.expiresAt.getTime() - Date.now()) : 0,\n  };\n}\n\n/**\n * Hook to require authentication\n * Throws error or redirects if user is not authenticated\n */\nexport function useRequireAuth(redirectTo?: string) {\n  const { isAuthenticated, isLoading } = useAuthContext();\n\n  useEffect(() => {\n    if (!isLoading && !isAuthenticated) {\n      if (redirectTo && typeof window !== 'undefined') {\n        window.location.href = redirectTo;\n      } else {\n        throw new Error('Authentication required');\n      }\n    }\n  }, [isAuthenticated, isLoading, redirectTo]);\n\n  return { isAuthenticated, isLoading };\n}\n\n/**\n * Hook to require specific role\n * Throws error if user doesn't have required role\n */\nexport function useRequireRole(requiredRole: UserRole | UserRole[], fallbackComponent?: React.ComponentType) {\n  const { hasRole, hasAnyRole, isAuthenticated, isLoading } = useAuthContext();\n\n  const hasRequiredRole = Array.isArray(requiredRole) \n    ? hasAnyRole(requiredRole)\n    : hasRole(requiredRole);\n\n  useEffect(() => {\n    if (!isLoading && isAuthenticated && !hasRequiredRole) {\n      if (!fallbackComponent) {\n        throw new Error(`Required role not found: ${Array.isArray(requiredRole) ? requiredRole.join(', ') : requiredRole}`);\n      }\n    }\n  }, [hasRequiredRole, isAuthenticated, isLoading, requiredRole, fallbackComponent]);\n\n  return {\n    hasRequiredRole,\n    isAuthenticated,\n    isLoading,\n    canAccess: isAuthenticated && hasRequiredRole,\n  };\n}","/**\n * React Auth Components\n * Pre-built authentication components for common use cases\n */\n\nimport React, { useState, useCallback } from 'react';\nimport { useAuth, useLogin, useLogout, useRoles, useRequireRole } from './use-auth';\nimport type { LoginCredentials, UserRole, PermissionCheck } from '@/auth/types';\n\n// Login Form Component\nexport interface LoginFormProps {\n  onSuccess?: () => void;\n  onError?: (error: string) => void;\n  className?: string;\n  autoComplete?: boolean;\n  showRememberMe?: boolean;\n  allowRoleSelection?: boolean;\n  availableRoles?: UserRole[];\n}\n\nexport function LoginForm({\n  onSuccess,\n  onError,\n  className = '',\n  autoComplete = true,\n  showRememberMe = false,\n  allowRoleSelection = false,\n  availableRoles = [],\n}: LoginFormProps) {\n  const { login, isLogging, loginError, clearLoginError } = useLogin();\n  \n  const [credentials, setCredentials] = useState<LoginCredentials>({\n    username: '',\n    password: '',\n  });\n  const [rememberMe, setRememberMe] = useState(false);\n\n  const handleSubmit = useCallback(async (e: React.FormEvent) => {\n    e.preventDefault();\n    clearLoginError();\n\n    try {\n      await login({\n        ...credentials,\n        ...(rememberMe && { scope: 'remember_me' }),\n      });\n      onSuccess?.();\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Login failed';\n      onError?.(errorMessage);\n    }\n  }, [credentials, rememberMe, login, onSuccess, onError, clearLoginError]);\n\n  const handleInputChange = useCallback((field: keyof LoginCredentials, value: string) => {\n    setCredentials(prev => ({ ...prev, [field]: value }));\n    if (loginError) {\n      clearLoginError();\n    }\n  }, [loginError, clearLoginError]);\n\n  return (\n    <form onSubmit={handleSubmit} className={className}>\n      <div className=\"auth-form-group\">\n        <label htmlFor=\"username\">Email or Username</label>\n        <input\n          id=\"username\"\n          type=\"email\"\n          value={credentials.username}\n          onChange={(e) => handleInputChange('username', e.target.value)}\n          required\n          autoComplete={autoComplete ? 'username' : 'off'}\n          disabled={isLogging}\n          placeholder=\"Enter your email\"\n        />\n      </div>\n\n      <div className=\"auth-form-group\">\n        <label htmlFor=\"password\">Password</label>\n        <input\n          id=\"password\"\n          type=\"password\"\n          value={credentials.password}\n          onChange={(e) => handleInputChange('password', e.target.value)}\n          required\n          autoComplete={autoComplete ? 'current-password' : 'off'}\n          disabled={isLogging}\n          placeholder=\"Enter your password\"\n        />\n      </div>\n\n      {allowRoleSelection && availableRoles.length > 0 && (\n        <div className=\"auth-form-group\">\n          <label htmlFor=\"preferred-role\">Preferred Role</label>\n          <select\n            id=\"preferred-role\"\n            value={credentials.preferred_role || ''}\n            onChange={(e) => handleInputChange('preferred_role', e.target.value as UserRole)}\n            disabled={isLogging}\n          >\n            <option value=\"\">Auto-detect role</option>\n            {availableRoles.map(role => (\n              <option key={role} value={role}>\n                {role.replace('ROLE_', '').toLowerCase().replace('_', ' ')}\n              </option>\n            ))}\n          </select>\n        </div>\n      )}\n\n      {showRememberMe && (\n        <div className=\"auth-form-group\">\n          <label>\n            <input\n              type=\"checkbox\"\n              checked={rememberMe}\n              onChange={(e) => setRememberMe(e.target.checked)}\n              disabled={isLogging}\n            />\n            Remember me\n          </label>\n        </div>\n      )}\n\n      {loginError && (\n        <div className=\"auth-error\" role=\"alert\">\n          {loginError.message}\n        </div>\n      )}\n\n      <button\n        type=\"submit\"\n        disabled={isLogging || !credentials.username || !credentials.password}\n        className=\"auth-submit-button\"\n      >\n        {isLogging ? 'Signing in...' : 'Sign In'}\n      </button>\n    </form>\n  );\n}\n\n// User Profile Component\nexport interface UserProfileProps {\n  showRoles?: boolean;\n  showSession?: boolean;\n  showPermissions?: boolean;\n  className?: string;\n}\n\nexport function UserProfile({\n  showRoles = true,\n  showSession = true,\n  showPermissions = false,\n  className = '',\n}: UserProfileProps) {\n  const { user, isAuthenticated } = useAuth();\n  const { logout, isLoggingOut } = useLogout();\n  const { primaryRole, simpleRole, effectiveRoles } = useRoles();\n\n  if (!isAuthenticated || !user) {\n    return null;\n  }\n\n  return (\n    <div className={`auth-user-profile ${className}`}>\n      <div className=\"auth-user-info\">\n        <h3>{user.name || user.email}</h3>\n        <p className=\"auth-user-email\">{user.email}</p>\n        {user.last_login && (\n          <p className=\"auth-last-login\">\n            Last login: {user.last_login.toLocaleString()}\n          </p>\n        )}\n      </div>\n\n      {showRoles && (\n        <div className=\"auth-user-roles\">\n          <h4>Current Role</h4>\n          <p className=\"auth-primary-role\">\n            {primaryRole?.replace('ROLE_', '').toLowerCase().replace('_', ' ') || 'Unknown'}\n            <span className=\"auth-simple-role\">({simpleRole})</span>\n          </p>\n          \n          {effectiveRoles.length > 1 && (\n            <details>\n              <summary>All Available Roles</summary>\n              <ul>\n                {effectiveRoles.map(role => (\n                  <li key={role}>\n                    {role.replace('ROLE_', '').toLowerCase().replace('_', ' ')}\n                  </li>\n                ))}\n              </ul>\n            </details>\n          )}\n        </div>\n      )}\n\n      {showSession && user.session_id && (\n        <div className=\"auth-session-info\">\n          <h4>Session</h4>\n          <p className=\"auth-session-id\">ID: {user.session_id}</p>\n        </div>\n      )}\n\n      {showPermissions && user.permissions.length > 0 && (\n        <div className=\"auth-user-permissions\">\n          <h4>Permissions</h4>\n          <ul>\n            {user.permissions.map(permission => (\n              <li key={permission}>{permission}</li>\n            ))}\n          </ul>\n        </div>\n      )}\n\n      <div className=\"auth-user-actions\">\n        <button\n          onClick={() => logout()}\n          disabled={isLoggingOut}\n          className=\"auth-logout-button\"\n        >\n          {isLoggingOut ? 'Signing out...' : 'Sign Out'}\n        </button>\n      </div>\n    </div>\n  );\n}\n\n// Role Switcher Component\nexport interface RoleSwitcherProps {\n  availableRoles?: UserRole[];\n  onRoleSwitch?: (role: UserRole) => void;\n  className?: string;\n}\n\nexport function RoleSwitcher({\n  availableRoles = [],\n  onRoleSwitch,\n  className = '',\n}: RoleSwitcherProps) {\n  const { switchRole, isSwitchingRole, primaryRole, effectiveRoles } = useRoles();\n\n  const handleRoleSwitch = useCallback(async (targetRole: UserRole) => {\n    try {\n      const success = await switchRole(targetRole);\n      if (success) {\n        onRoleSwitch?.(targetRole);\n      }\n    } catch (error) {\n      console.error('Role switch failed:', error);\n    }\n  }, [switchRole, onRoleSwitch]);\n\n  const switchableRoles = availableRoles.length > 0 \n    ? availableRoles.filter(role => effectiveRoles.includes(role))\n    : effectiveRoles;\n\n  if (switchableRoles.length <= 1) {\n    return null;\n  }\n\n  return (\n    <div className={`auth-role-switcher ${className}`}>\n      <label htmlFor=\"role-select\">Switch Role:</label>\n      <select\n        id=\"role-select\"\n        value={primaryRole || ''}\n        onChange={(e) => handleRoleSwitch(e.target.value as UserRole)}\n        disabled={isSwitchingRole}\n      >\n        {switchableRoles.map(role => (\n          <option key={role} value={role}>\n            {role.replace('ROLE_', '').toLowerCase().replace('_', ' ')}\n          </option>\n        ))}\n      </select>\n    </div>\n  );\n}\n\n// Auth Status Component\nexport interface AuthStatusProps {\n  showLoginPrompt?: boolean;\n  loginPromptText?: string;\n  className?: string;\n}\n\nexport function AuthStatus({\n  showLoginPrompt = true,\n  loginPromptText = 'Please sign in to continue',\n  className = '',\n}: AuthStatusProps) {\n  const { isAuthenticated, isLoading, error, user } = useAuth();\n\n  if (isLoading) {\n    return (\n      <div className={`auth-status auth-loading ${className}`}>\n        <p>Loading...</p>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className={`auth-status auth-error ${className}`}>\n        <p>Authentication error: {error.message}</p>\n      </div>\n    );\n  }\n\n  if (!isAuthenticated) {\n    return showLoginPrompt ? (\n      <div className={`auth-status auth-unauthenticated ${className}`}>\n        <p>{loginPromptText}</p>\n      </div>\n    ) : null;\n  }\n\n  return (\n    <div className={`auth-status auth-authenticated ${className}`}>\n      <p>Signed in as {user?.name || user?.email}</p>\n    </div>\n  );\n}\n\n// Protected Route Component\nexport interface ProtectedRouteProps {\n  children: React.ReactNode;\n  requiredRole?: UserRole | UserRole[];\n  fallback?: React.ComponentType;\n  redirectTo?: string;\n  className?: string;\n}\n\nexport function ProtectedRoute({\n  children,\n  requiredRole,\n  fallback: FallbackComponent,\n  redirectTo,\n  className = '',\n}: ProtectedRouteProps) {\n  const { isAuthenticated, isLoading } = useAuth();\n  const roleResult = requiredRole ? useRequireRole(requiredRole, FallbackComponent) : null;\n\n  if (isLoading) {\n    return (\n      <div className={`auth-protected-loading ${className}`}>\n        <p>Loading...</p>\n      </div>\n    );\n  }\n\n  if (!isAuthenticated) {\n    if (redirectTo && typeof window !== 'undefined') {\n      window.location.href = redirectTo;\n      return null;\n    }\n\n    return FallbackComponent ? (\n      <FallbackComponent />\n    ) : (\n      <div className={`auth-protected-unauthorized ${className}`}>\n        <p>Authentication required</p>\n      </div>\n    );\n  }\n\n  if (requiredRole && roleResult && !roleResult.canAccess) {\n    return FallbackComponent ? (\n      <FallbackComponent />\n    ) : (\n      <div className={`auth-protected-forbidden ${className}`}>\n        <p>Insufficient permissions</p>\n      </div>\n    );\n  }\n\n  return <>{children}</>;\n}\n\n// Permission Gate Component\nexport interface PermissionGateProps {\n  children: React.ReactNode;\n  resource: string;\n  action: string;\n  context?: Record<string, unknown>;\n  fallback?: React.ComponentType;\n  showLoading?: boolean;\n}\n\nexport function PermissionGate({\n  children,\n  resource,\n  action,\n  context,\n  fallback: FallbackComponent,\n  showLoading = true,\n}: PermissionGateProps) {\n  const [hasPermission, setHasPermission] = useState<boolean | null>(null);\n  const { checkPermission } = useAuth();\n\n  React.useEffect(() => {\n    const permissionCheck: PermissionCheck = {\n      resource,\n      action,\n      ...(context && { context })\n    };\n    \n    checkPermission(permissionCheck)\n      .then(result => setHasPermission(result.granted))\n      .catch(() => setHasPermission(false));\n  }, [checkPermission, resource, action, context]);\n\n  if (hasPermission === null) {\n    return showLoading ? (\n      <div className=\"auth-permission-loading\">\n        <p>Checking permissions...</p>\n      </div>\n    ) : null;\n  }\n\n  if (!hasPermission) {\n    return FallbackComponent ? (\n      <FallbackComponent />\n    ) : (\n      <div className=\"auth-permission-denied\">\n        <p>Permission denied</p>\n      </div>\n    );\n  }\n\n  return <>{children}</>;\n}","/**\n * Enhanced React Hooks for A-Cube SDK\n * Enterprise-grade data fetching, mutations, offline support, and authentication\n */\n\n// Core Provider System\nexport {\n  ACubeProvider,\n  useACube,\n  useACubeSDK,\n  useACubeStorage,\n  useACubeQueueManager,\n  useACubeSyncEngine,\n  useACubeNetworkManager,\n  useACubeNetworkStatus,\n  type ACubeContextValue,\n  type ACubeProviderProps\n} from './ACubeProvider';\n\n// Data Management Hooks\nexport { useACubeQuery, type QueryOptions, type QueryResult, queryUtils } from './useACubeQuery';\nexport { useACubeMutation, type MutationOptions, type MutationResult } from './useACubeMutation';\nexport { useACubeSubscription, type SubscriptionOptions, type SubscriptionResult } from './useACubeSubscription';\nexport { useACubeCache, type CacheOptions, type CacheResult } from './useACubeCache';\nexport { useACubeOffline, type OfflineOptions, type OfflineResult } from './useACubeOffline';\n\n// Authentication System\nexport {\n  // Core Provider and Context\n  AuthProvider,\n  useAuthContext,\n  useAuthAvailable,\n  type AuthProviderProps,\n  type AuthContextValue,\n} from './auth-provider';\n\nexport {\n  // Authentication Hooks\n  useAuth,\n  useLogin,\n  useLogout,\n  useUser,\n  useRoles,\n  usePermissions,\n  useSession,\n  useRequireAuth,\n  useRequireRole,\n} from './use-auth';\n\nexport {\n  // Pre-built React Components\n  LoginForm,\n  UserProfile,\n  RoleSwitcher,\n  AuthStatus,\n  ProtectedRoute,\n  PermissionGate,\n  type LoginFormProps,\n  type UserProfileProps,\n  type RoleSwitcherProps,\n  type AuthStatusProps,\n  type ProtectedRouteProps,\n  type PermissionGateProps,\n} from './auth-components';\n\n// Re-export auth types for convenience\nexport type {\n  AuthState,\n  AuthUser,\n  LoginCredentials,\n  LogoutOptions,\n  UserRole,\n  SimpleUserRole,\n  AuthError,\n  PermissionCheck,\n  PermissionResult,\n  SessionInfo,\n  OAuth2TokenResponse,\n  StoredAuthData,\n} from '@/auth/types';\n\n// Re-export branded types commonly used in React components\nexport type {\n  MerchantId,\n  CashierId,\n  PointOfSaleId,\n} from '@/types/branded';\n\n// Re-export common types for convenience\nexport type {\n  ACubeSDK\n} from '@/core/sdk';","/**\n * GDPR Compliance Manager for A-Cube SDK\n * Provides comprehensive GDPR compliance tools and data protection capabilities\n */\n\nexport interface GDPRConfig {\n  enabled: boolean;\n  dataRetention: {\n    defaultPeriod: number; // milliseconds\n    categories: Record<string, number>; // category -> retention period\n  };\n  consent: {\n    required: boolean;\n    granular: boolean; // Allow granular consent per data type\n    withdrawalEnabled: boolean;\n    consentVersion: string;\n  };\n  dataMinimization: {\n    enabled: boolean;\n    allowedFields: Record<string, string[]>; // purpose -> allowed fields\n  };\n  rightToErasure: {\n    enabled: boolean;\n    gracePeriod: number; // milliseconds before actual deletion\n    cascadeDeletion: boolean; // Delete related data\n  };\n  dataPortability: {\n    enabled: boolean;\n    formats: ('json' | 'xml' | 'csv')[];\n    includeMetadata: boolean;\n  };\n  anonymization: {\n    enabled: boolean;\n    techniques: ('pseudonymization' | 'aggregation' | 'suppression')[];\n    retainStructure: boolean;\n  };\n}\n\nexport interface DataSubject {\n  id: string;\n  email?: string;\n  createdAt: number;\n  lastActivity: number;\n  consentRecords: ConsentRecord[];\n  dataCategories: string[];\n  retentionOverrides: Record<string, number>;\n  anonymizationStatus: 'none' | 'pseudonymized' | 'anonymized' | 'deleted';\n}\n\nexport interface ConsentRecord {\n  id: string;\n  subjectId: string;\n  purpose: string;\n  dataTypes: string[];\n  consentGiven: boolean;\n  consentVersion: string;\n  timestamp: number;\n  expiresAt?: number;\n  source: 'explicit' | 'implied' | 'legitimate_interest';\n  withdrawnAt?: number;\n  withdrawalReason?: string;\n  metadata: Record<string, any>;\n}\n\nexport interface DataProcessingRecord {\n  id: string;\n  subjectId: string;\n  dataType: string;\n  purpose: string;\n  lawfulBasis: 'consent' | 'contract' | 'legal_obligation' | 'vital_interests' | 'public_task' | 'legitimate_interests';\n  processingActivity: string;\n  timestamp: number;\n  dataLocation: string;\n  retentionPeriod: number;\n  thirdPartySharing: boolean;\n  encryptionUsed: boolean;\n  metadata: Record<string, any>;\n}\n\nexport interface DataExportRequest {\n  id: string;\n  subjectId: string;\n  requestedAt: number;\n  completedAt?: number;\n  status: 'pending' | 'processing' | 'completed' | 'failed';\n  format: 'json' | 'xml' | 'csv';\n  includeMetadata: boolean;\n  dataTypes?: string[];\n  exportUrl?: string;\n  expiresAt?: number;\n}\n\nexport interface ErasureRequest {\n  id: string;\n  subjectId: string;\n  requestedAt: number;\n  scheduledAt: number;\n  completedAt?: number;\n  status: 'pending' | 'scheduled' | 'processing' | 'completed' | 'failed';\n  reason: string;\n  cascadeDelete: boolean;\n  dataTypes?: string[];\n  verificationRequired: boolean;\n  metadata: Record<string, any>;\n}\n\nexport interface GDPRAuditReport {\n  generatedAt: number;\n  period: { start: number; end: number };\n  summary: {\n    totalSubjects: number;\n    activeConsents: number;\n    withdrawnConsents: number;\n    dataExportRequests: number;\n    erasureRequests: number;\n    dataProcessingActivities: number;\n  };\n  compliance: {\n    consentCompliance: number; // percentage\n    retentionCompliance: number; // percentage\n    dataMinimizationCompliance: number; // percentage\n    securityCompliance: number; // percentage\n  };\n  violations: GDPRViolation[];\n  recommendations: string[];\n}\n\nexport interface GDPRViolation {\n  id: string;\n  type: 'consent' | 'retention' | 'data_minimization' | 'security' | 'transparency';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  description: string;\n  subjectId?: string;\n  detectedAt: number;\n  resolvedAt?: number;\n  status: 'open' | 'investigating' | 'resolved' | 'false_positive';\n  remediation?: string;\n  metadata: Record<string, any>;\n}\n\nexport class GDPRComplianceManager {\n  private config: GDPRConfig;\n  private dataSubjects = new Map<string, DataSubject>();\n  private consentRecords = new Map<string, ConsentRecord>();\n  private processingRecords: DataProcessingRecord[] = [];\n  private exportRequests = new Map<string, DataExportRequest>();\n  private erasureRequests = new Map<string, ErasureRequest>();\n  private violations: GDPRViolation[] = [];\n\n  constructor(config?: Partial<GDPRConfig>) {\n    this.config = {\n      enabled: true,\n      dataRetention: {\n        defaultPeriod: 365 * 24 * 60 * 60 * 1000, // 1 year\n        categories: {\n          'user_profile': 2 * 365 * 24 * 60 * 60 * 1000, // 2 years\n          'transaction_data': 7 * 365 * 24 * 60 * 60 * 1000, // 7 years\n          'analytics_data': 26 * 30 * 24 * 60 * 60 * 1000, // 26 months\n          'marketing_data': 365 * 24 * 60 * 60 * 1000, // 1 year\n        },\n      },\n      consent: {\n        required: true,\n        granular: true,\n        withdrawalEnabled: true,\n        consentVersion: '1.0.0',\n      },\n      dataMinimization: {\n        enabled: true,\n        allowedFields: {\n          'user_registration': ['email', 'name', 'company'],\n          'transaction_processing': ['amount', 'currency', 'timestamp'],\n          'analytics': ['user_id', 'event_type', 'timestamp'],\n        },\n      },\n      rightToErasure: {\n        enabled: true,\n        gracePeriod: 30 * 24 * 60 * 60 * 1000, // 30 days\n        cascadeDeletion: true,\n      },\n      dataPortability: {\n        enabled: true,\n        formats: ['json', 'csv'],\n        includeMetadata: true,\n      },\n      anonymization: {\n        enabled: true,\n        techniques: ['pseudonymization', 'aggregation'],\n        retainStructure: true,\n      },\n      ...config,\n    };\n\n    if (this.config.enabled) {\n      this.initializeRetentionScheduler();\n    }\n  }\n\n  /**\n   * Register a new data subject\n   */\n  async registerDataSubject(\n    subjectId: string,\n    email?: string,\n    initialConsent?: Partial<ConsentRecord>\n  ): Promise<void> {\n    if (!this.config.enabled) return;\n\n    const dataSubject: DataSubject = {\n      id: subjectId,\n      ...(email && { email }),\n      createdAt: Date.now(),\n      lastActivity: Date.now(),\n      consentRecords: [],\n      dataCategories: [],\n      retentionOverrides: {},\n      anonymizationStatus: 'none',\n    };\n\n    this.dataSubjects.set(subjectId, dataSubject);\n\n    // Record initial consent if provided\n    if (initialConsent) {\n      await this.recordConsent(subjectId, {\n        purpose: initialConsent.purpose || 'service_provision',\n        dataTypes: initialConsent.dataTypes || ['basic_profile'],\n        consentGiven: true,\n        source: 'explicit',\n        ...initialConsent,\n      });\n    }\n\n    this.recordProcessingActivity({\n      subjectId,\n      dataType: 'basic_profile',\n      purpose: 'user_registration',\n      lawfulBasis: initialConsent ? 'consent' : 'contract',\n      processingActivity: 'data_subject_registration',\n      dataLocation: 'internal_database',\n      retentionPeriod: this.config.dataRetention.categories['user_profile'] || this.config.dataRetention.defaultPeriod,\n      thirdPartySharing: false,\n      encryptionUsed: true,\n      metadata: { email: !!email },\n    });\n  }\n\n  /**\n   * Record consent for data processing\n   */\n  async recordConsent(\n    subjectId: string,\n    consent: Partial<ConsentRecord> & {\n      purpose: string;\n      dataTypes: string[];\n      consentGiven: boolean;\n    }\n  ): Promise<string> {\n    if (!this.config.enabled) return '';\n\n    const consentId = this.generateConsentId();\n    const now = Date.now();\n\n    const consentRecord: ConsentRecord = {\n      id: consentId,\n      subjectId,\n      consentVersion: this.config.consent.consentVersion,\n      timestamp: now,\n      source: 'explicit',\n      metadata: {},\n      ...consent,\n    };\n\n    // Set expiration if not provided\n    if (!consentRecord.expiresAt && consent.purpose === 'marketing') {\n      consentRecord.expiresAt = now + (365 * 24 * 60 * 60 * 1000); // 1 year for marketing\n    }\n\n    this.consentRecords.set(consentId, consentRecord);\n\n    // Update data subject\n    const dataSubject = this.dataSubjects.get(subjectId);\n    if (dataSubject) {\n      dataSubject.consentRecords.push(consentRecord);\n      dataSubject.lastActivity = now;\n      \n      // Add data categories\n      for (const dataType of consent.dataTypes) {\n        if (!dataSubject.dataCategories.includes(dataType)) {\n          dataSubject.dataCategories.push(dataType);\n        }\n      }\n    }\n\n    this.recordProcessingActivity({\n      subjectId,\n      dataType: 'consent_record',\n      purpose: 'consent_management',\n      lawfulBasis: 'legal_obligation',\n      processingActivity: 'consent_recording',\n      dataLocation: 'internal_database',\n      retentionPeriod: this.config.dataRetention.defaultPeriod,\n      thirdPartySharing: false,\n      encryptionUsed: true,\n      metadata: { consentId, purpose: consent.purpose },\n    });\n\n    return consentId;\n  }\n\n  /**\n   * Withdraw consent\n   */\n  async withdrawConsent(\n    subjectId: string,\n    consentId: string,\n    reason?: string\n  ): Promise<void> {\n    if (!this.config.enabled || !this.config.consent.withdrawalEnabled) return;\n\n    const consentRecord = this.consentRecords.get(consentId);\n    if (!consentRecord || consentRecord.subjectId !== subjectId) {\n      throw new Error('Consent record not found or access denied');\n    }\n\n    consentRecord.withdrawnAt = Date.now();\n    if (reason) {\n      consentRecord.withdrawalReason = reason;\n    }\n    consentRecord.consentGiven = false;\n\n    this.recordProcessingActivity({\n      subjectId,\n      dataType: 'consent_record',\n      purpose: 'consent_management',\n      lawfulBasis: 'legal_obligation',\n      processingActivity: 'consent_withdrawal',\n      dataLocation: 'internal_database',\n      retentionPeriod: this.config.dataRetention.defaultPeriod,\n      thirdPartySharing: false,\n      encryptionUsed: true,\n      metadata: { consentId, reason },\n    });\n\n    // Check if any data should be deleted due to lack of consent\n    await this.checkDataRetentionAfterConsentWithdrawal(subjectId);\n  }\n\n  /**\n   * Check if processing is lawful for a data subject\n   */\n  isProcessingLawful(\n    subjectId: string,\n    purpose: string,\n    dataTypes: string[]\n  ): { lawful: boolean; basis: string; warnings: string[] } {\n    if (!this.config.enabled) return { lawful: true, basis: 'not_applicable', warnings: [] };\n\n    const dataSubject = this.dataSubjects.get(subjectId);\n    if (!dataSubject) {\n      return { lawful: false, basis: 'no_subject', warnings: ['Data subject not registered'] };\n    }\n\n    const warnings: string[] = [];\n    let hasValidConsent = false;\n    let lawfulBasis = 'legitimate_interests';\n\n    // Check for valid consent\n    const relevantConsents = dataSubject.consentRecords.filter(\n      consent => \n        consent.purpose === purpose &&\n        consent.consentGiven &&\n        !consent.withdrawnAt &&\n        (!consent.expiresAt || consent.expiresAt > Date.now()) &&\n        dataTypes.every(type => consent.dataTypes.includes(type))\n    );\n\n    if (relevantConsents.length > 0) {\n      hasValidConsent = true;\n      lawfulBasis = 'consent';\n    }\n\n    // Check data minimization\n    if (this.config.dataMinimization.enabled) {\n      const allowedFields = this.config.dataMinimization.allowedFields[purpose] || [];\n      const excessiveFields = dataTypes.filter(type => !allowedFields.includes(type));\n      \n      if (excessiveFields.length > 0) {\n        warnings.push(`Excessive data types for purpose ${purpose}: ${excessiveFields.join(', ')}`);\n      }\n    }\n\n    // Special cases for legitimate interests\n    const legitimateInterestPurposes = ['fraud_prevention', 'security', 'service_provision'];\n    if (!hasValidConsent && legitimateInterestPurposes.includes(purpose)) {\n      lawfulBasis = 'legitimate_interests';\n    }\n\n    // Legal obligation basis\n    const legalObligationPurposes = ['tax_compliance', 'anti_money_laundering', 'data_retention'];\n    if (legalObligationPurposes.includes(purpose)) {\n      lawfulBasis = 'legal_obligation';\n    }\n\n    const lawful = hasValidConsent || \n                   legitimateInterestPurposes.includes(purpose) || \n                   legalObligationPurposes.includes(purpose);\n\n    return { lawful, basis: lawfulBasis, warnings };\n  }\n\n  /**\n   * Record data processing activity\n   */\n  recordProcessingActivity(activity: Omit<DataProcessingRecord, 'id' | 'timestamp'>): void {\n    if (!this.config.enabled) return;\n\n    const record: DataProcessingRecord = {\n      id: this.generateProcessingId(),\n      timestamp: Date.now(),\n      ...activity,\n    };\n\n    this.processingRecords.push(record);\n\n    // Keep only recent records (last 10,000)\n    if (this.processingRecords.length > 10000) {\n      this.processingRecords = this.processingRecords.slice(-10000);\n    }\n\n    // Update data subject activity\n    const dataSubject = this.dataSubjects.get(activity.subjectId);\n    if (dataSubject) {\n      dataSubject.lastActivity = Date.now();\n    }\n  }\n\n  /**\n   * Handle data export request (Right to Data Portability)\n   */\n  async requestDataExport(\n    subjectId: string,\n    options?: {\n      format?: 'json' | 'xml' | 'csv';\n      includeMetadata?: boolean;\n      dataTypes?: string[];\n    }\n  ): Promise<string> {\n    if (!this.config.enabled || !this.config.dataPortability.enabled) {\n      throw new Error('Data portability not enabled');\n    }\n\n    const requestId = this.generateRequestId();\n    const exportRequest: DataExportRequest = {\n      id: requestId,\n      subjectId,\n      requestedAt: Date.now(),\n      status: 'pending',\n      format: options?.format || 'json',\n      includeMetadata: options?.includeMetadata ?? this.config.dataPortability.includeMetadata,\n      ...(options?.dataTypes && { dataTypes: options.dataTypes }),\n    };\n\n    this.exportRequests.set(requestId, exportRequest);\n\n    // Process the export asynchronously\n    setTimeout(() => this.processDataExport(requestId), 1000);\n\n    this.recordProcessingActivity({\n      subjectId,\n      dataType: 'export_request',\n      purpose: 'data_portability',\n      lawfulBasis: 'legal_obligation',\n      processingActivity: 'data_export_request',\n      dataLocation: 'internal_database',\n      retentionPeriod: 30 * 24 * 60 * 60 * 1000, // 30 days\n      thirdPartySharing: false,\n      encryptionUsed: true,\n      metadata: { requestId, format: exportRequest.format },\n    });\n\n    return requestId;\n  }\n\n  /**\n   * Handle data erasure request (Right to be Forgotten)\n   */\n  async requestDataErasure(\n    subjectId: string,\n    reason: string,\n    options?: {\n      immediateErasure?: boolean;\n      dataTypes?: string[];\n      cascadeDelete?: boolean;\n    }\n  ): Promise<string> {\n    if (!this.config.enabled || !this.config.rightToErasure.enabled) {\n      throw new Error('Right to erasure not enabled');\n    }\n\n    const requestId = this.generateRequestId();\n    const now = Date.now();\n    const scheduledAt = options?.immediateErasure \n      ? now \n      : now + this.config.rightToErasure.gracePeriod;\n\n    const erasureRequest: ErasureRequest = {\n      id: requestId,\n      subjectId,\n      requestedAt: now,\n      scheduledAt,\n      status: 'pending',\n      reason,\n      cascadeDelete: options?.cascadeDelete ?? this.config.rightToErasure.cascadeDeletion,\n      ...(options?.dataTypes && { dataTypes: options.dataTypes }),\n      verificationRequired: !options?.immediateErasure,\n      metadata: {},\n    };\n\n    this.erasureRequests.set(requestId, erasureRequest);\n\n    // Schedule the erasure\n    setTimeout(() => this.processDataErasure(requestId), scheduledAt - now);\n\n    this.recordProcessingActivity({\n      subjectId,\n      dataType: 'erasure_request',\n      purpose: 'data_erasure',\n      lawfulBasis: 'legal_obligation',\n      processingActivity: 'data_erasure_request',\n      dataLocation: 'internal_database',\n      retentionPeriod: 30 * 24 * 60 * 60 * 1000, // 30 days\n      thirdPartySharing: false,\n      encryptionUsed: true,\n      metadata: { requestId, reason, scheduledAt },\n    });\n\n    return requestId;\n  }\n\n  /**\n   * Generate GDPR compliance report\n   */\n  generateComplianceReport(timeRangeMs: number = 30 * 24 * 60 * 60 * 1000): GDPRAuditReport {\n    const now = Date.now();\n    const start = now - timeRangeMs;\n\n    // Get data for the period\n    const periodProcessingRecords = this.processingRecords.filter(\n      record => record.timestamp >= start\n    );\n\n    const periodConsents = Array.from(this.consentRecords.values()).filter(\n      consent => consent.timestamp >= start\n    );\n\n    const periodExportRequests = Array.from(this.exportRequests.values()).filter(\n      request => request.requestedAt >= start\n    );\n\n    const periodErasureRequests = Array.from(this.erasureRequests.values()).filter(\n      request => request.requestedAt >= start\n    );\n\n    // Calculate compliance metrics\n    const totalConsents = periodConsents.length;\n    const activeConsents = periodConsents.filter(\n      c => c.consentGiven && !c.withdrawnAt && (!c.expiresAt || c.expiresAt > now)\n    ).length;\n    const withdrawnConsents = periodConsents.filter(c => c.withdrawnAt).length;\n\n    const consentCompliance = totalConsents > 0 ? (activeConsents / totalConsents) * 100 : 100;\n    const retentionCompliance = this.calculateRetentionCompliance();\n    const dataMinimizationCompliance = this.calculateDataMinimizationCompliance();\n    const securityCompliance = this.calculateSecurityCompliance(periodProcessingRecords);\n\n    return {\n      generatedAt: now,\n      period: { start, end: now },\n      summary: {\n        totalSubjects: this.dataSubjects.size,\n        activeConsents,\n        withdrawnConsents,\n        dataExportRequests: periodExportRequests.length,\n        erasureRequests: periodErasureRequests.length,\n        dataProcessingActivities: periodProcessingRecords.length,\n      },\n      compliance: {\n        consentCompliance,\n        retentionCompliance,\n        dataMinimizationCompliance,\n        securityCompliance,\n      },\n      violations: this.violations.filter(v => v.detectedAt >= start),\n      recommendations: this.generateRecommendations(),\n    };\n  }\n\n  /**\n   * Anonymize data for a subject\n   */\n  async anonymizeDataSubject(subjectId: string): Promise<void> {\n    if (!this.config.enabled || !this.config.anonymization.enabled) return;\n\n    const dataSubject = this.dataSubjects.get(subjectId);\n    if (!dataSubject) return;\n\n    if (this.config.anonymization.techniques.includes('pseudonymization')) {\n      // Replace identifiable information with pseudonyms\n      if (dataSubject.email) {\n        const pseudonymizedEmail = this.pseudonymizeEmail(dataSubject.email);\n        if (pseudonymizedEmail) {\n          dataSubject.email = pseudonymizedEmail;\n        }\n      }\n      dataSubject.anonymizationStatus = 'pseudonymized';\n    }\n\n    if (this.config.anonymization.techniques.includes('aggregation')) {\n      // Aggregate processing records\n      this.aggregateProcessingRecords(subjectId);\n    }\n\n    if (this.config.anonymization.techniques.includes('suppression')) {\n      // Remove specific identifiable fields\n      delete dataSubject.email;\n      dataSubject.anonymizationStatus = 'anonymized';\n    }\n\n    this.recordProcessingActivity({\n      subjectId,\n      dataType: 'anonymization_record',\n      purpose: 'data_anonymization',\n      lawfulBasis: 'legal_obligation',\n      processingActivity: 'data_anonymization',\n      dataLocation: 'internal_database',\n      retentionPeriod: this.config.dataRetention.defaultPeriod,\n      thirdPartySharing: false,\n      encryptionUsed: true,\n      metadata: { techniques: this.config.anonymization.techniques },\n    });\n  }\n\n  private async processDataExport(requestId: string): Promise<void> {\n    const exportRequest = this.exportRequests.get(requestId);\n    if (!exportRequest) return;\n\n    try {\n      exportRequest.status = 'processing';\n\n      const dataSubject = this.dataSubjects.get(exportRequest.subjectId);\n      if (!dataSubject) {\n        exportRequest.status = 'failed';\n        return;\n      }\n\n      // Collect all data for the subject\n      const exportData: any = {\n        subject: {\n          id: dataSubject.id,\n          email: dataSubject.email,\n          createdAt: dataSubject.createdAt,\n          lastActivity: dataSubject.lastActivity,\n          dataCategories: dataSubject.dataCategories,\n        },\n        consents: dataSubject.consentRecords,\n        processingActivities: this.processingRecords.filter(\n          record => record.subjectId === exportRequest.subjectId\n        ),\n      };\n\n      if (exportRequest.includeMetadata) {\n        exportData.metadata = {\n          exportedAt: Date.now(),\n          exportFormat: exportRequest.format,\n          gdprVersion: '2018',\n          retentionPolicies: this.config.dataRetention,\n        };\n      }\n\n      // Convert to requested format\n      let exportContent: string;\n      switch (exportRequest.format) {\n        case 'json':\n          exportContent = JSON.stringify(exportData, null, 2);\n          break;\n        case 'csv':\n          exportContent = this.convertToCSV(exportData);\n          break;\n        case 'xml':\n          exportContent = this.convertToXML(exportData);\n          break;\n        default:\n          throw new Error(`Unsupported format: ${exportRequest.format}`);\n      }\n\n      // In a real implementation, you'd save this to a secure location\n      exportRequest.exportUrl = `data:text/plain;base64,${btoa(exportContent)}`;\n      exportRequest.status = 'completed';\n      exportRequest.completedAt = Date.now();\n      exportRequest.expiresAt = Date.now() + (7 * 24 * 60 * 60 * 1000); // 7 days\n\n    } catch (error) {\n      exportRequest.status = 'failed';\n      console.error(`Data export failed for request ${requestId}:`, error);\n    }\n  }\n\n  private async processDataErasure(requestId: string): Promise<void> {\n    const erasureRequest = this.erasureRequests.get(requestId);\n    if (!erasureRequest) return;\n\n    try {\n      erasureRequest.status = 'processing';\n\n      const dataSubject = this.dataSubjects.get(erasureRequest.subjectId);\n      if (!dataSubject) {\n        erasureRequest.status = 'failed';\n        return;\n      }\n\n      // Mark as deleted\n      dataSubject.anonymizationStatus = 'deleted';\n\n      // Remove or anonymize processing records\n      if (erasureRequest.cascadeDelete) {\n        this.processingRecords = this.processingRecords.filter(\n          record => record.subjectId !== erasureRequest.subjectId\n        );\n      } else {\n        // Anonymize instead of delete\n        await this.anonymizeDataSubject(erasureRequest.subjectId);\n      }\n\n      erasureRequest.status = 'completed';\n      erasureRequest.completedAt = Date.now();\n\n    } catch (error) {\n      erasureRequest.status = 'failed';\n      console.error(`Data erasure failed for request ${requestId}:`, error);\n    }\n  }\n\n  private initializeRetentionScheduler(): void {\n    // Check retention policies every 24 hours\n    setInterval(() => {\n      this.enforceDataRetention();\n    }, 24 * 60 * 60 * 1000);\n\n    // Initial check\n    setTimeout(() => this.enforceDataRetention(), 5000);\n  }\n\n  private enforceDataRetention(): void {\n    const now = Date.now();\n\n    // Check each data subject for retention compliance\n    for (const [subjectId, dataSubject] of this.dataSubjects.entries()) {\n      for (const category of dataSubject.dataCategories) {\n        const retentionPeriod = dataSubject.retentionOverrides[category] ||\n                              this.config.dataRetention.categories[category] ||\n                              this.config.dataRetention.defaultPeriod;\n\n        if (now - dataSubject.createdAt > retentionPeriod) {\n          // Data subject exceeds retention period\n          this.scheduleDataSubjectDeletion(subjectId, category);\n        }\n      }\n    }\n\n    // Clean up old processing records\n    const maxAge = Math.max(...Object.values(this.config.dataRetention.categories));\n    this.processingRecords = this.processingRecords.filter(\n      record => now - record.timestamp <= maxAge\n    );\n  }\n\n  private scheduleDataSubjectDeletion(subjectId: string, category: string): void {\n    // In a real implementation, this would schedule proper deletion\n    console.log(`Scheduling deletion for subject ${subjectId}, category ${category}`);\n  }\n\n  private async checkDataRetentionAfterConsentWithdrawal(subjectId: string): Promise<void> {\n    const dataSubject = this.dataSubjects.get(subjectId);\n    if (!dataSubject) return;\n\n    const activeConsents = dataSubject.consentRecords.filter(\n      consent => consent.consentGiven && !consent.withdrawnAt\n    );\n\n    if (activeConsents.length === 0) {\n      // No active consents, check if data can be retained under other lawful bases\n      const legitimateInterestData = this.processingRecords.filter(\n        record => record.subjectId === subjectId && \n                 record.lawfulBasis === 'legitimate_interests'\n      );\n\n      if (legitimateInterestData.length === 0) {\n        // Schedule data deletion\n        await this.requestDataErasure(subjectId, 'consent_withdrawn', { immediateErasure: false });\n      }\n    }\n  }\n\n  private calculateRetentionCompliance(): number {\n    const now = Date.now();\n    let compliantSubjects = 0;\n    let totalSubjects = 0;\n\n    for (const [_subjectId, dataSubject] of this.dataSubjects.entries()) {\n      totalSubjects++;\n      let subjectCompliant = true;\n\n      for (const category of dataSubject.dataCategories) {\n        const retentionPeriod = this.config.dataRetention.categories[category] ||\n                              this.config.dataRetention.defaultPeriod;\n        \n        if (now - dataSubject.createdAt > retentionPeriod) {\n          subjectCompliant = false;\n          break;\n        }\n      }\n\n      if (subjectCompliant) {\n        compliantSubjects++;\n      }\n    }\n\n    return totalSubjects > 0 ? (compliantSubjects / totalSubjects) * 100 : 100;\n  }\n\n  private calculateDataMinimizationCompliance(): number {\n    if (!this.config.dataMinimization.enabled) return 100;\n\n    const recentRecords = this.processingRecords.filter(\n      record => Date.now() - record.timestamp <= 30 * 24 * 60 * 60 * 1000 // Last 30 days\n    );\n\n    let compliantRecords = 0;\n    let totalRecords = recentRecords.length;\n\n    for (const record of recentRecords) {\n      const allowedFields = this.config.dataMinimization.allowedFields[record.purpose] || [];\n      if (allowedFields.length === 0 || allowedFields.includes(record.dataType)) {\n        compliantRecords++;\n      }\n    }\n\n    return totalRecords > 0 ? (compliantRecords / totalRecords) * 100 : 100;\n  }\n\n  private calculateSecurityCompliance(records: DataProcessingRecord[]): number {\n    const encryptedRecords = records.filter(record => record.encryptionUsed);\n    return records.length > 0 ? (encryptedRecords.length / records.length) * 100 : 100;\n  }\n\n  private generateRecommendations(): string[] {\n    const recommendations: string[] = [];\n\n    // Check consent expiration\n    const expiringConsents = Array.from(this.consentRecords.values()).filter(\n      consent => consent.expiresAt && \n                consent.expiresAt - Date.now() <= 30 * 24 * 60 * 60 * 1000 // 30 days\n    );\n\n    if (expiringConsents.length > 0) {\n      recommendations.push(`${expiringConsents.length} consents are expiring within 30 days`);\n    }\n\n    // Check data minimization\n    if (this.config.dataMinimization.enabled) {\n      const dataMinimizationScore = this.calculateDataMinimizationCompliance();\n      if (dataMinimizationScore < 95) {\n        recommendations.push('Review data collection practices to improve data minimization compliance');\n      }\n    }\n\n    // Check retention policies\n    const retentionScore = this.calculateRetentionCompliance();\n    if (retentionScore < 95) {\n      recommendations.push('Review and update data retention policies');\n    }\n\n    return recommendations;\n  }\n\n  private pseudonymizeEmail(email?: string): string | undefined {\n    if (!email) return undefined;\n    \n    const emailParts = email.split('@');\n    if (emailParts.length !== 2) return undefined;\n    \n    const [local, domain] = emailParts;\n    if (!local || !domain) return undefined;\n    const hash = btoa(local).substring(0, 8);\n    return `user_${hash}@${domain}`;\n  }\n\n  private aggregateProcessingRecords(subjectId: string): void {\n    const subjectRecords = this.processingRecords.filter(\n      record => record.subjectId === subjectId\n    );\n\n    // Group by purpose and create aggregated records\n    const aggregated = subjectRecords.reduce((acc, record) => {\n      const key = record.purpose;\n      if (!acc[key]) {\n        acc[key] = {\n          count: 0,\n          dataTypes: new Set<string>(),\n          firstActivity: record.timestamp,\n          lastActivity: record.timestamp,\n        };\n      }\n      \n      acc[key].count++;\n      acc[key].dataTypes.add(record.dataType);\n      acc[key].lastActivity = Math.max(acc[key].lastActivity, record.timestamp);\n      \n      return acc;\n    }, {} as Record<string, any>);\n\n    // Replace individual records with aggregated ones\n    this.processingRecords = this.processingRecords.filter(\n      record => record.subjectId !== subjectId\n    );\n\n    for (const [purpose, stats] of Object.entries(aggregated)) {\n      this.processingRecords.push({\n        id: this.generateProcessingId(),\n        subjectId: `anonymized_${btoa(subjectId).substring(0, 8)}`,\n        dataType: 'aggregated',\n        purpose,\n        lawfulBasis: 'legitimate_interests',\n        processingActivity: 'aggregated_analytics',\n        timestamp: stats.lastActivity,\n        dataLocation: 'internal_database',\n        retentionPeriod: this.config.dataRetention.defaultPeriod,\n        thirdPartySharing: false,\n        encryptionUsed: true,\n        metadata: {\n          aggregated: true,\n          count: stats.count,\n          dataTypes: Array.from(stats.dataTypes),\n          period: {\n            start: stats.firstActivity,\n            end: stats.lastActivity,\n          },\n        },\n      });\n    }\n  }\n\n  private convertToCSV(data: any): string {\n    // Simplified CSV conversion - in production, use proper CSV library\n    const lines: string[] = [];\n    \n    // Headers\n    lines.push('Type,ID,Timestamp,Data');\n    \n    // Subject data\n    lines.push(`Subject,${data.subject.id},${data.subject.createdAt},${JSON.stringify(data.subject).replace(/,/g, ';')}`);\n    \n    // Consents\n    for (const consent of data.consents) {\n      lines.push(`Consent,${consent.id},${consent.timestamp},${JSON.stringify(consent).replace(/,/g, ';')}`);\n    }\n    \n    return lines.join('\\n');\n  }\n\n  private convertToXML(data: any): string {\n    // Simplified XML conversion - in production, use proper XML library\n    let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<gdpr-export>\\n';\n    \n    xml += '  <subject>\\n';\n    xml += `    <id>${data.subject.id}</id>\\n`;\n    xml += `    <email>${data.subject.email || ''}</email>\\n`;\n    xml += `    <created-at>${data.subject.createdAt}</created-at>\\n`;\n    xml += '  </subject>\\n';\n    \n    xml += '  <consents>\\n';\n    for (const consent of data.consents) {\n      xml += '    <consent>\\n';\n      xml += `      <id>${consent.id}</id>\\n`;\n      xml += `      <purpose>${consent.purpose}</purpose>\\n`;\n      xml += `      <given>${consent.consentGiven}</given>\\n`;\n      xml += '    </consent>\\n';\n    }\n    xml += '  </consents>\\n';\n    \n    xml += '</gdpr-export>';\n    return xml;\n  }\n\n  private generateConsentId(): string {\n    return `consent_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private generateProcessingId(): string {\n    return `proc_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private generateRequestId(): string {\n    return `req_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n}","/**\n * Fiscal Audit Compliance for A-Cube SDK\n * Provides comprehensive fiscal compliance tools for Italian tax system\n */\n\nexport interface FiscalConfig {\n  enabled: boolean;\n  taxRegion: 'IT' | 'EU' | 'GLOBAL';\n  retentionPeriod: number; // 10 years for Italian fiscal law\n  digitalSignature: {\n    required: boolean;\n    algorithm: 'ECDSA' | 'RSA-PSS';\n    certificateValidation: boolean;\n  };\n  receiptSequencing: {\n    enforceSequential: boolean;\n    allowGaps: boolean;\n    maxGapSize: number;\n  };\n  auditTrail: {\n    immutable: boolean;\n    hashChaining: boolean;\n    timestamping: boolean;\n  };\n  compliance: {\n    agenziaEntrate: boolean; // Italian Revenue Agency\n    vatCompliance: boolean;\n    antiMoneyLaundering: boolean;\n  };\n}\n\nexport interface FiscalDocument {\n  id: string;\n  type: 'receipt' | 'invoice' | 'credit_note' | 'fiscal_report';\n  sequenceNumber: number;\n  fiscalYear: number;\n  documentNumber: string;\n  timestamp: number;\n  amount: {\n    net: number;\n    vat: number;\n    total: number;\n    currency: string;\n  };\n  merchant: {\n    vatNumber: string;\n    fiscalCode: string;\n    name: string;\n    address: string;\n  };\n  customer?: {\n    vatNumber?: string;\n    fiscalCode?: string;\n    name?: string;\n  };\n  items: FiscalLineItem[];\n  vat: VATBreakdown[];\n  paymentMethod: string;\n  digitalSignature?: string;\n  hash: string;\n  previousHash?: string;\n  auditTrail: FiscalAuditEntry[];\n  compliance: {\n    agenziaEntrateCompliant: boolean;\n    vatCompliant: boolean;\n    fiscallyValid: boolean;\n    warnings: string[];\n  };\n  metadata: {\n    pos_id?: string;\n    operator_id?: string;\n    location?: string;\n    device_serial?: string;\n  };\n}\n\nexport interface FiscalLineItem {\n  id: string;\n  description: string;\n  quantity: number;\n  unitPrice: number;\n  vatRate: number;\n  vatAmount: number;\n  totalAmount: number;\n  category?: string;\n  sku?: string;\n}\n\nexport interface VATBreakdown {\n  rate: number;\n  netAmount: number;\n  vatAmount: number;\n  totalAmount: number;\n  category: 'standard' | 'reduced' | 'exempt' | 'zero';\n}\n\nexport interface FiscalAuditEntry {\n  id: string;\n  timestamp: number;\n  action: 'created' | 'modified' | 'voided' | 'transmitted' | 'archived';\n  userId: string;\n  details: Record<string, any>;\n  hash: string;\n  signature?: string;\n}\n\nexport interface FiscalPeriod {\n  year: number;\n  month?: number;\n  quarter?: number;\n  startDate: number;\n  endDate: number;\n  status: 'open' | 'closed' | 'transmitted' | 'archived';\n  documents: string[]; // Document IDs\n  summary: {\n    totalDocuments: number;\n    totalAmount: number;\n    totalVAT: number;\n    byType: Record<string, number>;\n    byVATRate: Record<string, number>;\n  };\n  transmissionData?: {\n    transmittedAt: number;\n    batchId: string;\n    acknowledgmentId?: string;\n    status: 'pending' | 'accepted' | 'rejected';\n  };\n}\n\nexport interface FiscalViolation {\n  id: string;\n  type: 'sequence_gap' | 'invalid_vat' | 'missing_signature' | 'retention_violation' | 'transmission_failure';\n  severity: 'warning' | 'error' | 'critical';\n  documentId?: string;\n  description: string;\n  detectedAt: number;\n  resolvedAt?: number;\n  resolution?: string;\n  automaticResolution: boolean;\n  metadata: Record<string, any>;\n}\n\nexport interface FiscalReport {\n  id: string;\n  type: 'vat_summary' | 'sales_summary' | 'audit_trail' | 'compliance_check';\n  period: FiscalPeriod;\n  generatedAt: number;\n  generatedBy: string;\n  data: any;\n  hash: string;\n  signature?: string;\n  format: 'json' | 'xml' | 'pdf';\n  compliance: {\n    agenziaEntrateFormat: boolean;\n    digitallyValid: boolean;\n    complete: boolean;\n  };\n}\n\nexport class FiscalAuditManager {\n  private config: FiscalConfig;\n  private documents = new Map<string, FiscalDocument>();\n  private periods = new Map<string, FiscalPeriod>();\n  private violations: FiscalViolation[] = [];\n  private sequenceCounters = new Map<string, number>(); // type -> last sequence number\n  private auditChain: string[] = []; // Hash chain for immutability\n  private reports = new Map<string, FiscalReport>();\n\n  constructor(config?: Partial<FiscalConfig>) {\n    this.config = {\n      enabled: true,\n      taxRegion: 'IT',\n      retentionPeriod: 10 * 365 * 24 * 60 * 60 * 1000, // 10 years\n      digitalSignature: {\n        required: true,\n        algorithm: 'ECDSA',\n        certificateValidation: true,\n      },\n      receiptSequencing: {\n        enforceSequential: true,\n        allowGaps: false,\n        maxGapSize: 0,\n      },\n      auditTrail: {\n        immutable: true,\n        hashChaining: true,\n        timestamping: true,\n      },\n      compliance: {\n        agenziaEntrate: true,\n        vatCompliance: true,\n        antiMoneyLaundering: true,\n      },\n      ...config,\n    };\n\n    if (this.config.enabled) {\n      this.initializeFiscalSystem();\n    }\n  }\n\n  /**\n   * Create a fiscal document (receipt, invoice, etc.)\n   */\n  async createFiscalDocument(\n    type: FiscalDocument['type'],\n    merchantInfo: FiscalDocument['merchant'],\n    items: FiscalLineItem[],\n    paymentMethod: string,\n    customerInfo?: FiscalDocument['customer'],\n    metadata?: FiscalDocument['metadata']\n  ): Promise<string> {\n    if (!this.config.enabled) {\n      throw new Error('Fiscal audit system is disabled');\n    }\n\n    const documentId = this.generateDocumentId();\n    const timestamp = Date.now();\n    const fiscalYear = new Date(timestamp).getFullYear();\n    \n    // Generate sequence number\n    const sequenceKey = `${type}_${fiscalYear}`;\n    const sequenceNumber = this.getNextSequenceNumber(sequenceKey);\n    \n    // Validate sequence if required\n    if (this.config.receiptSequencing.enforceSequential) {\n      await this.validateSequence(type, sequenceNumber, fiscalYear);\n    }\n\n    // Calculate amounts and VAT\n    const { amount, vat } = this.calculateAmounts(items);\n\n    // Validate VAT compliance\n    if (this.config.compliance.vatCompliance) {\n      this.validateVATCompliance(items, vat);\n    }\n\n    // Create document\n    const document: FiscalDocument = {\n      id: documentId,\n      type,\n      sequenceNumber,\n      fiscalYear,\n      documentNumber: this.generateDocumentNumber(type, sequenceNumber, fiscalYear),\n      timestamp,\n      amount,\n      merchant: merchantInfo,\n      ...(customerInfo && { customer: customerInfo }),\n      items,\n      vat,\n      paymentMethod,\n      hash: '', // Will be calculated\n      previousHash: this.getLastDocumentHash() || '',\n      auditTrail: [],\n      compliance: {\n        agenziaEntrateCompliant: false,\n        vatCompliant: false,\n        fiscallyValid: false,\n        warnings: [],\n      },\n      metadata: metadata || {},\n    };\n\n    // Calculate document hash\n    document.hash = await this.calculateDocumentHash(document);\n\n    // Add to audit chain\n    if (this.config.auditTrail.hashChaining) {\n      this.auditChain.push(document.hash);\n    }\n\n    // Create initial audit entry\n    const auditEntry: FiscalAuditEntry = {\n      id: this.generateAuditId(),\n      timestamp,\n      action: 'created',\n      userId: metadata?.operator_id || 'system',\n      details: {\n        type,\n        amount: amount.total,\n        sequenceNumber,\n        itemCount: items.length,\n      },\n      hash: await this.calculateAuditHash(documentId, 'created', timestamp),\n    };\n\n    document.auditTrail.push(auditEntry);\n\n    // Digital signature if required\n    if (this.config.digitalSignature.required) {\n      document.digitalSignature = await this.signDocument(document);\n    }\n\n    // Validate compliance\n    document.compliance = await this.validateCompliance(document);\n\n    // Store document\n    this.documents.set(documentId, document);\n\n    // Update fiscal period\n    await this.updateFiscalPeriod(document);\n\n    // Check for violations\n    await this.checkForViolations(document);\n\n    return documentId;\n  }\n\n  /**\n   * Void a fiscal document\n   */\n  async voidFiscalDocument(\n    documentId: string,\n    reason: string,\n    userId: string\n  ): Promise<void> {\n    const document = this.documents.get(documentId);\n    if (!document) {\n      throw new Error(`Document not found: ${documentId}`);\n    }\n\n    // Check if document can be voided\n    const voidDeadline = document.timestamp + (24 * 60 * 60 * 1000); // 24 hours\n    if (Date.now() > voidDeadline && this.config.taxRegion === 'IT') {\n      throw new Error('Document cannot be voided after 24 hours (Italian fiscal law)');\n    }\n\n    // Create void audit entry\n    const auditEntry: FiscalAuditEntry = {\n      id: this.generateAuditId(),\n      timestamp: Date.now(),\n      action: 'voided',\n      userId,\n      details: {\n        reason,\n        originalAmount: document.amount.total,\n        voidedAt: Date.now(),\n      },\n      hash: await this.calculateAuditHash(documentId, 'voided', Date.now()),\n    };\n\n    document.auditTrail.push(auditEntry);\n\n    // Recalculate document hash with void\n    document.hash = await this.calculateDocumentHash(document);\n\n    // Update fiscal period\n    await this.updateFiscalPeriod(document);\n  }\n\n  /**\n   * Generate fiscal period report\n   */\n  async generateFiscalReport(\n    type: FiscalReport['type'],\n    year: number,\n    month?: number,\n    quarter?: number\n  ): Promise<string> {\n    const periodKey = this.generatePeriodKey(year, month, quarter);\n    const period = this.periods.get(periodKey);\n\n    if (!period) {\n      throw new Error(`Fiscal period not found: ${periodKey}`);\n    }\n\n    const reportId = this.generateReportId();\n    const timestamp = Date.now();\n\n    let reportData: any;\n\n    switch (type) {\n      case 'vat_summary':\n        reportData = await this.generateVATSummary(period);\n        break;\n      case 'sales_summary':\n        reportData = await this.generateSalesSummary(period);\n        break;\n      case 'audit_trail':\n        reportData = await this.generateAuditTrailReport(period);\n        break;\n      case 'compliance_check':\n        reportData = await this.generateComplianceReport(period);\n        break;\n      default:\n        throw new Error(`Unsupported report type: ${type}`);\n    }\n\n    const report: FiscalReport = {\n      id: reportId,\n      type,\n      period,\n      generatedAt: timestamp,\n      generatedBy: 'system',\n      data: reportData,\n      hash: '', // Will be calculated\n      format: 'json',\n      compliance: {\n        agenziaEntrateFormat: this.config.compliance.agenziaEntrate,\n        digitallyValid: false,\n        complete: true,\n      },\n    };\n\n    // Calculate report hash\n    report.hash = await this.calculateReportHash(report);\n\n    // Digital signature if required\n    if (this.config.digitalSignature.required) {\n      report.signature = await this.signReport(report);\n      report.compliance.digitallyValid = true;\n    }\n\n    this.reports.set(reportId, report);\n    return reportId;\n  }\n\n  /**\n   * Validate fiscal document integrity\n   */\n  async validateDocumentIntegrity(documentId: string): Promise<{\n    isValid: boolean;\n    issues: string[];\n    hashChainValid: boolean;\n    signatureValid: boolean;\n  }> {\n    const document = this.documents.get(documentId);\n    if (!document) {\n      return {\n        isValid: false,\n        issues: ['Document not found'],\n        hashChainValid: false,\n        signatureValid: false,\n      };\n    }\n\n    const issues: string[] = [];\n\n    // Verify document hash\n    const calculatedHash = await this.calculateDocumentHash(document);\n    const hashValid = calculatedHash === document.hash;\n    if (!hashValid) {\n      issues.push('Document hash mismatch');\n    }\n\n    // Verify hash chain\n    let hashChainValid = true;\n    if (this.config.auditTrail.hashChaining && document.previousHash) {\n      const previousDocument = this.findDocumentByHash(document.previousHash);\n      if (!previousDocument) {\n        hashChainValid = false;\n        issues.push('Previous document not found in chain');\n      }\n    }\n\n    // Verify digital signature\n    let signatureValid = true;\n    if (this.config.digitalSignature.required && document.digitalSignature) {\n      signatureValid = await this.verifyDocumentSignature(document);\n      if (!signatureValid) {\n        issues.push('Digital signature invalid');\n      }\n    }\n\n    // Verify audit trail\n    for (const entry of document.auditTrail) {\n      const auditHash = await this.calculateAuditHash(\n        documentId,\n        entry.action,\n        entry.timestamp\n      );\n      if (auditHash !== entry.hash) {\n        issues.push(`Audit entry ${entry.id} hash mismatch`);\n      }\n    }\n\n    return {\n      isValid: issues.length === 0,\n      issues,\n      hashChainValid,\n      signatureValid,\n    };\n  }\n\n  /**\n   * Get fiscal compliance status\n   */\n  getFiscalComplianceStatus(): {\n    overall: 'compliant' | 'warnings' | 'violations';\n    documents: {\n      total: number;\n      compliant: number;\n      withWarnings: number;\n      withViolations: number;\n    };\n    periods: {\n      open: number;\n      closed: number;\n      transmitted: number;\n    };\n    violations: {\n      total: number;\n      critical: number;\n      unresolved: number;\n    };\n    retention: {\n      totalDocuments: number;\n      expiringSoon: number; // Within 6 months\n      expired: number;\n    };\n  } {\n    const documents = Array.from(this.documents.values());\n    const periods = Array.from(this.periods.values());\n    \n    const compliantDocs = documents.filter(d => d.compliance.fiscallyValid);\n    const warningDocs = documents.filter(d => d.compliance.warnings.length > 0);\n    const violationDocs = documents.filter(d => !d.compliance.fiscallyValid);\n\n    const openPeriods = periods.filter(p => p.status === 'open').length;\n    const closedPeriods = periods.filter(p => p.status === 'closed').length;\n    const transmittedPeriods = periods.filter(p => p.status === 'transmitted').length;\n\n    const criticalViolations = this.violations.filter(v => v.severity === 'critical').length;\n    const unresolvedViolations = this.violations.filter(v => !v.resolvedAt).length;\n\n    const now = Date.now();\n    const sixMonthsFromNow = now + (6 * 30 * 24 * 60 * 60 * 1000);\n    const retentionDeadline = now - this.config.retentionPeriod;\n\n    const expiringSoon = documents.filter(d => \n      d.timestamp + this.config.retentionPeriod > now && \n      d.timestamp + this.config.retentionPeriod <= sixMonthsFromNow\n    ).length;\n\n    const expired = documents.filter(d => \n      d.timestamp < retentionDeadline\n    ).length;\n\n    let overall: 'compliant' | 'warnings' | 'violations' = 'compliant';\n    if (criticalViolations > 0 || violationDocs.length > 0) {\n      overall = 'violations';\n    } else if (warningDocs.length > 0) {\n      overall = 'warnings';\n    }\n\n    return {\n      overall,\n      documents: {\n        total: documents.length,\n        compliant: compliantDocs.length,\n        withWarnings: warningDocs.length,\n        withViolations: violationDocs.length,\n      },\n      periods: {\n        open: openPeriods,\n        closed: closedPeriods,\n        transmitted: transmittedPeriods,\n      },\n      violations: {\n        total: this.violations.length,\n        critical: criticalViolations,\n        unresolved: unresolvedViolations,\n      },\n      retention: {\n        totalDocuments: documents.length,\n        expiringSoon,\n        expired,\n      },\n    };\n  }\n\n  /**\n   * Export fiscal data for tax authorities\n   */\n  async exportFiscalData(\n    year: number,\n    format: 'xml' | 'json' = 'xml'\n  ): Promise<string> {\n    const yearDocuments = Array.from(this.documents.values())\n      .filter(doc => doc.fiscalYear === year);\n\n    const exportData = {\n      metadata: {\n        exportedAt: Date.now(),\n        taxYear: year,\n        totalDocuments: yearDocuments.length,\n        software: 'A-Cube eReceipt SDK',\n        version: '2.0.0',\n      },\n      merchant: yearDocuments[0]?.merchant || {},\n      documents: yearDocuments.map(doc => ({\n        id: doc.id,\n        type: doc.type,\n        documentNumber: doc.documentNumber,\n        timestamp: doc.timestamp,\n        amount: doc.amount,\n        vat: doc.vat,\n        hash: doc.hash,\n        digitalSignature: doc.digitalSignature,\n      })),\n      summary: {\n        totalAmount: yearDocuments.reduce((sum, doc) => sum + doc.amount.total, 0),\n        totalVAT: yearDocuments.reduce((sum, doc) => sum + doc.amount.vat, 0),\n        documentsByType: this.groupDocumentsByType(yearDocuments),\n      },\n      compliance: {\n        agenziaEntrateCompliant: this.config.compliance.agenziaEntrate,\n        retentionCompliant: true,\n        digitallyValid: yearDocuments.every(doc => doc.digitalSignature),\n      },\n    };\n\n    if (format === 'xml') {\n      return this.convertToAgenziaEntrateXML(exportData);\n    } else {\n      return JSON.stringify(exportData, null, 2);\n    }\n  }\n\n  private initializeFiscalSystem(): void {\n    // Initialize current fiscal period\n    const now = new Date();\n    const currentYear = now.getFullYear();\n    const currentMonth = now.getMonth() + 1;\n    \n    this.ensureFiscalPeriod(currentYear, currentMonth);\n\n    // Set up periodic compliance checks\n    setInterval(() => {\n      this.performPeriodicComplianceCheck();\n    }, 24 * 60 * 60 * 1000); // Daily\n  }\n\n  private getNextSequenceNumber(sequenceKey: string): number {\n    const current = this.sequenceCounters.get(sequenceKey) || 0;\n    const next = current + 1;\n    this.sequenceCounters.set(sequenceKey, next);\n    return next;\n  }\n\n  private async validateSequence(\n    type: string,\n    sequenceNumber: number,\n    fiscalYear: number\n  ): Promise<void> {\n    if (!this.config.receiptSequencing.enforceSequential) return;\n\n    const sequenceKey = `${type}_${fiscalYear}`;\n    const expectedNumber = (this.sequenceCounters.get(sequenceKey) || 0) + 1;\n\n    if (sequenceNumber !== expectedNumber) {\n      if (!this.config.receiptSequencing.allowGaps) {\n        throw new Error(`Sequence violation: expected ${expectedNumber}, got ${sequenceNumber}`);\n      }\n\n      const gap = Math.abs(sequenceNumber - expectedNumber);\n      if (gap > this.config.receiptSequencing.maxGapSize) {\n        throw new Error(`Sequence gap too large: ${gap} > ${this.config.receiptSequencing.maxGapSize}`);\n      }\n\n      // Record the gap as a violation\n      this.recordViolation({\n        type: 'sequence_gap',\n        severity: 'warning',\n        description: `Sequence gap detected: expected ${expectedNumber}, got ${sequenceNumber}`,\n        metadata: { type, fiscalYear, expectedNumber, actualNumber: sequenceNumber },\n      });\n    }\n  }\n\n  private calculateAmounts(items: FiscalLineItem[]): {\n    amount: FiscalDocument['amount'];\n    vat: VATBreakdown[];\n  } {\n    let netTotal = 0;\n    let vatTotal = 0;\n    const vatBreakdown = new Map<number, { net: number; vat: number }>();\n\n    for (const item of items) {\n      const itemNet = item.quantity * item.unitPrice;\n      const itemVat = itemNet * (item.vatRate / 100);\n      \n      netTotal += itemNet;\n      vatTotal += itemVat;\n\n      // Group by VAT rate\n      const existing = vatBreakdown.get(item.vatRate) || { net: 0, vat: 0 };\n      existing.net += itemNet;\n      existing.vat += itemVat;\n      vatBreakdown.set(item.vatRate, existing);\n    }\n\n    const vat: VATBreakdown[] = Array.from(vatBreakdown.entries()).map(([rate, amounts]) => ({\n      rate,\n      netAmount: amounts.net,\n      vatAmount: amounts.vat,\n      totalAmount: amounts.net + amounts.vat,\n      category: this.getVATCategory(rate),\n    }));\n\n    return {\n      amount: {\n        net: netTotal,\n        vat: vatTotal,\n        total: netTotal + vatTotal,\n        currency: 'EUR',\n      },\n      vat,\n    };\n  }\n\n  private getVATCategory(rate: number): VATBreakdown['category'] {\n    if (rate === 0) return 'zero';\n    if (rate === 22) return 'standard'; // Italy standard rate\n    if (rate === 10 || rate === 4) return 'reduced'; // Italy reduced rates\n    return 'standard';\n  }\n\n  private validateVATCompliance(items: FiscalLineItem[], _vat: VATBreakdown[]): void {\n    // Validate Italian VAT rates\n    const validRates = [0, 4, 5, 10, 22]; // Valid Italian VAT rates\n    \n    for (const item of items) {\n      if (!validRates.includes(item.vatRate)) {\n        this.recordViolation({\n          type: 'invalid_vat',\n          severity: 'error',\n          description: `Invalid VAT rate: ${item.vatRate}% (item: ${item.description})`,\n          metadata: { itemId: item.id, vatRate: item.vatRate },\n        });\n      }\n    }\n  }\n\n  private async calculateDocumentHash(document: FiscalDocument): Promise<string> {\n    const hashData = {\n      id: document.id,\n      type: document.type,\n      sequenceNumber: document.sequenceNumber,\n      timestamp: document.timestamp,\n      amount: document.amount,\n      merchant: document.merchant,\n      items: document.items,\n      previousHash: document.previousHash,\n    };\n\n    const encoder = new TextEncoder();\n    const data = encoder.encode(JSON.stringify(hashData));\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    \n    return Array.from(new Uint8Array(hashBuffer))\n      .map(b => b.toString(16).padStart(2, '0'))\n      .join('');\n  }\n\n  private async calculateAuditHash(\n    documentId: string,\n    action: string,\n    timestamp: number\n  ): Promise<string> {\n    const hashData = `${documentId}:${action}:${timestamp}`;\n    const encoder = new TextEncoder();\n    const data = encoder.encode(hashData);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    \n    return Array.from(new Uint8Array(hashBuffer))\n      .map(b => b.toString(16).padStart(2, '0'))\n      .join('');\n  }\n\n  private async calculateReportHash(report: FiscalReport): Promise<string> {\n    const hashData = {\n      id: report.id,\n      type: report.type,\n      period: report.period,\n      generatedAt: report.generatedAt,\n      data: report.data,\n    };\n\n    const encoder = new TextEncoder();\n    const data = encoder.encode(JSON.stringify(hashData));\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    \n    return Array.from(new Uint8Array(hashBuffer))\n      .map(b => b.toString(16).padStart(2, '0'))\n      .join('');\n  }\n\n  private getLastDocumentHash(): string | undefined {\n    return this.auditChain[this.auditChain.length - 1];\n  }\n\n  private findDocumentByHash(hash: string): FiscalDocument | undefined {\n    return Array.from(this.documents.values()).find(doc => doc.hash === hash);\n  }\n\n  private async signDocument(document: FiscalDocument): Promise<string> {\n    // Simplified digital signature - in production, use proper PKI\n    const documentHash = await this.calculateDocumentHash(document);\n    return `signature_${documentHash.substring(0, 16)}`;\n  }\n\n  private async signReport(report: FiscalReport): Promise<string> {\n    // Simplified digital signature - in production, use proper PKI\n    const reportHash = await this.calculateReportHash(report);\n    return `signature_${reportHash.substring(0, 16)}`;\n  }\n\n  private async verifyDocumentSignature(document: FiscalDocument): Promise<boolean> {\n    // Simplified verification - in production, use proper PKI\n    if (!document.digitalSignature) return false;\n    \n    const documentHash = await this.calculateDocumentHash(document);\n    const expectedSignature = `signature_${documentHash.substring(0, 16)}`;\n    \n    return document.digitalSignature === expectedSignature;\n  }\n\n  private async validateCompliance(document: FiscalDocument): Promise<FiscalDocument['compliance']> {\n    const warnings: string[] = [];\n    let agenziaEntrateCompliant = true;\n    let vatCompliant = true;\n    let fiscallyValid = true;\n\n    // Check Agenzia delle Entrate compliance\n    if (this.config.compliance.agenziaEntrate) {\n      if (!document.merchant.vatNumber || !document.merchant.fiscalCode) {\n        warnings.push('Missing merchant VAT number or fiscal code');\n        agenziaEntrateCompliant = false;\n      }\n\n      if (!document.digitalSignature && this.config.digitalSignature.required) {\n        warnings.push('Missing digital signature');\n        agenziaEntrateCompliant = false;\n      }\n    }\n\n    // Check VAT compliance\n    if (this.config.compliance.vatCompliance) {\n      const totalVAT = document.vat.reduce((sum, v) => sum + v.vatAmount, 0);\n      if (Math.abs(totalVAT - document.amount.vat) > 0.01) {\n        warnings.push('VAT calculation mismatch');\n        vatCompliant = false;\n      }\n    }\n\n    fiscallyValid = agenziaEntrateCompliant && vatCompliant;\n\n    return {\n      agenziaEntrateCompliant,\n      vatCompliant,\n      fiscallyValid,\n      warnings,\n    };\n  }\n\n  private generateDocumentNumber(type: string, sequenceNumber: number, fiscalYear: number): string {\n    const typePrefix = {\n      receipt: 'RC',\n      invoice: 'FT',\n      credit_note: 'NC',\n      fiscal_report: 'RF',\n    }[type] || 'DOC';\n\n    return `${typePrefix}${fiscalYear}${String(sequenceNumber).padStart(6, '0')}`;\n  }\n\n  private ensureFiscalPeriod(year: number, month?: number, quarter?: number): void {\n    const periodKey = this.generatePeriodKey(year, month, quarter);\n    \n    if (!this.periods.has(periodKey)) {\n      const startDate = month \n        ? new Date(year, month - 1, 1).getTime()\n        : new Date(year, 0, 1).getTime();\n      \n      const endDate = month\n        ? new Date(year, month, 0).getTime()\n        : new Date(year + 1, 0, 0).getTime();\n\n      const period: FiscalPeriod = {\n        year,\n        ...(month !== undefined && { month }),\n        ...(quarter !== undefined && { quarter }),\n        startDate,\n        endDate,\n        status: 'open',\n        documents: [],\n        summary: {\n          totalDocuments: 0,\n          totalAmount: 0,\n          totalVAT: 0,\n          byType: {},\n          byVATRate: {},\n        },\n      };\n\n      this.periods.set(periodKey, period);\n    }\n  }\n\n  private async updateFiscalPeriod(document: FiscalDocument): Promise<void> {\n    const date = new Date(document.timestamp);\n    const year = date.getFullYear();\n    const month = date.getMonth() + 1;\n\n    this.ensureFiscalPeriod(year, month);\n\n    const periodKey = this.generatePeriodKey(year, month);\n    const period = this.periods.get(periodKey)!;\n\n    // Add document to period if not already present\n    if (!period.documents.includes(document.id)) {\n      period.documents.push(document.id);\n      \n      // Update summary\n      period.summary.totalDocuments++;\n      period.summary.totalAmount += document.amount.total;\n      period.summary.totalVAT += document.amount.vat;\n      \n      // Update by type\n      period.summary.byType[document.type] = (period.summary.byType[document.type] || 0) + 1;\n      \n      // Update by VAT rate\n      for (const vat of document.vat) {\n        const rateKey = `${vat.rate}%`;\n        period.summary.byVATRate[rateKey] = (period.summary.byVATRate[rateKey] || 0) + vat.vatAmount;\n      }\n    }\n  }\n\n  private async checkForViolations(document: FiscalDocument): Promise<void> {\n    // Check for missing required fields\n    if (this.config.digitalSignature.required && !document.digitalSignature) {\n      this.recordViolation({\n        type: 'missing_signature',\n        severity: 'critical',\n        documentId: document.id,\n        description: 'Document missing required digital signature',\n        metadata: { documentType: document.type },\n      });\n    }\n\n    // Check VAT compliance\n    if (!document.compliance.vatCompliant) {\n      this.recordViolation({\n        type: 'invalid_vat',\n        severity: 'error',\n        documentId: document.id,\n        description: 'VAT calculation errors detected',\n        metadata: { warnings: document.compliance.warnings },\n      });\n    }\n  }\n\n  private recordViolation(violation: Omit<FiscalViolation, 'id' | 'detectedAt' | 'automaticResolution'>): void {\n    const fullViolation: FiscalViolation = {\n      id: this.generateViolationId(),\n      detectedAt: Date.now(),\n      automaticResolution: false,\n      ...violation,\n    };\n\n    this.violations.push(fullViolation);\n  }\n\n  private async generateVATSummary(period: FiscalPeriod): Promise<any> {\n    const documents = period.documents.map(id => this.documents.get(id)!).filter(Boolean);\n    \n    const vatSummary = documents.reduce((summary, doc) => {\n      for (const vat of doc.vat) {\n        const key = `${vat.rate}%`;\n        if (!summary[key]) {\n          summary[key] = { netAmount: 0, vatAmount: 0, totalAmount: 0 };\n        }\n        summary[key].netAmount += vat.netAmount;\n        summary[key].vatAmount += vat.vatAmount;\n        summary[key].totalAmount += vat.totalAmount;\n      }\n      return summary;\n    }, {} as Record<string, any>);\n\n    return {\n      period: `${period.year}-${period.month?.toString().padStart(2, '0') || 'YEAR'}`,\n      vatSummary,\n      totalNet: Object.values(vatSummary).reduce((sum: number, v: any) => sum + v.netAmount, 0),\n      totalVAT: Object.values(vatSummary).reduce((sum: number, v: any) => sum + v.vatAmount, 0),\n      totalGross: Object.values(vatSummary).reduce((sum: number, v: any) => sum + v.totalAmount, 0),\n    };\n  }\n\n  private async generateSalesSummary(period: FiscalPeriod): Promise<any> {\n    return {\n      period: `${period.year}-${period.month?.toString().padStart(2, '0') || 'YEAR'}`,\n      summary: period.summary,\n      documents: period.documents.length,\n    };\n  }\n\n  private async generateAuditTrailReport(period: FiscalPeriod): Promise<any> {\n    const documents = period.documents.map(id => this.documents.get(id)!).filter(Boolean);\n    \n    const auditEntries = documents.flatMap(doc => \n      doc.auditTrail.map(entry => ({\n        documentId: doc.id,\n        documentNumber: doc.documentNumber,\n        ...entry,\n      }))\n    );\n\n    return {\n      period: `${period.year}-${period.month?.toString().padStart(2, '0') || 'YEAR'}`,\n      auditEntries,\n      totalEntries: auditEntries.length,\n    };\n  }\n\n  private async generateComplianceReport(period: FiscalPeriod): Promise<any> {\n    const documents = period.documents.map(id => this.documents.get(id)!).filter(Boolean);\n    \n    const compliantDocs = documents.filter(doc => doc.compliance.fiscallyValid);\n    const nonCompliantDocs = documents.filter(doc => !doc.compliance.fiscallyValid);\n\n    return {\n      period: `${period.year}-${period.month?.toString().padStart(2, '0') || 'YEAR'}`,\n      complianceRate: documents.length > 0 ? (compliantDocs.length / documents.length) * 100 : 100,\n      totalDocuments: documents.length,\n      compliantDocuments: compliantDocs.length,\n      nonCompliantDocuments: nonCompliantDocs.length,\n      violations: this.violations.filter(v => \n        v.documentId && period.documents.includes(v.documentId)\n      ),\n    };\n  }\n\n  private performPeriodicComplianceCheck(): void {\n    // Check for documents approaching retention deadline\n    const now = Date.now();\n    const warningPeriod = 6 * 30 * 24 * 60 * 60 * 1000; // 6 months\n    \n    for (const document of this.documents.values()) {\n      const retentionDeadline = document.timestamp + this.config.retentionPeriod;\n      \n      if (retentionDeadline - now <= warningPeriod && retentionDeadline > now) {\n        this.recordViolation({\n          type: 'retention_violation',\n          severity: 'warning',\n          documentId: document.id,\n          description: `Document approaching retention deadline`,\n          metadata: { \n            retentionDeadline,\n            daysRemaining: Math.floor((retentionDeadline - now) / (24 * 60 * 60 * 1000))\n          },\n        });\n      }\n    }\n  }\n\n  private convertToAgenziaEntrateXML(data: any): string {\n    // Simplified XML conversion for Italian Revenue Agency format\n    // In production, use proper XML library and official schema\n    let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n    xml += '<DatiFattura versione=\"1.0\">\\n';\n    xml += '  <DatiGenerali>\\n';\n    xml += `    <AnnoFiscale>${data.metadata.taxYear}</AnnoFiscale>\\n`;\n    xml += `    <NumeroDocumenti>${data.metadata.totalDocuments}</NumeroDocumenti>\\n`;\n    xml += '  </DatiGenerali>\\n';\n    xml += '  <Documenti>\\n';\n    \n    for (const doc of data.documents) {\n      xml += '    <Documento>\\n';\n      xml += `      <ID>${doc.id}</ID>\\n`;\n      xml += `      <Numero>${doc.documentNumber}</Numero>\\n`;\n      xml += `      <Data>${new Date(doc.timestamp).toISOString().split('T')[0]}</Data>\\n`;\n      xml += `      <Importo>${doc.amount.total}</Importo>\\n`;\n      xml += `      <IVA>${doc.amount.vat}</IVA>\\n`;\n      xml += '    </Documento>\\n';\n    }\n    \n    xml += '  </Documenti>\\n';\n    xml += '</DatiFattura>';\n    \n    return xml;\n  }\n\n  private groupDocumentsByType(documents: FiscalDocument[]): Record<string, number> {\n    return documents.reduce((acc, doc) => {\n      acc[doc.type] = (acc[doc.type] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n  }\n\n  private generatePeriodKey(year: number, month?: number, quarter?: number): string {\n    if (month) return `${year}-${month.toString().padStart(2, '0')}`;\n    if (quarter) return `${year}-Q${quarter}`;\n    return `${year}`;\n  }\n\n  private generateDocumentId(): string {\n    return `doc_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private generateAuditId(): string {\n    return `audit_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private generateReportId(): string {\n    return `report_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private generateViolationId(): string {\n    return `violation_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n}","/**\n * Compliance Tools for A-Cube SDK\n * Complete suite of compliance management tools for GDPR, fiscal audit, and access control\n */\n\nimport {\n  GDPRComplianceManager,\n  type GDPRConfig,\n  type DataSubject,\n  type ConsentRecord,\n  type DataProcessingRecord,\n  type DataExportRequest,\n  type ErasureRequest,\n  type GDPRAuditReport,\n  type GDPRViolation,\n} from './gdpr-compliance';\n\nimport {\n  FiscalAuditManager,\n  type FiscalConfig,\n  type FiscalDocument,\n  type FiscalLineItem,\n  type VATBreakdown,\n  type FiscalAuditEntry,\n  type FiscalPeriod,\n  type FiscalViolation,\n  type FiscalReport,\n} from './fiscal-audit';\n\nimport {\n  AccessControlManager,\n  type AccessControlConfig,\n  type Role,\n  type Permission,\n  type AccessCondition,\n  type User,\n  type UserSession,\n  type AccessRequest,\n  type AccessContext,\n  type AccessAuditEntry,\n} from './access-control';\n\nexport {\n  GDPRComplianceManager,\n  type GDPRConfig,\n  type DataSubject,\n  type ConsentRecord,\n  type DataProcessingRecord,\n  type DataExportRequest,\n  type ErasureRequest,\n  type GDPRAuditReport,\n  type GDPRViolation,\n  FiscalAuditManager,\n  type FiscalConfig,\n  type FiscalDocument,\n  type FiscalLineItem,\n  type VATBreakdown,\n  type FiscalAuditEntry,\n  type FiscalPeriod,\n  type FiscalViolation,\n  type FiscalReport,\n  AccessControlManager,\n  type AccessControlConfig,\n  type Role,\n  type Permission,\n  type AccessCondition,\n  type User,\n  type UserSession,\n  type AccessRequest,\n  type AccessContext,\n  type AccessAuditEntry,\n};\n\n/**\n * Comprehensive Compliance Manager\n * Integrates all compliance components into a unified interface\n */\nexport class ComplianceManager {\n  private gdpr: GDPRComplianceManager;\n  private fiscal: FiscalAuditManager;\n  private access: AccessControlManager;\n\n  constructor(config?: {\n    gdpr?: Partial<GDPRConfig>;\n    fiscal?: Partial<FiscalConfig>;\n    access?: Partial<AccessControlConfig>;\n  }) {\n    this.gdpr = new GDPRComplianceManager(config?.gdpr);\n    this.fiscal = new FiscalAuditManager(config?.fiscal);\n    this.access = new AccessControlManager(config?.access);\n  }\n\n  /**\n   * Get GDPR compliance manager\n   */\n  getGDPR(): GDPRComplianceManager {\n    return this.gdpr;\n  }\n\n  /**\n   * Get fiscal audit manager\n   */\n  getFiscal(): FiscalAuditManager {\n    return this.fiscal;\n  }\n\n  /**\n   * Get access control manager\n   */\n  getAccess(): AccessControlManager {\n    return this.access;\n  }\n\n  /**\n   * Initialize compliance with default configurations\n   */\n  async initialize(): Promise<{\n    gdprEnabled: boolean;\n    fiscalEnabled: boolean;\n    accessEnabled: boolean;\n  }> {\n    // Register default data subject for system operations\n    await this.gdpr.registerDataSubject(\n      'system',\n      undefined,\n      {\n        purpose: 'system_operations',\n        dataTypes: ['system_logs'],\n        consentGiven: true,\n        source: 'legitimate_interest',\n      }\n    );\n\n    // Create default admin user\n    await this.access.createUser(\n      {\n        email: 'admin@system.local',\n        name: 'System Administrator',\n        roles: ['admin'],\n        attributes: { system: true },\n        status: 'active',\n      },\n      'system'\n    );\n\n    return {\n      gdprEnabled: true,\n      fiscalEnabled: true,\n      accessEnabled: true,\n    };\n  }\n\n  /**\n   * Process receipt with full compliance checks\n   */\n  async processReceiptWithCompliance(\n    receiptData: {\n      merchantInfo: any;\n      items: any[];\n      paymentMethod: string;\n      customerInfo?: any;\n    },\n    sessionId: string,\n    context: AccessContext\n  ): Promise<{\n    documentId?: string;\n    accessGranted: boolean;\n    gdprCompliant: boolean;\n    fiscalCompliant: boolean;\n    warnings: string[];\n  }> {\n    const warnings: string[] = [];\n    \n    // Check access permissions\n    const accessCheck = await this.access.checkAccess(\n      sessionId,\n      'receipts',\n      'create',\n      context\n    );\n\n    if (!accessCheck.granted) {\n      return {\n        accessGranted: false,\n        gdprCompliant: false,\n        fiscalCompliant: false,\n        warnings: [accessCheck.reason || 'Access denied'],\n      };\n    }\n\n    // Check GDPR compliance if customer data is present\n    let gdprCompliant = true;\n    if (receiptData.customerInfo) {\n      const processingLawfulness = this.gdpr.isProcessingLawful(\n        receiptData.customerInfo.id || 'anonymous',\n        'transaction_processing',\n        ['transaction_data', 'payment_info']\n      );\n\n      if (!processingLawfulness.lawful) {\n        gdprCompliant = false;\n        warnings.push(...processingLawfulness.warnings);\n      }\n    }\n\n    // Create fiscal document\n    let documentId: string | undefined;\n    let fiscalCompliant = true;\n\n    try {\n      documentId = await this.fiscal.createFiscalDocument(\n        'receipt',\n        receiptData.merchantInfo,\n        receiptData.items,\n        receiptData.paymentMethod,\n        receiptData.customerInfo\n      );\n    } catch (error) {\n      fiscalCompliant = false;\n      warnings.push(`Fiscal compliance error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    // Record GDPR processing activity if customer data is involved\n    if (receiptData.customerInfo && gdprCompliant) {\n      this.gdpr.recordProcessingActivity({\n        subjectId: receiptData.customerInfo.id || 'anonymous',\n        dataType: 'transaction_data',\n        purpose: 'payment_processing',\n        lawfulBasis: 'contract',\n        processingActivity: 'receipt_creation',\n        dataLocation: 'internal_database',\n        retentionPeriod: 10 * 365 * 24 * 60 * 60 * 1000, // 10 years for fiscal\n        thirdPartySharing: false,\n        encryptionUsed: true,\n        metadata: { documentId, amount: receiptData.items.reduce((sum, item) => sum + item.totalAmount, 0) },\n      });\n    }\n\n    return {\n      ...(documentId && { documentId }),\n      accessGranted: true,\n      gdprCompliant,\n      fiscalCompliant,\n      warnings,\n    };\n  }\n\n  /**\n   * Generate comprehensive compliance report\n   */\n  async generateComplianceReport(timeRangeMs: number = 30 * 24 * 60 * 60 * 1000): Promise<{\n    period: { start: number; end: number };\n    gdpr: any;\n    fiscal: any;\n    access: any;\n    overall: {\n      complianceScore: number;\n      criticalIssues: number;\n      recommendations: string[];\n    };\n  }> {\n    const now = Date.now();\n    const start = now - timeRangeMs;\n\n    // Get individual compliance reports\n    const gdprReport = this.gdpr.generateComplianceReport(timeRangeMs);\n    const fiscalStatus = this.fiscal.getFiscalComplianceStatus();\n    const accessStats = this.access.getAccessControlStats();\n\n    // Calculate overall compliance score\n    const gdprScore = this.calculateGDPRScore(gdprReport);\n    const fiscalScore = this.calculateFiscalScore(fiscalStatus);\n    const accessScore = this.calculateAccessScore(accessStats);\n    \n    const overallScore = Math.round((gdprScore + fiscalScore + accessScore) / 3);\n\n    // Identify critical issues\n    const criticalIssues = \n      gdprReport.violations.filter(v => v.severity === 'critical').length +\n      fiscalStatus.violations.critical +\n      accessStats.audit.highRiskEvents;\n\n    // Generate recommendations\n    const recommendations = [\n      ...gdprReport.recommendations,\n      ...(fiscalStatus.overall !== 'compliant' ? ['Review fiscal compliance violations'] : []),\n      ...(accessStats.audit.failedAttempts > 10 ? ['Investigate failed access attempts'] : []),\n    ];\n\n    return {\n      period: { start, end: now },\n      gdpr: gdprReport,\n      fiscal: fiscalStatus,\n      access: accessStats,\n      overall: {\n        complianceScore: overallScore,\n        criticalIssues,\n        recommendations,\n      },\n    };\n  }\n\n  /**\n   * Handle data subject request (GDPR Article 15-22)\n   */\n  async handleDataSubjectRequest(\n    type: 'access' | 'portability' | 'erasure' | 'rectification',\n    subjectId: string,\n    requestDetails?: any\n  ): Promise<{\n    requestId: string;\n    status: 'pending' | 'processing' | 'completed';\n    estimatedCompletion?: number;\n  }> {\n    switch (type) {\n      case 'access':\n        // Provide access to all data\n        const exportId = await this.gdpr.requestDataExport(subjectId, {\n          format: 'json',\n          includeMetadata: true,\n        });\n        return {\n          requestId: exportId,\n          status: 'processing',\n          estimatedCompletion: Date.now() + (24 * 60 * 60 * 1000), // 24 hours\n        };\n\n      case 'portability':\n        // Export data in machine-readable format\n        const portabilityId = await this.gdpr.requestDataExport(subjectId, {\n          format: 'json',\n          includeMetadata: false,\n        });\n        return {\n          requestId: portabilityId,\n          status: 'processing',\n          estimatedCompletion: Date.now() + (24 * 60 * 60 * 1000),\n        };\n\n      case 'erasure':\n        // Right to be forgotten\n        const erasureId = await this.gdpr.requestDataErasure(\n          subjectId,\n          requestDetails?.reason || 'data_subject_request',\n          { immediateErasure: false }\n        );\n        return {\n          requestId: erasureId,\n          status: 'pending',\n          estimatedCompletion: Date.now() + (30 * 24 * 60 * 60 * 1000), // 30 days\n        };\n\n      case 'rectification':\n        // Right to rectification - would need additional implementation\n        return {\n          requestId: `rectification_${Date.now()}`,\n          status: 'pending',\n          estimatedCompletion: Date.now() + (7 * 24 * 60 * 60 * 1000), // 7 days\n        };\n\n      default:\n        throw new Error(`Unsupported request type: ${type}`);\n    }\n  }\n\n  /**\n   * Perform automated compliance health check\n   */\n  async performHealthCheck(): Promise<{\n    status: 'healthy' | 'warning' | 'critical';\n    checks: Array<{\n      component: 'gdpr' | 'fiscal' | 'access';\n      status: 'pass' | 'warning' | 'fail';\n      message: string;\n    }>;\n    recommendations: string[];\n  }> {\n    const checks: Array<{\n      component: 'gdpr' | 'fiscal' | 'access';\n      status: 'pass' | 'warning' | 'fail';\n      message: string;\n    }> = [];\n\n    // GDPR health check\n    const gdprReport = this.gdpr.generateComplianceReport(24 * 60 * 60 * 1000); // Last 24h\n    const criticalGdprViolations = gdprReport.violations.filter(v => v.severity === 'critical').length;\n    \n    checks.push({\n      component: 'gdpr',\n      status: criticalGdprViolations > 0 ? 'fail' : gdprReport.violations.length > 0 ? 'warning' : 'pass',\n      message: `${gdprReport.violations.length} violations found (${criticalGdprViolations} critical)`,\n    });\n\n    // Fiscal health check\n    const fiscalStatus = this.fiscal.getFiscalComplianceStatus();\n    checks.push({\n      component: 'fiscal',\n      status: fiscalStatus.overall === 'violations' ? 'fail' : fiscalStatus.overall === 'warnings' ? 'warning' : 'pass',\n      message: `Fiscal compliance: ${fiscalStatus.overall} (${fiscalStatus.violations.critical} critical violations)`,\n    });\n\n    // Access control health check\n    const accessStats = this.access.getAccessControlStats();\n    const highRiskEvents = accessStats.audit.highRiskEvents;\n    \n    checks.push({\n      component: 'access',\n      status: highRiskEvents > 10 ? 'fail' : highRiskEvents > 0 ? 'warning' : 'pass',\n      message: `${highRiskEvents} high-risk access events detected`,\n    });\n\n    // Overall status\n    const failedChecks = checks.filter(c => c.status === 'fail').length;\n    const warningChecks = checks.filter(c => c.status === 'warning').length;\n    \n    let status: 'healthy' | 'warning' | 'critical';\n    if (failedChecks > 0) {\n      status = 'critical';\n    } else if (warningChecks > 0) {\n      status = 'warning';\n    } else {\n      status = 'healthy';\n    }\n\n    // Generate recommendations\n    const recommendations: string[] = [];\n    if (criticalGdprViolations > 0) {\n      recommendations.push('Address critical GDPR violations immediately');\n    }\n    if (fiscalStatus.violations.critical > 0) {\n      recommendations.push('Review fiscal compliance violations');\n    }\n    if (highRiskEvents > 10) {\n      recommendations.push('Investigate high-risk access events');\n    }\n\n    return { status, checks, recommendations };\n  }\n\n  private calculateGDPRScore(report: any): number {\n    const totalEvents = report.summary.totalSubjects + report.summary.dataProcessingActivities;\n    const violations = report.violations.length;\n    \n    if (totalEvents === 0) return 100;\n    \n    const violationRate = violations / totalEvents;\n    return Math.max(0, Math.round(100 - (violationRate * 100)));\n  }\n\n  private calculateFiscalScore(status: any): number {\n    if (status.overall === 'compliant') return 100;\n    if (status.overall === 'warnings') return 75;\n    if (status.violations.critical > 0) return 25;\n    return 50;\n  }\n\n  private calculateAccessScore(stats: any): number {\n    const totalAttempts = stats.audit.totalEntries;\n    const failedAttempts = stats.audit.failedAttempts;\n    const highRiskEvents = stats.audit.highRiskEvents;\n    \n    if (totalAttempts === 0) return 100;\n    \n    const failureRate = failedAttempts / totalAttempts;\n    const riskRate = highRiskEvents / totalAttempts;\n    \n    const score = 100 - (failureRate * 50) - (riskRate * 50);\n    return Math.max(0, Math.round(score));\n  }\n}\n\n/**\n * Compliance utilities\n */\nexport const ComplianceUtils = {\n  /**\n   * Validate GDPR lawful basis\n   */\n  isValidLawfulBasis(basis: string): boolean {\n    const validBases = [\n      'consent',\n      'contract',\n      'legal_obligation',\n      'vital_interests',\n      'public_task',\n      'legitimate_interests'\n    ];\n    return validBases.includes(basis);\n  },\n\n  /**\n   * Validate Italian VAT number\n   */\n  isValidItalianVAT(vatNumber: string): boolean {\n    // Italian VAT format: IT + 11 digits\n    const pattern = /^IT\\d{11}$/;\n    return pattern.test(vatNumber);\n  },\n\n  /**\n   * Validate Italian fiscal code\n   */\n  isValidItalianFiscalCode(fiscalCode: string): boolean {\n    // Italian fiscal code format: 16 alphanumeric characters\n    const pattern = /^[A-Z]{6}\\d{2}[A-Z]\\d{2}[A-Z]\\d{3}[A-Z]$/;\n    return pattern.test(fiscalCode);\n  },\n\n  /**\n   * Calculate data retention period based on category\n   */\n  getRetentionPeriod(category: string, region: string = 'IT'): number {\n    const periods: Record<string, Record<string, number>> = {\n      IT: {\n        transaction_data: 10 * 365 * 24 * 60 * 60 * 1000, // 10 years\n        user_profile: 2 * 365 * 24 * 60 * 60 * 1000, // 2 years\n        marketing_data: 365 * 24 * 60 * 60 * 1000, // 1 year\n        analytics_data: 26 * 30 * 24 * 60 * 60 * 1000, // 26 months (GDPR)\n      },\n    };\n\n    return periods[region]?.[category] || (365 * 24 * 60 * 60 * 1000); // Default 1 year\n  },\n\n  /**\n   * Check if data processing requires explicit consent\n   */\n  requiresExplicitConsent(purpose: string, dataTypes: string[]): boolean {\n    const sensitiveDataTypes = ['health', 'biometric', 'genetic', 'political', 'religious'];\n    const sensitiveDataPresent = dataTypes.some(type => sensitiveDataTypes.includes(type));\n\n    const consentRequiredPurposes = ['marketing', 'profiling', 'advertising'];\n    const purposeRequiresConsent = consentRequiredPurposes.includes(purpose);\n\n    return sensitiveDataPresent || purposeRequiresConsent;\n  },\n\n  /**\n   * Generate compliance report summary\n   */\n  summarizeCompliance(report: any): string {\n    const { gdpr, fiscal, access, overall } = report;\n    \n    let summary = `Compliance Report Summary:\\n`;\n    summary += `Overall Score: ${overall.complianceScore}%\\n`;\n    summary += `Critical Issues: ${overall.criticalIssues}\\n\\n`;\n    \n    summary += `GDPR: ${gdpr.violations.length} violations\\n`;\n    summary += `Fiscal: ${fiscal.overall} status\\n`;\n    summary += `Access: ${access.audit.failedAttempts} failed attempts\\n\\n`;\n    \n    if (overall.recommendations.length > 0) {\n      summary += `Recommendations:\\n`;\n      overall.recommendations.forEach((rec: string, i: number) => {\n        summary += `${i + 1}. ${rec}\\n`;\n      });\n    }\n    \n    return summary;\n  },\n};","/**\n * Plugin Manager - Core plugin system for A-Cube SDK\n * Provides extensible architecture with lifecycle hooks and middleware\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport type { ACubeSDK } from '@/core/sdk';\nimport type { RequestOptions, HttpResponse } from '@/http/client';\n\nexport interface PluginManifest {\n  name: string;\n  version: string;\n  description?: string;\n  author?: string;\n  dependencies?: string[];\n  peerDependencies?: string[];\n  sdkVersion?: string;\n  permissions?: PluginPermission[];\n}\n\nexport type PluginPermission = \n  | 'http:read' \n  | 'http:write' \n  | 'storage:read' \n  | 'storage:write' \n  | 'events:emit' \n  | 'events:listen' \n  | 'cache:read' \n  | 'cache:write'\n  | 'config:read'\n  | 'config:write';\n\nexport interface PluginContext {\n  sdk: ACubeSDK;\n  logger: PluginLogger;\n  storage: PluginStorage;\n  events: PluginEventEmitter;\n  config: PluginConfig;\n  cache: PluginCache;\n  http: PluginHttpClient;\n}\n\nexport interface PluginLogger {\n  debug(message: string, meta?: any): void;\n  info(message: string, meta?: any): void;\n  warn(message: string, meta?: any): void;\n  error(message: string, meta?: any): void;\n}\n\nexport interface PluginStorage {\n  get<T>(key: string): T | undefined;\n  set<T>(key: string, value: T): void;\n  delete(key: string): void;\n  clear(): void;\n  keys(): string[];\n}\n\nexport interface PluginEventEmitter {\n  on(event: string, listener: (...args: any[]) => void): void;\n  off(event: string, listener: (...args: any[]) => void): void;\n  emit(event: string, ...args: any[]): boolean;\n}\n\nexport interface PluginConfig {\n  get<T>(key: string): T | undefined;\n  set<T>(key: string, value: T): void;\n  has(key: string): boolean;\n}\n\nexport interface PluginCache {\n  get<T>(key: string): T | undefined;\n  set<T>(key: string, value: T, ttl?: number): void;\n  delete(key: string): void;\n  clear(): void;\n}\n\nexport interface PluginHttpClient {\n  request<T>(options: RequestOptions): Promise<HttpResponse<T>>;\n  get<T>(url: string, options?: Partial<RequestOptions>): Promise<HttpResponse<T>>;\n  post<T>(url: string, data?: any, options?: Partial<RequestOptions>): Promise<HttpResponse<T>>;\n}\n\nexport interface PluginLifecycleHooks {\n  onInit?(context: PluginContext): Promise<void> | void;\n  onDestroy?(context: PluginContext): Promise<void> | void;\n  onConfigChange?(context: PluginContext, key: string, value: any): Promise<void> | void;\n  beforeRequest?(context: PluginContext, options: RequestOptions): Promise<RequestOptions> | RequestOptions;\n  afterResponse?(context: PluginContext, response: HttpResponse<any>): Promise<HttpResponse<any>> | HttpResponse<any>;\n  onError?(context: PluginContext, error: Error): Promise<Error | void> | Error | void;\n}\n\nexport interface Plugin extends PluginLifecycleHooks {\n  manifest: PluginManifest;\n}\n\nexport interface PluginRegistration {\n  plugin: Plugin;\n  context: PluginContext;\n  isActive: boolean;\n  loadedAt: Date;\n  errors: PluginError[];\n}\n\nexport interface PluginError {\n  message: string;\n  stack?: string;\n  timestamp: Date;\n  phase: 'load' | 'init' | 'runtime' | 'destroy';\n}\n\nexport class PluginManager extends EventEmitter {\n  private plugins = new Map<string, PluginRegistration>();\n  private middleware: PluginMiddleware[] = [];\n  private sdk: ACubeSDK;\n  private globalConfig = new Map<string, any>();\n  private globalCache = new Map<string, { value: any; expires?: number }>();\n\n  constructor(sdk: ACubeSDK) {\n    super();\n    this.sdk = sdk;\n  }\n\n  /**\n   * Register a plugin with the SDK\n   */\n  async register(plugin: Plugin): Promise<void> {\n    const { name, version } = plugin.manifest;\n    \n    // Validate plugin\n    this.validatePlugin(plugin);\n    \n    // Check if plugin already registered\n    if (this.plugins.has(name)) {\n      throw new PluginManagerError(`Plugin '${name}' is already registered`);\n    }\n\n    // Validate dependencies\n    await this.validateDependencies(plugin);\n\n    // Create plugin context\n    const context = this.createPluginContext(plugin);\n    \n    const registration: PluginRegistration = {\n      plugin,\n      context,\n      isActive: false,\n      loadedAt: new Date(),\n      errors: [],\n    };\n\n    try {\n      // Initialize plugin\n      if (plugin.onInit) {\n        await plugin.onInit(context);\n      }\n\n      registration.isActive = true;\n      this.plugins.set(name, registration);\n      \n      // Register middleware hooks\n      this.registerMiddleware(plugin, context);\n      \n      this.emit('plugin:registered', { name, version });\n      \n      console.info(`Plugin '${name}@${version}' registered successfully`);\n    } catch (error) {\n      const pluginError: PluginError = {\n        message: error instanceof Error ? error.message : String(error),\n        ...(error instanceof Error && error.stack && { stack: error.stack }),\n        timestamp: new Date(),\n        phase: 'init',\n      };\n      \n      registration.errors.push(pluginError);\n      this.plugins.set(name, registration);\n      \n      this.emit('plugin:error', { name, error: pluginError });\n      throw new PluginManagerError(`Failed to initialize plugin '${name}': ${pluginError.message}`);\n    }\n  }\n\n  /**\n   * Unregister a plugin\n   */\n  async unregister(name: string): Promise<void> {\n    const registration = this.plugins.get(name);\n    if (!registration) {\n      throw new PluginManagerError(`Plugin '${name}' is not registered`);\n    }\n\n    try {\n      // Call destroy hook\n      if (registration.plugin.onDestroy) {\n        await registration.plugin.onDestroy(registration.context);\n      }\n\n      // Remove middleware\n      this.middleware = this.middleware.filter(m => m.pluginName !== name);\n      \n      this.plugins.delete(name);\n      this.emit('plugin:unregistered', { name });\n      \n      console.info(`Plugin '${name}' unregistered successfully`);\n    } catch (error) {\n      const pluginError: PluginError = {\n        message: error instanceof Error ? error.message : String(error),\n        ...(error instanceof Error && error.stack && { stack: error.stack }),\n        timestamp: new Date(),\n        phase: 'destroy',\n      };\n      \n      registration.errors.push(pluginError);\n      this.emit('plugin:error', { name, error: pluginError });\n      throw new PluginManagerError(`Failed to destroy plugin '${name}': ${pluginError.message}`);\n    }\n  }\n\n  /**\n   * Get information about registered plugins\n   */\n  getRegisteredPlugins(): Array<{ name: string; version: string; isActive: boolean; loadedAt: Date; errors: PluginError[] }> {\n    return Array.from(this.plugins.values()).map(reg => ({\n      name: reg.plugin.manifest.name,\n      version: reg.plugin.manifest.version,\n      isActive: reg.isActive,\n      loadedAt: reg.loadedAt,\n      errors: reg.errors,\n    }));\n  }\n\n  /**\n   * Check if plugin is registered\n   */\n  isRegistered(name: string): boolean {\n    return this.plugins.has(name);\n  }\n\n  /**\n   * Get plugin by name\n   */\n  getPlugin(name: string): Plugin | undefined {\n    return this.plugins.get(name)?.plugin;\n  }\n\n  /**\n   * Execute middleware hooks\n   */\n  async executeBeforeRequestHooks(options: RequestOptions): Promise<RequestOptions> {\n    let modifiedOptions = options;\n    \n    for (const middleware of this.middleware) {\n      if (middleware.beforeRequest) {\n        try {\n          modifiedOptions = await middleware.beforeRequest(middleware.context, modifiedOptions) || modifiedOptions;\n        } catch (error) {\n          this.handleMiddlewareError(middleware.pluginName, 'beforeRequest', error);\n        }\n      }\n    }\n    \n    return modifiedOptions;\n  }\n\n  async executeAfterResponseHooks(response: HttpResponse<any>): Promise<HttpResponse<any>> {\n    let modifiedResponse = response;\n    \n    for (const middleware of this.middleware) {\n      if (middleware.afterResponse) {\n        try {\n          modifiedResponse = await middleware.afterResponse(middleware.context, modifiedResponse) || modifiedResponse;\n        } catch (error) {\n          this.handleMiddlewareError(middleware.pluginName, 'afterResponse', error);\n        }\n      }\n    }\n    \n    return modifiedResponse;\n  }\n\n  async executeErrorHooks(error: Error): Promise<Error> {\n    let modifiedError = error;\n    \n    for (const middleware of this.middleware) {\n      if (middleware.onError) {\n        try {\n          const result = await middleware.onError(middleware.context, modifiedError);\n          if (result instanceof Error) {\n            modifiedError = result;\n          }\n        } catch (hookError) {\n          this.handleMiddlewareError(middleware.pluginName, 'onError', hookError);\n        }\n      }\n    }\n    \n    return modifiedError;\n  }\n\n  /**\n   * Cleanup all plugins\n   */\n  async destroy(): Promise<void> {\n    const pluginNames = Array.from(this.plugins.keys());\n    \n    for (const name of pluginNames) {\n      try {\n        await this.unregister(name);\n      } catch (error) {\n        console.error(`Failed to unregister plugin '${name}' during cleanup:`, error);\n      }\n    }\n    \n    this.removeAllListeners();\n  }\n\n  private validatePlugin(plugin: Plugin): void {\n    const { name, version } = plugin.manifest;\n    \n    if (!name || typeof name !== 'string') {\n      throw new PluginManagerError('Plugin manifest must have a valid name');\n    }\n    \n    if (!version || typeof version !== 'string') {\n      throw new PluginManagerError('Plugin manifest must have a valid version');\n    }\n    \n    // Validate plugin name format\n    if (!/^[a-z0-9-_]+$/i.test(name)) {\n      throw new PluginManagerError('Plugin name can only contain letters, numbers, hyphens, and underscores');\n    }\n  }\n\n  private async validateDependencies(plugin: Plugin): Promise<void> {\n    const { dependencies = [], peerDependencies = [] } = plugin.manifest;\n    \n    // Check plugin dependencies\n    for (const dep of dependencies) {\n      if (!this.isRegistered(dep)) {\n        throw new PluginManagerError(`Plugin dependency '${dep}' is not registered`);\n      }\n    }\n    \n    // Peer dependencies are warnings only\n    for (const peerDep of peerDependencies) {\n      if (!this.isRegistered(peerDep)) {\n        console.warn(`Plugin peer dependency '${peerDep}' is not registered`);\n      }\n    }\n  }\n\n  private createPluginContext(plugin: Plugin): PluginContext {\n    const pluginName = plugin.manifest.name;\n    const permissions = plugin.manifest.permissions || [];\n    \n    return {\n      sdk: this.sdk,\n      logger: this.createPluginLogger(pluginName),\n      storage: this.createPluginStorage(pluginName, permissions),\n      events: this.createPluginEventEmitter(pluginName, permissions),\n      config: this.createPluginConfig(pluginName, permissions),\n      cache: this.createPluginCache(pluginName, permissions),\n      http: this.createPluginHttpClient(permissions),\n    };\n  }\n\n  private createPluginLogger(pluginName: string): PluginLogger {\n    return {\n      debug: (message, meta) => console.debug(`[${pluginName}] ${message}`, meta),\n      info: (message, meta) => console.info(`[${pluginName}] ${message}`, meta),\n      warn: (message, meta) => console.warn(`[${pluginName}] ${message}`, meta),\n      error: (message, meta) => console.error(`[${pluginName}] ${message}`, meta),\n    };\n  }\n\n  private createPluginStorage(pluginName: string, permissions: PluginPermission[]): PluginStorage {\n    const canRead = permissions.includes('storage:read');\n    const canWrite = permissions.includes('storage:write');\n    const storageKey = `plugin:${pluginName}`;\n    \n    return {\n      get: <T>(key: string): T | undefined => {\n        if (!canRead) throw new PluginManagerError('Plugin does not have storage:read permission');\n        const data = localStorage.getItem(`${storageKey}:${key}`);\n        return data ? JSON.parse(data) : undefined;\n      },\n      set: <T>(key: string, value: T): void => {\n        if (!canWrite) throw new PluginManagerError('Plugin does not have storage:write permission');\n        localStorage.setItem(`${storageKey}:${key}`, JSON.stringify(value));\n      },\n      delete: (key: string): void => {\n        if (!canWrite) throw new PluginManagerError('Plugin does not have storage:write permission');\n        localStorage.removeItem(`${storageKey}:${key}`);\n      },\n      clear: (): void => {\n        if (!canWrite) throw new PluginManagerError('Plugin does not have storage:write permission');\n        const keys = Object.keys(localStorage).filter(k => k.startsWith(`${storageKey}:`));\n        keys.forEach(k => localStorage.removeItem(k));\n      },\n      keys: (): string[] => {\n        if (!canRead) throw new PluginManagerError('Plugin does not have storage:read permission');\n        return Object.keys(localStorage)\n          .filter(k => k.startsWith(`${storageKey}:`))\n          .map(k => k.replace(`${storageKey}:`, ''));\n      },\n    };\n  }\n\n  private createPluginEventEmitter(pluginName: string, permissions: PluginPermission[]): PluginEventEmitter {\n    const canListen = permissions.includes('events:listen');\n    const canEmit = permissions.includes('events:emit');\n    \n    return {\n      on: (event: string, listener: (...args: any[]) => void): void => {\n        if (!canListen) throw new PluginManagerError('Plugin does not have events:listen permission');\n        this.on(`plugin:${pluginName}:${event}`, listener);\n      },\n      off: (event: string, listener: (...args: any[]) => void): void => {\n        if (!canListen) throw new PluginManagerError('Plugin does not have events:listen permission');\n        this.off(`plugin:${pluginName}:${event}`, listener);\n      },\n      emit: (event: string, ...args: any[]): boolean => {\n        if (!canEmit) throw new PluginManagerError('Plugin does not have events:emit permission');\n        return this.emit(`plugin:${pluginName}:${event}`, ...args);\n      },\n    };\n  }\n\n  private createPluginConfig(pluginName: string, permissions: PluginPermission[]): PluginConfig {\n    const canRead = permissions.includes('config:read');\n    const canWrite = permissions.includes('config:write');\n    \n    return {\n      get: <T>(key: string): T | undefined => {\n        if (!canRead) throw new PluginManagerError('Plugin does not have config:read permission');\n        return this.globalConfig.get(`${pluginName}:${key}`);\n      },\n      set: <T>(key: string, value: T): void => {\n        if (!canWrite) throw new PluginManagerError('Plugin does not have config:write permission');\n        this.globalConfig.set(`${pluginName}:${key}`, value);\n      },\n      has: (key: string): boolean => {\n        if (!canRead) throw new PluginManagerError('Plugin does not have config:read permission');\n        return this.globalConfig.has(`${pluginName}:${key}`);\n      },\n    };\n  }\n\n  private createPluginCache(pluginName: string, permissions: PluginPermission[]): PluginCache {\n    const canRead = permissions.includes('cache:read');\n    const canWrite = permissions.includes('cache:write');\n    \n    return {\n      get: <T>(key: string): T | undefined => {\n        if (!canRead) throw new PluginManagerError('Plugin does not have cache:read permission');\n        const entry = this.globalCache.get(`${pluginName}:${key}`);\n        if (!entry) return undefined;\n        if (entry.expires && Date.now() > entry.expires) {\n          this.globalCache.delete(`${pluginName}:${key}`);\n          return undefined;\n        }\n        return entry.value;\n      },\n      set: <T>(key: string, value: T, ttl?: number): void => {\n        if (!canWrite) throw new PluginManagerError('Plugin does not have cache:write permission');\n        const expires = ttl ? Date.now() + ttl : undefined;\n        this.globalCache.set(`${pluginName}:${key}`, { value, ...(expires && { expires }) });\n      },\n      delete: (key: string): void => {\n        if (!canWrite) throw new PluginManagerError('Plugin does not have cache:write permission');\n        this.globalCache.delete(`${pluginName}:${key}`);\n      },\n      clear: (): void => {\n        if (!canWrite) throw new PluginManagerError('Plugin does not have cache:write permission');\n        const keys = Array.from(this.globalCache.keys()).filter(k => k.startsWith(`${pluginName}:`));\n        keys.forEach(k => this.globalCache.delete(k));\n      },\n    };\n  }\n\n  private createPluginHttpClient(permissions: PluginPermission[]): PluginHttpClient {\n    const canRead = permissions.includes('http:read');\n    const canWrite = permissions.includes('http:write');\n    \n    const httpClient = this.sdk.getClients().api;\n    \n    return {\n      request: async <T>(options: RequestOptions): Promise<HttpResponse<T>> => {\n        const isReadOperation = options.method === 'GET';\n        const isWriteOperation = ['POST', 'PUT', 'PATCH', 'DELETE'].includes(options.method);\n        \n        if (isReadOperation && !canRead) {\n          throw new PluginManagerError('Plugin does not have http:read permission');\n        }\n        if (isWriteOperation && !canWrite) {\n          throw new PluginManagerError('Plugin does not have http:write permission');\n        }\n        \n        return httpClient.request<T>(options);\n      },\n      get: async <T>(url: string, options?: Partial<RequestOptions>): Promise<HttpResponse<T>> => {\n        if (!canRead) throw new PluginManagerError('Plugin does not have http:read permission');\n        return httpClient.get<T>(url, options);\n      },\n      post: async <T>(url: string, data?: any, options?: Partial<RequestOptions>): Promise<HttpResponse<T>> => {\n        if (!canWrite) throw new PluginManagerError('Plugin does not have http:write permission');\n        return httpClient.post<T>(url, data, options);\n      },\n    };\n  }\n\n  private registerMiddleware(plugin: Plugin, context: PluginContext): void {\n    const middleware: PluginMiddleware = {\n      pluginName: plugin.manifest.name,\n      context,\n      ...(plugin.beforeRequest && { beforeRequest: plugin.beforeRequest }),\n      ...(plugin.afterResponse && { afterResponse: plugin.afterResponse }),\n      ...(plugin.onError && { onError: plugin.onError }),\n    };\n    \n    this.middleware.push(middleware);\n  }\n\n  private handleMiddlewareError(pluginName: string, phase: string, error: unknown): void {\n    const registration = this.plugins.get(pluginName);\n    if (registration) {\n      const pluginError: PluginError = {\n        message: error instanceof Error ? error.message : String(error),\n        ...(error instanceof Error && error.stack && { stack: error.stack }),\n        timestamp: new Date(),\n        phase: 'runtime',\n      };\n      \n      registration.errors.push(pluginError);\n      this.emit('plugin:error', { name: pluginName, error: pluginError });\n    }\n    \n    console.error(`Plugin '${pluginName}' error in ${phase}:`, error);\n  }\n}\n\ninterface PluginMiddleware {\n  pluginName: string;\n  context: PluginContext;\n  beforeRequest?: (context: PluginContext, options: RequestOptions) => Promise<RequestOptions> | RequestOptions;\n  afterResponse?: (context: PluginContext, response: HttpResponse<any>) => Promise<HttpResponse<any>> | HttpResponse<any>;\n  onError?: (context: PluginContext, error: Error) => Promise<Error | void> | Error | void;\n}\n\nexport class PluginManagerError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginManagerError';\n  }\n}","/**\n * Base Plugin Class - Abstract base for all A-Cube SDK plugins\n * Provides common functionality and type-safe implementation\n */\n\nimport type { \n  Plugin, \n  PluginManifest, \n  PluginContext, \n  PluginPermission,\n  PluginLifecycleHooks \n} from './plugin-manager';\nimport type { RequestOptions, HttpResponse } from '@/http/client';\n\nexport abstract class BasePlugin implements Plugin {\n  abstract readonly manifest: PluginManifest;\n  \n  protected context?: PluginContext;\n\n  /**\n   * Initialize the plugin with context\n   */\n  async onInit(context: PluginContext): Promise<void> {\n    this.context = context;\n    this.log('info', 'Plugin initialized');\n    await this.initialize(context);\n  }\n\n  /**\n   * Cleanup plugin resources\n   */\n  async onDestroy(context: PluginContext): Promise<void> {\n    this.log('info', 'Plugin destroying');\n    await this.cleanup(context);\n    delete this.context;\n  }\n\n  /**\n   * Handle configuration changes\n   */\n  async onConfigChange(context: PluginContext, key: string, value: any): Promise<void> {\n    this.log('debug', `Config changed: ${key}`, { value });\n    await this.handleConfigChange(context, key, value);\n  }\n\n  /**\n   * Process requests before they are sent\n   */\n  async beforeRequest(context: PluginContext, options: RequestOptions): Promise<RequestOptions> {\n    this.log('debug', `Processing request: ${options.method} ${options.url}`);\n    return await this.processRequest(context, options) || options;\n  }\n\n  /**\n   * Process responses after they are received\n   */\n  async afterResponse(context: PluginContext, response: HttpResponse<any>): Promise<HttpResponse<any>> {\n    this.log('debug', `Processing response: ${response.status}`);\n    return await this.processResponse(context, response) || response;\n  }\n\n  /**\n   * Handle errors\n   */\n  async onError(context: PluginContext, error: Error): Promise<Error | void> {\n    this.log('error', 'Handling error', { error: error.message });\n    return await this.handleError(context, error) || error;\n  }\n\n  // Abstract methods for subclasses to implement\n\n  /**\n   * Plugin-specific initialization logic\n   */\n  protected abstract initialize(context: PluginContext): Promise<void>;\n\n  /**\n   * Plugin-specific cleanup logic\n   */\n  protected abstract cleanup(context: PluginContext): Promise<void>;\n\n  // Optional hooks for subclasses to override\n\n  /**\n   * Handle configuration changes (optional)\n   */\n  protected async handleConfigChange(_context: PluginContext, _key: string, _value: any): Promise<void> {\n    // Default implementation - do nothing\n  }\n\n  /**\n   * Process outgoing requests (optional)\n   */\n  protected async processRequest(_context: PluginContext, options: RequestOptions): Promise<RequestOptions | void> {\n    // Default implementation - do nothing\n    return options;\n  }\n\n  /**\n   * Process incoming responses (optional)\n   */\n  protected async processResponse(_context: PluginContext, response: HttpResponse<any>): Promise<HttpResponse<any> | void> {\n    // Default implementation - do nothing\n    return response;\n  }\n\n  /**\n   * Handle errors (optional)\n   */\n  protected async handleError(_context: PluginContext, error: Error): Promise<Error | void> {\n    // Default implementation - do nothing\n    return error;\n  }\n\n  // Utility methods\n\n  /**\n   * Ensure plugin has required permissions\n   */\n  protected requirePermissions(...permissions: PluginPermission[]): void {\n    const pluginPermissions = this.manifest.permissions || [];\n    \n    for (const permission of permissions) {\n      if (!pluginPermissions.includes(permission)) {\n        throw new Error(`Plugin '${this.manifest.name}' requires permission: ${permission}`);\n      }\n    }\n  }\n\n  /**\n   * Check if plugin has permission\n   */\n  protected hasPermission(permission: PluginPermission): boolean {\n    return (this.manifest.permissions || []).includes(permission);\n  }\n\n  /**\n   * Log messages with plugin context\n   */\n  protected log(level: 'debug' | 'info' | 'warn' | 'error', message: string, meta?: any): void {\n    if (this.context) {\n      this.context.logger[level](message, meta);\n    } else {\n      console[level](`[${this.manifest.name}] ${message}`, meta);\n    }\n  }\n\n  /**\n   * Get configuration value\n   */\n  protected getConfig<T>(key: string): T | undefined {\n    this.requirePermissions('config:read');\n    return this.context?.config.get<T>(key);\n  }\n\n  /**\n   * Set configuration value\n   */\n  protected setConfig<T>(key: string, value: T): void {\n    this.requirePermissions('config:write');\n    this.context?.config.set(key, value);\n  }\n\n  /**\n   * Get from cache\n   */\n  protected getFromCache<T>(key: string): T | undefined {\n    this.requirePermissions('cache:read');\n    return this.context?.cache.get<T>(key);\n  }\n\n  /**\n   * Set in cache\n   */\n  protected setInCache<T>(key: string, value: T, ttl?: number): void {\n    this.requirePermissions('cache:write');\n    this.context?.cache.set(key, value, ttl);\n  }\n\n  /**\n   * Get from storage\n   */\n  protected getFromStorage<T>(key: string): T | undefined {\n    this.requirePermissions('storage:read');\n    return this.context?.storage.get<T>(key);\n  }\n\n  /**\n   * Set in storage\n   */\n  protected setInStorage<T>(key: string, value: T): void {\n    this.requirePermissions('storage:write');\n    this.context?.storage.set(key, value);\n  }\n\n  /**\n   * Emit event\n   */\n  protected emitEvent(event: string, ...args: any[]): boolean {\n    this.requirePermissions('events:emit');\n    return this.context?.events.emit(event, ...args) || false;\n  }\n\n  /**\n   * Listen to event\n   */\n  protected onEvent(event: string, listener: (...args: any[]) => void): void {\n    this.requirePermissions('events:listen');\n    this.context?.events.on(event, listener);\n  }\n\n  /**\n   * Make HTTP request\n   */\n  protected async makeRequest<T>(options: RequestOptions): Promise<HttpResponse<T>> {\n    const isReadOperation = options.method === 'GET';\n    this.requirePermissions(isReadOperation ? 'http:read' : 'http:write');\n    \n    if (!this.context) {\n      throw new Error('Plugin context not available');\n    }\n    \n    return this.context.http.request<T>(options);\n  }\n\n  /**\n   * Get SDK instance\n   */\n  protected get sdk() {\n    if (!this.context) {\n      throw new Error('Plugin context not available');\n    }\n    return this.context.sdk;\n  }\n\n  /**\n   * Validate plugin manifest\n   */\n  public static validateManifest(manifest: PluginManifest): void {\n    if (!manifest.name || typeof manifest.name !== 'string') {\n      throw new Error('Plugin manifest must have a valid name');\n    }\n    \n    if (!manifest.version || typeof manifest.version !== 'string') {\n      throw new Error('Plugin manifest must have a valid version');\n    }\n    \n    // Validate semantic version format\n    const semverRegex = /^(\\d+)\\.(\\d+)\\.(\\d+)(?:-([0-9A-Za-z-]+(?:\\.[0-9A-Za-z-]+)*))?(?:\\+([0-9A-Za-z-]+(?:\\.[0-9A-Za-z-]+)*))?$/;\n    if (!semverRegex.test(manifest.version)) {\n      throw new Error('Plugin version must follow semantic versioning (e.g., 1.0.0)');\n    }\n    \n    // Validate permissions if provided\n    if (manifest.permissions) {\n      const validPermissions: PluginPermission[] = [\n        'http:read', 'http:write', 'storage:read', 'storage:write',\n        'events:emit', 'events:listen', 'cache:read', 'cache:write',\n        'config:read', 'config:write'\n      ];\n      \n      for (const permission of manifest.permissions) {\n        if (!validPermissions.includes(permission)) {\n          throw new Error(`Invalid permission: ${permission}`);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Plugin Builder - Utility class for creating plugins programmatically\n */\nexport class PluginBuilder {\n  private manifest: Partial<PluginManifest> = {};\n  private hooks: Partial<PluginLifecycleHooks> = {};\n\n  static create(name: string, version: string): PluginBuilder {\n    return new PluginBuilder().name(name).version(version);\n  }\n\n  name(name: string): this {\n    this.manifest.name = name;\n    return this;\n  }\n\n  version(version: string): this {\n    this.manifest.version = version;\n    return this;\n  }\n\n  description(description: string): this {\n    this.manifest.description = description;\n    return this;\n  }\n\n  author(author: string): this {\n    this.manifest.author = author;\n    return this;\n  }\n\n  permissions(...permissions: PluginPermission[]): this {\n    this.manifest.permissions = permissions;\n    return this;\n  }\n\n  dependencies(...dependencies: string[]): this {\n    this.manifest.dependencies = dependencies;\n    return this;\n  }\n\n  onInit(handler: (context: PluginContext) => Promise<void> | void): this {\n    this.hooks.onInit = handler;\n    return this;\n  }\n\n  onDestroy(handler: (context: PluginContext) => Promise<void> | void): this {\n    this.hooks.onDestroy = handler;\n    return this;\n  }\n\n  beforeRequest(handler: (context: PluginContext, options: RequestOptions) => Promise<RequestOptions> | RequestOptions): this {\n    this.hooks.beforeRequest = handler;\n    return this;\n  }\n\n  afterResponse(handler: (context: PluginContext, response: HttpResponse<any>) => Promise<HttpResponse<any>> | HttpResponse<any>): this {\n    this.hooks.afterResponse = handler;\n    return this;\n  }\n\n  onError(handler: (context: PluginContext, error: Error) => Promise<Error | void> | Error | void): this {\n    this.hooks.onError = handler;\n    return this;\n  }\n\n  build(): Plugin {\n    if (!this.manifest.name || !this.manifest.version) {\n      throw new Error('Plugin name and version are required');\n    }\n\n    const manifest = this.manifest as PluginManifest;\n    BasePlugin.validateManifest(manifest);\n\n    return {\n      manifest,\n      ...this.hooks,\n    };\n  }\n}","/**\n * Plugin Core System\n * Complete plugin architecture for A-Cube SDK\n */\n\nexport { \n  PluginManager, \n  PluginManagerError,\n  type Plugin,\n  type PluginManifest,\n  type PluginContext,\n  type PluginPermission,\n  type PluginLifecycleHooks,\n  type PluginRegistration,\n  type PluginError,\n  type PluginLogger,\n  type PluginStorage,\n  type PluginEventEmitter,\n  type PluginConfig,\n  type PluginCache,\n  type PluginHttpClient,\n} from './plugin-manager';\n\nexport { \n  BasePlugin, \n  PluginBuilder \n} from './base-plugin';","/**\n * Analytics Plugin - Track API usage, performance metrics, and user behavior\n * Provides comprehensive analytics for A-Cube SDK usage\n */\n\nimport { BasePlugin } from '../core/base-plugin';\nimport type { PluginContext, PluginManifest } from '../core/plugin-manager';\nimport type { RequestOptions, HttpResponse } from '@/http/client';\n\nexport interface AnalyticsEvent {\n  event: string;\n  timestamp: number;\n  properties: Record<string, any>;\n  userId?: string;\n  sessionId: string;\n}\n\nexport interface PerformanceMetric {\n  operation: string;\n  duration: number;\n  timestamp: number;\n  success: boolean;\n  errorCode?: string;\n  metadata?: Record<string, any>;\n}\n\nexport interface UsageStats {\n  totalRequests: number;\n  successfulRequests: number;\n  failedRequests: number;\n  averageResponseTime: number;\n  topEndpoints: Array<{ endpoint: string; count: number }>;\n  errorDistribution: Record<string, number>;\n  timeRange: { start: number; end: number };\n}\n\nexport class AnalyticsPlugin extends BasePlugin {\n  readonly manifest: PluginManifest = {\n    name: 'analytics',\n    version: '1.0.0',\n    description: 'Track API usage, performance metrics, and user behavior',\n    author: 'A-Cube Team',\n    permissions: [\n      'http:read',\n      'storage:read',\n      'storage:write',\n      'cache:read',\n      'cache:write',\n      'events:emit',\n      'config:read',\n      'config:write',\n    ],\n  };\n\n  private sessionId: string = '';\n  private requestMetrics: Map<string, { startTime: number; options: RequestOptions }> = new Map();\n  private eventQueue: AnalyticsEvent[] = [];\n  private performanceMetrics: PerformanceMetric[] = [];\n  private flushInterval?: NodeJS.Timeout;\n\n  protected async initialize(context: PluginContext): Promise<void> {\n    // Generate session ID\n    this.sessionId = this.generateSessionId();\n    \n    // Load configuration\n    const config = this.getConfig<{\n      enabled: boolean;\n      batchSize: number;\n      flushInterval: number;\n      endpoint?: string;\n      trackUserActions: boolean;\n      trackPerformance: boolean;\n    }>('settings') || {\n      enabled: true,\n      batchSize: 50,\n      flushInterval: 30000, // 30 seconds\n      trackUserActions: true,\n      trackPerformance: true,\n    };\n\n    if (!config.enabled) {\n      this.log('info', 'Analytics disabled by configuration');\n      return;\n    }\n\n    // Set up periodic flush\n    this.flushInterval = setInterval(() => {\n      this.flushEvents();\n    }, config.flushInterval) as unknown as NodeJS.Timeout;\n\n    // Track session start\n    this.trackEvent('session_start', {\n      sdk_version: '2.0.0',\n      environment: context.sdk.getConfig().environment,\n      timestamp: Date.now(),\n    });\n\n    this.log('info', 'Analytics plugin initialized', { sessionId: this.sessionId });\n  }\n\n  protected async cleanup(_context: PluginContext): Promise<void> {\n    // Flush remaining events\n    await this.flushEvents();\n    \n    // Clear interval\n    if (this.flushInterval) {\n      clearInterval(this.flushInterval);\n    }\n\n    // Track session end\n    const sessionParts = this.sessionId.split('_');\n    const sessionStart = sessionParts[1] ? parseInt(sessionParts[1]) : Date.now();\n    this.trackEvent('session_end', {\n      duration: Date.now() - sessionStart,\n      total_requests: this.performanceMetrics.length,\n    });\n\n    // Final flush\n    await this.flushEvents();\n\n    this.log('info', 'Analytics plugin cleaned up');\n  }\n\n  protected override async processRequest(_context: PluginContext, options: RequestOptions): Promise<RequestOptions> {\n    const config = this.getConfig<{ trackPerformance: boolean }>('settings');\n    if (!config?.trackPerformance) return options;\n\n    // Generate request ID for tracking\n    const requestId = `req_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n    \n    // Store request start time\n    this.requestMetrics.set(requestId, {\n      startTime: Date.now(),\n      options: { ...options },\n    });\n\n    // Add request ID to metadata for correlation\n    options.metadata = {\n      ...options.metadata,\n      analyticsRequestId: requestId,\n    };\n\n    // Track API call event\n    this.trackEvent('api_call_start', {\n      method: options.method,\n      url: this.sanitizeUrl(options.url),\n      request_id: requestId,\n    });\n\n    return options;\n  }\n\n  protected override async processResponse(_context: PluginContext, response: HttpResponse<any>): Promise<HttpResponse<any>> {\n    const config = this.getConfig<{ trackPerformance: boolean }>('settings');\n    if (!config?.trackPerformance) return response;\n\n    const requestId = response.requestId;\n    const requestData = this.requestMetrics.get(requestId);\n\n    if (requestData) {\n      const duration = response.duration;\n      const success = response.status >= 200 && response.status < 400;\n\n      // Record performance metric\n      const metric: PerformanceMetric = {\n        operation: `${requestData.options.method} ${this.sanitizeUrl(requestData.options.url)}`,\n        duration,\n        timestamp: Date.now(),\n        success,\n        metadata: {\n          status: response.status,\n          method: requestData.options.method,\n        },\n      };\n\n      this.performanceMetrics.push(metric);\n      this.requestMetrics.delete(requestId);\n\n      // Track API call completion\n      this.trackEvent('api_call_complete', {\n        method: requestData.options.method,\n        url: this.sanitizeUrl(requestData.options.url),\n        status: response.status,\n        duration,\n        success,\n        request_id: requestId,\n      });\n\n      // Store metrics in cache for quick access\n      this.updateCachedStats(metric);\n    }\n\n    return response;\n  }\n\n  protected override async handleError(_context: PluginContext, error: Error): Promise<Error> {\n    // Track error event\n    this.trackEvent('api_error', {\n      error_type: error.constructor.name,\n      error_message: error.message,\n      timestamp: Date.now(),\n    });\n\n    return error;\n  }\n\n  /**\n   * Track custom event\n   */\n  public trackEvent(event: string, properties: Record<string, any> = {}, userId?: string): void {\n    const analyticsEvent: AnalyticsEvent = {\n      event,\n      timestamp: Date.now(),\n      properties,\n      ...(userId && { userId }),\n      sessionId: this.sessionId,\n    };\n\n    this.eventQueue.push(analyticsEvent);\n\n    // Auto-flush if queue is full\n    const config = this.getConfig<{ batchSize: number }>('settings');\n    if (this.eventQueue.length >= (config?.batchSize || 50)) {\n      this.flushEvents();\n    }\n\n    this.log('debug', `Tracked event: ${event}`, properties);\n  }\n\n  /**\n   * Get usage statistics\n   */\n  public getUsageStats(timeRangeMs: number = 3600000): UsageStats {\n    const now = Date.now();\n    const startTime = now - timeRangeMs;\n    \n    const relevantMetrics = this.performanceMetrics.filter(\n      m => m.timestamp >= startTime\n    );\n\n    const totalRequests = relevantMetrics.length;\n    const successfulRequests = relevantMetrics.filter(m => m.success).length;\n    const failedRequests = totalRequests - successfulRequests;\n\n    const averageResponseTime = totalRequests > 0\n      ? relevantMetrics.reduce((sum, m) => sum + m.duration, 0) / totalRequests\n      : 0;\n\n    // Count endpoints\n    const endpointCounts = relevantMetrics.reduce((acc, m) => {\n      const endpoint = m.operation;\n      acc[endpoint] = (acc[endpoint] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const topEndpoints = Object.entries(endpointCounts)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 10)\n      .map(([endpoint, count]) => ({ endpoint, count }));\n\n    // Error distribution\n    const errorDistribution = relevantMetrics\n      .filter(m => !m.success)\n      .reduce((acc, m) => {\n        const errorCode = m.errorCode || 'unknown';\n        acc[errorCode] = (acc[errorCode] || 0) + 1;\n        return acc;\n      }, {} as Record<string, number>);\n\n    return {\n      totalRequests,\n      successfulRequests,\n      failedRequests,\n      averageResponseTime,\n      topEndpoints,\n      errorDistribution,\n      timeRange: { start: startTime, end: now },\n    };\n  }\n\n  /**\n   * Get performance metrics\n   */\n  public getPerformanceMetrics(limit: number = 100): PerformanceMetric[] {\n    return this.performanceMetrics\n      .slice(-limit)\n      .sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  /**\n   * Clear all stored data\n   */\n  public clearData(): void {\n    this.eventQueue = [];\n    this.performanceMetrics = [];\n    this.requestMetrics.clear();\n    \n    // Clear storage\n    const keys = this.context?.storage.keys() || [];\n    keys.forEach(key => {\n      if (key.startsWith('analytics_')) {\n        this.context?.storage.delete(key);\n      }\n    });\n\n    this.log('info', 'Analytics data cleared');\n  }\n\n  private async flushEvents(): Promise<void> {\n    if (this.eventQueue.length === 0) return;\n\n    const events = [...this.eventQueue];\n    this.eventQueue = [];\n\n    try {\n      // Store events locally\n      const storageKey = `analytics_events_${Date.now()}`;\n      this.setInStorage(storageKey, events);\n\n      // Emit event for external analytics providers\n      this.emitEvent('analytics_batch', { events, sessionId: this.sessionId });\n\n      // Optionally send to external endpoint\n      const config = this.getConfig<{ endpoint?: string }>('settings');\n      if (config?.endpoint) {\n        try {\n          await this.makeRequest({\n            method: 'POST',\n            url: config.endpoint,\n            data: { events, sessionId: this.sessionId },\n          });\n        } catch (error) {\n          this.log('warn', 'Failed to send analytics to external endpoint', { error });\n          // Re-queue events on failure\n          this.eventQueue.unshift(...events);\n        }\n      }\n\n      this.log('debug', `Flushed ${events.length} analytics events`);\n    } catch (error) {\n      this.log('error', 'Failed to flush analytics events', { error });\n      // Re-queue events on failure\n      this.eventQueue.unshift(...events);\n    }\n  }\n\n  private updateCachedStats(metric: PerformanceMetric): void {\n    try {\n      const cached = this.getFromCache<UsageStats>('usage_stats') || {\n        totalRequests: 0,\n        successfulRequests: 0,\n        failedRequests: 0,\n        averageResponseTime: 0,\n        topEndpoints: [],\n        errorDistribution: {},\n        timeRange: { start: Date.now(), end: Date.now() },\n      };\n\n      cached.totalRequests++;\n      if (metric.success) {\n        cached.successfulRequests++;\n      } else {\n        cached.failedRequests++;\n      }\n\n      // Update average response time\n      cached.averageResponseTime = (\n        (cached.averageResponseTime * (cached.totalRequests - 1) + metric.duration) /\n        cached.totalRequests\n      );\n\n      cached.timeRange.end = Date.now();\n\n      this.setInCache('usage_stats', cached, 300000); // Cache for 5 minutes\n    } catch (error) {\n      this.log('warn', 'Failed to update cached stats', { error });\n    }\n  }\n\n  private generateSessionId(): string {\n    return `session_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private sanitizeUrl(url: string): string {\n    // Remove sensitive parameters from URL for analytics\n    try {\n      const urlObj = new URL(url, 'https://example.com');\n      urlObj.searchParams.delete('api_key');\n      urlObj.searchParams.delete('token');\n      urlObj.searchParams.delete('authorization');\n      return urlObj.pathname + (urlObj.search || '');\n    } catch {\n      return url;\n    }\n  }\n}","/**\n * Audit Plugin - Comprehensive audit logging and compliance for A-Cube SDK\n * Provides detailed audit trails, compliance reporting, and security monitoring\n */\n\nimport { BasePlugin } from '../core/base-plugin';\nimport type { PluginContext, PluginManifest } from '../core/plugin-manager';\nimport type { RequestOptions, HttpResponse } from '@/http/client';\n\nexport interface AuditEvent {\n  id: string;\n  timestamp: number;\n  type: 'request' | 'response' | 'auth' | 'config' | 'error' | 'security' | 'data';\n  action: string;\n  actor: {\n    userId?: string;\n    sessionId: string;\n    ipAddress?: string;\n    userAgent?: string;\n  };\n  resource: {\n    type: string;\n    id?: string;\n    path?: string;\n  };\n  outcome: 'success' | 'failure' | 'warning';\n  details: Record<string, any>;\n  risk: 'low' | 'medium' | 'high' | 'critical';\n  compliance: {\n    gdpr: boolean;\n    fiscal: boolean;\n    internal: boolean;\n  };\n  retention: number; // Days to retain\n}\n\nexport interface ComplianceReport {\n  period: { start: number; end: number };\n  events: {\n    total: number;\n    byType: Record<string, number>;\n    byRisk: Record<string, number>;\n    byOutcome: Record<string, number>;\n  };\n  compliance: {\n    gdpr: {\n      dataAccess: number;\n      dataModification: number;\n      dataExport: number;\n      dataDelete: number;\n    };\n    fiscal: {\n      receiptCreation: number;\n      receiptVoid: number;\n      receiptModification: number;\n      fiscalReports: number;\n    };\n    security: {\n      authFailures: number;\n      suspiciousActivity: number;\n      privilegeEscalation: number;\n      dataLeaks: number;\n    };\n  };\n  violations: AuditEvent[];\n  recommendations: string[];\n}\n\nexport interface AuditFilter {\n  type?: AuditEvent['type'][];\n  action?: string[];\n  outcome?: AuditEvent['outcome'][];\n  risk?: AuditEvent['risk'][];\n  timeRange?: { start: number; end: number };\n  userId?: string;\n  resource?: string;\n  compliance?: ('gdpr' | 'fiscal' | 'internal')[];\n}\n\nexport class AuditPlugin extends BasePlugin {\n  readonly manifest: PluginManifest = {\n    name: 'audit',\n    version: '1.0.0',\n    description: 'Comprehensive audit logging and compliance for A-Cube SDK',\n    author: 'A-Cube Team',\n    permissions: [\n      'http:read',\n      'storage:read',\n      'storage:write',\n      'cache:read',\n      'cache:write',\n      'events:emit',\n      'config:read',\n      'config:write',\n    ],\n  };\n\n  private events: AuditEvent[] = [];\n  private sessionId: string = '';\n  private currentUser?: { id: string; role: string };\n  private suspiciousActivity = new Map<string, number>();\n  private isEnabled: boolean = true;\n  private maxEvents: number = 10000;\n  private retentionPeriods = {\n    low: 30,      // 30 days\n    medium: 90,   // 90 days\n    high: 365,    // 1 year\n    critical: 2555, // 7 years (Italian fiscal requirement)\n  };\n\n  protected async initialize(_context: PluginContext): Promise<void> {\n    // Load configuration\n    const config = this.getConfig<{\n      enabled: boolean;\n      maxEvents: number;\n      retentionPeriods: Record<string, number>;\n      complianceMode: 'strict' | 'standard' | 'minimal';\n      realTimeAlerts: boolean;\n      dataPrivacy: boolean;\n    }>('settings') || {\n      enabled: true,\n      maxEvents: 10000,\n      retentionPeriods: this.retentionPeriods,\n      complianceMode: 'standard',\n      realTimeAlerts: true,\n      dataPrivacy: true,\n    };\n\n    this.isEnabled = config.enabled;\n    this.maxEvents = config.maxEvents;\n    this.retentionPeriods = { ...this.retentionPeriods, ...config.retentionPeriods };\n\n    if (!this.isEnabled) {\n      this.log('info', 'Audit plugin disabled by configuration');\n      return;\n    }\n\n    // Generate session ID\n    this.sessionId = this.generateSessionId();\n\n    // Load persisted events\n    await this.loadPersistedEvents();\n\n    // Set up periodic cleanup\n    setInterval(() => {\n      this.cleanupExpiredEvents();\n    }, 3600000); // Every hour\n\n    // Set up real-time monitoring\n    if (config.realTimeAlerts) {\n      this.setupRealTimeMonitoring();\n    }\n\n    // Track plugin initialization\n    this.recordAuditEvent({\n      type: 'config',\n      action: 'audit_plugin_initialized',\n      resource: { type: 'plugin', id: 'audit' },\n      outcome: 'success',\n      details: {\n        config: {\n          maxEvents: this.maxEvents,\n          complianceMode: config.complianceMode,\n          realTimeAlerts: config.realTimeAlerts,\n        },\n      },\n      risk: 'low',\n      compliance: { gdpr: false, fiscal: false, internal: true },\n    });\n\n    this.log('info', 'Audit plugin initialized', { \n      sessionId: this.sessionId,\n      maxEvents: this.maxEvents,\n      complianceMode: config.complianceMode,\n    });\n  }\n\n  protected async cleanup(_context: PluginContext): Promise<void> {\n    // Persist events\n    await this.persistEvents();\n\n    // Generate final compliance report\n    const report = this.generateComplianceReport(86400000); // Last 24 hours\n    this.emitEvent('compliance_report', report);\n\n    // Track plugin shutdown\n    this.recordAuditEvent({\n      type: 'config',\n      action: 'audit_plugin_shutdown',\n      resource: { type: 'plugin', id: 'audit' },\n      outcome: 'success',\n      details: {\n        totalEvents: this.events.length,\n        sessionDuration: Date.now() - (parseInt(this.sessionId.split('_')[1] || '0') || Date.now()),\n      },\n      risk: 'low',\n      compliance: { gdpr: false, fiscal: false, internal: true },\n    });\n\n    this.log('info', 'Audit plugin cleaned up');\n  }\n\n  protected override async processRequest(_context: PluginContext, options: RequestOptions): Promise<RequestOptions> {\n    if (!this.isEnabled) return options;\n\n    // Extract user context\n    const authorization = options.headers?.['Authorization'] || options.headers?.['authorization'];\n    const userId = this.extractUserIdFromAuth(authorization);\n\n    // Record request audit event\n    this.recordAuditEvent({\n      type: 'request',\n      action: `${options.method.toLowerCase()}_request`,\n      resource: {\n        type: 'api_endpoint',\n        path: this.sanitizePath(options.url),\n      },\n      outcome: 'success', // Will be updated in response handler\n      details: {\n        method: options.method,\n        url: this.sanitizeUrl(options.url),\n        headers: this.sanitizeHeaders(options.headers),\n        bodySize: options.data ? this.calculateSize(options.data) : 0,\n        userAgent: options.headers?.['User-Agent'],\n      },\n      risk: this.assessRequestRisk(options),\n      compliance: this.assessRequestCompliance(options),\n    }, userId);\n\n    // Add audit correlation ID\n    options.headers = {\n      ...options.headers,\n      'X-Audit-Correlation-ID': this.generateCorrelationId(),\n    };\n\n    return options;\n  }\n\n  protected override async processResponse(_context: PluginContext, response: HttpResponse<any>): Promise<HttpResponse<any>> {\n    if (!this.isEnabled) return response;\n\n    const correlationId = response.headers?.['x-audit-correlation-id'];\n    // Defensive typing for config property that may exist on extended response objects\n    const responseConfig = (response as any).config;\n    const userId = this.extractUserIdFromAuth(responseConfig?.headers?.['Authorization']);\n\n    // Record response audit event\n    this.recordAuditEvent({\n      type: 'response',\n      action: `${responseConfig?.method?.toLowerCase() || 'unknown'}_response`,\n      resource: {\n        type: 'api_endpoint',\n        path: this.sanitizePath(responseConfig?.url || ''),\n      },\n      outcome: response.status >= 200 && response.status < 400 ? 'success' : 'failure',\n      details: {\n        status: response.status,\n        statusText: response.statusText,\n        duration: response.duration,\n        responseSize: this.calculateSize(response.data),\n        fromCache: 'fromCache' in response ? (response as any).fromCache : false,\n        correlationId,\n      },\n      risk: this.assessResponseRisk(response),\n      compliance: this.assessResponseCompliance(response),\n    }, userId);\n\n    // Check for suspicious activity\n    if (response.status >= 400) {\n      this.checkSuspiciousActivity(userId, response);\n    }\n\n    return response;\n  }\n\n  protected override async handleError(_context: PluginContext, error: Error): Promise<Error> {\n    if (!this.isEnabled) return error;\n\n    // Record error audit event\n    this.recordAuditEvent({\n      type: 'error',\n      action: 'request_error',\n      resource: {\n        type: 'api_endpoint',\n        path: this.sanitizePath((error as any).config?.url || ''),\n      },\n      outcome: 'failure',\n      details: {\n        error: error.name,\n        message: error.message,\n        code: (error as any).code,\n        status: (error as any).status,\n        stack: error.stack,\n      },\n      risk: this.assessErrorRisk(error),\n      compliance: { gdpr: false, fiscal: false, internal: true },\n    });\n\n    return error;\n  }\n\n  /**\n   * Record custom audit event\n   */\n  public recordAuditEvent(\n    event: Omit<AuditEvent, 'id' | 'timestamp' | 'actor' | 'retention'>,\n    userId?: string\n  ): void {\n    const auditEvent: AuditEvent = {\n      id: this.generateEventId(),\n      timestamp: Date.now(),\n      actor: {\n        ...(userId && { userId }),\n        sessionId: this.sessionId,\n        ...(() => {\n          const ipAddress = this.getCurrentIpAddress();\n          const userAgent = this.getCurrentUserAgent();\n          return {\n            ...(ipAddress && { ipAddress }),\n            ...(userAgent && { userAgent }),\n          };\n        })(),\n      },\n      retention: this.retentionPeriods[event.risk],\n      ...event,\n    };\n\n    this.events.push(auditEvent);\n\n    // Maintain max events limit\n    if (this.events.length > this.maxEvents) {\n      this.events = this.events.slice(-this.maxEvents);\n    }\n\n    // Emit real-time event\n    this.emitEvent('audit_event', auditEvent);\n\n    // Check for compliance violations\n    this.checkComplianceViolations(auditEvent);\n\n    this.log('debug', `Audit event recorded: ${event.action}`, {\n      type: event.type,\n      risk: event.risk,\n      outcome: event.outcome,\n    });\n  }\n\n  /**\n   * Set current user context\n   */\n  public setUserContext(userId: string, role: string): void {\n    const previousUser = this.currentUser;\n    this.currentUser = { id: userId, role };\n\n    this.recordAuditEvent({\n      type: 'auth',\n      action: 'user_context_changed',\n      resource: { type: 'user_session', id: userId },\n      outcome: 'success',\n      details: {\n        previousUser: previousUser?.id,\n        newUser: userId,\n        role,\n      },\n      risk: 'medium',\n      compliance: { gdpr: true, fiscal: false, internal: true },\n    });\n\n    this.log('info', 'User context set', { userId, role });\n  }\n\n  /**\n   * Get audit events with filtering\n   */\n  public getAuditEvents(filter?: AuditFilter): AuditEvent[] {\n    let filteredEvents = [...this.events];\n\n    if (filter) {\n      if (filter.type) {\n        filteredEvents = filteredEvents.filter(e => filter.type!.includes(e.type));\n      }\n      \n      if (filter.action) {\n        filteredEvents = filteredEvents.filter(e => \n          filter.action!.some(action => e.action.includes(action))\n        );\n      }\n      \n      if (filter.outcome) {\n        filteredEvents = filteredEvents.filter(e => filter.outcome!.includes(e.outcome));\n      }\n      \n      if (filter.risk) {\n        filteredEvents = filteredEvents.filter(e => filter.risk!.includes(e.risk));\n      }\n      \n      if (filter.timeRange) {\n        filteredEvents = filteredEvents.filter(e => \n          e.timestamp >= filter.timeRange!.start && \n          e.timestamp <= filter.timeRange!.end\n        );\n      }\n      \n      if (filter.userId) {\n        filteredEvents = filteredEvents.filter(e => e.actor.userId === filter.userId);\n      }\n      \n      if (filter.resource) {\n        filteredEvents = filteredEvents.filter(e => \n          e.resource.type.includes(filter.resource!) || \n          e.resource.path?.includes(filter.resource!)\n        );\n      }\n      \n      if (filter.compliance) {\n        filteredEvents = filteredEvents.filter(e => \n          filter.compliance!.some(comp => e.compliance[comp])\n        );\n      }\n    }\n\n    return filteredEvents.sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  /**\n   * Generate compliance report\n   */\n  public generateComplianceReport(timeRangeMs: number = 86400000): ComplianceReport {\n    const now = Date.now();\n    const start = now - timeRangeMs;\n    \n    const periodEvents = this.getAuditEvents({\n      timeRange: { start, end: now }\n    });\n\n    // Event statistics\n    const events = {\n      total: periodEvents.length,\n      byType: this.groupBy(periodEvents, 'type'),\n      byRisk: this.groupBy(periodEvents, 'risk'),\n      byOutcome: this.groupBy(periodEvents, 'outcome'),\n    };\n\n    // GDPR compliance\n    const gdprEvents = periodEvents.filter(e => e.compliance.gdpr);\n    const gdpr = {\n      dataAccess: gdprEvents.filter(e => e.action.includes('read') || e.action.includes('get')).length,\n      dataModification: gdprEvents.filter(e => e.action.includes('update') || e.action.includes('patch')).length,\n      dataExport: gdprEvents.filter(e => e.action.includes('export')).length,\n      dataDelete: gdprEvents.filter(e => e.action.includes('delete')).length,\n    };\n\n    // Fiscal compliance\n    const fiscalEvents = periodEvents.filter(e => e.compliance.fiscal);\n    const fiscal = {\n      receiptCreation: fiscalEvents.filter(e => e.action.includes('create_receipt')).length,\n      receiptVoid: fiscalEvents.filter(e => e.action.includes('void_receipt')).length,\n      receiptModification: fiscalEvents.filter(e => e.action.includes('modify_receipt')).length,\n      fiscalReports: fiscalEvents.filter(e => e.action.includes('fiscal_report')).length,\n    };\n\n    // Security events\n    const securityEvents = periodEvents.filter(e => e.type === 'security' || e.risk === 'critical');\n    const security = {\n      authFailures: securityEvents.filter(e => e.action.includes('auth') && e.outcome === 'failure').length,\n      suspiciousActivity: securityEvents.filter(e => e.action.includes('suspicious')).length,\n      privilegeEscalation: securityEvents.filter(e => e.action.includes('privilege')).length,\n      dataLeaks: securityEvents.filter(e => e.action.includes('leak') || e.action.includes('breach')).length,\n    };\n\n    // Violations (high risk events with failures)\n    const violations = periodEvents.filter(e => \n      (e.risk === 'high' || e.risk === 'critical') && e.outcome === 'failure'\n    );\n\n    // Recommendations\n    const recommendations = this.generateRecommendations(periodEvents, violations);\n\n    return {\n      period: { start, end: now },\n      events,\n      compliance: { gdpr, fiscal, security },\n      violations,\n      recommendations,\n    };\n  }\n\n  /**\n   * Export audit data for external systems\n   */\n  public exportAuditData(filter?: AuditFilter): {\n    metadata: {\n      exportTime: number;\n      totalEvents: number;\n      filter?: AuditFilter;\n    };\n    events: AuditEvent[];\n  } {\n    const events = this.getAuditEvents(filter);\n    \n    this.recordAuditEvent({\n      type: 'data',\n      action: 'audit_data_export',\n      resource: { type: 'audit_log' },\n      outcome: 'success',\n      details: {\n        eventCount: events.length,\n        filter,\n        exportFormat: 'json',\n      },\n      risk: 'medium',\n      compliance: { gdpr: true, fiscal: true, internal: true },\n    });\n\n    return {\n      metadata: {\n        exportTime: Date.now(),\n        totalEvents: events.length,\n        ...(filter && { filter }),\n      },\n      events,\n    };\n  }\n\n  /**\n   * Clear audit data (with compliance considerations)\n   */\n  public clearAuditData(olderThan?: number, preserveCompliance: boolean = true): number {\n    const cutoff = olderThan ? Date.now() - olderThan : 0;\n    const initialCount = this.events.length;\n\n    if (preserveCompliance) {\n      // Keep events that must be retained for compliance\n      this.events = this.events.filter(e => {\n        const retentionEnd = e.timestamp + (e.retention * 24 * 60 * 60 * 1000);\n        return Date.now() < retentionEnd || e.timestamp > cutoff;\n      });\n    } else {\n      this.events = this.events.filter(e => e.timestamp > cutoff);\n    }\n\n    const deletedCount = initialCount - this.events.length;\n\n    this.recordAuditEvent({\n      type: 'data',\n      action: 'audit_data_cleared',\n      resource: { type: 'audit_log' },\n      outcome: 'success',\n      details: {\n        deletedCount,\n        preserveCompliance,\n        cutoffTime: cutoff,\n      },\n      risk: 'high',\n      compliance: { gdpr: true, fiscal: true, internal: true },\n    });\n\n    this.log('info', `Cleared ${deletedCount} audit events`, { \n      preserveCompliance,\n      remaining: this.events.length,\n    });\n\n    return deletedCount;\n  }\n\n  private assessRequestRisk(options: RequestOptions): AuditEvent['risk'] {\n    // High risk for authentication and configuration endpoints\n    if (options.url.includes('/auth') || options.url.includes('/config')) {\n      return 'high';\n    }\n    \n    // Medium risk for data modification\n    if (['POST', 'PUT', 'PATCH', 'DELETE'].includes(options.method)) {\n      return 'medium';\n    }\n    \n    return 'low';\n  }\n\n  private assessResponseRisk(response: HttpResponse<any>): AuditEvent['risk'] {\n    // Critical risk for authentication failures\n    if (response.status === 401 || response.status === 403) {\n      return 'critical';\n    }\n    \n    // High risk for server errors\n    if (response.status >= 500) {\n      return 'high';\n    }\n    \n    // Medium risk for client errors\n    if (response.status >= 400) {\n      return 'medium';\n    }\n    \n    return 'low';\n  }\n\n  private assessErrorRisk(error: Error): AuditEvent['risk'] {\n    // Critical risk for security-related errors\n    if (error.message.includes('unauthorized') || error.message.includes('forbidden')) {\n      return 'critical';\n    }\n    \n    return 'high';\n  }\n\n  private assessRequestCompliance(options: RequestOptions): AuditEvent['compliance'] {\n    const path = options.url.toLowerCase();\n    \n    return {\n      gdpr: path.includes('/user') || path.includes('/profile') || path.includes('/data'),\n      fiscal: path.includes('/receipt') || path.includes('/payment') || path.includes('/fiscal'),\n      internal: true,\n    };\n  }\n\n  private assessResponseCompliance(response: HttpResponse<any>): AuditEvent['compliance'] {\n    const path = (response as any).config?.url?.toLowerCase() || '';\n    \n    return {\n      gdpr: path.includes('/user') || path.includes('/profile') || path.includes('/data'),\n      fiscal: path.includes('/receipt') || path.includes('/payment') || path.includes('/fiscal'),\n      internal: true,\n    };\n  }\n\n  private checkSuspiciousActivity(userId?: string, response?: HttpResponse<any>): void {\n    if (!userId) return;\n\n    const key = `${userId}_failures`;\n    const failures = this.suspiciousActivity.get(key) || 0;\n    const newFailures = failures + 1;\n    \n    this.suspiciousActivity.set(key, newFailures);\n\n    // Alert on multiple failures\n    if (newFailures >= 5) {\n      this.recordAuditEvent({\n        type: 'security',\n        action: 'suspicious_activity_detected',\n        resource: { type: 'user_account', id: userId },\n        outcome: 'warning',\n        details: {\n          failureCount: newFailures,\n          recentStatus: response?.status,\n          pattern: 'multiple_auth_failures',\n        },\n        risk: 'critical',\n        compliance: { gdpr: true, fiscal: false, internal: true },\n      }, userId);\n    }\n\n    // Reset counter after 15 minutes\n    setTimeout(() => {\n      this.suspiciousActivity.delete(key);\n    }, 900000);\n  }\n\n  private checkComplianceViolations(event: AuditEvent): void {\n    const violations: string[] = [];\n\n    // Check for data access without proper authorization\n    if (event.compliance.gdpr && event.type === 'request' && !event.actor.userId) {\n      violations.push('GDPR: Data access without user identification');\n    }\n\n    // Check for fiscal operations outside business hours\n    if (event.compliance.fiscal && this.isOutsideBusinessHours()) {\n      violations.push('Fiscal: Operation outside business hours');\n    }\n\n    // Check for critical operations without proper logging\n    if (event.risk === 'critical' && !event.details) {\n      violations.push('Security: Critical operation without detailed logging');\n    }\n\n    if (violations.length > 0) {\n      this.recordAuditEvent({\n        type: 'security',\n        action: 'compliance_violation_detected',\n        resource: event.resource,\n        outcome: 'warning',\n        details: {\n          violations,\n          originalEvent: event.id,\n        },\n        risk: 'critical',\n        compliance: { gdpr: true, fiscal: true, internal: true },\n      });\n    }\n  }\n\n  private setupRealTimeMonitoring(): void {\n    // Monitor for real-time compliance violations\n    this.onEvent('audit_event', (event: AuditEvent) => {\n      if (event.risk === 'critical' || event.outcome === 'failure') {\n        this.emitEvent('security_alert', {\n          type: 'real_time_alert',\n          event,\n          timestamp: Date.now(),\n        });\n      }\n    });\n  }\n\n  private generateRecommendations(events: AuditEvent[], _violations: AuditEvent[]): string[] {\n    const recommendations: string[] = [];\n\n    // Security recommendations\n    const authFailures = events.filter(e => \n      e.action.includes('auth') && e.outcome === 'failure'\n    ).length;\n    \n    if (authFailures > 10) {\n      recommendations.push('Implement stronger authentication mechanisms (MFA, rate limiting)');\n    }\n\n    // Compliance recommendations\n    const gdprEvents = events.filter(e => e.compliance.gdpr);\n    const undocumentedGdprEvents = gdprEvents.filter(e => !e.details || Object.keys(e.details).length === 0);\n    \n    if (undocumentedGdprEvents.length > 0) {\n      recommendations.push('Enhance GDPR event documentation and data processing records');\n    }\n\n    // Performance recommendations\n    const slowRequests = events.filter(e => \n      e.type === 'response' && e.details?.duration > 5000\n    ).length;\n    \n    if (slowRequests > events.length * 0.1) {\n      recommendations.push('Review and optimize slow API endpoints affecting audit performance');\n    }\n\n    return recommendations;\n  }\n\n  private generateSessionId(): string {\n    return `audit_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private generateEventId(): string {\n    return `evt_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private generateCorrelationId(): string {\n    return `corr_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private extractUserIdFromAuth(authorization?: string): string | undefined {\n    if (!authorization) return undefined;\n    \n    try {\n      // Simple JWT extraction - in production, use proper JWT library\n      const token = authorization.replace('Bearer ', '');\n      const payloadPart = token.split('.')[1];\n      if (!payloadPart) return undefined;\n      const payload = JSON.parse(atob(payloadPart));\n      return payload.sub || payload.userId;\n    } catch {\n      return undefined;\n    }\n  }\n\n  private getCurrentIpAddress(): string | undefined {\n    // In browser environment, this would need to be provided by the application\n    return undefined;\n  }\n\n  private getCurrentUserAgent(): string | undefined {\n    return typeof navigator !== 'undefined' ? navigator.userAgent : undefined;\n  }\n\n  private sanitizePath(url: string): string {\n    try {\n      const urlObj = new URL(url, 'https://example.com');\n      return urlObj.pathname;\n    } catch {\n      return url;\n    }\n  }\n\n  private sanitizeUrl(url: string): string {\n    try {\n      const urlObj = new URL(url, 'https://example.com');\n      urlObj.searchParams.delete('api_key');\n      urlObj.searchParams.delete('token');\n      return urlObj.pathname + (urlObj.search || '');\n    } catch {\n      return url;\n    }\n  }\n\n  private sanitizeHeaders(headers: Record<string, any> = {}): Record<string, any> {\n    const sanitized = { ...headers };\n    const sensitiveHeaders = ['authorization', 'x-api-key', 'cookie'];\n    \n    for (const header of sensitiveHeaders) {\n      if (sanitized[header]) {\n        sanitized[header] = '[REDACTED]';\n      }\n    }\n    \n    return sanitized;\n  }\n\n  private calculateSize(data: any): number {\n    if (!data) return 0;\n    \n    try {\n      return new Blob([JSON.stringify(data)]).size;\n    } catch {\n      return 0;\n    }\n  }\n\n  private groupBy(array: AuditEvent[], key: keyof AuditEvent): Record<string, number> {\n    return array.reduce((acc, item) => {\n      const value = String(item[key]);\n      acc[value] = (acc[value] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n  }\n\n  private isOutsideBusinessHours(): boolean {\n    const now = new Date();\n    const hour = now.getHours();\n    const day = now.getDay();\n    \n    // Outside 9-17 Monday-Friday\n    return hour < 9 || hour >= 17 || day === 0 || day === 6;\n  }\n\n  private cleanupExpiredEvents(): void {\n    const now = Date.now();\n    const initialCount = this.events.length;\n    \n    this.events = this.events.filter(event => {\n      const retentionEnd = event.timestamp + (event.retention * 24 * 60 * 60 * 1000);\n      return now < retentionEnd;\n    });\n    \n    const deletedCount = initialCount - this.events.length;\n    \n    if (deletedCount > 0) {\n      this.log('debug', `Cleaned up ${deletedCount} expired audit events`);\n    }\n  }\n\n  private async loadPersistedEvents(): Promise<void> {\n    try {\n      const persistedEvents = this.getFromStorage<AuditEvent[]>('audit_events');\n      \n      if (persistedEvents) {\n        // Only load non-expired events\n        const now = Date.now();\n        this.events = persistedEvents.filter(event => {\n          const retentionEnd = event.timestamp + (event.retention * 24 * 60 * 60 * 1000);\n          return now < retentionEnd;\n        });\n      }\n      \n      this.log('debug', 'Loaded persisted audit events', {\n        events: this.events.length,\n      });\n    } catch (error) {\n      this.log('warn', 'Failed to load persisted audit events', { error });\n    }\n  }\n\n  private async persistEvents(): Promise<void> {\n    try {\n      this.setInStorage('audit_events', this.events);\n      \n      this.log('debug', 'Persisted audit events', {\n        events: this.events.length,\n      });\n    } catch (error) {\n      this.log('warn', 'Failed to persist audit events', { error });\n    }\n  }\n}","/**\n * Cache Plugin - Advanced caching strategies for A-Cube SDK\n * Provides intelligent caching with TTL, invalidation, and cache warming\n */\n\nimport { BasePlugin } from '../core/base-plugin';\nimport type { PluginContext, PluginManifest } from '../core/plugin-manager';\nimport type { RequestOptions, HttpResponse } from '@/http/client';\n\nexport interface CacheEntry<T = any> {\n  key: string;\n  data: T;\n  timestamp: number;\n  ttl: number;\n  hits: number;\n  lastAccessed: number;\n  tags: string[];\n  metadata?: Record<string, any>;\n}\n\nexport interface CacheStats {\n  totalEntries: number;\n  totalSize: number;\n  hitRate: number;\n  missRate: number;\n  evictionCount: number;\n  topKeys: Array<{ key: string; hits: number }>;\n  memoryUsage: {\n    used: number;\n    available: number;\n    percentage: number;\n  };\n}\n\nexport interface CacheConfig {\n  enabled: boolean;\n  maxSize: number; // Maximum number of entries\n  defaultTtl: number; // Default TTL in milliseconds\n  strategy: 'lru' | 'lfu' | 'fifo';\n  compression: boolean;\n  persistence: boolean;\n  maxMemoryMB: number;\n  warmupUrls: string[];\n}\n\nexport interface CacheWarmupRule {\n  pattern: string;\n  interval: number;\n  priority: 'low' | 'medium' | 'high';\n  conditions?: {\n    timeRange?: { start: string; end: string }; // HH:MM format\n    dayOfWeek?: number[]; // 0-6, Sunday = 0\n  };\n}\n\nexport class CachePlugin extends BasePlugin {\n  readonly manifest: PluginManifest = {\n    name: 'cache',\n    version: '1.0.0',\n    description: 'Advanced caching strategies for A-Cube SDK',\n    author: 'A-Cube Team',\n    permissions: [\n      'http:read',\n      'http:write',\n      'storage:read',\n      'storage:write',\n      'cache:read',\n      'cache:write',\n      'events:emit',\n      'config:read',\n      'config:write',\n    ],\n  };\n\n  private cache = new Map<string, CacheEntry>();\n  private stats = {\n    hits: 0,\n    misses: 0,\n    evictions: 0,\n    totalRequests: 0,\n  };\n  private config: CacheConfig = {\n    enabled: true,\n    maxSize: 1000,\n    defaultTtl: 300000,\n    strategy: 'lru',\n    compression: false,\n    persistence: false,\n    maxMemoryMB: 50,\n    warmupUrls: [],\n  };\n  private warmupRules: CacheWarmupRule[] = [];\n  private warmupInterval?: NodeJS.Timeout;\n  private isEnabled: boolean = true;\n\n  protected async initialize(_context: PluginContext): Promise<void> {\n    // Load configuration\n    this.config = this.getConfig<CacheConfig>('settings') || {\n      enabled: true,\n      maxSize: 1000,\n      defaultTtl: 300000, // 5 minutes\n      strategy: 'lru',\n      compression: false,\n      persistence: true,\n      maxMemoryMB: 50,\n      warmupUrls: [],\n    };\n\n    this.isEnabled = this.config.enabled;\n\n    if (!this.isEnabled) {\n      this.log('info', 'Cache plugin disabled by configuration');\n      return;\n    }\n\n    // Load persisted cache if enabled\n    if (this.config.persistence) {\n      await this.loadPersistedCache();\n    }\n\n    // Load warmup rules\n    this.warmupRules = this.getConfig<CacheWarmupRule[]>('warmupRules') || [];\n\n    // Start cache warmup if rules exist\n    if (this.warmupRules.length > 0) {\n      this.startCacheWarmup();\n    }\n\n    // Set up periodic cleanup\n    setInterval(() => {\n      this.cleanupExpiredEntries();\n    }, 60000); // Every minute\n\n    this.log('info', 'Cache plugin initialized', {\n      strategy: this.config.strategy,\n      maxSize: this.config.maxSize,\n      defaultTtl: this.config.defaultTtl,\n      persistence: this.config.persistence,\n      warmupRules: this.warmupRules.length,\n    });\n  }\n\n  protected async cleanup(_context: PluginContext): Promise<void> {\n    // Stop warmup interval\n    if (this.warmupInterval) {\n      clearInterval(this.warmupInterval);\n    }\n\n    // Persist cache if enabled\n    if (this.config.persistence) {\n      await this.persistCache();\n    }\n\n    // Emit final stats\n    this.emitEvent('cache_stats', this.getCacheStats());\n\n    this.log('info', 'Cache plugin cleaned up', {\n      finalEntries: this.cache.size,\n      hitRate: this.calculateHitRate(),\n    });\n  }\n\n  protected override async processRequest(_context: PluginContext, options: RequestOptions): Promise<RequestOptions> {\n    if (!this.isEnabled || !this.shouldCache(options)) {\n      return options;\n    }\n\n    const cacheKey = this.generateCacheKey(options);\n    const cached = this.getCacheEntry(cacheKey);\n\n    if (cached && !this.isExpired(cached)) {\n      // Cache hit - return cached response\n      this.stats.hits++;\n      this.stats.totalRequests++;\n      \n      cached.hits++;\n      cached.lastAccessed = Date.now();\n\n      // Create mock response from cache\n      const cachedResponse: HttpResponse<any> = {\n        data: cached.data,\n        status: 200,\n        statusText: 'OK',\n        headers: cached.metadata?.headers || {},\n        duration: 0,\n        requestId: `cached_${Date.now()}`,\n      };\n      \n      // Add extended properties using type assertion for cache metadata\n      (cachedResponse as any).config = options;\n      (cachedResponse as any).fromCache = true;\n\n      // Emit cache hit event\n      this.emitEvent('cache_hit', { key: cacheKey, data: cached });\n\n      this.log('debug', `Cache HIT: ${cacheKey}`, {\n        hits: cached.hits,\n        age: Date.now() - cached.timestamp,\n      });\n\n      // Bypass actual request by modifying options to trigger cached response\n      options.metadata = {\n        ...options.metadata,\n        _cachedResponse: cachedResponse,\n        _cacheKey: cacheKey,\n      };\n    } else {\n      // Cache miss\n      this.stats.misses++;\n      this.stats.totalRequests++;\n\n      // Add cache metadata for response processing\n      options.metadata = {\n        ...options.metadata,\n        _cacheKey: cacheKey,\n        _shouldCache: true,\n      };\n\n      this.log('debug', `Cache MISS: ${cacheKey}`);\n    }\n\n    return options;\n  }\n\n  protected override async processResponse(_context: PluginContext, response: HttpResponse<any>): Promise<HttpResponse<any>> {\n    if (!this.isEnabled) return response;\n\n    // Defensive typing for config property\n    const responseConfig = (response as any).config;\n    \n    // Return cached response if available\n    if (responseConfig?.metadata?._cachedResponse) {\n      return responseConfig.metadata._cachedResponse;\n    }\n\n    // Cache successful responses\n    if (responseConfig?.metadata?._shouldCache && this.shouldCacheResponse(response)) {\n      const cacheKey = responseConfig.metadata._cacheKey;\n      const ttl = this.determineTtl(response);\n\n      this.setInCache(cacheKey, response.data, ttl, {\n        url: responseConfig?.url,\n        method: responseConfig?.method,\n        status: response.status,\n        headers: response.headers,\n        timestamp: Date.now(),\n      });\n\n      this.log('debug', `Cached response: ${cacheKey}`, {\n        ttl,\n        size: this.calculateSize(response.data),\n      });\n    }\n\n    return response;\n  }\n\n  /**\n   * Manually set cache entry\n   */\n  public setCache<T>(key: string, data: T, ttl?: number, tags: string[] = []): void {\n    this.setInCache(key, data, ttl || this.config.defaultTtl, {}, tags);\n  }\n\n  /**\n   * Get cache entry\n   */\n  public getCache<T>(key: string): T | undefined {\n    const entry = this.getCacheEntry(key);\n    if (entry && !this.isExpired(entry)) {\n      entry.hits++;\n      entry.lastAccessed = Date.now();\n      return entry.data;\n    }\n    return undefined;\n  }\n\n  /**\n   * Delete cache entry\n   */\n  public deleteCache(key: string): boolean {\n    const deleted = this.cache.delete(key);\n    if (deleted) {\n      this.emitEvent('cache_delete', { key });\n      this.log('debug', `Cache entry deleted: ${key}`);\n    }\n    return deleted;\n  }\n\n  /**\n   * Clear cache by tags\n   */\n  public clearByTags(tags: string[]): number {\n    let cleared = 0;\n    \n    for (const [key, entry] of this.cache.entries()) {\n      if (tags.some(tag => entry.tags.includes(tag))) {\n        this.cache.delete(key);\n        cleared++;\n      }\n    }\n\n    if (cleared > 0) {\n      this.emitEvent('cache_clear', { tags, count: cleared });\n      this.log('info', `Cleared ${cleared} cache entries by tags`, { tags });\n    }\n\n    return cleared;\n  }\n\n  /**\n   * Clear all cache\n   */\n  public clearAll(): void {\n    const count = this.cache.size;\n    this.cache.clear();\n    this.emitEvent('cache_clear_all', { count });\n    this.log('info', `Cleared all cache entries`, { count });\n  }\n\n  /**\n   * Get cache statistics\n   */\n  public getCacheStats(): CacheStats {\n    const entries = Array.from(this.cache.values());\n    const totalSize = entries.reduce((sum, entry) => sum + this.calculateSize(entry.data), 0);\n    const hitRate = this.calculateHitRate();\n\n    const topKeys = entries\n      .sort((a, b) => b.hits - a.hits)\n      .slice(0, 10)\n      .map(entry => ({ key: entry.key, hits: entry.hits }));\n\n    const memoryUsage = this.calculateMemoryUsage(totalSize);\n\n    return {\n      totalEntries: this.cache.size,\n      totalSize,\n      hitRate,\n      missRate: 1 - hitRate,\n      evictionCount: this.stats.evictions,\n      topKeys,\n      memoryUsage,\n    };\n  }\n\n  /**\n   * Warm cache with predefined URLs\n   */\n  public async warmCache(urls: string[] = this.config.warmupUrls): Promise<void> {\n    if (!this.isEnabled || urls.length === 0) return;\n\n    this.log('info', `Starting cache warmup for ${urls.length} URLs`);\n\n    for (const url of urls) {\n      try {\n        const options: RequestOptions = {\n          method: 'GET',\n          url,\n          headers: { 'X-Cache-Warmup': 'true' },\n        };\n\n        await this.makeRequest(options);\n        this.log('debug', `Warmed cache for: ${url}`);\n      } catch (error) {\n        this.log('warn', `Failed to warm cache for: ${url}`, { error });\n      }\n    }\n\n    this.log('info', 'Cache warmup completed');\n  }\n\n  /**\n   * Set cache warmup rules\n   */\n  public setWarmupRules(rules: CacheWarmupRule[]): void {\n    this.warmupRules = rules;\n    this.setConfig('warmupRules', rules);\n\n    // Restart warmup with new rules\n    if (this.warmupInterval) {\n      clearInterval(this.warmupInterval);\n    }\n    \n    if (rules.length > 0) {\n      this.startCacheWarmup();\n    }\n\n    this.log('info', 'Cache warmup rules updated', { count: rules.length });\n  }\n\n  /**\n   * Get cache keys matching pattern\n   */\n  public getKeysByPattern(pattern: string): string[] {\n    const regex = new RegExp(pattern.replace(/\\*/g, '.*'));\n    return Array.from(this.cache.keys()).filter(key => regex.test(key));\n  }\n\n  /**\n   * Get cache entries by tags\n   */\n  public getEntriesByTags(tags: string[]): CacheEntry[] {\n    return Array.from(this.cache.values()).filter(entry =>\n      tags.some(tag => entry.tags.includes(tag))\n    );\n  }\n\n  protected override setInCache<T>(key: string, data: T, ttl: number, metadata: Record<string, any> = {}, tags: string[] = []): void {\n    // Check memory limits\n    if (this.shouldEvict()) {\n      this.evictEntries();\n    }\n\n    const entry: CacheEntry<T> = {\n      key,\n      data,\n      timestamp: Date.now(),\n      ttl,\n      hits: 0,\n      lastAccessed: Date.now(),\n      tags,\n      metadata,\n    };\n\n    this.cache.set(key, entry);\n    this.emitEvent('cache_set', { key, ttl, tags });\n  }\n\n  /**\n   * Get full cache entry object\n   */\n  private getCacheEntry(key: string): CacheEntry | undefined {\n    return this.cache.get(key);\n  }\n\n  /**\n   * Get cached data only (inherited method)\n   */\n  protected override getFromCache<T>(key: string): T | undefined {\n    const entry = this.cache.get(key);\n    return entry?.data as T | undefined;\n  }\n\n  private shouldCache(options: RequestOptions): boolean {\n    // Only cache GET requests by default\n    if (options.method !== 'GET') return false;\n\n    // Don't cache if explicitly disabled\n    if (options.headers?.['X-No-Cache'] === 'true') return false;\n\n    // Don't cache warmup requests\n    if (options.headers?.['X-Cache-Warmup'] === 'true') return false;\n\n    return true;\n  }\n\n  private shouldCacheResponse(response: HttpResponse<any>): boolean {\n    // Only cache successful responses\n    if (response.status < 200 || response.status >= 300) return false;\n\n    // Don't cache responses with no-cache headers\n    const cacheControl = response.headers?.['cache-control'];\n    if (cacheControl?.includes('no-cache') || cacheControl?.includes('no-store')) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private generateCacheKey(options: RequestOptions): string {\n    const url = new URL(options.url, 'https://example.com');\n    const params = Array.from(url.searchParams.entries())\n      .sort(([a], [b]) => a.localeCompare(b))\n      .map(([key, value]) => `${key}=${value}`)\n      .join('&');\n\n    return `${options.method}:${url.pathname}${params ? '?' + params : ''}`;\n  }\n\n  private determineTtl(response: HttpResponse<any>): number {\n    // Check Cache-Control header\n    const cacheControl = response.headers?.['cache-control'];\n    if (cacheControl) {\n      const maxAgeMatch = cacheControl.match(/max-age=(\\d+)/);\n      if (maxAgeMatch) {\n        const maxAgeValue = maxAgeMatch[1];\n        if (maxAgeValue) {\n          return parseInt(maxAgeValue) * 1000; // Convert to milliseconds\n        }\n      }\n    }\n\n    // Check Expires header\n    const expires = response.headers?.['expires'];\n    if (expires) {\n      const expiresTime = new Date(expires).getTime();\n      const now = Date.now();\n      if (expiresTime > now) {\n        return expiresTime - now;\n      }\n    }\n\n    // Use default TTL\n    return this.config.defaultTtl;\n  }\n\n  private isExpired(entry: CacheEntry): boolean {\n    return Date.now() - entry.timestamp > entry.ttl;\n  }\n\n  private shouldEvict(): boolean {\n    return this.cache.size >= this.config.maxSize ||\n           this.calculateMemoryUsage().percentage > 90;\n  }\n\n  private evictEntries(): void {\n    const entriesToEvict = Math.max(1, Math.floor(this.config.maxSize * 0.1)); // Evict 10%\n    const entries = Array.from(this.cache.entries());\n\n    let evicted: Array<[string, CacheEntry]>;\n\n    switch (this.config.strategy) {\n      case 'lru':\n        evicted = entries\n          .sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed)\n          .slice(0, entriesToEvict);\n        break;\n      \n      case 'lfu':\n        evicted = entries\n          .sort(([, a], [, b]) => a.hits - b.hits)\n          .slice(0, entriesToEvict);\n        break;\n      \n      case 'fifo':\n      default:\n        evicted = entries\n          .sort(([, a], [, b]) => a.timestamp - b.timestamp)\n          .slice(0, entriesToEvict);\n        break;\n    }\n\n    for (const [key] of evicted) {\n      this.cache.delete(key);\n      this.stats.evictions++;\n    }\n\n    this.emitEvent('cache_eviction', { \n      strategy: this.config.strategy, \n      count: evicted.length \n    });\n\n    this.log('debug', `Evicted ${evicted.length} cache entries using ${this.config.strategy} strategy`);\n  }\n\n  private cleanupExpiredEntries(): void {\n    let cleanedCount = 0;\n\n    for (const [key, entry] of this.cache.entries()) {\n      if (this.isExpired(entry)) {\n        this.cache.delete(key);\n        cleanedCount++;\n      }\n    }\n\n    if (cleanedCount > 0) {\n      this.emitEvent('cache_cleanup', { count: cleanedCount });\n      this.log('debug', `Cleaned up ${cleanedCount} expired cache entries`);\n    }\n  }\n\n  private calculateHitRate(): number {\n    return this.stats.totalRequests > 0 \n      ? this.stats.hits / this.stats.totalRequests \n      : 0;\n  }\n\n  private calculateSize(data: any): number {\n    if (!data) return 0;\n    \n    try {\n      return new Blob([JSON.stringify(data)]).size;\n    } catch {\n      return 0;\n    }\n  }\n\n  private calculateMemoryUsage(totalSize?: number): { used: number; available: number; percentage: number } {\n    const used = totalSize || Array.from(this.cache.values())\n      .reduce((sum, entry) => sum + this.calculateSize(entry.data), 0);\n    \n    const available = this.config.maxMemoryMB * 1024 * 1024; // Convert MB to bytes\n    const percentage = available > 0 ? (used / available) * 100 : 0;\n\n    return { used, available, percentage };\n  }\n\n  private startCacheWarmup(): void {\n    // Run warmup every hour\n    this.warmupInterval = setInterval(() => {\n      this.executeWarmupRules();\n    }, 3600000) as unknown as NodeJS.Timeout;\n\n    // Initial warmup\n    setTimeout(() => this.executeWarmupRules(), 5000);\n  }\n\n  private async executeWarmupRules(): Promise<void> {\n    const now = new Date();\n    const currentHour = now.getHours();\n    const currentMinute = now.getMinutes();\n    const dayOfWeek = now.getDay();\n\n    for (const rule of this.warmupRules) {\n      if (this.shouldExecuteWarmupRule(rule, currentHour, currentMinute, dayOfWeek)) {\n        try {\n          const urls = this.getUrlsFromPattern(rule.pattern);\n          await this.warmCache(urls);\n        } catch (error) {\n          this.log('warn', `Failed to execute warmup rule: ${rule.pattern}`, { error });\n        }\n      }\n    }\n  }\n\n  private shouldExecuteWarmupRule(rule: CacheWarmupRule, hour: number, minute: number, dayOfWeek: number): boolean {\n    if (rule.conditions) {\n      if (rule.conditions.dayOfWeek && !rule.conditions.dayOfWeek.includes(dayOfWeek)) {\n        return false;\n      }\n\n      if (rule.conditions.timeRange) {\n        const startParts = rule.conditions.timeRange.start.split(':').map(Number);\n        const endParts = rule.conditions.timeRange.end.split(':').map(Number);\n        const [startHour, startMinute] = startParts;\n        const [endHour, endMinute] = endParts;\n        \n        if (startHour === undefined || startMinute === undefined || \n            endHour === undefined || endMinute === undefined) {\n          return false; // Skip invalid time range\n        }\n        \n        const currentTime = hour * 60 + minute;\n        const startTime = startHour * 60 + startMinute;\n        const endTime = endHour * 60 + endMinute;\n        \n        if (currentTime < startTime || currentTime > endTime) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  private getUrlsFromPattern(pattern: string): string[] {\n    // Simple pattern matching - could be enhanced with more sophisticated logic\n    if (pattern.includes('*')) {\n      // For now, return warmup URLs that match the pattern\n      return this.config.warmupUrls.filter(url => {\n        const regex = new RegExp(pattern.replace(/\\*/g, '.*'));\n        return regex.test(url);\n      });\n    }\n    \n    return [pattern];\n  }\n\n  private async loadPersistedCache(): Promise<void> {\n    try {\n      const persistedEntries = this.getFromStorage<Array<[string, CacheEntry]>>('cache_entries');\n      const persistedStats = this.getFromStorage<typeof this.stats>('cache_stats');\n      \n      if (persistedEntries) {\n        for (const [key, entry] of persistedEntries) {\n          if (!this.isExpired(entry)) {\n            this.cache.set(key, entry);\n          }\n        }\n      }\n      \n      if (persistedStats) {\n        this.stats = { ...this.stats, ...persistedStats };\n      }\n      \n      this.log('debug', 'Loaded persisted cache', {\n        entries: this.cache.size,\n        hitRate: this.calculateHitRate(),\n      });\n    } catch (error) {\n      this.log('warn', 'Failed to load persisted cache', { error });\n    }\n  }\n\n  private async persistCache(): Promise<void> {\n    try {\n      const entries = Array.from(this.cache.entries());\n      this.setInStorage('cache_entries', entries);\n      this.setInStorage('cache_stats', this.stats);\n      \n      this.log('debug', 'Persisted cache', {\n        entries: entries.length,\n        hitRate: this.calculateHitRate(),\n      });\n    } catch (error) {\n      this.log('warn', 'Failed to persist cache', { error });\n    }\n  }\n}","/**\n * Debug Plugin - Advanced debugging and logging for A-Cube SDK\n * Provides comprehensive debugging tools and request/response logging\n */\n\nimport { BasePlugin } from '../core/base-plugin';\nimport type { PluginContext, PluginManifest } from '../core/plugin-manager';\nimport type { RequestOptions, HttpResponse } from '@/http/client';\n\nexport interface DebugEvent {\n  id: string;\n  timestamp: number;\n  type: 'request' | 'response' | 'error' | 'log';\n  level: 'debug' | 'info' | 'warn' | 'error';\n  message: string;\n  data?: any;\n  duration?: number;\n  stackTrace?: string;\n  correlationId?: string;\n}\n\nexport interface DebugFilter {\n  level?: ('debug' | 'info' | 'warn' | 'error')[];\n  type?: ('request' | 'response' | 'error' | 'log')[];\n  timeRange?: { start: number; end: number };\n  keyword?: string;\n  correlationId?: string;\n}\n\nexport interface DebugSession {\n  id: string;\n  name: string;\n  startTime: number;\n  endTime?: number;\n  events: DebugEvent[];\n  metadata: Record<string, any>;\n}\n\nexport class DebugPlugin extends BasePlugin {\n  readonly manifest: PluginManifest = {\n    name: 'debug',\n    version: '1.0.0',\n    description: 'Advanced debugging and logging for A-Cube SDK',\n    author: 'A-Cube Team',\n    permissions: [\n      'http:read',\n      'storage:read',\n      'storage:write',\n      'cache:read',\n      'cache:write',\n      'events:emit',\n      'config:read',\n      'config:write',\n    ],\n  };\n\n  private events: DebugEvent[] = [];\n  private sessions = new Map<string, DebugSession>();\n  private activeSession?: string;\n  private requestCorrelations = new Map<string, string>();\n  private maxEvents: number = 1000;\n  private isEnabled: boolean = true;\n\n  protected async initialize(_context: PluginContext): Promise<void> {\n    // Load configuration\n    const config = this.getConfig<{\n      enabled: boolean;\n      maxEvents: number;\n      autoSession: boolean;\n      logLevel: 'debug' | 'info' | 'warn' | 'error';\n      persistEvents: boolean;\n    }>('settings') || {\n      enabled: true,\n      maxEvents: 1000,\n      autoSession: true,\n      logLevel: 'debug',\n      persistEvents: false,\n    };\n\n    this.isEnabled = config.enabled;\n    this.maxEvents = config.maxEvents;\n\n    if (!this.isEnabled) {\n      this.log('info', 'Debug plugin disabled by configuration');\n      return;\n    }\n\n    // Load persisted events if enabled\n    if (config.persistEvents) {\n      await this.loadPersistedEvents();\n    }\n\n    // Start auto session if enabled\n    if (config.autoSession) {\n      this.startSession('main', { auto: true });\n    }\n\n    // Set up global error handler\n    this.setupGlobalErrorHandler();\n\n    this.log('info', 'Debug plugin initialized', { \n      maxEvents: this.maxEvents,\n      autoSession: config.autoSession,\n      logLevel: config.logLevel \n    });\n  }\n\n  protected async cleanup(_context: PluginContext): Promise<void> {\n    const config = this.getConfig<{ persistEvents: boolean }>('settings');\n    \n    // Persist events if enabled\n    if (config?.persistEvents) {\n      await this.persistEvents();\n    }\n\n    // End active session\n    if (this.activeSession) {\n      this.endSession(this.activeSession);\n    }\n\n    this.log('info', 'Debug plugin cleaned up');\n  }\n\n  protected override async processRequest(_context: PluginContext, options: RequestOptions): Promise<RequestOptions> {\n    if (!this.isEnabled) return options;\n\n    // Generate correlation ID\n    const correlationId = `req_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n    \n    // Store correlation for response tracking\n    const requestId = `${options.method}_${options.url}_${Date.now()}`;\n    this.requestCorrelations.set(requestId, correlationId);\n\n    // Add debug headers\n    options.headers = {\n      ...options.headers,\n      'X-Debug-Correlation-ID': correlationId,\n      'X-Debug-Plugin': 'enabled',\n    };\n\n    // Log request\n    this.addEvent({\n      id: `${correlationId}_request`,\n      timestamp: Date.now(),\n      type: 'request',\n      level: 'debug',\n      message: `${options.method} ${options.url}`,\n      data: {\n        method: options.method,\n        url: this.sanitizeUrl(options.url),\n        headers: this.sanitizeHeaders(options.headers),\n        body: this.sanitizeBody(options.data),\n        timeout: options.timeout,\n      },\n      correlationId,\n    });\n\n    // Add correlation ID to options metadata\n    options.metadata = {\n      ...options.metadata,\n      debugCorrelationId: correlationId,\n    };\n\n    return options;\n  }\n\n  protected override async processResponse(_context: PluginContext, response: HttpResponse<any>): Promise<HttpResponse<any>> {\n    if (!this.isEnabled) return response;\n\n    const correlationId = response.headers?.['x-debug-correlation-id'] || \n                         (response as any).config?.metadata?.debugCorrelationId;\n\n    // Log response\n    this.addEvent({\n      id: `${correlationId}_response`,\n      timestamp: Date.now(),\n      type: 'response',\n      level: response.status >= 400 ? 'error' : 'debug',\n      message: `${response.status} ${response.statusText}`,\n      data: {\n        status: response.status,\n        statusText: response.statusText,\n        headers: this.sanitizeHeaders(response.headers),\n        data: this.sanitizeResponseBody(response.data),\n        duration: response.duration,\n        fromCache: 'fromCache' in response ? (response as any).fromCache : false,\n      },\n      duration: response.duration,\n      correlationId,\n    });\n\n    return response;\n  }\n\n  protected override async handleError(_context: PluginContext, error: Error): Promise<Error> {\n    if (!this.isEnabled) return error;\n\n    // Extract correlation ID from error context\n    const correlationId = (error as any).correlationId || \n                         (error as any).config?.metadata?.debugCorrelationId;\n\n    // Log error with full stack trace\n    this.addEvent({\n      id: `${correlationId || 'unknown'}_error`,\n      timestamp: Date.now(),\n      type: 'error',\n      level: 'error',\n      message: error.message,\n      data: {\n        name: error.name,\n        message: error.message,\n        code: (error as any).code,\n        status: (error as any).status,\n        response: (error as any).response ? {\n          status: (error as any).response.status,\n          statusText: (error as any).response.statusText,\n          data: this.sanitizeResponseBody((error as any).response.data),\n        } : undefined,\n      },\n      ...(error.stack && { stackTrace: error.stack }),\n      ...(correlationId && { correlationId }),\n    });\n\n    return error;\n  }\n\n  /**\n   * Start a debug session\n   */\n  public startSession(name: string, metadata: Record<string, any> = {}): string {\n    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n    \n    const session: DebugSession = {\n      id: sessionId,\n      name,\n      startTime: Date.now(),\n      events: [],\n      metadata,\n    };\n\n    this.sessions.set(sessionId, session);\n    this.activeSession = sessionId;\n\n    this.addEvent({\n      id: `${sessionId}_start`,\n      timestamp: Date.now(),\n      type: 'log',\n      level: 'info',\n      message: `Debug session started: ${name}`,\n      data: { sessionId, metadata },\n    });\n\n    this.log('info', `Debug session started: ${name}`, { sessionId, metadata });\n    return sessionId;\n  }\n\n  /**\n   * End a debug session\n   */\n  public endSession(sessionId: string): DebugSession | undefined {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      this.log('warn', `Session not found: ${sessionId}`);\n      return undefined;\n    }\n\n    session.endTime = Date.now();\n    session.events = this.events.filter(e => \n      e.timestamp >= session.startTime && \n      (!session.endTime || e.timestamp <= session.endTime)\n    );\n\n    this.addEvent({\n      id: `${sessionId}_end`,\n      timestamp: Date.now(),\n      type: 'log',\n      level: 'info',\n      message: `Debug session ended: ${session.name}`,\n      data: { \n        sessionId,\n        duration: session.endTime - session.startTime,\n        eventCount: session.events.length,\n      },\n    });\n\n    if (this.activeSession === sessionId) {\n      delete (this as any).activeSession;\n    }\n\n    this.log('info', `Debug session ended: ${session.name}`, { \n      sessionId,\n      duration: session.endTime - session.startTime,\n      eventCount: session.events.length,\n    });\n\n    return session;\n  }\n\n  /**\n   * Add custom debug event\n   */\n  public addDebugLog(level: 'debug' | 'info' | 'warn' | 'error', message: string, data?: any): void {\n    this.addEvent({\n      id: `log_${Date.now()}_${Math.random().toString(36).substring(2)}`,\n      timestamp: Date.now(),\n      type: 'log',\n      level,\n      message,\n      data,\n      ...(this.activeSession && { correlationId: this.activeSession }),\n    });\n  }\n\n  /**\n   * Get debug events with optional filtering\n   */\n  public getEvents(filter?: DebugFilter): DebugEvent[] {\n    let filteredEvents = [...this.events];\n\n    if (filter) {\n      if (filter.level) {\n        filteredEvents = filteredEvents.filter(e => filter.level!.includes(e.level));\n      }\n      \n      if (filter.type) {\n        filteredEvents = filteredEvents.filter(e => filter.type!.includes(e.type));\n      }\n      \n      if (filter.timeRange) {\n        filteredEvents = filteredEvents.filter(e => \n          e.timestamp >= filter.timeRange!.start && \n          e.timestamp <= filter.timeRange!.end\n        );\n      }\n      \n      if (filter.keyword) {\n        const keyword = filter.keyword.toLowerCase();\n        filteredEvents = filteredEvents.filter(e => \n          e.message.toLowerCase().includes(keyword) ||\n          JSON.stringify(e.data || {}).toLowerCase().includes(keyword)\n        );\n      }\n      \n      if (filter.correlationId) {\n        filteredEvents = filteredEvents.filter(e => e.correlationId === filter.correlationId);\n      }\n    }\n\n    return filteredEvents.sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  /**\n   * Get debug session\n   */\n  public getSession(sessionId: string): DebugSession | undefined {\n    return this.sessions.get(sessionId);\n  }\n\n  /**\n   * Get all sessions\n   */\n  public getSessions(): DebugSession[] {\n    return Array.from(this.sessions.values());\n  }\n\n  /**\n   * Export debug data\n   */\n  public exportDebugData(sessionId?: string): { session?: DebugSession; events: DebugEvent[] } {\n    const session = sessionId ? this.sessions.get(sessionId) : undefined;\n    const events = sessionId && session \n      ? session.events \n      : this.events;\n\n    return { ...(session && { session }), events };\n  }\n\n  /**\n   * Clear debug data\n   */\n  public clearDebugData(sessionId?: string): void {\n    if (sessionId) {\n      const session = this.sessions.get(sessionId);\n      if (session) {\n        // Remove session events from main events array\n        this.events = this.events.filter(e => \n          !(e.timestamp >= session.startTime && \n            (!session.endTime || e.timestamp <= session.endTime))\n        );\n        this.sessions.delete(sessionId);\n      }\n    } else {\n      this.events = [];\n      this.sessions.clear();\n      delete (this as any).activeSession;\n    }\n\n    this.log('info', 'Debug data cleared', { sessionId: sessionId || 'all' });\n  }\n\n  /**\n   * Get debug statistics\n   */\n  public getDebugStats(): {\n    totalEvents: number;\n    eventsByType: Record<string, number>;\n    eventsByLevel: Record<string, number>;\n    activeSessions: number;\n    averageRequestDuration: number;\n    errorRate: number;\n  } {\n    const eventsByType = this.events.reduce((acc, e) => {\n      acc[e.type] = (acc[e.type] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const eventsByLevel = this.events.reduce((acc, e) => {\n      acc[e.level] = (acc[e.level] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const requestEvents = this.events.filter(e => e.type === 'response' && e.duration);\n    const averageRequestDuration = requestEvents.length > 0\n      ? requestEvents.reduce((sum, e) => sum + (e.duration || 0), 0) / requestEvents.length\n      : 0;\n\n    const errorEvents = this.events.filter(e => e.level === 'error').length;\n    const errorRate = this.events.length > 0 ? errorEvents / this.events.length : 0;\n\n    const activeSessions = Array.from(this.sessions.values()).filter(s => !s.endTime).length;\n\n    return {\n      totalEvents: this.events.length,\n      eventsByType,\n      eventsByLevel,\n      activeSessions,\n      averageRequestDuration,\n      errorRate,\n    };\n  }\n\n  private addEvent(event: DebugEvent): void {\n    this.events.push(event);\n\n    // Maintain max events limit\n    if (this.events.length > this.maxEvents) {\n      this.events = this.events.slice(-this.maxEvents);\n    }\n\n    // Emit event for external listeners\n    this.emitEvent('debug_event', event);\n\n    // Add to active session if exists\n    if (this.activeSession) {\n      const session = this.sessions.get(this.activeSession);\n      if (session && !session.endTime) {\n        session.events.push(event);\n      }\n    }\n  }\n\n  private sanitizeUrl(url: string): string {\n    try {\n      const urlObj = new URL(url, 'https://example.com');\n      // Remove sensitive parameters\n      urlObj.searchParams.delete('api_key');\n      urlObj.searchParams.delete('token');\n      urlObj.searchParams.delete('password');\n      return urlObj.pathname + (urlObj.search || '');\n    } catch {\n      return url;\n    }\n  }\n\n  private sanitizeHeaders(headers: Record<string, any> = {}): Record<string, any> {\n    const sanitized = { ...headers };\n    const sensitiveHeaders = ['authorization', 'x-api-key', 'cookie', 'set-cookie'];\n    \n    for (const header of sensitiveHeaders) {\n      if (sanitized[header]) {\n        sanitized[header] = '[REDACTED]';\n      }\n      if (sanitized[header.toLowerCase()]) {\n        sanitized[header.toLowerCase()] = '[REDACTED]';\n      }\n    }\n    \n    return sanitized;\n  }\n\n  private sanitizeBody(body: any): any {\n    if (!body) return body;\n    \n    if (typeof body === 'string') {\n      try {\n        const parsed = JSON.parse(body);\n        return this.sanitizeObject(parsed);\n      } catch {\n        return '[BINARY_DATA]';\n      }\n    }\n    \n    return this.sanitizeObject(body);\n  }\n\n  private sanitizeResponseBody(body: any): any {\n    if (!body) return body;\n    \n    // Limit response body size for logging\n    const bodyStr = JSON.stringify(body);\n    if (bodyStr.length > 10000) {\n      return '[LARGE_RESPONSE_TRUNCATED]';\n    }\n    \n    return this.sanitizeObject(body);\n  }\n\n  private sanitizeObject(obj: any): any {\n    if (obj === null || typeof obj !== 'object') return obj;\n    \n    if (Array.isArray(obj)) {\n      return obj.map(item => this.sanitizeObject(item));\n    }\n    \n    const sanitized: any = {};\n    const sensitiveKeys = ['password', 'token', 'secret', 'key', 'authorization', 'credential'];\n    \n    for (const [key, value] of Object.entries(obj)) {\n      const keyLower = key.toLowerCase();\n      if (sensitiveKeys.some(sensitive => keyLower.includes(sensitive))) {\n        sanitized[key] = '[REDACTED]';\n      } else {\n        sanitized[key] = this.sanitizeObject(value);\n      }\n    }\n    \n    return sanitized;\n  }\n\n  private setupGlobalErrorHandler(): void {\n    // Browser error handler\n    if (typeof window !== 'undefined') {\n      window.addEventListener('error', (event) => {\n        this.addEvent({\n          id: `global_error_${Date.now()}`,\n          timestamp: Date.now(),\n          type: 'error',\n          level: 'error',\n          message: `Global error: ${event.message}`,\n          data: {\n            filename: event.filename,\n            lineno: event.lineno,\n            colno: event.colno,\n            error: event.error?.message,\n          },\n          stackTrace: event.error?.stack,\n        });\n      });\n\n      window.addEventListener('unhandledrejection', (event) => {\n        this.addEvent({\n          id: `unhandled_rejection_${Date.now()}`,\n          timestamp: Date.now(),\n          type: 'error',\n          level: 'error',\n          message: `Unhandled promise rejection: ${event.reason}`,\n          data: {\n            reason: event.reason,\n          },\n        });\n      });\n    }\n  }\n\n  private async loadPersistedEvents(): Promise<void> {\n    try {\n      const persistedEvents = this.getFromStorage<DebugEvent[]>('events');\n      const persistedSessions = this.getFromStorage<DebugSession[]>('sessions');\n      \n      if (persistedEvents) {\n        this.events = persistedEvents.slice(-this.maxEvents);\n      }\n      \n      if (persistedSessions) {\n        for (const session of persistedSessions) {\n          this.sessions.set(session.id, session);\n        }\n      }\n      \n      this.log('debug', 'Loaded persisted debug data', {\n        events: this.events.length,\n        sessions: this.sessions.size,\n      });\n    } catch (error) {\n      this.log('warn', 'Failed to load persisted debug data', { error });\n    }\n  }\n\n  private async persistEvents(): Promise<void> {\n    try {\n      this.setInStorage('events', this.events);\n      this.setInStorage('sessions', Array.from(this.sessions.values()));\n      \n      this.log('debug', 'Persisted debug data', {\n        events: this.events.length,\n        sessions: this.sessions.size,\n      });\n    } catch (error) {\n      this.log('warn', 'Failed to persist debug data', { error });\n    }\n  }\n}","/**\n * Performance Plugin - Monitor and optimize A-Cube SDK performance\n * Provides comprehensive performance tracking and optimization recommendations\n */\n\nimport { BasePlugin } from '../core/base-plugin';\nimport type { PluginContext, PluginManifest } from '../core/plugin-manager';\nimport type { RequestOptions, HttpResponse } from '@/http/client';\n\nexport interface PerformanceMetric {\n  id: string;\n  timestamp: number;\n  type: 'request' | 'memory' | 'bundle' | 'render' | 'custom';\n  name: string;\n  value: number;\n  unit: 'ms' | 'bytes' | 'count' | 'percentage';\n  category: 'network' | 'computation' | 'memory' | 'storage' | 'ui';\n  metadata?: Record<string, any>;\n  tags?: string[];\n}\n\nexport interface PerformanceAlert {\n  id: string;\n  timestamp: number;\n  level: 'info' | 'warning' | 'critical';\n  metric: string;\n  threshold: number;\n  actualValue: number;\n  message: string;\n  recommendation?: string;\n}\n\nexport interface PerformanceBudget {\n  metric: string;\n  warning: number;\n  critical: number;\n  unit: 'ms' | 'bytes' | 'count' | 'percentage';\n  category: 'network' | 'computation' | 'memory' | 'storage' | 'ui';\n}\n\nexport interface PerformanceReport {\n  period: { start: number; end: number };\n  metrics: {\n    requests: {\n      total: number;\n      average: number;\n      p50: number;\n      p95: number;\n      p99: number;\n      slowest: PerformanceMetric[];\n    };\n    memory: {\n      peak: number;\n      average: number;\n      trend: 'increasing' | 'decreasing' | 'stable';\n    };\n    budgets: {\n      passed: number;\n      warnings: number;\n      critical: number;\n    };\n  };\n  alerts: PerformanceAlert[];\n  recommendations: string[];\n}\n\nexport class PerformancePlugin extends BasePlugin {\n  readonly manifest: PluginManifest = {\n    name: 'performance',\n    version: '1.0.0',\n    description: 'Monitor and optimize A-Cube SDK performance',\n    author: 'A-Cube Team',\n    permissions: [\n      'http:read',\n      'storage:read',\n      'storage:write',\n      'cache:read',\n      'cache:write',\n      'events:emit',\n      'config:read',\n      'config:write',\n    ],\n  };\n\n  private metrics: PerformanceMetric[] = [];\n  private alerts: PerformanceAlert[] = [];\n  private budgets: PerformanceBudget[] = [];\n  private requestStartTimes = new Map<string, number>();\n  private memoryMonitor?: NodeJS.Timeout;\n  private isEnabled: boolean = true;\n  private maxMetrics: number = 5000;\n\n  protected async initialize(_context: PluginContext): Promise<void> {\n    // Load configuration\n    const config = this.getConfig<{\n      enabled: boolean;\n      maxMetrics: number;\n      budgets: PerformanceBudget[];\n      memoryMonitoring: boolean;\n      alertThresholds: {\n        slowRequest: number;\n        highMemory: number;\n        errorRate: number;\n      };\n    }>('settings') || {\n      enabled: true,\n      maxMetrics: 5000,\n      budgets: this.getDefaultBudgets(),\n      memoryMonitoring: true,\n      alertThresholds: {\n        slowRequest: 5000, // 5 seconds\n        highMemory: 100 * 1024 * 1024, // 100MB\n        errorRate: 0.05, // 5%\n      },\n    };\n\n    this.isEnabled = config.enabled;\n    this.maxMetrics = config.maxMetrics;\n    this.budgets = config.budgets;\n\n    if (!this.isEnabled) {\n      this.log('info', 'Performance plugin disabled by configuration');\n      return;\n    }\n\n    // Start memory monitoring if enabled\n    if (config.memoryMonitoring) {\n      this.startMemoryMonitoring();\n    }\n\n    // Load persisted metrics\n    await this.loadPersistedMetrics();\n\n    // Track plugin initialization performance\n    if (this.context?.sdk) {\n      const sdk = this.context.sdk;\n      this.recordMetric({\n        id: `plugin_init_${Date.now()}`,\n        timestamp: Date.now(),\n        type: 'custom',\n        name: 'performance_plugin_initialization',\n        value: 0, // Plugin initialization complete\n        unit: 'ms',\n        category: 'computation',\n        metadata: { \n          environment: sdk.getConfig()?.environment || 'unknown',\n          version: '2.0.0' \n        },\n      });\n    }\n\n    this.log('info', 'Performance plugin initialized', { \n      budgets: this.budgets.length,\n      memoryMonitoring: config.memoryMonitoring \n    });\n  }\n\n  protected async cleanup(_context: PluginContext): Promise<void> {\n    // Stop memory monitoring\n    if (this.memoryMonitor) {\n      clearInterval(this.memoryMonitor);\n    }\n\n    // Persist metrics\n    await this.persistMetrics();\n\n    // Generate final report\n    const report = this.generateReport(3600000); // Last hour\n    this.emitEvent('performance_report', report);\n\n    this.log('info', 'Performance plugin cleaned up');\n  }\n\n  protected override async processRequest(_context: PluginContext, options: RequestOptions): Promise<RequestOptions> {\n    if (!this.isEnabled) return options;\n\n    // Record request start time\n    const requestId = `${options.method}_${options.url}_${Date.now()}`;\n    this.requestStartTimes.set(requestId, performance.now());\n\n    // Add performance tracking headers\n    options.headers = {\n      ...options.headers,\n      'X-Performance-Tracking': 'enabled',\n      'X-Request-Start': Date.now().toString(),\n    };\n\n    // Track request size if body exists\n    if (options.data) {\n      const bodySize = this.calculateSize(options.data);\n      this.recordMetric({\n        id: `request_size_${Date.now()}`,\n        timestamp: Date.now(),\n        type: 'request',\n        name: 'request_size',\n        value: bodySize,\n        unit: 'bytes',\n        category: 'network',\n        metadata: {\n          method: options.method,\n          url: this.sanitizeUrl(options.url),\n        },\n      });\n    }\n\n    return options;\n  }\n\n  protected override async processResponse(_context: PluginContext, response: HttpResponse<any>): Promise<HttpResponse<any>> {\n    if (!this.isEnabled) return response;\n\n    const requestId = Object.keys(Object.fromEntries(this.requestStartTimes))\n      .find(key => key.includes(response.config?.url || ''));\n\n    if (requestId) {\n      const startTime = this.requestStartTimes.get(requestId);\n      if (startTime) {\n        const duration = performance.now() - startTime;\n        this.requestStartTimes.delete(requestId);\n\n        // Record request duration\n        this.recordMetric({\n          id: `request_duration_${Date.now()}`,\n          timestamp: Date.now(),\n          type: 'request',\n          name: 'request_duration',\n          value: duration,\n          unit: 'ms',\n          category: 'network',\n          metadata: {\n            method: response.config?.method,\n            url: this.sanitizeUrl(response.config?.url || ''),\n            status: response.status,\n            fromCache: response.fromCache,\n          },\n          tags: [\n            response.status >= 400 ? 'error' : 'success',\n            response.fromCache ? 'cached' : 'fresh',\n          ],\n        });\n\n        // Check against budgets\n        this.checkBudgets('request_duration', duration, 'ms');\n\n        // Record response size\n        const responseSize = this.calculateSize(response.data);\n        this.recordMetric({\n          id: `response_size_${Date.now()}`,\n          timestamp: Date.now(),\n          type: 'request',\n          name: 'response_size',\n          value: responseSize,\n          unit: 'bytes',\n          category: 'network',\n          metadata: {\n            method: response.config?.method,\n            url: this.sanitizeUrl(response.config?.url || ''),\n            status: response.status,\n          },\n        });\n      }\n    }\n\n    return response;\n  }\n\n  protected override async handleError(_context: PluginContext, error: Error): Promise<Error> {\n    if (!this.isEnabled) return error;\n\n    // Record error metric\n    this.recordMetric({\n      id: `error_${Date.now()}`,\n      timestamp: Date.now(),\n      type: 'custom',\n      name: 'request_error',\n      value: 1,\n      unit: 'count',\n      category: 'network',\n      metadata: {\n        error: error.name,\n        message: error.message,\n        status: (error as any).status,\n      },\n      tags: ['error'],\n    });\n\n    return error;\n  }\n\n  /**\n   * Record a custom performance metric\n   */\n  public recordMetric(metric: Omit<PerformanceMetric, 'id' | 'timestamp'> & Partial<Pick<PerformanceMetric, 'id' | 'timestamp'>>): void {\n    const fullMetric: PerformanceMetric = {\n      id: metric.id || `custom_${Date.now()}_${Math.random().toString(36).substring(2)}`,\n      timestamp: metric.timestamp || Date.now(),\n      ...metric,\n    };\n\n    this.metrics.push(fullMetric);\n\n    // Maintain max metrics limit\n    if (this.metrics.length > this.maxMetrics) {\n      this.metrics = this.metrics.slice(-this.maxMetrics);\n    }\n\n    // Check budgets\n    this.checkBudgets(fullMetric.name, fullMetric.value, fullMetric.unit);\n\n    // Emit metric event\n    this.emitEvent('performance_metric', fullMetric);\n\n    this.log('debug', `Recorded metric: ${fullMetric.name}`, fullMetric);\n  }\n\n  /**\n   * Set performance budgets\n   */\n  public setBudgets(budgets: PerformanceBudget[]): void {\n    this.budgets = budgets;\n    this.setConfig('budgets', budgets);\n    this.log('info', 'Performance budgets updated', { count: budgets.length });\n  }\n\n  /**\n   * Get performance metrics with optional filtering\n   */\n  public getMetrics(filter?: {\n    type?: PerformanceMetric['type'][];\n    category?: PerformanceMetric['category'][];\n    timeRange?: { start: number; end: number };\n    name?: string;\n    tags?: string[];\n  }): PerformanceMetric[] {\n    let filteredMetrics = [...this.metrics];\n\n    if (filter) {\n      if (filter.type) {\n        filteredMetrics = filteredMetrics.filter(m => filter.type!.includes(m.type));\n      }\n      \n      if (filter.category) {\n        filteredMetrics = filteredMetrics.filter(m => filter.category!.includes(m.category));\n      }\n      \n      if (filter.timeRange) {\n        filteredMetrics = filteredMetrics.filter(m => \n          m.timestamp >= filter.timeRange!.start && \n          m.timestamp <= filter.timeRange!.end\n        );\n      }\n      \n      if (filter.name) {\n        filteredMetrics = filteredMetrics.filter(m => m.name.includes(filter.name!));\n      }\n      \n      if (filter.tags) {\n        filteredMetrics = filteredMetrics.filter(m => \n          filter.tags!.some(tag => m.tags?.includes(tag))\n        );\n      }\n    }\n\n    return filteredMetrics.sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  /**\n   * Get performance alerts\n   */\n  public getAlerts(level?: PerformanceAlert['level']): PerformanceAlert[] {\n    let alerts = [...this.alerts];\n    \n    if (level) {\n      alerts = alerts.filter(a => a.level === level);\n    }\n    \n    return alerts.sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  /**\n   * Generate performance report\n   */\n  public generateReport(timeRangeMs: number = 3600000): PerformanceReport {\n    const now = Date.now();\n    const start = now - timeRangeMs;\n    \n    const periodMetrics = this.getMetrics({\n      timeRange: { start, end: now }\n    });\n\n    // Request metrics\n    const requestMetrics = periodMetrics.filter(m => m.name === 'request_duration');\n    const requestDurations = requestMetrics.map(m => m.value).sort((a, b) => a - b);\n    \n    const requests = {\n      total: requestMetrics.length,\n      average: requestDurations.length > 0 ? requestDurations.reduce((a, b) => a + b, 0) / requestDurations.length : 0,\n      p50: this.percentile(requestDurations, 50),\n      p95: this.percentile(requestDurations, 95),\n      p99: this.percentile(requestDurations, 99),\n      slowest: requestMetrics\n        .sort((a, b) => b.value - a.value)\n        .slice(0, 5),\n    };\n\n    // Memory metrics\n    const memoryMetrics = periodMetrics.filter(m => m.name === 'memory_usage');\n    const memoryValues = memoryMetrics.map(m => m.value);\n    \n    const memory = {\n      peak: memoryValues.length > 0 ? Math.max(...memoryValues) : 0,\n      average: memoryValues.length > 0 ? memoryValues.reduce((a, b) => a + b, 0) / memoryValues.length : 0,\n      trend: this.calculateTrend(memoryValues) as 'increasing' | 'decreasing' | 'stable',\n    };\n\n    // Budget compliance\n    const recentAlerts = this.alerts.filter(a => a.timestamp >= start);\n    const budgets = {\n      passed: this.budgets.length - recentAlerts.filter(a => a.level === 'warning' || a.level === 'critical').length,\n      warnings: recentAlerts.filter(a => a.level === 'warning').length,\n      critical: recentAlerts.filter(a => a.level === 'critical').length,\n    };\n\n    // Recommendations\n    const recommendations = this.generateRecommendations(periodMetrics, recentAlerts);\n\n    return {\n      period: { start, end: now },\n      metrics: { requests, memory, budgets },\n      alerts: recentAlerts,\n      recommendations,\n    };\n  }\n\n  /**\n   * Clear performance data\n   */\n  public clearData(olderThan?: number): void {\n    if (olderThan) {\n      const cutoff = Date.now() - olderThan;\n      this.metrics = this.metrics.filter(m => m.timestamp > cutoff);\n      this.alerts = this.alerts.filter(a => a.timestamp > cutoff);\n    } else {\n      this.metrics = [];\n      this.alerts = [];\n    }\n\n    this.log('info', 'Performance data cleared', { olderThan });\n  }\n\n  /**\n   * Get current performance summary\n   */\n  public getPerformanceSummary(): {\n    totalMetrics: number;\n    activeAlerts: number;\n    averageRequestTime: number;\n    errorRate: number;\n    memoryUsage: number;\n  } {\n    const recentMetrics = this.getMetrics({\n      timeRange: { start: Date.now() - 300000, end: Date.now() } // Last 5 minutes\n    });\n\n    const requestMetrics = recentMetrics.filter(m => m.name === 'request_duration');\n    const errorMetrics = recentMetrics.filter(m => m.tags?.includes('error'));\n    const memoryMetrics = recentMetrics.filter(m => m.name === 'memory_usage');\n\n    const averageRequestTime = requestMetrics.length > 0\n      ? requestMetrics.reduce((sum, m) => sum + m.value, 0) / requestMetrics.length\n      : 0;\n\n    const errorRate = recentMetrics.length > 0 ? errorMetrics.length / recentMetrics.length : 0;\n\n    const memoryUsage = memoryMetrics.length > 0\n      ? memoryMetrics[memoryMetrics.length - 1]?.value || 0\n      : 0;\n\n    return {\n      totalMetrics: this.metrics.length,\n      activeAlerts: this.alerts.filter(a => a.timestamp > Date.now() - 3600000).length,\n      averageRequestTime,\n      errorRate,\n      memoryUsage,\n    };\n  }\n\n  private checkBudgets(metricName: string, value: number, unit: string): void {\n    const budget = this.budgets.find(b => b.metric === metricName && b.unit === unit);\n    if (!budget) return;\n\n    let alertLevel: PerformanceAlert['level'] | null = null;\n    let threshold = 0;\n\n    if (value >= budget.critical) {\n      alertLevel = 'critical';\n      threshold = budget.critical;\n    } else if (value >= budget.warning) {\n      alertLevel = 'warning';\n      threshold = budget.warning;\n    }\n\n    if (alertLevel) {\n      const alert: PerformanceAlert = {\n        id: `alert_${Date.now()}_${Math.random().toString(36).substring(2)}`,\n        timestamp: Date.now(),\n        level: alertLevel,\n        metric: metricName,\n        threshold,\n        actualValue: value,\n        message: `${metricName} exceeded ${alertLevel} threshold: ${value}${unit} > ${threshold}${unit}`,\n        recommendation: this.getBudgetRecommendation(metricName, budget.category),\n      };\n\n      this.alerts.push(alert);\n      this.emitEvent('performance_alert', alert);\n      \n      this.log(alertLevel === 'critical' ? 'error' : 'warn', alert.message, alert);\n    }\n  }\n\n  private startMemoryMonitoring(): void {\n    if (typeof window !== 'undefined' && 'performance' in window && 'memory' in performance) {\n      this.memoryMonitor = setInterval(() => {\n        const memory = (performance as any).memory;\n        if (memory) {\n          this.recordMetric({\n            type: 'memory',\n            name: 'memory_usage',\n            value: memory.usedJSHeapSize,\n            unit: 'bytes',\n            category: 'memory',\n            metadata: {\n              totalJSHeapSize: memory.totalJSHeapSize,\n              jsHeapSizeLimit: memory.jsHeapSizeLimit,\n            },\n          });\n        }\n      }, 5000) as unknown as NodeJS.Timeout; // Every 5 seconds\n    }\n  }\n\n  private getDefaultBudgets(): PerformanceBudget[] {\n    return [\n      { metric: 'request_duration', warning: 1000, critical: 3000, unit: 'ms', category: 'network' },\n      { metric: 'response_size', warning: 1024 * 1024, critical: 5 * 1024 * 1024, unit: 'bytes', category: 'network' },\n      { metric: 'memory_usage', warning: 50 * 1024 * 1024, critical: 100 * 1024 * 1024, unit: 'bytes', category: 'memory' },\n    ];\n  }\n\n  private calculateSize(data: any): number {\n    if (!data) return 0;\n    \n    if (typeof data === 'string') {\n      return new Blob([data]).size;\n    }\n    \n    try {\n      return new Blob([JSON.stringify(data)]).size;\n    } catch {\n      return 0;\n    }\n  }\n\n  private sanitizeUrl(url: string): string {\n    try {\n      const urlObj = new URL(url, 'https://example.com');\n      urlObj.searchParams.delete('api_key');\n      urlObj.searchParams.delete('token');\n      return urlObj.pathname;\n    } catch {\n      return url;\n    }\n  }\n\n  private percentile(values: number[], p: number): number {\n    if (values.length === 0) return 0;\n    const index = Math.ceil(values.length * p / 100) - 1;\n    return values[Math.max(0, index)] || 0;\n  }\n\n  private calculateTrend(values: number[]): string {\n    if (values.length < 2) return 'stable';\n    \n    const first = values.slice(0, Math.ceil(values.length / 3));\n    const last = values.slice(-Math.ceil(values.length / 3));\n    \n    const firstAvg = first.reduce((a, b) => a + b, 0) / first.length;\n    const lastAvg = last.reduce((a, b) => a + b, 0) / last.length;\n    \n    const change = (lastAvg - firstAvg) / firstAvg;\n    \n    if (change > 0.1) return 'increasing';\n    if (change < -0.1) return 'decreasing';\n    return 'stable';\n  }\n\n  private generateRecommendations(metrics: PerformanceMetric[], alerts: PerformanceAlert[]): string[] {\n    const recommendations: string[] = [];\n    \n    // Request performance recommendations\n    const slowRequests = metrics.filter(m => m.name === 'request_duration' && m.value > 2000);\n    if (slowRequests.length > 0) {\n      recommendations.push('Consider implementing request caching for slow endpoints');\n      recommendations.push('Review API payload sizes and optimize data transfer');\n    }\n    \n    // Memory recommendations\n    const memoryAlerts = alerts.filter(a => a.metric === 'memory_usage');\n    if (memoryAlerts.length > 0) {\n      recommendations.push('Monitor for memory leaks and optimize object lifecycle');\n      recommendations.push('Consider implementing pagination for large datasets');\n    }\n    \n    // Error rate recommendations\n    const errorMetrics = metrics.filter(m => m.tags?.includes('error'));\n    if (errorMetrics.length > metrics.length * 0.05) {\n      recommendations.push('Implement retry logic for failed requests');\n      recommendations.push('Review error handling and add circuit breakers');\n    }\n    \n    return recommendations;\n  }\n\n  private getBudgetRecommendation(metric: string, category: PerformanceBudget['category']): string {\n    const recommendations: Record<string, Record<string, string>> = {\n      network: {\n        request_duration: 'Consider implementing caching, optimizing API calls, or adding request deduplication',\n        response_size: 'Implement response compression, reduce payload size, or use pagination',\n      },\n      memory: {\n        memory_usage: 'Review object lifecycle, implement garbage collection optimization, or reduce memory footprint',\n      },\n      computation: {\n        default: 'Optimize algorithms, reduce computational complexity, or implement background processing',\n      },\n    };\n    \n    return recommendations[category]?.[metric] || recommendations[category]?.default || 'Review and optimize this metric';\n  }\n\n  private async loadPersistedMetrics(): Promise<void> {\n    try {\n      const persistedMetrics = this.getFromStorage<PerformanceMetric[]>('metrics');\n      const persistedAlerts = this.getFromStorage<PerformanceAlert[]>('alerts');\n      \n      if (persistedMetrics) {\n        this.metrics = persistedMetrics.slice(-this.maxMetrics);\n      }\n      \n      if (persistedAlerts) {\n        this.alerts = persistedAlerts;\n      }\n      \n      this.log('debug', 'Loaded persisted performance data', {\n        metrics: this.metrics.length,\n        alerts: this.alerts.length,\n      });\n    } catch (error) {\n      this.log('warn', 'Failed to load persisted performance data', { error });\n    }\n  }\n\n  private async persistMetrics(): Promise<void> {\n    try {\n      this.setInStorage('metrics', this.metrics);\n      this.setInStorage('alerts', this.alerts);\n      \n      this.log('debug', 'Persisted performance data', {\n        metrics: this.metrics.length,\n        alerts: this.alerts.length,\n      });\n    } catch (error) {\n      this.log('warn', 'Failed to persist performance data', { error });\n    }\n  }\n}","/**\n * Built-in Plugins for A-Cube SDK\n * Complete suite of enterprise-grade plugins for analytics, debugging, performance, caching, and auditing\n */\n\nimport { AnalyticsPlugin } from '@/plugins/builtin/analytics-plugin';\nimport { AuditPlugin } from '@/plugins/builtin/audit-plugin';\nimport { CachePlugin } from '@/plugins/builtin/cache-plugin';\nimport { DebugPlugin } from '@/plugins/builtin/debug-plugin';\nimport { PerformancePlugin } from '@/plugins/builtin/performance-plugin';\n\n// Export all built-in plugins\nexport { AnalyticsPlugin } from './analytics-plugin';\nexport { DebugPlugin } from './debug-plugin';\nexport { PerformancePlugin } from './performance-plugin';\nexport { CachePlugin } from './cache-plugin';\nexport { AuditPlugin } from './audit-plugin';\n\n// Export plugin types for convenience\nexport type {\n  AnalyticsEvent,\n  PerformanceMetric,\n  UsageStats,\n} from './analytics-plugin';\n\nexport type {\n  DebugEvent,\n  DebugFilter,\n  DebugSession,\n} from './debug-plugin';\n\nexport type {\n  PerformanceMetric as PerfMetric,\n  PerformanceAlert,\n  PerformanceBudget,\n  PerformanceReport,\n} from './performance-plugin';\n\nexport type {\n  CacheEntry,\n  CacheStats,\n  CacheConfig,\n  CacheWarmupRule,\n} from './cache-plugin';\n\nexport type {\n  AuditEvent,\n  ComplianceReport,\n  AuditFilter,\n} from './audit-plugin';\n\n/**\n * Plugin registry for easy access to all built-in plugins\n */\nexport const BUILTIN_PLUGINS = {\n  analytics: () => AnalyticsPlugin,\n  debug: () => DebugPlugin,\n  performance: () => PerformancePlugin,\n  cache: () => CachePlugin,\n  audit: () => AuditPlugin,\n} as const;\n\n/**\n * Plugin categories for organization\n */\nexport const PLUGIN_CATEGORIES = {\n  monitoring: ['analytics', 'performance', 'debug'],\n  optimization: ['cache', 'performance'],\n  compliance: ['audit'],\n  development: ['debug'],\n} as const;\n\n/**\n * Utility function to get plugin by name\n */\nexport function getBuiltinPlugin(name: keyof typeof BUILTIN_PLUGINS) {\n  return BUILTIN_PLUGINS[name]();\n}\n\n/**\n * Utility function to get plugins by category\n */\nexport function getPluginsByCategory(category: keyof typeof PLUGIN_CATEGORIES) {\n  return PLUGIN_CATEGORIES[category].map(name => \n    BUILTIN_PLUGINS[name as keyof typeof BUILTIN_PLUGINS]()\n  );\n}\n\n/**\n * Plugin manifest information\n */\nexport const PLUGIN_MANIFESTS = {\n  analytics: {\n    name: 'analytics',\n    version: '1.0.0',\n    description: 'Track API usage, performance metrics, and user behavior',\n    category: 'monitoring',\n    dependencies: [],\n    permissions: ['http:read', 'storage:read', 'storage:write', 'cache:read', 'cache:write', 'events:emit', 'config:read', 'config:write'],\n  },\n  debug: {\n    name: 'debug',\n    version: '1.0.0',\n    description: 'Advanced debugging and logging for A-Cube SDK',\n    category: 'development',\n    dependencies: [],\n    permissions: ['http:read', 'storage:read', 'storage:write', 'cache:read', 'cache:write', 'events:emit', 'config:read', 'config:write'],\n  },\n  performance: {\n    name: 'performance',\n    version: '1.0.0',\n    description: 'Monitor and optimize A-Cube SDK performance',\n    category: 'optimization',\n    dependencies: [],\n    permissions: ['http:read', 'storage:read', 'storage:write', 'cache:read', 'cache:write', 'events:emit', 'config:read', 'config:write'],\n  },\n  cache: {\n    name: 'cache',\n    version: '1.0.0',\n    description: 'Advanced caching strategies for A-Cube SDK',\n    category: 'optimization',\n    dependencies: [],\n    permissions: ['http:read', 'http:write', 'storage:read', 'storage:write', 'cache:read', 'cache:write', 'events:emit', 'config:read', 'config:write'],\n  },\n  audit: {\n    name: 'audit',\n    version: '1.0.0',\n    description: 'Comprehensive audit logging and compliance for A-Cube SDK',\n    category: 'compliance',\n    dependencies: [],\n    permissions: ['http:read', 'storage:read', 'storage:write', 'cache:read', 'cache:write', 'events:emit', 'config:read', 'config:write'],\n  },\n} as const;","/**\n * A-Cube SDK Plugin System\n * Complete plugin architecture with core system and built-in plugins\n */\n\n// Export core plugin system\nexport * from './core';\n\n// Export all built-in plugins\nexport * from './builtin';\n\n// Re-export common types for convenience\nexport type {\n  Plugin,\n  PluginManifest,\n  PluginContext,\n  PluginPermission,\n  PluginLifecycleHooks,\n} from './core/plugin-manager';\n\n// Import for internal use\nimport type { Plugin } from './core/plugin-manager';\n\nexport type {\n  BasePlugin,\n  PluginBuilder,\n} from './core/base-plugin';\n\n/**\n * Plugin system utilities\n */\nexport const PluginUtils = {\n  /**\n   * Create a plugin bundle with multiple plugins\n   */\n  createBundle: (plugins: Plugin[]) => ({\n    plugins,\n    register: async (manager: any) => {\n      for (const plugin of plugins) {\n        await manager.register(plugin);\n      }\n    },\n  }),\n\n  /**\n   * Validate plugin compatibility\n   */\n  validateCompatibility: (plugin: Plugin, sdkVersion: string) => {\n    const manifest = plugin.manifest;\n    \n    if (manifest.sdkVersion && manifest.sdkVersion !== sdkVersion) {\n      throw new Error(`Plugin ${manifest.name} requires SDK version ${manifest.sdkVersion}, got ${sdkVersion}`);\n    }\n    \n    return true;\n  },\n\n  /**\n   * Get plugin dependencies\n   */\n  getDependencies: (plugin: Plugin): string[] => {\n    return plugin.manifest.dependencies || [];\n  },\n\n  /**\n   * Check if plugin has permission\n   */\n  hasPermission: (plugin: Plugin, permission: string): boolean => {\n    return (plugin.manifest.permissions || []).includes(permission as any);\n  },\n};","/**\n * Pre-commit Quality Gates for A-Cube SDK\n * Automated quality checks before code commits\n */\n\nexport interface QualityGateConfig {\n  enabled: boolean;\n  failFast: boolean; // Stop on first failure\n  parallel: boolean; // Run checks in parallel\n  timeoutMs: number;\n  checks: {\n    lint: QualityCheckConfig;\n    format: QualityCheckConfig;\n    typecheck: QualityCheckConfig;\n    test: QualityCheckConfig;\n    security: QualityCheckConfig;\n    dependencies: QualityCheckConfig;\n    commitMessage: QualityCheckConfig;\n    fileSize: QualityCheckConfig;\n  };\n  notifications: {\n    slack?: { webhook: string; channel: string };\n    email?: { recipients: string[]; smtp: any };\n    teams?: { webhook: string };\n  };\n}\n\nexport interface QualityCheckConfig {\n  enabled: boolean;\n  severity: 'error' | 'warning' | 'info';\n  autofix: boolean;\n  timeout: number;\n  rules?: Record<string, any>;\n}\n\nexport interface QualityCheckResult {\n  check: string;\n  status: 'pass' | 'fail' | 'warning' | 'skipped';\n  duration: number;\n  details: {\n    filesChecked: number;\n    issues: QualityIssue[];\n    autoFixed: number;\n    warnings: string[];\n  };\n  command?: string;\n  output?: string;\n}\n\nexport interface QualityIssue {\n  file: string;\n  line?: number;\n  column?: number;\n  rule: string;\n  severity: 'error' | 'warning' | 'info';\n  message: string;\n  fixable: boolean;\n  category: 'lint' | 'format' | 'type' | 'security' | 'dependency' | 'style';\n}\n\nexport interface CommitValidation {\n  isValid: boolean;\n  score: number; // 0-100\n  issues: QualityIssue[];\n  suggestions: string[];\n  bypassable: boolean;\n}\n\nexport class PreCommitManager {\n  private config: QualityGateConfig;\n  private hooks: Map<string, QualityHook> = new Map();\n  private cache: Map<string, QualityCheckResult> = new Map();\n\n  constructor(config?: Partial<QualityGateConfig>) {\n    this.config = {\n      enabled: true,\n      failFast: false,\n      parallel: true,\n      timeoutMs: 300000, // 5 minutes\n      checks: {\n        lint: { enabled: true, severity: 'error', autofix: true, timeout: 60000 },\n        format: { enabled: true, severity: 'warning', autofix: true, timeout: 30000 },\n        typecheck: { enabled: true, severity: 'error', autofix: false, timeout: 120000 },\n        test: { enabled: true, severity: 'error', autofix: false, timeout: 180000 },\n        security: { enabled: true, severity: 'error', autofix: false, timeout: 90000 },\n        dependencies: { enabled: true, severity: 'warning', autofix: false, timeout: 60000 },\n        commitMessage: { enabled: true, severity: 'warning', autofix: false, timeout: 5000 },\n        fileSize: { enabled: true, severity: 'warning', autofix: false, timeout: 10000 },\n      },\n      notifications: {},\n      ...config,\n    };\n\n    this.initializeDefaultHooks();\n  }\n\n  /**\n   * Register custom quality hook\n   */\n  registerHook(name: string, hook: QualityHook): void {\n    this.hooks.set(name, hook);\n  }\n\n  /**\n   * Run all pre-commit checks\n   */\n  async runPreCommitChecks(stagedFiles: string[]): Promise<CommitValidation> {\n    if (!this.config.enabled) {\n      return {\n        isValid: true,\n        score: 100,\n        issues: [],\n        suggestions: [],\n        bypassable: false,\n      };\n    }\n\n    const startTime = Date.now();\n    const results: QualityCheckResult[] = [];\n    const enabledChecks = Object.entries(this.config.checks)\n      .filter(([_, config]) => config.enabled)\n      .map(([name, config]) => ({ name, config }));\n\n    try {\n      if (this.config.parallel && !this.config.failFast) {\n        // Run all checks in parallel\n        const promises = enabledChecks.map(({ name, config }) =>\n          this.runQualityCheck(name, config, stagedFiles)\n        );\n        const checkResults = await Promise.allSettled(promises);\n        \n        checkResults.forEach((result, index) => {\n          if (result.status === 'fulfilled') {\n            results.push(result.value);\n          } else {\n            results.push({\n              check: enabledChecks[index]?.name || 'unknown',\n              status: 'fail',\n              duration: 0,\n              details: {\n                filesChecked: 0,\n                issues: [{\n                  file: 'system',\n                  rule: 'execution_error',\n                  severity: 'error',\n                  message: result.reason?.message || 'Check execution failed',\n                  fixable: false,\n                  category: 'lint',\n                }],\n                autoFixed: 0,\n                warnings: [],\n              },\n            });\n          }\n        });\n      } else {\n        // Run checks sequentially\n        for (const { name, config } of enabledChecks) {\n          const result = await this.runQualityCheck(name, config, stagedFiles);\n          results.push(result);\n\n          if (this.config.failFast && result.status === 'fail' && config.severity === 'error') {\n            break;\n          }\n        }\n      }\n\n      // Calculate overall validation result\n      const validation = this.calculateCommitValidation(results);\n      \n      // Cache results for performance\n      this.cacheResults(results);\n      \n      // Send notifications if needed\n      if (!validation.isValid || validation.issues.length > 0) {\n        await this.sendNotifications(validation, results);\n      }\n\n      // Log summary\n      this.logQualitySummary(results, Date.now() - startTime);\n\n      return validation;\n\n    } catch (error) {\n      return {\n        isValid: false,\n        score: 0,\n        issues: [{\n          file: 'system',\n          rule: 'pre_commit_error',\n          severity: 'error',\n          message: error instanceof Error ? error.message : 'Unknown error',\n          fixable: false,\n          category: 'lint',\n        }],\n        suggestions: ['Check pre-commit configuration', 'Verify tool availability'],\n        bypassable: false,\n      };\n    }\n  }\n\n  /**\n   * Auto-fix issues where possible\n   */\n  async autoFixIssues(stagedFiles: string[]): Promise<{\n    fixed: number;\n    remaining: QualityIssue[];\n  }> {\n    let totalFixed = 0;\n    const remainingIssues: QualityIssue[] = [];\n\n    for (const [checkName, config] of Object.entries(this.config.checks)) {\n      if (!config.enabled || !config.autofix) continue;\n\n      const hook = this.hooks.get(checkName);\n      if (!hook?.autofix) continue;\n\n      try {\n        const result = await hook.autofix(stagedFiles, config);\n        totalFixed += result.fixed;\n        remainingIssues.push(...result.remaining);\n      } catch (error) {\n        console.warn(`Auto-fix failed for ${checkName}:`, error);\n      }\n    }\n\n    return { fixed: totalFixed, remaining: remainingIssues };\n  }\n\n  /**\n   * Validate commit message format\n   */\n  validateCommitMessage(message: string): QualityCheckResult {\n    const issues: QualityIssue[] = [];\n    const patterns = {\n      conventional: /^(feat|fix|docs|style|refactor|test|chore|ci|perf|build|revert)(\\(.+\\))?: .{1,50}/,\n      length: /^.{1,72}$/,\n      capitalization: /^[A-Z]/,\n    };\n\n    // Check conventional commit format\n    if (!patterns.conventional.test(message)) {\n      issues.push({\n        file: 'commit-message',\n        rule: 'conventional-commits',\n        severity: 'warning',\n        message: 'Commit message should follow conventional commits format',\n        fixable: false,\n        category: 'style',\n      });\n    }\n\n    // Check length\n    const firstLine = message.split('\\n')[0] || '';\n    if (!patterns.length.test(firstLine)) {\n      issues.push({\n        file: 'commit-message',\n        rule: 'message-length',\n        severity: 'warning',\n        message: 'Commit message first line should be 1-72 characters',\n        fixable: false,\n        category: 'style',\n      });\n    }\n\n    return {\n      check: 'commitMessage',\n      status: issues.length === 0 ? 'pass' : 'warning',\n      duration: 0,\n      details: {\n        filesChecked: 1,\n        issues,\n        autoFixed: 0,\n        warnings: [],\n      },\n    };\n  }\n\n  /**\n   * Check file sizes\n   */\n  async checkFileSizes(files: string[]): Promise<QualityCheckResult> {\n    const issues: QualityIssue[] = [];\n    const maxSizes = {\n      '.js': 100 * 1024,   // 100KB\n      '.ts': 100 * 1024,   // 100KB\n      '.tsx': 100 * 1024,  // 100KB\n      '.jsx': 100 * 1024,  // 100KB\n      '.json': 10 * 1024,  // 10KB\n      '.md': 50 * 1024,    // 50KB\n    };\n\n    for (const file of files) {\n      try {\n        const fs = await import('fs');\n        const stats = await fs.promises.stat(file);\n        const ext = file.substring(file.lastIndexOf('.'));\n        const maxSize = maxSizes[ext as keyof typeof maxSizes];\n        \n        if (maxSize && stats.size > maxSize) {\n          issues.push({\n            file,\n            rule: 'file-size',\n            severity: 'warning',\n            message: `File size ${Math.round(stats.size / 1024)}KB exceeds limit ${Math.round(maxSize / 1024)}KB`,\n            fixable: false,\n            category: 'style',\n          });\n        }\n      } catch (error) {\n        // File might not exist or be readable, skip\n      }\n    }\n\n    return {\n      check: 'fileSize',\n      status: issues.length === 0 ? 'pass' : 'warning',\n      duration: 0,\n      details: {\n        filesChecked: files.length,\n        issues,\n        autoFixed: 0,\n        warnings: [],\n      },\n    };\n  }\n\n  /**\n   * Generate quality report\n   */\n  generateQualityReport(results: QualityCheckResult[]): {\n    summary: {\n      totalChecks: number;\n      passed: number;\n      failed: number;\n      warnings: number;\n      score: number;\n    };\n    details: QualityCheckResult[];\n    recommendations: string[];\n  } {\n    const passed = results.filter(r => r.status === 'pass').length;\n    const failed = results.filter(r => r.status === 'fail').length;\n    const warnings = results.filter(r => r.status === 'warning').length;\n    \n    const score = Math.round((passed / results.length) * 100);\n    \n    const recommendations: string[] = [];\n    \n    if (failed > 0) {\n      recommendations.push('Fix critical issues before committing');\n    }\n    \n    if (warnings > 0) {\n      recommendations.push('Consider addressing warnings to improve code quality');\n    }\n\n    const securityIssues = results.some(r => \n      r.details.issues.some(i => i.category === 'security')\n    );\n    \n    if (securityIssues) {\n      recommendations.push('Review and fix security vulnerabilities immediately');\n    }\n\n    return {\n      summary: {\n        totalChecks: results.length,\n        passed,\n        failed,\n        warnings,\n        score,\n      },\n      details: results,\n      recommendations,\n    };\n  }\n\n  private async runQualityCheck(\n    name: string,\n    config: QualityCheckConfig,\n    files: string[]\n  ): Promise<QualityCheckResult> {\n    const startTime = Date.now();\n    const hook = this.hooks.get(name);\n    \n    if (!hook) {\n      return {\n        check: name,\n        status: 'skipped',\n        duration: 0,\n        details: {\n          filesChecked: 0,\n          issues: [],\n          autoFixed: 0,\n          warnings: [`No hook registered for ${name}`],\n        },\n      };\n    }\n\n    try {\n      const result = await Promise.race([\n        hook.execute(files, config),\n        new Promise<QualityCheckResult>((_, reject) =>\n          setTimeout(() => reject(new Error('Timeout')), config.timeout)\n        ),\n      ]);\n\n      result.duration = Date.now() - startTime;\n      return result;\n    } catch (error) {\n      return {\n        check: name,\n        status: 'fail',\n        duration: Date.now() - startTime,\n        details: {\n          filesChecked: files.length,\n          issues: [{\n            file: 'system',\n            rule: 'execution_error',\n            severity: 'error',\n            message: error instanceof Error ? error.message : 'Unknown error',\n            fixable: false,\n            category: 'lint',\n          }],\n          autoFixed: 0,\n          warnings: [],\n        },\n      };\n    }\n  }\n\n  private calculateCommitValidation(results: QualityCheckResult[]): CommitValidation {\n    const issues: QualityIssue[] = [];\n    const suggestions: string[] = [];\n    \n    let score = 100;\n    let hasErrors = false;\n\n    for (const result of results) {\n      issues.push(...result.details.issues);\n      \n      if (result.status === 'fail') {\n        const errorIssues = result.details.issues.filter(i => i.severity === 'error');\n        if (errorIssues.length > 0) {\n          hasErrors = true;\n          score -= errorIssues.length * 10;\n        }\n      }\n      \n      if (result.status === 'warning') {\n        score -= result.details.issues.length * 2;\n      }\n    }\n\n    score = Math.max(0, score);\n\n    if (hasErrors) {\n      suggestions.push('Fix all error-level issues before committing');\n    }\n    \n    if (issues.some(i => i.fixable)) {\n      suggestions.push('Run auto-fix to resolve fixable issues');\n    }\n\n    return {\n      isValid: !hasErrors,\n      score,\n      issues,\n      suggestions,\n      bypassable: !hasErrors && issues.every(i => i.severity !== 'error'),\n    };\n  }\n\n  private cacheResults(results: QualityCheckResult[]): void {\n    const cacheKey = `quality_${Date.now()}`;\n    this.cache.set(cacheKey, {\n      check: 'summary',\n      status: results.every(r => r.status === 'pass') ? 'pass' : 'fail',\n      duration: results.reduce((sum, r) => sum + r.duration, 0),\n      details: {\n        filesChecked: Math.max(...results.map(r => r.details.filesChecked)),\n        issues: results.flatMap(r => r.details.issues),\n        autoFixed: results.reduce((sum, r) => sum + r.details.autoFixed, 0),\n        warnings: results.flatMap(r => r.details.warnings),\n      },\n    });\n    \n    // Keep only last 10 results\n    if (this.cache.size > 10) {\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey !== undefined) {\n        this.cache.delete(firstKey);\n      }\n    }\n  }\n\n  private async sendNotifications(\n    validation: CommitValidation,\n    results: QualityCheckResult[]\n  ): Promise<void> {\n    if (!validation.isValid && this.config.notifications.slack) {\n      // Send Slack notification for failed commits\n      const message = this.formatSlackMessage(validation, results);\n      await this.sendSlackNotification(message);\n    }\n  }\n\n  private formatSlackMessage(\n    validation: CommitValidation,\n    _results: QualityCheckResult[]\n  ): string {\n    const errorCount = validation.issues.filter(i => i.severity === 'error').length;\n    const warningCount = validation.issues.filter(i => i.severity === 'warning').length;\n    \n    return ` Pre-commit Quality Check Failed\nScore: ${validation.score}/100\nErrors: ${errorCount}\nWarnings: ${warningCount}\nStatus: ${validation.isValid ? ' Passed' : ' Failed'}`;\n  }\n\n  private async sendSlackNotification(message: string): Promise<void> {\n    // Implementation would depend on Slack webhook integration\n    console.log('Slack notification:', message);\n  }\n\n  private logQualitySummary(results: QualityCheckResult[], duration: number): void {\n    console.log('\\n Quality Check Summary');\n    console.log(''.repeat(50));\n    \n    for (const result of results) {\n      const icon = result.status === 'pass' ? '' : \n                   result.status === 'fail' ? '' : \n                   result.status === 'warning' ? '' : '';\n      \n      console.log(`${icon} ${result.check}: ${result.status} (${result.duration}ms)`);\n      \n      if (result.details.issues.length > 0) {\n        result.details.issues.forEach(issue => {\n          console.log(`    ${issue.file}: ${issue.message}`);\n        });\n      }\n    }\n    \n    console.log(''.repeat(50));\n    console.log(`Total duration: ${duration}ms`);\n  }\n\n  private initializeDefaultHooks(): void {\n    // ESLint hook\n    this.hooks.set('lint', {\n      execute: async (files, _config) => ({\n        check: 'lint',\n        status: 'pass',\n        duration: 0,\n        details: { filesChecked: files.length, issues: [], autoFixed: 0, warnings: [] },\n      }),\n      autofix: async (_files, _config) => ({ fixed: 0, remaining: [] }),\n    });\n\n    // Prettier hook\n    this.hooks.set('format', {\n      execute: async (files, _config) => ({\n        check: 'format',\n        status: 'pass',\n        duration: 0,\n        details: { filesChecked: files.length, issues: [], autoFixed: 0, warnings: [] },\n      }),\n      autofix: async (_files, _config) => ({ fixed: 0, remaining: [] }),\n    });\n\n    // TypeScript hook\n    this.hooks.set('typecheck', {\n      execute: async (files, _config) => ({\n        check: 'typecheck',\n        status: 'pass',\n        duration: 0,\n        details: { filesChecked: files.length, issues: [], autoFixed: 0, warnings: [] },\n      }),\n    });\n\n    // Jest/Test hook\n    this.hooks.set('test', {\n      execute: async (files, _config) => ({\n        check: 'test',\n        status: 'pass',\n        duration: 0,\n        details: { filesChecked: files.length, issues: [], autoFixed: 0, warnings: [] },\n      }),\n    });\n\n    // Security audit hook\n    this.hooks.set('security', {\n      execute: async (files, _config) => ({\n        check: 'security',\n        status: 'pass',\n        duration: 0,\n        details: { filesChecked: files.length, issues: [], autoFixed: 0, warnings: [] },\n      }),\n    });\n\n    // Dependency check hook\n    this.hooks.set('dependencies', {\n      execute: async (files, _config) => ({\n        check: 'dependencies',\n        status: 'pass',\n        duration: 0,\n        details: { filesChecked: files.length, issues: [], autoFixed: 0, warnings: [] },\n      }),\n    });\n  }\n}\n\nexport interface QualityHook {\n  execute(files: string[], config: QualityCheckConfig): Promise<QualityCheckResult>;\n  autofix?(files: string[], config: QualityCheckConfig): Promise<{\n    fixed: number;\n    remaining: QualityIssue[];\n  }>;\n}","/**\n * CI/CD Pipeline Management for A-Cube SDK\n * Automated build, test, and deployment workflows\n */\n\nexport interface CICDConfig {\n  enabled: boolean;\n  provider: 'github' | 'gitlab' | 'azure' | 'jenkins' | 'custom';\n  environment: 'development' | 'staging' | 'production';\n  pipelines: {\n    build: PipelineConfig;\n    test: PipelineConfig;\n    security: PipelineConfig;\n    deploy: PipelineConfig;\n    release: PipelineConfig;\n  };\n  notifications: {\n    slack?: { webhook: string; channels: string[] };\n    email?: { recipients: string[]; templates: Record<string, string> };\n    teams?: { webhook: string };\n  };\n  artifacts: {\n    retention: number; // days\n    storage: 'local' | 's3' | 'azure' | 'gcs';\n    encryption: boolean;\n  };\n}\n\nexport interface PipelineConfig {\n  enabled: boolean;\n  trigger: 'push' | 'pr' | 'schedule' | 'manual';\n  schedule?: string; // cron format\n  timeout: number; // minutes\n  retries: number;\n  parallel: boolean;\n  steps: PipelineStep[];\n  conditions?: PipelineCondition[];\n}\n\nexport interface PipelineStep {\n  name: string;\n  type: 'command' | 'script' | 'action' | 'docker' | 'deploy';\n  command?: string;\n  script?: string;\n  action?: string;\n  dockerfile?: string;\n  environment?: Record<string, string>;\n  workingDirectory?: string;\n  continueOnError: boolean;\n  timeout: number;\n  retries: number;\n  cache?: {\n    key: string;\n    paths: string[];\n  };\n}\n\nexport interface PipelineCondition {\n  type: 'branch' | 'tag' | 'file_changed' | 'env_var' | 'custom';\n  pattern: string;\n  exclude?: string[];\n}\n\nexport interface PipelineRun {\n  id: string;\n  pipelineType: string;\n  status: 'pending' | 'running' | 'success' | 'failure' | 'cancelled';\n  trigger: string;\n  branch: string;\n  commit: string;\n  startedAt: number;\n  completedAt?: number;\n  duration?: number;\n  steps: PipelineStepResult[];\n  artifacts: ArtifactInfo[];\n  metrics: PipelineMetrics;\n}\n\nexport interface PipelineStepResult {\n  name: string;\n  status: 'pending' | 'running' | 'success' | 'failure' | 'skipped';\n  startedAt: number;\n  completedAt?: number;\n  duration?: number;\n  exitCode?: number;\n  output?: string;\n  error?: string;\n  retryCount: number;\n}\n\nexport interface ArtifactInfo {\n  name: string;\n  path: string;\n  size: number;\n  type: 'build' | 'test' | 'coverage' | 'security' | 'docs';\n  url?: string;\n  expiresAt: number;\n}\n\nexport interface PipelineMetrics {\n  buildTime: number;\n  testCoverage: number;\n  codeQuality: number;\n  securityScore: number;\n  bundleSize: number;\n  performance: {\n    loadTime: number;\n    memoryUsage: number;\n    cpuUsage: number;\n  };\n}\n\nexport interface DeploymentConfig {\n  environment: string;\n  strategy: 'rolling' | 'blue_green' | 'canary' | 'recreate';\n  replicas: number;\n  healthChecks: {\n    enabled: boolean;\n    path: string;\n    timeout: number;\n    interval: number;\n    retries: number;\n  };\n  rollback: {\n    enabled: boolean;\n    triggers: string[];\n    timeout: number;\n  };\n  secrets: Record<string, string>;\n}\n\nexport class CICDManager {\n  private config: CICDConfig;\n  private runs = new Map<string, PipelineRun>();\n  private deployments = new Map<string, DeploymentConfig>();\n\n  constructor(config?: Partial<CICDConfig>) {\n    this.config = {\n      enabled: true,\n      provider: 'github',\n      environment: 'development',\n      pipelines: {\n        build: this.getDefaultBuildPipeline(),\n        test: this.getDefaultTestPipeline(),\n        security: this.getDefaultSecurityPipeline(),\n        deploy: this.getDefaultDeployPipeline(),\n        release: this.getDefaultReleasePipeline(),\n      },\n      notifications: {},\n      artifacts: {\n        retention: 30,\n        storage: 'local',\n        encryption: true,\n      },\n      ...config,\n    };\n\n    // Configuration initialized\n  }\n\n  /**\n   * Trigger pipeline execution\n   */\n  async triggerPipeline(\n    type: keyof CICDConfig['pipelines'],\n    context: {\n      branch: string;\n      commit: string;\n      trigger: string;\n      author?: string;\n      message?: string;\n    }\n  ): Promise<string> {\n    if (!this.config.enabled) {\n      throw new Error('CI/CD is disabled');\n    }\n\n    const pipeline = this.config.pipelines[type];\n    if (!pipeline.enabled) {\n      throw new Error(`Pipeline ${type} is disabled`);\n    }\n\n    // Check conditions\n    if (!this.evaluateConditions(pipeline.conditions || [], context)) {\n      throw new Error(`Pipeline conditions not met for ${type}`);\n    }\n\n    const runId = this.generateRunId();\n    const run: PipelineRun = {\n      id: runId,\n      pipelineType: type,\n      status: 'pending',\n      trigger: context.trigger,\n      branch: context.branch,\n      commit: context.commit,\n      startedAt: Date.now(),\n      steps: pipeline.steps.map(step => ({\n        name: step.name,\n        status: 'pending',\n        startedAt: 0,\n        retryCount: 0,\n      })),\n      artifacts: [],\n      metrics: this.initializeMetrics(),\n    };\n\n    this.runs.set(runId, run);\n\n    // Execute pipeline asynchronously\n    this.executePipeline(runId, pipeline).catch(error => {\n      console.error(`Pipeline ${runId} failed:`, error);\n      run.status = 'failure';\n      run.completedAt = Date.now();\n    });\n\n    return runId;\n  }\n\n  /**\n   * Get pipeline run status\n   */\n  getPipelineRun(runId: string): PipelineRun | undefined {\n    return this.runs.get(runId);\n  }\n\n  /**\n   * List pipeline runs with filtering\n   */\n  listPipelineRuns(filter?: {\n    type?: string;\n    status?: string;\n    branch?: string;\n    since?: number;\n    limit?: number;\n  }): PipelineRun[] {\n    let runs = Array.from(this.runs.values());\n\n    if (filter) {\n      if (filter.type) {\n        runs = runs.filter(r => r.pipelineType === filter.type);\n      }\n      if (filter.status) {\n        runs = runs.filter(r => r.status === filter.status);\n      }\n      if (filter.branch) {\n        runs = runs.filter(r => r.branch === filter.branch);\n      }\n      if (filter.since) {\n        runs = runs.filter(r => r.startedAt >= filter.since!);\n      }\n    }\n\n    runs.sort((a, b) => b.startedAt - a.startedAt);\n\n    if (filter?.limit) {\n      runs = runs.slice(0, filter.limit);\n    }\n\n    return runs;\n  }\n\n  /**\n   * Cancel running pipeline\n   */\n  async cancelPipeline(runId: string): Promise<void> {\n    const run = this.runs.get(runId);\n    if (!run) {\n      throw new Error(`Pipeline run ${runId} not found`);\n    }\n\n    if (run.status !== 'running') {\n      throw new Error(`Pipeline ${runId} is not running`);\n    }\n\n    run.status = 'cancelled';\n    run.completedAt = Date.now();\n    run.duration = run.completedAt - run.startedAt;\n\n    await this.sendNotification('pipeline_cancelled', run);\n  }\n\n  /**\n   * Deploy to environment\n   */\n  async deployToEnvironment(\n    environment: string,\n    deploymentConfig: DeploymentConfig,\n    artifacts: ArtifactInfo[]\n  ): Promise<string> {\n    const deploymentId = this.generateRunId();\n    \n    try {\n      // Validate deployment config\n      await this.validateDeployment(deploymentConfig);\n      \n      // Execute deployment strategy\n      await this.executeDeploymentStrategy(deploymentConfig, artifacts);\n      \n      // Run health checks\n      await this.runHealthChecks(deploymentConfig);\n      \n      // Store deployment info\n      this.deployments.set(deploymentId, deploymentConfig);\n      \n      await this.sendNotification('deployment_success', {\n        deploymentId,\n        environment,\n        strategy: deploymentConfig.strategy,\n      });\n\n      return deploymentId;\n    } catch (error) {\n      await this.sendNotification('deployment_failure', {\n        deploymentId,\n        environment,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Generate CI/CD workflow files\n   */\n  generateWorkflowFiles(): Record<string, string> {\n    const workflows: Record<string, string> = {};\n\n    switch (this.config.provider) {\n      case 'github':\n        workflows['.github/workflows/ci.yml'] = this.generateGitHubWorkflow();\n        workflows['.github/workflows/release.yml'] = this.generateGitHubReleaseWorkflow();\n        break;\n      \n      case 'gitlab':\n        workflows['.gitlab-ci.yml'] = this.generateGitLabWorkflow();\n        break;\n      \n      case 'azure':\n        workflows['azure-pipelines.yml'] = this.generateAzureWorkflow();\n        break;\n    }\n\n    return workflows;\n  }\n\n  /**\n   * Get pipeline metrics and analytics\n   */\n  getPipelineMetrics(timeRange: number = 30 * 24 * 60 * 60 * 1000): {\n    summary: {\n      totalRuns: number;\n      successRate: number;\n      averageDuration: number;\n      failureReasons: Record<string, number>;\n    };\n    trends: {\n      buildTimes: Array<{ date: number; duration: number }>;\n      successRates: Array<{ date: number; rate: number }>;\n      deploymentFrequency: Array<{ date: number; count: number }>;\n    };\n    quality: {\n      testCoverage: number;\n      codeQuality: number;\n      securityScore: number;\n    };\n  } {\n    const cutoff = Date.now() - timeRange;\n    const recentRuns = Array.from(this.runs.values())\n      .filter(r => r.startedAt >= cutoff);\n\n    const totalRuns = recentRuns.length;\n    const successfulRuns = recentRuns.filter(r => r.status === 'success').length;\n    const successRate = totalRuns > 0 ? (successfulRuns / totalRuns) * 100 : 0;\n    \n    const completedRuns = recentRuns.filter(r => r.duration);\n    const averageDuration = completedRuns.length > 0\n      ? completedRuns.reduce((sum, r) => sum + (r.duration || 0), 0) / completedRuns.length\n      : 0;\n\n    const failureReasons: Record<string, number> = {};\n    recentRuns\n      .filter(r => r.status === 'failure')\n      .forEach(r => {\n        const reason = this.extractFailureReason(r);\n        failureReasons[reason] = (failureReasons[reason] || 0) + 1;\n      });\n\n    return {\n      summary: {\n        totalRuns,\n        successRate,\n        averageDuration,\n        failureReasons,\n      },\n      trends: {\n        buildTimes: this.generateBuildTimeTrend(recentRuns),\n        successRates: this.generateSuccessRateTrend(recentRuns),\n        deploymentFrequency: this.generateDeploymentFrequency(recentRuns),\n      },\n      quality: {\n        testCoverage: this.calculateAverageMetric(recentRuns, 'testCoverage'),\n        codeQuality: this.calculateAverageMetric(recentRuns, 'codeQuality'),\n        securityScore: this.calculateAverageMetric(recentRuns, 'securityScore'),\n      },\n    };\n  }\n\n  private async executePipeline(runId: string, pipeline: PipelineConfig): Promise<void> {\n    const run = this.runs.get(runId)!;\n    run.status = 'running';\n\n    await this.sendNotification('pipeline_started', run);\n\n    try {\n      if (pipeline.parallel) {\n        // Execute steps in parallel\n        await Promise.all(\n          pipeline.steps.map((step, index) => \n            this.executeStep(run, step, index)\n          )\n        );\n      } else {\n        // Execute steps sequentially\n        for (let i = 0; i < pipeline.steps.length; i++) {\n          const step = pipeline.steps[i];\n          if (step) {\n            await this.executeStep(run, step, i);\n          }\n          \n          const stepResult = run.steps[i];\n          if (stepResult?.status === 'failure' && !step?.continueOnError) {\n            throw new Error(`Step ${stepResult.name} failed`);\n          }\n        }\n      }\n\n      run.status = 'success';\n      await this.sendNotification('pipeline_success', run);\n    } catch (error) {\n      run.status = 'failure';\n      await this.sendNotification('pipeline_failure', run);\n      throw error;\n    } finally {\n      run.completedAt = Date.now();\n      run.duration = run.completedAt - run.startedAt;\n    }\n  }\n\n  private async executeStep(\n    run: PipelineRun,\n    step: PipelineStep,\n    index: number\n  ): Promise<void> {\n    const stepResult = run.steps[index];\n    if (!stepResult) {\n      throw new Error(`Step result not found at index ${index}`);\n    }\n\n    stepResult.status = 'running';\n    stepResult.startedAt = Date.now();\n\n    let retries = 0;\n    while (retries <= step.retries) {\n      try {\n        switch (step.type) {\n          case 'command':\n            await this.executeCommand(step.command!, step.environment);\n            break;\n          case 'script':\n            await this.executeScript(step.script!, step.environment);\n            break;\n          case 'docker':\n            await this.executeDocker(step.dockerfile!, step.environment);\n            break;\n          default:\n            throw new Error(`Unsupported step type: ${step.type}`);\n        }\n\n        stepResult.status = 'success';\n        stepResult.exitCode = 0;\n        break;\n      } catch (error) {\n        retries++;\n        stepResult.retryCount = retries;\n        stepResult.error = error instanceof Error ? error.message : 'Unknown error';\n\n        if (retries > step.retries) {\n          stepResult.status = 'failure';\n          stepResult.exitCode = 1;\n          break;\n        }\n      }\n    }\n\n    stepResult.completedAt = Date.now();\n    stepResult.duration = stepResult.completedAt - stepResult.startedAt;\n  }\n\n  private async executeCommand(command: string, env?: Record<string, string>): Promise<void> {\n    // Mock command execution\n    console.log(`Executing command: ${command}`, env ? `with env: ${Object.keys(env).length} vars` : '');\n    await new Promise(resolve => setTimeout(resolve, 1000));\n  }\n\n  private async executeScript(script: string, env?: Record<string, string>): Promise<void> {\n    // Mock script execution\n    console.log(`Executing script: ${script}`, env ? `with env: ${Object.keys(env).length} vars` : '');\n    await new Promise(resolve => setTimeout(resolve, 2000));\n  }\n\n  private async executeDocker(dockerfile: string, env?: Record<string, string>): Promise<void> {\n    // Mock docker execution\n    console.log(`Building docker image from: ${dockerfile}`, env ? `with env: ${Object.keys(env).length} vars` : '');\n    await new Promise(resolve => setTimeout(resolve, 5000));\n  }\n\n  private evaluateConditions(\n    conditions: PipelineCondition[],\n    context: { branch: string; commit: string }\n  ): boolean {\n    return conditions.every(condition => {\n      switch (condition.type) {\n        case 'branch':\n          return new RegExp(condition.pattern).test(context.branch);\n        case 'tag':\n          return new RegExp(condition.pattern).test(context.commit);\n        default:\n          return true;\n      }\n    });\n  }\n\n  private async validateDeployment(config: DeploymentConfig): Promise<void> {\n    if (config.replicas < 1) {\n      throw new Error('Deployment must have at least 1 replica');\n    }\n    \n    if (config.healthChecks.enabled && !config.healthChecks.path) {\n      throw new Error('Health check path is required when health checks are enabled');\n    }\n  }\n\n  private async executeDeploymentStrategy(\n    config: DeploymentConfig,\n    artifacts: ArtifactInfo[]\n  ): Promise<void> {\n    switch (config.strategy) {\n      case 'rolling':\n        await this.executeRollingDeployment(config, artifacts);\n        break;\n      case 'blue_green':\n        await this.executeBlueGreenDeployment(config, artifacts);\n        break;\n      case 'canary':\n        await this.executeCanaryDeployment(config, artifacts);\n        break;\n      default:\n        throw new Error(`Unsupported deployment strategy: ${config.strategy}`);\n    }\n  }\n\n  private async executeRollingDeployment(\n    config: DeploymentConfig,\n    artifacts: ArtifactInfo[]\n  ): Promise<void> {\n    console.log(`Executing rolling deployment for ${config.environment} with ${artifacts.length} artifacts...`);\n    await new Promise(resolve => setTimeout(resolve, 3000));\n  }\n\n  private async executeBlueGreenDeployment(\n    config: DeploymentConfig,\n    artifacts: ArtifactInfo[]\n  ): Promise<void> {\n    console.log(`Executing blue-green deployment for ${config.environment} with ${artifacts.length} artifacts...`);\n    await new Promise(resolve => setTimeout(resolve, 5000));\n  }\n\n  private async executeCanaryDeployment(\n    config: DeploymentConfig,\n    artifacts: ArtifactInfo[]\n  ): Promise<void> {\n    console.log(`Executing canary deployment for ${config.environment} with ${artifacts.length} artifacts...`);\n    await new Promise(resolve => setTimeout(resolve, 4000));\n  }\n\n  private async runHealthChecks(config: DeploymentConfig): Promise<void> {\n    if (!config.healthChecks.enabled) return;\n\n    console.log(`Running health checks on ${config.healthChecks.path}...`);\n    await new Promise(resolve => setTimeout(resolve, 2000));\n  }\n\n  private async sendNotification(type: string, data: any): Promise<void> {\n    console.log(`Notification [${type}]:`, data);\n  }\n\n  private generateGitHubWorkflow(): string {\n    return `name: CI\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    strategy:\n      matrix:\n        node-version: [18.x, 20.x]\n    \n    steps:\n    - uses: actions/checkout@v4\n    - name: Use Node.js \\${{ matrix.node-version }}\n      uses: actions/setup-node@v4\n      with:\n        node-version: \\${{ matrix.node-version }}\n        cache: 'npm'\n    \n    - run: npm ci\n    - run: npm run build\n    - run: npm run lint\n    - run: npm run test\n    - run: npm run typecheck\n    \n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n      if: matrix.node-version == '20.x'`;\n  }\n\n  private generateGitHubReleaseWorkflow(): string {\n    return `name: Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v4\n    - uses: actions/setup-node@v4\n      with:\n        node-version: '20.x'\n        registry-url: 'https://registry.npmjs.org'\n    \n    - run: npm ci\n    - run: npm run build\n    - run: npm run test\n    - run: npm publish\n      env:\n        NODE_AUTH_TOKEN: \\${{ secrets.NPM_TOKEN }}`;\n  }\n\n  private generateGitLabWorkflow(): string {\n    return `stages:\n  - test\n  - build\n  - deploy\n\nvariables:\n  NODE_VERSION: \"20.x\"\n\ncache:\n  paths:\n    - node_modules/\n\ntest:\n  stage: test\n  image: node:\\${NODE_VERSION}\n  script:\n    - npm ci\n    - npm run lint\n    - npm run test\n    - npm run typecheck\n  coverage: '/Lines\\\\s*:\\\\s*(\\\\d+\\\\.?\\\\d*)%/'\n\nbuild:\n  stage: build\n  image: node:\\${NODE_VERSION}\n  script:\n    - npm ci\n    - npm run build\n  artifacts:\n    paths:\n      - dist/`;\n  }\n\n  private generateAzureWorkflow(): string {\n    return `trigger:\n- main\n- develop\n\npool:\n  vmImage: 'ubuntu-latest'\n\nvariables:\n  nodeVersion: '20.x'\n\nsteps:\n- task: NodeTool@0\n  inputs:\n    versionSpec: '\\$(nodeVersion)'\n  displayName: 'Install Node.js'\n\n- script: |\n    npm ci\n    npm run build\n    npm run lint\n    npm run test\n  displayName: 'Build and Test'`;\n  }\n\n  private getDefaultBuildPipeline(): PipelineConfig {\n    return {\n      enabled: true,\n      trigger: 'push',\n      timeout: 30,\n      retries: 1,\n      parallel: false,\n      steps: [\n        {\n          name: 'Install Dependencies',\n          type: 'command',\n          command: 'npm ci',\n          continueOnError: false,\n          timeout: 10,\n          retries: 2,\n        },\n        {\n          name: 'Build',\n          type: 'command',\n          command: 'npm run build',\n          continueOnError: false,\n          timeout: 15,\n          retries: 1,\n        },\n      ],\n    };\n  }\n\n  private getDefaultTestPipeline(): PipelineConfig {\n    return {\n      enabled: true,\n      trigger: 'push',\n      timeout: 20,\n      retries: 1,\n      parallel: true,\n      steps: [\n        {\n          name: 'Lint',\n          type: 'command',\n          command: 'npm run lint',\n          continueOnError: false,\n          timeout: 5,\n          retries: 0,\n        },\n        {\n          name: 'Type Check',\n          type: 'command',\n          command: 'npm run typecheck',\n          continueOnError: false,\n          timeout: 10,\n          retries: 0,\n        },\n        {\n          name: 'Unit Tests',\n          type: 'command',\n          command: 'npm run test',\n          continueOnError: false,\n          timeout: 15,\n          retries: 1,\n        },\n      ],\n    };\n  }\n\n  private getDefaultSecurityPipeline(): PipelineConfig {\n    return {\n      enabled: true,\n      trigger: 'push',\n      timeout: 15,\n      retries: 0,\n      parallel: true,\n      steps: [\n        {\n          name: 'Security Audit',\n          type: 'command',\n          command: 'npm audit',\n          continueOnError: true,\n          timeout: 5,\n          retries: 0,\n        },\n        {\n          name: 'Dependency Check',\n          type: 'command',\n          command: 'npm run security:check',\n          continueOnError: true,\n          timeout: 10,\n          retries: 0,\n        },\n      ],\n    };\n  }\n\n  private getDefaultDeployPipeline(): PipelineConfig {\n    return {\n      enabled: false,\n      trigger: 'manual',\n      timeout: 60,\n      retries: 0,\n      parallel: false,\n      steps: [\n        {\n          name: 'Deploy to Staging',\n          type: 'deploy',\n          continueOnError: false,\n          timeout: 30,\n          retries: 1,\n        },\n      ],\n    };\n  }\n\n  private getDefaultReleasePipeline(): PipelineConfig {\n    return {\n      enabled: false,\n      trigger: 'manual',\n      timeout: 30,\n      retries: 0,\n      parallel: false,\n      steps: [\n        {\n          name: 'Create Release',\n          type: 'command',\n          command: 'npm run release',\n          continueOnError: false,\n          timeout: 20,\n          retries: 0,\n        },\n      ],\n    };\n  }\n\n  private initializeMetrics(): PipelineMetrics {\n    return {\n      buildTime: 0,\n      testCoverage: 0,\n      codeQuality: 0,\n      securityScore: 0,\n      bundleSize: 0,\n      performance: {\n        loadTime: 0,\n        memoryUsage: 0,\n        cpuUsage: 0,\n      },\n    };\n  }\n\n\n  private generateRunId(): string {\n    return `run_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private extractFailureReason(run: PipelineRun): string {\n    const failedStep = run.steps.find(s => s.status === 'failure');\n    return failedStep?.error || 'Unknown failure';\n  }\n\n  private generateBuildTimeTrend(runs: PipelineRun[]): Array<{ date: number; duration: number }> {\n    return runs\n      .filter(r => r.duration)\n      .map(r => ({ date: r.startedAt, duration: r.duration! }))\n      .sort((a, b) => a.date - b.date);\n  }\n\n  private generateSuccessRateTrend(runs: PipelineRun[]): Array<{ date: number; rate: number }> {\n    // Group by day and calculate success rate\n    const grouped = new Map<string, { total: number; success: number }>();\n    \n    runs.forEach(r => {\n      const day = new Date(r.startedAt).toDateString();\n      const stats = grouped.get(day) || { total: 0, success: 0 };\n      stats.total++;\n      if (r.status === 'success') stats.success++;\n      grouped.set(day, stats);\n    });\n\n    return Array.from(grouped.entries()).map(([day, stats]) => ({\n      date: new Date(day).getTime(),\n      rate: (stats.success / stats.total) * 100,\n    }));\n  }\n\n  private generateDeploymentFrequency(runs: PipelineRun[]): Array<{ date: number; count: number }> {\n    const deployments = runs.filter(r => r.pipelineType === 'deploy');\n    const grouped = new Map<string, number>();\n    \n    deployments.forEach(r => {\n      const day = new Date(r.startedAt).toDateString();\n      grouped.set(day, (grouped.get(day) || 0) + 1);\n    });\n\n    return Array.from(grouped.entries()).map(([day, count]) => ({\n      date: new Date(day).getTime(),\n      count,\n    }));\n  }\n\n  private calculateAverageMetric(runs: PipelineRun[], metric: keyof PipelineMetrics): number {\n    const values = runs\n      .map(r => r.metrics[metric])\n      .filter(v => typeof v === 'number' && v > 0) as number[];\n    \n    return values.length > 0 ? values.reduce((sum, v) => sum + v, 0) / values.length : 0;\n  }\n}","/**\n * Dependency Management for A-Cube SDK\n * Automated dependency updates, security scanning, and license compliance\n */\n\nexport interface DependencyConfig {\n  enabled: boolean;\n  scanSchedule: string; // cron format\n  autoUpdate: {\n    enabled: boolean;\n    policy: 'patch' | 'minor' | 'major' | 'custom';\n    excludePatterns: string[];\n    requireApproval: boolean;\n  };\n  security: {\n    scanVulnerabilities: boolean;\n    allowedSeverities: ('low' | 'moderate' | 'high' | 'critical')[];\n    autoFixSecurityIssues: boolean;\n    reportingThreshold: 'low' | 'moderate' | 'high' | 'critical';\n  };\n  license: {\n    scanLicenses: boolean;\n    allowedLicenses: string[];\n    blockedLicenses: string[];\n    requireApproval: string[];\n  };\n  monitoring: {\n    trackUsage: boolean;\n    detectUnused: boolean;\n    bundleSizeTracking: boolean;\n    performanceImpact: boolean;\n  };\n}\n\nexport interface DependencyInfo {\n  name: string;\n  version: string;\n  type: 'dependency' | 'devDependency' | 'peerDependency' | 'optionalDependency';\n  license: string;\n  repository?: string;\n  homepage?: string;\n  description?: string;\n  size: {\n    bundled: number;\n    unpacked: number;\n  };\n  usage: {\n    imported: boolean;\n    lastUsed: number;\n    importCount: number;\n    files: string[];\n  };\n  security: {\n    vulnerabilities: SecurityVulnerability[];\n    riskScore: number;\n    lastScanned: number;\n  };\n  updates: {\n    current: string;\n    latest: string;\n    wanted: string;\n    type: 'patch' | 'minor' | 'major';\n    breaking: boolean;\n    changelog?: string;\n  };\n}\n\nexport interface SecurityVulnerability {\n  id: string;\n  title: string;\n  description: string;\n  severity: 'low' | 'moderate' | 'high' | 'critical';\n  cvss: number;\n  cwe: string[];\n  references: string[];\n  vulnerableVersions: string;\n  patchedVersions: string;\n  publishedAt: number;\n  updatedAt: number;\n}\n\nexport interface DependencyReport {\n  timestamp: number;\n  summary: {\n    total: number;\n    outdated: number;\n    vulnerable: number;\n    unused: number;\n    licenseIssues: number;\n  };\n  dependencies: DependencyInfo[];\n  vulnerabilities: SecurityVulnerability[];\n  recommendations: DependencyRecommendation[];\n  metrics: {\n    bundleSize: number;\n    loadTime: number;\n    securityScore: number;\n    licenseCompliance: number;\n  };\n}\n\nexport interface DependencyRecommendation {\n  type: 'update' | 'remove' | 'replace' | 'add' | 'security_fix';\n  package: string;\n  current?: string;\n  recommended?: string;\n  reason: string;\n  impact: 'low' | 'medium' | 'high';\n  breaking: boolean;\n  effort: 'low' | 'medium' | 'high';\n  benefits: string[];\n  risks: string[];\n}\n\nexport interface UpdatePlan {\n  id: string;\n  createdAt: number;\n  updates: Array<{\n    package: string;\n    from: string;\n    to: string;\n    type: 'patch' | 'minor' | 'major';\n    breaking: boolean;\n    reason: string;\n  }>;\n  strategy: 'all_at_once' | 'incremental' | 'critical_first';\n  testingRequired: boolean;\n  approvalRequired: boolean;\n  estimatedRisk: 'low' | 'medium' | 'high';\n}\n\nexport class DependencyManager {\n  private config: DependencyConfig;\n  // private _dependencies = new Map<string, DependencyInfo>();\n  private vulnerabilities = new Map<string, SecurityVulnerability>();\n  private updatePlans = new Map<string, UpdatePlan>();\n  private scanHistory: DependencyReport[] = [];\n\n  constructor(config?: Partial<DependencyConfig>) {\n    this.config = {\n      enabled: true,\n      scanSchedule: '0 2 * * 1', // Weekly on Monday at 2 AM\n      autoUpdate: {\n        enabled: false,\n        policy: 'patch',\n        excludePatterns: [],\n        requireApproval: true,\n      },\n      security: {\n        scanVulnerabilities: true,\n        allowedSeverities: ['low', 'moderate'],\n        autoFixSecurityIssues: false,\n        reportingThreshold: 'moderate',\n      },\n      license: {\n        scanLicenses: true,\n        allowedLicenses: ['MIT', 'Apache-2.0', 'BSD-3-Clause', 'ISC'],\n        blockedLicenses: ['GPL-3.0', 'AGPL-3.0'],\n        requireApproval: ['LGPL-2.1', 'MPL-2.0'],\n      },\n      monitoring: {\n        trackUsage: true,\n        detectUnused: true,\n        bundleSizeTracking: true,\n        performanceImpact: true,\n      },\n      ...config,\n    };\n  }\n\n  /**\n   * Scan all dependencies for updates, vulnerabilities, and compliance\n   */\n  async scanDependencies(): Promise<DependencyReport> {\n    if (!this.config.enabled) {\n      throw new Error('Dependency management is disabled');\n    }\n\n    const startTime = Date.now();\n    console.log(' Starting dependency scan...');\n\n    try {\n      // Load package.json and lock files\n      const packageInfo = await this.loadPackageInfo();\n      \n      // Scan for updates\n      const updateInfo = await this.scanForUpdates(packageInfo);\n      \n      // Scan for vulnerabilities\n      const vulnerabilityInfo = await this.scanVulnerabilities(packageInfo);\n      \n      // Check license compliance\n      const licenseInfo = await this.scanLicenses(packageInfo);\n      \n      // Analyze usage patterns\n      const usageInfo = await this.analyzeUsage(packageInfo);\n      \n      // Generate recommendations\n      const recommendations = await this.generateRecommendations(\n        updateInfo,\n        vulnerabilityInfo,\n        licenseInfo,\n        usageInfo\n      );\n\n      // Create report\n      const report: DependencyReport = {\n        timestamp: Date.now(),\n        summary: {\n          total: packageInfo.length,\n          outdated: updateInfo.filter(d => d.updates.current !== d.updates.latest).length,\n          vulnerable: vulnerabilityInfo.filter(d => d.security.vulnerabilities.length > 0).length,\n          unused: usageInfo.filter(d => !d.usage.imported).length,\n          licenseIssues: licenseInfo.filter(d => this.hasLicenseIssue(d)).length,\n        },\n        dependencies: this.mergeDependencyInfo(packageInfo, updateInfo, vulnerabilityInfo, licenseInfo, usageInfo),\n        vulnerabilities: Array.from(this.vulnerabilities.values()),\n        recommendations,\n        metrics: await this.calculateMetrics(),\n      };\n\n      // Store in history\n      this.scanHistory.push(report);\n      if (this.scanHistory.length > 10) {\n        this.scanHistory = this.scanHistory.slice(-10);\n      }\n\n      console.log(` Dependency scan completed in ${Date.now() - startTime}ms`);\n      this.logScanSummary(report);\n\n      return report;\n    } catch (error) {\n      console.error(' Dependency scan failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create update plan for dependencies\n   */\n  async createUpdatePlan(\n    packages?: string[],\n    strategy: UpdatePlan['strategy'] = 'incremental'\n  ): Promise<string> {\n    const report = await this.scanDependencies();\n    \n    const outdatedDeps = report.dependencies.filter(d => \n      d.updates.current !== d.updates.latest &&\n      (!packages || packages.includes(d.name))\n    );\n\n    const updates = outdatedDeps.map(dep => ({\n      package: dep.name,\n      from: dep.updates.current,\n      to: dep.updates.latest,\n      type: dep.updates.type,\n      breaking: dep.updates.breaking,\n      reason: this.getUpdateReason(dep),\n    }));\n\n    const plan: UpdatePlan = {\n      id: this.generatePlanId(),\n      createdAt: Date.now(),\n      updates,\n      strategy,\n      testingRequired: updates.some(u => u.type === 'major' || u.breaking),\n      approvalRequired: this.config.autoUpdate.requireApproval || updates.some(u => u.breaking),\n      estimatedRisk: this.calculatePlanRisk(updates),\n    };\n\n    this.updatePlans.set(plan.id, plan);\n    return plan.id;\n  }\n\n  /**\n   * Execute update plan\n   */\n  async executeUpdatePlan(planId: string): Promise<{\n    success: boolean;\n    updated: string[];\n    failed: Array<{ package: string; error: string }>;\n  }> {\n    const plan = this.updatePlans.get(planId);\n    if (!plan) {\n      throw new Error(`Update plan ${planId} not found`);\n    }\n\n    const updated: string[] = [];\n    const failed: Array<{ package: string; error: string }> = [];\n\n    for (const update of plan.updates) {\n      try {\n        await this.updatePackage(update.package, update.to);\n        updated.push(update.package);\n        console.log(` Updated ${update.package} from ${update.from} to ${update.to}`);\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        failed.push({ package: update.package, error: errorMessage });\n        console.error(` Failed to update ${update.package}:`, errorMessage);\n      }\n    }\n\n    return {\n      success: failed.length === 0,\n      updated,\n      failed,\n    };\n  }\n\n  /**\n   * Fix security vulnerabilities\n   */\n  async fixSecurityVulnerabilities(autoApprove: boolean = false): Promise<{\n    fixed: string[];\n    failed: Array<{ package: string; error: string }>;\n    requiresManualReview: string[];\n  }> {\n    const report = await this.scanDependencies();\n    const vulnerableDeps = report.dependencies.filter(d => \n      d.security.vulnerabilities.length > 0\n    );\n\n    const fixed: string[] = [];\n    const failed: Array<{ package: string; error: string }> = [];\n    const requiresManualReview: string[] = [];\n\n    for (const dep of vulnerableDeps) {\n      const criticalVulns = dep.security.vulnerabilities.filter(v => v.severity === 'critical');\n      const canAutoFix = this.config.security.autoFixSecurityIssues || autoApprove;\n\n      if (criticalVulns.length > 0 && !canAutoFix) {\n        requiresManualReview.push(dep.name);\n        continue;\n      }\n\n      try {\n        // Try to update to a patched version\n        const patchedVersion = this.findPatchedVersion(dep);\n        if (patchedVersion) {\n          await this.updatePackage(dep.name, patchedVersion);\n          fixed.push(dep.name);\n        } else {\n          requiresManualReview.push(dep.name);\n        }\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        failed.push({ package: dep.name, error: errorMessage });\n      }\n    }\n\n    return { fixed, failed, requiresManualReview };\n  }\n\n  /**\n   * Remove unused dependencies\n   */\n  async removeUnusedDependencies(): Promise<{\n    removed: string[];\n    kept: Array<{ package: string; reason: string }>;\n  }> {\n    const report = await this.scanDependencies();\n    const unusedDeps = report.dependencies.filter(d => \n      !d.usage.imported && d.type === 'dependency'\n    );\n\n    const removed: string[] = [];\n    const kept: Array<{ package: string; reason: string }> = [];\n\n    for (const dep of unusedDeps) {\n      // Check if it's a peer dependency or has special handling\n      if (this.shouldKeepPackage(dep)) {\n        kept.push({\n          package: dep.name,\n          reason: this.getKeepReason(dep),\n        });\n        continue;\n      }\n\n      try {\n        await this.removePackage(dep.name);\n        removed.push(dep.name);\n        console.log(` Removed unused dependency: ${dep.name}`);\n      } catch (error) {\n        console.error(` Failed to remove ${dep.name}:`, error);\n      }\n    }\n\n    return { removed, kept };\n  }\n\n  /**\n   * Get dependency metrics and trends\n   */\n  getDependencyMetrics(): {\n    current: DependencyReport['metrics'];\n    trends: {\n      bundleSize: Array<{ date: number; size: number }>;\n      vulnerabilities: Array<{ date: number; count: number }>;\n      outdated: Array<{ date: number; count: number }>;\n    };\n  } {\n    const latest = this.scanHistory[this.scanHistory.length - 1];\n    \n    return {\n      current: latest?.metrics || {\n        bundleSize: 0,\n        loadTime: 0,\n        securityScore: 100,\n        licenseCompliance: 100,\n      },\n      trends: {\n        bundleSize: this.scanHistory.map(r => ({\n          date: r.timestamp,\n          size: r.metrics.bundleSize,\n        })),\n        vulnerabilities: this.scanHistory.map(r => ({\n          date: r.timestamp,\n          count: r.summary.vulnerable,\n        })),\n        outdated: this.scanHistory.map(r => ({\n          date: r.timestamp,\n          count: r.summary.outdated,\n        })),\n      },\n    };\n  }\n\n  private async loadPackageInfo(): Promise<DependencyInfo[]> {\n    // Mock implementation - would read package.json and lock files\n    return [\n      {\n        name: 'react',\n        version: '18.2.0',\n        type: 'dependency',\n        license: 'MIT',\n        size: { bundled: 42000, unpacked: 120000 },\n        usage: { imported: true, lastUsed: Date.now(), importCount: 5, files: ['src/index.ts'] },\n        security: { vulnerabilities: [], riskScore: 0, lastScanned: Date.now() },\n        updates: { current: '18.2.0', latest: '18.2.0', wanted: '18.2.0', type: 'patch', breaking: false },\n      },\n      {\n        name: 'lodash',\n        version: '4.17.20',\n        type: 'dependency',\n        license: 'MIT',\n        size: { bundled: 70000, unpacked: 280000 },\n        usage: { imported: false, lastUsed: 0, importCount: 0, files: [] },\n        security: { vulnerabilities: [], riskScore: 0, lastScanned: Date.now() },\n        updates: { current: '4.17.20', latest: '4.17.21', wanted: '4.17.21', type: 'patch', breaking: false },\n      },\n    ];\n  }\n\n  private async scanForUpdates(dependencies: DependencyInfo[]): Promise<DependencyInfo[]> {\n    // Mock implementation - would check npm registry for updates\n    return dependencies.map(dep => ({\n      ...dep,\n      updates: {\n        ...dep.updates,\n        // Simulate some outdated packages\n        latest: dep.name === 'lodash' ? '4.17.21' : dep.updates.latest,\n      },\n    }));\n  }\n\n  private async scanVulnerabilities(dependencies: DependencyInfo[]): Promise<DependencyInfo[]> {\n    // Mock implementation - would use npm audit or similar\n    return dependencies;\n  }\n\n  private async scanLicenses(dependencies: DependencyInfo[]): Promise<DependencyInfo[]> {\n    // Mock implementation - would check license compatibility\n    return dependencies;\n  }\n\n  private async analyzeUsage(dependencies: DependencyInfo[]): Promise<DependencyInfo[]> {\n    // Mock implementation - would analyze import statements\n    return dependencies;\n  }\n\n  private async generateRecommendations(\n    ..._dependencyArrays: DependencyInfo[][]\n  ): Promise<DependencyRecommendation[]> {\n    const recommendations: DependencyRecommendation[] = [];\n    \n    // Example recommendation for unused dependency\n    recommendations.push({\n      type: 'remove',\n      package: 'lodash',\n      reason: 'Package is not imported in any source files',\n      impact: 'low',\n      breaking: false,\n      effort: 'low',\n      benefits: ['Reduce bundle size', 'Remove security surface'],\n      risks: ['May be used dynamically'],\n    });\n\n    return recommendations;\n  }\n\n  private mergeDependencyInfo(...arrays: DependencyInfo[][]): DependencyInfo[] {\n    // Merge dependency information from different scans\n    return arrays[0] || [];\n  }\n\n  private async calculateMetrics(): Promise<DependencyReport['metrics']> {\n    return {\n      bundleSize: 512000, // 512KB\n      loadTime: 250, // 250ms\n      securityScore: 95,\n      licenseCompliance: 100,\n    };\n  }\n\n  private hasLicenseIssue(dep: DependencyInfo): boolean {\n    return this.config.license.blockedLicenses.includes(dep.license) ||\n           this.config.license.requireApproval.includes(dep.license);\n  }\n\n  private getUpdateReason(dep: DependencyInfo): string {\n    if (dep.security.vulnerabilities.length > 0) {\n      return 'Security vulnerability fix';\n    }\n    if (dep.updates.type === 'patch') {\n      return 'Bug fixes and improvements';\n    }\n    if (dep.updates.type === 'minor') {\n      return 'New features and improvements';\n    }\n    return 'Major version update';\n  }\n\n  private calculatePlanRisk(updates: UpdatePlan['updates']): UpdatePlan['estimatedRisk'] {\n    const hasBreaking = updates.some(u => u.breaking);\n    const hasMajor = updates.some(u => u.type === 'major');\n    \n    if (hasBreaking || hasMajor) return 'high';\n    if (updates.some(u => u.type === 'minor')) return 'medium';\n    return 'low';\n  }\n\n  private async updatePackage(name: string, version: string): Promise<void> {\n    // Mock implementation - would run npm/yarn update command\n    console.log(`Updating ${name} to ${version}...`);\n    await new Promise(resolve => setTimeout(resolve, 1000));\n  }\n\n  private async removePackage(name: string): Promise<void> {\n    // Mock implementation - would run npm/yarn remove command\n    console.log(`Removing ${name}...`);\n    await new Promise(resolve => setTimeout(resolve, 500));\n  }\n\n  private findPatchedVersion(dep: DependencyInfo): string | null {\n    // Mock implementation - would find the latest patched version\n    return dep.updates.latest;\n  }\n\n  private shouldKeepPackage(dep: DependencyInfo): boolean {\n    // Check if package should be kept despite appearing unused\n    const keepPatterns = ['@types/', 'eslint-', 'babel-', 'webpack-'];\n    return keepPatterns.some(pattern => dep.name.includes(pattern));\n  }\n\n  private getKeepReason(dep: DependencyInfo): string {\n    if (dep.name.startsWith('@types/')) return 'TypeScript type definitions';\n    if (dep.name.includes('eslint')) return 'ESLint configuration';\n    if (dep.name.includes('babel')) return 'Babel configuration';\n    if (dep.name.includes('webpack')) return 'Webpack configuration';\n    return 'Build tool dependency';\n  }\n\n  private generatePlanId(): string {\n    return `plan_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private logScanSummary(report: DependencyReport): void {\n    console.log('\\n Dependency Scan Summary');\n    console.log(''.repeat(40));\n    console.log(`Total dependencies: ${report.summary.total}`);\n    console.log(`Outdated: ${report.summary.outdated}`);\n    console.log(`Vulnerable: ${report.summary.vulnerable}`);\n    console.log(`Unused: ${report.summary.unused}`);\n    console.log(`License issues: ${report.summary.licenseIssues}`);\n    console.log(`Security score: ${report.metrics.securityScore}/100`);\n    console.log(`Bundle size: ${Math.round(report.metrics.bundleSize / 1024)}KB`);\n    console.log(''.repeat(40));\n  }\n}","/**\n * Quality Automation System for A-Cube SDK\n * Complete suite of quality gates, CI/CD, and dependency management\n */\n\nimport {\n  PreCommitManager,\n  type QualityGateConfig,\n  type QualityCheckConfig,\n  type QualityCheckResult,\n  type QualityIssue,\n  type CommitValidation,\n  type QualityHook,\n} from './pre-commit';\n\nimport {\n  CICDManager,\n  type CICDConfig,\n  type PipelineConfig,\n  type PipelineStep,\n  type PipelineRun,\n  type DeploymentConfig,\n  type PipelineMetrics,\n  type ArtifactInfo,\n} from './ci-cd';\n\nimport {\n  DependencyManager,\n  type DependencyConfig,\n  type DependencyInfo,\n  type DependencyReport,\n  type SecurityVulnerability,\n  type DependencyRecommendation,\n  type UpdatePlan,\n} from './dependency-management';\n\nexport {\n  PreCommitManager,\n  type QualityGateConfig,\n  type QualityCheckConfig,\n  type QualityCheckResult,\n  type QualityIssue,\n  type CommitValidation,\n  type QualityHook,\n  CICDManager,\n  type CICDConfig,\n  type PipelineConfig,\n  type PipelineStep,\n  type PipelineRun,\n  type DeploymentConfig,\n  type PipelineMetrics,\n  type ArtifactInfo,\n  DependencyManager,\n  type DependencyConfig,\n  type DependencyInfo,\n  type DependencyReport,\n  type SecurityVulnerability,\n  type DependencyRecommendation,\n  type UpdatePlan,\n};\n\n/**\n * Comprehensive Quality Manager\n * Integrates all quality automation components into a unified interface\n */\nexport class QualityManager {\n  private preCommit: PreCommitManager;\n  private cicd: CICDManager;\n  private dependencies: DependencyManager;\n\n  constructor(config?: {\n    preCommit?: Partial<QualityGateConfig>;\n    cicd?: Partial<CICDConfig>;\n    dependencies?: Partial<DependencyConfig>;\n  }) {\n    this.preCommit = new PreCommitManager(config?.preCommit);\n    this.cicd = new CICDManager(config?.cicd);\n    this.dependencies = new DependencyManager(config?.dependencies);\n  }\n\n  /**\n   * Get pre-commit manager\n   */\n  getPreCommit(): PreCommitManager {\n    return this.preCommit;\n  }\n\n  /**\n   * Get CI/CD manager\n   */\n  getCICD(): CICDManager {\n    return this.cicd;\n  }\n\n  /**\n   * Get dependency manager\n   */\n  getDependencies(): DependencyManager {\n    return this.dependencies;\n  }\n\n  /**\n   * Initialize quality automation with default configurations\n   */\n  async initialize(): Promise<{\n    preCommitEnabled: boolean;\n    cicdEnabled: boolean;\n    dependenciesEnabled: boolean;\n    workflowFiles: Record<string, string>;\n  }> {\n    // Generate CI/CD workflow files\n    const workflowFiles = this.cicd.generateWorkflowFiles();\n\n    // Run initial dependency scan\n    await this.dependencies.scanDependencies();\n\n    return {\n      preCommitEnabled: true,\n      cicdEnabled: true,\n      dependenciesEnabled: true,\n      workflowFiles,\n    };\n  }\n\n  /**\n   * Run complete quality check for commit\n   */\n  async runQualityCheck(\n    stagedFiles: string[],\n    commitMessage: string\n  ): Promise<{\n    validation: CommitValidation;\n    dependencyReport?: DependencyReport;\n    recommendations: string[];\n  }> {\n    const recommendations: string[] = [];\n\n    // Run pre-commit checks\n    const validation = await this.preCommit.runPreCommitChecks(stagedFiles);\n\n    // Validate commit message\n    const commitValidation = this.preCommit.validateCommitMessage(commitMessage);\n    if (commitValidation.status !== 'pass') {\n      validation.issues.push(...commitValidation.details.issues);\n    }\n\n    // Run dependency scan if package files changed\n    let dependencyReport: DependencyReport | undefined;\n    const packageFilesChanged = stagedFiles.some(file => \n      file.includes('package.json') || \n      file.includes('package-lock.json') || \n      file.includes('yarn.lock')\n    );\n\n    if (packageFilesChanged) {\n      dependencyReport = await this.dependencies.scanDependencies();\n      \n      if (dependencyReport.summary.vulnerable > 0) {\n        recommendations.push('Fix security vulnerabilities before committing');\n      }\n      \n      if (dependencyReport.summary.outdated > 5) {\n        recommendations.push('Consider updating outdated dependencies');\n      }\n    }\n\n    // Generate overall recommendations\n    if (!validation.isValid) {\n      recommendations.push('Fix all quality issues before committing');\n    }\n\n    if (validation.issues.some(i => i.fixable)) {\n      recommendations.push('Run auto-fix to resolve fixable issues');\n    }\n\n    return {\n      validation,\n      ...(dependencyReport && { dependencyReport }),\n      recommendations,\n    };\n  }\n\n  /**\n   * Execute full CI/CD pipeline\n   */\n  async runFullPipeline(context: {\n    branch: string;\n    commit: string;\n    trigger: string;\n  }): Promise<{\n    buildRun?: string;\n    testRun?: string;\n    securityRun?: string;\n    deployRun?: string;\n  }> {\n    const results: Record<string, string> = {};\n\n    try {\n      // Trigger build pipeline\n      results.buildRun = await this.cicd.triggerPipeline('build', context);\n\n      // Trigger test pipeline\n      results.testRun = await this.cicd.triggerPipeline('test', context);\n\n      // Trigger security pipeline\n      results.securityRun = await this.cicd.triggerPipeline('security', context);\n\n      // Trigger deploy pipeline (if on main branch)\n      if (context.branch === 'main' || context.branch === 'master') {\n        results.deployRun = await this.cicd.triggerPipeline('deploy', context);\n      }\n\n      return results;\n    } catch (error) {\n      console.error('Pipeline execution failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Perform automated maintenance\n   */\n  async performMaintenance(): Promise<{\n    dependencyUpdates: {\n      planId?: string;\n      updated: string[];\n      failed: Array<{ package: string; error: string }>;\n    };\n    securityFixes: {\n      fixed: string[];\n      failed: Array<{ package: string; error: string }>;\n      requiresManualReview: string[];\n    };\n    cleanup: {\n      removed: string[];\n      kept: Array<{ package: string; reason: string }>;\n    };\n  }> {\n    console.log(' Starting automated maintenance...');\n\n    // Create and execute dependency update plan\n    const planId = await this.dependencies.createUpdatePlan(undefined, 'incremental');\n    const dependencyUpdates = await this.dependencies.executeUpdatePlan(planId);\n\n    // Fix security vulnerabilities\n    const securityFixes = await this.dependencies.fixSecurityVulnerabilities();\n\n    // Remove unused dependencies\n    const cleanup = await this.dependencies.removeUnusedDependencies();\n\n    console.log(' Automated maintenance completed');\n\n    return {\n      dependencyUpdates: { planId, ...dependencyUpdates },\n      securityFixes,\n      cleanup,\n    };\n  }\n\n  /**\n   * Generate comprehensive quality report\n   */\n  async generateQualityReport(): Promise<{\n    overview: {\n      qualityScore: number;\n      securityScore: number;\n      maintenanceScore: number;\n      recommendations: string[];\n    };\n    preCommit: {\n      checksEnabled: number;\n      lastRunTime?: number;\n      averageRunTime: number;\n    };\n    cicd: {\n      pipelineRuns: number;\n      successRate: number;\n      averageBuildTime: number;\n      deploymentFrequency: number;\n    };\n    dependencies: {\n      total: number;\n      outdated: number;\n      vulnerable: number;\n      unused: number;\n      bundleSize: number;\n    };\n    trends: {\n      qualityTrend: 'improving' | 'stable' | 'declining';\n      securityTrend: 'improving' | 'stable' | 'declining';\n      performanceTrend: 'improving' | 'stable' | 'declining';\n    };\n  }> {\n    // Get dependency metrics\n    const dependencyMetrics = this.dependencies.getDependencyMetrics();\n    \n    // Get CI/CD metrics\n    const cicdMetrics = this.cicd.getPipelineMetrics();\n\n    // Get latest dependency report\n    const dependencyReport = await this.dependencies.scanDependencies();\n\n    // Calculate overall scores\n    const qualityScore = this.calculateQualityScore(cicdMetrics, dependencyReport);\n    const securityScore = dependencyMetrics.current.securityScore;\n    const maintenanceScore = this.calculateMaintenanceScore(dependencyReport);\n\n    // Generate recommendations\n    const recommendations = this.generateQualityRecommendations(\n      qualityScore,\n      securityScore,\n      maintenanceScore,\n      dependencyReport\n    );\n\n    return {\n      overview: {\n        qualityScore,\n        securityScore,\n        maintenanceScore,\n        recommendations,\n      },\n      preCommit: {\n        checksEnabled: 8, // Number of enabled checks\n        averageRunTime: 30000, // 30 seconds\n      },\n      cicd: {\n        pipelineRuns: cicdMetrics.summary.totalRuns,\n        successRate: cicdMetrics.summary.successRate,\n        averageBuildTime: cicdMetrics.summary.averageDuration,\n        deploymentFrequency: cicdMetrics.trends.deploymentFrequency.length,\n      },\n      dependencies: {\n        total: dependencyReport.summary.total,\n        outdated: dependencyReport.summary.outdated,\n        vulnerable: dependencyReport.summary.vulnerable,\n        unused: dependencyReport.summary.unused,\n        bundleSize: dependencyReport.metrics.bundleSize,\n      },\n      trends: {\n        qualityTrend: this.calculateTrend(cicdMetrics.trends.successRates),\n        securityTrend: this.calculateTrend(dependencyMetrics.trends.vulnerabilities, true),\n        performanceTrend: this.calculateTrend(dependencyMetrics.trends.bundleSize, true),\n      },\n    };\n  }\n\n  /**\n   * Setup development environment with quality tools\n   */\n  async setupDevelopmentEnvironment(): Promise<{\n    configFiles: Record<string, string>;\n    scripts: Record<string, string>;\n    devDependencies: string[];\n  }> {\n    const configFiles: Record<string, string> = {\n      '.husky/pre-commit': this.generatePreCommitHook(),\n      '.eslintrc.js': this.generateESLintConfig(),\n      '.prettierrc': this.generatePrettierConfig(),\n      'jest.config.js': this.generateJestConfig(),\n      '.gitignore': this.generateGitIgnore(),\n      'commitlint.config.js': this.generateCommitLintConfig(),\n    };\n\n    const scripts: Record<string, string> = {\n      'lint': 'eslint src --ext .ts,.tsx,.js,.jsx',\n      'lint:fix': 'eslint src --ext .ts,.tsx,.js,.jsx --fix',\n      'format': 'prettier --write \"src/**/*.{ts,tsx,js,jsx,json,md}\"',\n      'typecheck': 'tsc --noEmit',\n      'test': 'jest',\n      'test:coverage': 'jest --coverage',\n      'test:watch': 'jest --watch',\n      'quality:check': 'npm run lint && npm run typecheck && npm run test',\n      'deps:audit': 'npm audit',\n      'deps:update': 'npm update',\n      'deps:outdated': 'npm outdated',\n    };\n\n    const devDependencies = [\n      '@typescript-eslint/eslint-plugin',\n      '@typescript-eslint/parser',\n      'eslint',\n      'eslint-config-prettier',\n      'eslint-plugin-prettier',\n      'prettier',\n      'husky',\n      'lint-staged',\n      '@commitlint/cli',\n      '@commitlint/config-conventional',\n      'jest',\n      '@types/jest',\n      'ts-jest',\n    ];\n\n    return { configFiles, scripts, devDependencies };\n  }\n\n  private calculateQualityScore(\n    cicdMetrics: ReturnType<CICDManager['getPipelineMetrics']>,\n    dependencyReport: DependencyReport\n  ): number {\n    const cicdScore = cicdMetrics.summary.successRate;\n    const dependencyScore = Math.max(0, 100 - (dependencyReport.summary.outdated * 2));\n    const securityScore = dependencyReport.metrics.securityScore;\n    \n    return Math.round((cicdScore + dependencyScore + securityScore) / 3);\n  }\n\n  private calculateMaintenanceScore(report: DependencyReport): number {\n    const outdatedPenalty = report.summary.outdated * 3;\n    const unusedPenalty = report.summary.unused * 2;\n    const vulnerabilityPenalty = report.summary.vulnerable * 5;\n    \n    return Math.max(0, 100 - outdatedPenalty - unusedPenalty - vulnerabilityPenalty);\n  }\n\n  private generateQualityRecommendations(\n    qualityScore: number,\n    securityScore: number,\n    maintenanceScore: number,\n    dependencyReport: DependencyReport\n  ): string[] {\n    const recommendations: string[] = [];\n\n    if (qualityScore < 80) {\n      recommendations.push('Improve CI/CD pipeline success rate');\n    }\n\n    if (securityScore < 90) {\n      recommendations.push('Address security vulnerabilities immediately');\n    }\n\n    if (maintenanceScore < 70) {\n      recommendations.push('Update outdated dependencies and remove unused packages');\n    }\n\n    if (dependencyReport.summary.vulnerable > 0) {\n      recommendations.push('Run automated security fixes');\n    }\n\n    if (dependencyReport.summary.unused > 5) {\n      recommendations.push('Clean up unused dependencies');\n    }\n\n    if (dependencyReport.metrics.bundleSize > 1024 * 1024) { // 1MB\n      recommendations.push('Optimize bundle size and consider code splitting');\n    }\n\n    return recommendations;\n  }\n\n  private calculateTrend(\n    data: Array<{ date: number; [key: string]: number }>,\n    inverse: boolean = false\n  ): 'improving' | 'stable' | 'declining' {\n    if (data.length < 2) return 'stable';\n\n    const recent = data.slice(-3);\n    const values = recent.map(d => Object.values(d).find(v => typeof v === 'number' && v !== d.date) as number);\n    \n    const trend = (values[values.length - 1] || 0) - (values[0] || 0);\n    const threshold = 5; // 5% change threshold\n\n    if (Math.abs(trend) < threshold) return 'stable';\n    \n    const isImproving = inverse ? trend < 0 : trend > 0;\n    return isImproving ? 'improving' : 'declining';\n  }\n\n  private generatePreCommitHook(): string {\n    return `#!/bin/sh\n. \"$(dirname \"$0\")/_/husky.sh\"\n\necho \" Running pre-commit quality checks...\"\nnpm run quality:check`;\n  }\n\n  private generateESLintConfig(): string {\n    return `module.exports = {\n  parser: '@typescript-eslint/parser',\n  extends: [\n    'eslint:recommended',\n    '@typescript-eslint/recommended',\n    'prettier',\n  ],\n  plugins: ['@typescript-eslint', 'prettier'],\n  rules: {\n    'prettier/prettier': 'error',\n    '@typescript-eslint/no-unused-vars': 'error',\n    '@typescript-eslint/no-explicit-any': 'warn',\n  },\n  env: {\n    node: true,\n    es2021: true,\n  },\n};`;\n  }\n\n  private generatePrettierConfig(): string {\n    return JSON.stringify({\n      semi: true,\n      trailingComma: 'es5',\n      singleQuote: true,\n      printWidth: 100,\n      tabWidth: 2,\n    }, null, 2);\n  }\n\n  private generateJestConfig(): string {\n    return `module.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  collectCoverageFrom: [\n    'src/**/*.{ts,tsx}',\n    '!src/**/*.d.ts',\n  ],\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 80,\n      lines: 80,\n      statements: 80,\n    },\n  },\n};`;\n  }\n\n  private generateGitIgnore(): string {\n    return `# Dependencies\nnode_modules/\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Build outputs\ndist/\nbuild/\n*.tsbuildinfo\n\n# Environment files\n.env\n.env.local\n.env.production\n\n# IDE files\n.vscode/\n.idea/\n*.swp\n*.swo\n\n# OS files\n.DS_Store\nThumbs.db\n\n# Test coverage\ncoverage/\n\n# Logs\nlogs/\n*.log`;\n  }\n\n  private generateCommitLintConfig(): string {\n    return `module.exports = {\n  extends: ['@commitlint/config-conventional'],\n  rules: {\n    'type-enum': [2, 'always', [\n      'feat', 'fix', 'docs', 'style', 'refactor',\n      'test', 'chore', 'ci', 'perf', 'build', 'revert'\n    ]],\n    'subject-max-length': [2, 'always', 72],\n  },\n};`;\n  }\n}\n\n/**\n * Quality automation utilities\n */\nexport const QualityUtils = {\n  /**\n   * Validate project structure for quality tools\n   */\n  validateProjectStructure(_projectPath: string): {\n    isValid: boolean;\n    missing: string[];\n    recommendations: string[];\n  } {\n    const requiredFiles = [\n      'package.json',\n      'tsconfig.json',\n      '.eslintrc.js',\n      '.prettierrc',\n      'jest.config.js',\n    ];\n\n    // Mock validation\n    const missing = requiredFiles.filter(_file => \n      Math.random() > 0.8 // Simulate some missing files\n    );\n\n    const recommendations: string[] = [];\n    if (missing.includes('.eslintrc.js')) {\n      recommendations.push('Setup ESLint for code quality');\n    }\n    if (missing.includes('.prettierrc')) {\n      recommendations.push('Setup Prettier for code formatting');\n    }\n    if (missing.includes('jest.config.js')) {\n      recommendations.push('Setup Jest for testing');\n    }\n\n    return {\n      isValid: missing.length === 0,\n      missing,\n      recommendations,\n    };\n  },\n\n  /**\n   * Generate quality gates configuration\n   */\n  generateQualityGatesConfig(\n    level: 'basic' | 'standard' | 'strict' = 'standard'\n  ): QualityGateConfig {\n    const configs = {\n      basic: {\n        enabled: true,\n        failFast: false,\n        parallel: true,\n        timeoutMs: 300000,\n        checks: {\n          lint: { enabled: true, severity: 'warning' as const, autofix: true, timeout: 60000 },\n          format: { enabled: true, severity: 'warning' as const, autofix: true, timeout: 30000 },\n          typecheck: { enabled: true, severity: 'error' as const, autofix: false, timeout: 120000 },\n          test: { enabled: false, severity: 'error' as const, autofix: false, timeout: 180000 },\n          security: { enabled: false, severity: 'warning' as const, autofix: false, timeout: 90000 },\n          dependencies: { enabled: false, severity: 'warning' as const, autofix: false, timeout: 60000 },\n          commitMessage: { enabled: true, severity: 'warning' as const, autofix: false, timeout: 5000 },\n          fileSize: { enabled: true, severity: 'warning' as const, autofix: false, timeout: 10000 },\n        },\n        notifications: {},\n      },\n      standard: {\n        enabled: true,\n        failFast: false,\n        parallel: true,\n        timeoutMs: 300000,\n        checks: {\n          lint: { enabled: true, severity: 'error' as const, autofix: true, timeout: 60000 },\n          format: { enabled: true, severity: 'warning' as const, autofix: true, timeout: 30000 },\n          typecheck: { enabled: true, severity: 'error' as const, autofix: false, timeout: 120000 },\n          test: { enabled: true, severity: 'error' as const, autofix: false, timeout: 180000 },\n          security: { enabled: true, severity: 'error' as const, autofix: false, timeout: 90000 },\n          dependencies: { enabled: true, severity: 'warning' as const, autofix: false, timeout: 60000 },\n          commitMessage: { enabled: true, severity: 'warning' as const, autofix: false, timeout: 5000 },\n          fileSize: { enabled: true, severity: 'warning' as const, autofix: false, timeout: 10000 },\n        },\n        notifications: {},\n      },\n      strict: {\n        enabled: true,\n        failFast: true,\n        parallel: false,\n        timeoutMs: 600000,\n        checks: {\n          lint: { enabled: true, severity: 'error' as const, autofix: false, timeout: 60000 },\n          format: { enabled: true, severity: 'error' as const, autofix: false, timeout: 30000 },\n          typecheck: { enabled: true, severity: 'error' as const, autofix: false, timeout: 120000 },\n          test: { enabled: true, severity: 'error' as const, autofix: false, timeout: 300000 },\n          security: { enabled: true, severity: 'error' as const, autofix: false, timeout: 180000 },\n          dependencies: { enabled: true, severity: 'error' as const, autofix: false, timeout: 120000 },\n          commitMessage: { enabled: true, severity: 'error' as const, autofix: false, timeout: 5000 },\n          fileSize: { enabled: true, severity: 'error' as const, autofix: false, timeout: 10000 },\n        },\n        notifications: {},\n      },\n    };\n\n    return configs[level];\n  },\n\n  /**\n   * Calculate quality score based on various metrics\n   */\n  calculateQualityScore(metrics: {\n    testCoverage: number;\n    lintErrors: number;\n    securityVulnerabilities: number;\n    outdatedDependencies: number;\n    codeComplexity: number;\n  }): {\n    score: number;\n    grade: 'A' | 'B' | 'C' | 'D' | 'F';\n    breakdown: Record<string, number>;\n  } {\n    const breakdown = {\n      testCoverage: Math.min(100, metrics.testCoverage),\n      codeQuality: Math.max(0, 100 - metrics.lintErrors * 2),\n      security: Math.max(0, 100 - metrics.securityVulnerabilities * 10),\n      maintenance: Math.max(0, 100 - metrics.outdatedDependencies * 3),\n      complexity: Math.max(0, 100 - metrics.codeComplexity),\n    };\n\n    const score = Math.round(\n      Object.values(breakdown).reduce((sum, value) => sum + value, 0) / 5\n    );\n\n    let grade: 'A' | 'B' | 'C' | 'D' | 'F';\n    if (score >= 90) grade = 'A';\n    else if (score >= 80) grade = 'B';\n    else if (score >= 70) grade = 'C';\n    else if (score >= 60) grade = 'D';\n    else grade = 'F';\n\n    return { score, grade, breakdown };\n  },\n};","/**\n * Background Sync Manager for A-Cube E-Receipt SDK\n * Advanced offline-first synchronization with intelligent retry strategies\n * \n * Features:\n * - Priority-based sync queue\n * - Conflict resolution strategies\n * - Delta sync optimization\n * - Batch synchronization\n * - Progress tracking\n * - Automatic retry with exponential backoff\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport type { HttpClient, HttpResponse } from '@/http/client';\nimport type { UnifiedStorage } from '@/storage/unified-storage';\nimport { createStorageKey } from '@/storage/unified-storage';\nimport { createStorage } from '@/storage/storage-factory';\n\n/**\n * Sync operation types\n */\nexport type SyncOperationType = 'create' | 'update' | 'delete' | 'batch';\n\n/**\n * Sync operation priority levels\n */\nexport type SyncPriority = 'critical' | 'high' | 'normal' | 'low';\n\n/**\n * Conflict resolution strategies\n */\nexport type ConflictStrategy = 'client-wins' | 'server-wins' | 'merge' | 'manual';\n\n/**\n * Sync operation status\n */\nexport type SyncStatus = 'pending' | 'syncing' | 'completed' | 'failed' | 'conflict';\n\n/**\n * Sync operation interface\n */\nexport interface SyncOperation {\n  id: string;\n  type: SyncOperationType;\n  priority: SyncPriority;\n  endpoint: string;\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n  data?: any;\n  headers?: Record<string, string>;\n  metadata: {\n    createdAt: Date;\n    updatedAt: Date;\n    attemptCount: number;\n    lastAttempt?: Date;\n    nextRetry?: Date;\n    userId?: string;\n    deviceId?: string;\n    checksum?: string;\n  };\n  status: SyncStatus;\n  error?: {\n    code: string;\n    message: string;\n    details?: any;\n  };\n  conflictData?: {\n    localVersion: any;\n    serverVersion: any;\n    strategy: ConflictStrategy;\n  };\n}\n\n/**\n * Sync batch interface\n */\nexport interface SyncBatch {\n  id: string;\n  operations: SyncOperation[];\n  priority: SyncPriority;\n  status: SyncStatus;\n  progress: {\n    total: number;\n    completed: number;\n    failed: number;\n    conflicts: number;\n  };\n  metadata: {\n    createdAt: Date;\n    startedAt?: Date;\n    completedAt?: Date;\n    duration?: number;\n  };\n}\n\n/**\n * Background sync configuration\n */\nexport interface BackgroundSyncConfig {\n  /** Maximum number of operations in queue */\n  maxQueueSize?: number;\n  \n  /** Maximum retry attempts per operation */\n  maxRetries?: number;\n  \n  /** Base retry delay in milliseconds */\n  baseRetryDelay?: number;\n  \n  /** Maximum retry delay in milliseconds */\n  maxRetryDelay?: number;\n  \n  /** Batch size for sync operations */\n  batchSize?: number;\n  \n  /** Enable delta sync optimization */\n  enableDeltaSync?: boolean;\n  \n  /** Enable compression for sync data */\n  enableCompression?: boolean;\n  \n  /** Conflict resolution strategy */\n  defaultConflictStrategy?: ConflictStrategy;\n  \n  /** Storage configuration */\n  storage?: {\n    adapter?: 'memory' | 'localStorage' | 'indexedDB' | 'reactNative';\n    encryptionKey?: string;\n  };\n  \n  /** Network detection */\n  networkDetection?: {\n    enabled?: boolean;\n    checkInterval?: number;\n    endpoints?: string[];\n  };\n}\n\n/**\n * Background sync events\n */\nexport interface BackgroundSyncEvents {\n  'sync:started': { batch: SyncBatch };\n  'sync:progress': { batch: SyncBatch; operation: SyncOperation };\n  'sync:completed': { batch: SyncBatch; duration: number };\n  'sync:failed': { batch: SyncBatch; error: Error };\n  'operation:queued': { operation: SyncOperation };\n  'operation:started': { operation: SyncOperation };\n  'operation:completed': { operation: SyncOperation; response: any };\n  'operation:failed': { operation: SyncOperation; error: Error };\n  'operation:conflict': { operation: SyncOperation; conflict: any };\n  'queue:full': { size: number; operation: SyncOperation };\n  'network:online': { timestamp: Date };\n  'network:offline': { timestamp: Date };\n}\n\n/**\n * Sync statistics\n */\nexport interface SyncStatistics {\n  totalOperations: number;\n  pendingOperations: number;\n  completedOperations: number;\n  failedOperations: number;\n  conflictedOperations: number;\n  averageSyncTime: number;\n  lastSyncTime?: Date;\n  nextSyncTime?: Date;\n  dataTransferred: {\n    uploaded: number;\n    downloaded: number;\n  };\n}\n\nconst DEFAULT_CONFIG: Required<BackgroundSyncConfig> = {\n  maxQueueSize: 5000,\n  maxRetries: 5,\n  baseRetryDelay: 5000,\n  maxRetryDelay: 300000, // 5 minutes\n  batchSize: 50,\n  enableDeltaSync: true,\n  enableCompression: true,\n  defaultConflictStrategy: 'server-wins',\n  storage: {\n    adapter: 'indexedDB' as const,\n  },\n  networkDetection: {\n    enabled: true,\n    checkInterval: 30000, // 30 seconds\n    endpoints: ['/health', '/ping'],\n  },\n};\n\n/**\n * Background Sync Manager\n * Handles offline-first synchronization with intelligent retry and conflict resolution\n */\nexport class BackgroundSyncManager extends EventEmitter<BackgroundSyncEvents> {\n  private config: Required<BackgroundSyncConfig>;\n  private storage: UnifiedStorage | null = null;\n  private httpClient: HttpClient;\n  private syncQueue: Map<string, SyncOperation> = new Map();\n  private activeBatch: SyncBatch | null = null;\n  private isOnline: boolean = navigator.onLine;\n  private isSyncing: boolean = false;\n  private networkCheckInterval?: NodeJS.Timeout;\n  private syncTimeout: NodeJS.Timeout | undefined = undefined;\n  private statistics: SyncStatistics = {\n    totalOperations: 0,\n    pendingOperations: 0,\n    completedOperations: 0,\n    failedOperations: 0,\n    conflictedOperations: 0,\n    averageSyncTime: 0,\n    dataTransferred: {\n      uploaded: 0,\n      downloaded: 0,\n    },\n  };\n\n  constructor(httpClient: HttpClient, config: BackgroundSyncConfig = {}) {\n    super();\n    this.httpClient = httpClient;\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    \n    this.setupEventListeners();\n    this.initialize();\n  }\n\n  /**\n   * Initialize the sync manager\n   */\n  private async initialize(): Promise<void> {\n    try {\n      // Initialize storage\n      this.storage = await createStorage({\n        preferredAdapter: this.config.storage.adapter === 'indexedDB' ? 'indexeddb' : \n                          this.config.storage.adapter === 'localStorage' ? 'localstorage' : 'auto',\n        encryption: { enabled: false },\n      });\n\n      // Load existing queue from storage\n      await this.loadQueueFromStorage();\n\n      // Start network monitoring\n      if (this.config.networkDetection.enabled) {\n        this.startNetworkMonitoring();\n      }\n\n      // Register for service worker sync if available\n      if ('serviceWorker' in navigator && 'sync' in ServiceWorkerRegistration.prototype) {\n        this.registerBackgroundSync();\n      }\n    } catch (error) {\n      console.error('Failed to initialize BackgroundSyncManager:', error);\n    }\n  }\n\n  /**\n   * Setup event listeners\n   */\n  private setupEventListeners(): void {\n    // Online/offline events\n    window.addEventListener('online', () => this.handleOnlineStatus(true));\n    window.addEventListener('offline', () => this.handleOnlineStatus(false));\n\n    // Page visibility for aggressive sync\n    document.addEventListener('visibilitychange', () => {\n      if (!document.hidden && this.isOnline && !this.isSyncing) {\n        this.syncNow();\n      }\n    });\n  }\n\n  /**\n   * Queue a sync operation\n   */\n  async queueOperation(\n    operation: Omit<SyncOperation, 'id' | 'metadata' | 'status'>\n  ): Promise<SyncOperation> {\n    // Check queue size limit\n    if (this.syncQueue.size >= this.config.maxQueueSize) {\n      const op = { ...operation, id: '', metadata: {}, status: 'pending' as SyncStatus };\n      this.emit('queue:full', { size: this.syncQueue.size, operation: op as SyncOperation });\n      throw new Error('Sync queue is full');\n    }\n\n    // Create sync operation\n    const userId = this.getCurrentUserId();\n    const syncOp: SyncOperation = {\n      ...operation,\n      id: this.generateOperationId(),\n      metadata: {\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        attemptCount: 0,\n        ...(userId ? { userId } : {}),\n        deviceId: this.getDeviceId(),\n        checksum: this.calculateChecksum(operation.data),\n      },\n      status: 'pending',\n    };\n\n    // Add to queue\n    this.syncQueue.set(syncOp.id, syncOp);\n    this.statistics.totalOperations++;\n    this.statistics.pendingOperations++;\n\n    // Persist to storage\n    await this.saveQueueToStorage();\n\n    // Emit event\n    this.emit('operation:queued', { operation: syncOp });\n\n    // Try to sync immediately if online\n    if (this.isOnline && !this.isSyncing) {\n      this.scheduleSyncWithDelay(0);\n    }\n\n    return syncOp;\n  }\n\n  /**\n   * Queue multiple operations as a batch\n   */\n  async queueBatch(\n    operations: Array<Omit<SyncOperation, 'id' | 'metadata' | 'status'>>,\n    priority: SyncPriority = 'normal'\n  ): Promise<SyncBatch> {\n    const batch: SyncBatch = {\n      id: this.generateBatchId(),\n      operations: [],\n      priority,\n      status: 'pending',\n      progress: {\n        total: operations.length,\n        completed: 0,\n        failed: 0,\n        conflicts: 0,\n      },\n      metadata: {\n        createdAt: new Date(),\n      },\n    };\n\n    // Queue all operations\n    for (const op of operations) {\n      try {\n        const syncOp = await this.queueOperation({ ...op, priority });\n        batch.operations.push(syncOp);\n      } catch (error) {\n        console.error('Failed to queue operation:', error);\n      }\n    }\n\n    return batch;\n  }\n\n  /**\n   * Start synchronization\n   */\n  async syncNow(): Promise<void> {\n    if (this.isSyncing || !this.isOnline) {\n      return;\n    }\n\n    this.isSyncing = true;\n\n    try {\n      // Get pending operations sorted by priority and creation time\n      const pendingOps = this.getPendingOperations();\n      \n      if (pendingOps.length === 0) {\n        this.isSyncing = false;\n        return;\n      }\n\n      // Create batch\n      const batch: SyncBatch = {\n        id: this.generateBatchId(),\n        operations: pendingOps.slice(0, this.config.batchSize),\n        priority: 'normal',\n        status: 'syncing',\n        progress: {\n          total: Math.min(pendingOps.length, this.config.batchSize),\n          completed: 0,\n          failed: 0,\n          conflicts: 0,\n        },\n        metadata: {\n          createdAt: new Date(),\n          startedAt: new Date(),\n        },\n      };\n\n      this.activeBatch = batch;\n      this.emit('sync:started', { batch });\n\n      // Process operations\n      for (const operation of batch.operations) {\n        try {\n          await this.processOperation(operation, batch);\n        } catch (error) {\n          console.error('Failed to process operation:', operation.id, error);\n        }\n      }\n\n      // Complete batch\n      batch.status = 'completed';\n      batch.metadata.completedAt = new Date();\n      batch.metadata.duration = batch.metadata.completedAt.getTime() - batch.metadata.startedAt!.getTime();\n\n      this.emit('sync:completed', { batch, duration: batch.metadata.duration });\n      this.statistics.lastSyncTime = new Date();\n\n    } catch (error) {\n      console.error('Sync failed:', error);\n      if (this.activeBatch) {\n        this.activeBatch.status = 'failed';\n        this.emit('sync:failed', { batch: this.activeBatch, error: error as Error });\n      }\n    } finally {\n      this.isSyncing = false;\n      this.activeBatch = null;\n      await this.saveQueueToStorage();\n      \n      // Schedule next sync if there are pending operations\n      if (this.statistics.pendingOperations > 0) {\n        this.scheduleNextSync();\n      }\n    }\n  }\n\n  /**\n   * Process a single sync operation\n   */\n  private async processOperation(operation: SyncOperation, batch: SyncBatch): Promise<void> {\n    operation.status = 'syncing';\n    operation.metadata.lastAttempt = new Date();\n    operation.metadata.attemptCount++;\n\n    this.emit('operation:started', { operation });\n    this.emit('sync:progress', { batch, operation });\n\n    try {\n      // Prepare request\n      const requestData = this.config.enableCompression \n        ? await this.compressData(operation.data)\n        : operation.data;\n\n      // Execute request\n      const response = await this.httpClient.request({\n        method: operation.method,\n        url: operation.endpoint,\n        data: requestData,\n        headers: {\n          ...operation.headers,\n          'X-Sync-Operation-Id': operation.id,\n          'X-Sync-Priority': operation.priority,\n          'X-Sync-Checksum': operation.metadata.checksum || '',\n        },\n      });\n\n      // Handle response\n      if (response.status >= 200 && response.status < 300) {\n        // Success\n        operation.status = 'completed';\n        this.syncQueue.delete(operation.id);\n        this.statistics.pendingOperations--;\n        this.statistics.completedOperations++;\n        batch.progress.completed++;\n\n        // Update data transferred statistics\n        this.updateDataTransferStats(operation, response);\n\n        this.emit('operation:completed', { operation, response: response.data });\n      } else if (response.status === 409) {\n        // Conflict\n        await this.handleConflict(operation, response, batch);\n      } else {\n        // Other errors\n        throw new Error(`Sync failed with status ${response.status}`);\n      }\n    } catch (error) {\n      await this.handleOperationError(operation, error as Error, batch);\n    }\n  }\n\n  /**\n   * Handle conflict resolution\n   */\n  private async handleConflict(\n    operation: SyncOperation,\n    response: HttpResponse<any>,\n    batch: SyncBatch\n  ): Promise<void> {\n    operation.status = 'conflict';\n    operation.conflictData = {\n      localVersion: operation.data,\n      serverVersion: response.data.serverVersion,\n      strategy: this.config.defaultConflictStrategy,\n    };\n\n    this.statistics.conflictedOperations++;\n    batch.progress.conflicts++;\n\n    this.emit('operation:conflict', { \n      operation, \n      conflict: operation.conflictData \n    });\n\n    // Apply conflict resolution strategy\n    switch (this.config.defaultConflictStrategy) {\n      case 'client-wins':\n        // Retry with force flag\n        operation.headers = {\n          ...operation.headers,\n          'X-Force-Update': 'true',\n        };\n        operation.status = 'pending';\n        operation.metadata.attemptCount = 0;\n        break;\n\n      case 'server-wins':\n        // Accept server version, remove from queue\n        operation.status = 'completed';\n        this.syncQueue.delete(operation.id);\n        this.statistics.pendingOperations--;\n        break;\n\n      case 'merge':\n        // Attempt to merge changes\n        const mergedData = await this.mergeConflict(\n          operation.conflictData.localVersion,\n          operation.conflictData.serverVersion\n        );\n        operation.data = mergedData;\n        operation.status = 'pending';\n        operation.metadata.attemptCount = 0;\n        break;\n\n      case 'manual':\n        // Keep in queue for manual resolution\n        break;\n    }\n  }\n\n  /**\n   * Handle operation error\n   */\n  private async handleOperationError(\n    operation: SyncOperation,\n    error: Error,\n    batch: SyncBatch\n  ): Promise<void> {\n    operation.error = {\n      code: 'SYNC_ERROR',\n      message: error.message,\n      details: error,\n    };\n\n    // Check retry eligibility\n    if (operation.metadata.attemptCount < this.config.maxRetries) {\n      // Calculate next retry time with exponential backoff\n      const delay = Math.min(\n        this.config.baseRetryDelay * Math.pow(2, operation.metadata.attemptCount - 1),\n        this.config.maxRetryDelay\n      );\n      \n      operation.metadata.nextRetry = new Date(Date.now() + delay);\n      operation.status = 'pending';\n      \n      this.emit('operation:failed', { operation, error });\n    } else {\n      // Max retries exceeded\n      operation.status = 'failed';\n      this.statistics.failedOperations++;\n      batch.progress.failed++;\n      \n      // Remove from queue\n      this.syncQueue.delete(operation.id);\n      this.statistics.pendingOperations--;\n      \n      this.emit('operation:failed', { operation, error });\n    }\n  }\n\n  /**\n   * Get pending operations sorted by priority\n   */\n  private getPendingOperations(): SyncOperation[] {\n    const now = new Date();\n    const pendingOps = Array.from(this.syncQueue.values())\n      .filter(op => {\n        if (op.status !== 'pending') return false;\n        if (op.metadata.nextRetry && op.metadata.nextRetry > now) return false;\n        return true;\n      });\n\n    // Sort by priority and creation time\n    return pendingOps.sort((a, b) => {\n      const priorityOrder = { critical: 0, high: 1, normal: 2, low: 3 };\n      const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];\n      \n      if (priorityDiff !== 0) return priorityDiff;\n      \n      return a.metadata.createdAt.getTime() - b.metadata.createdAt.getTime();\n    });\n  }\n\n  /**\n   * Register for background sync with service worker\n   */\n  private async registerBackgroundSync(): Promise<void> {\n    try {\n      const registration = await navigator.serviceWorker.ready;\n      \n      if ('sync' in registration) {\n        await (registration as any).sync.register('acube-background-sync');\n        console.log('Background sync registered');\n      }\n    } catch (error) {\n      console.warn('Failed to register background sync:', error);\n    }\n  }\n\n  /**\n   * Start network monitoring\n   */\n  private startNetworkMonitoring(): void {\n    this.networkCheckInterval = setInterval(async () => {\n      if (!this.config.networkDetection.endpoints || this.config.networkDetection.endpoints.length === 0) return;\n      \n      try {\n        // Try to reach one of the health check endpoints\n        const endpoint = this.config.networkDetection.endpoints[0];\n        if (!endpoint) return;\n        \n        const response = await this.httpClient.get(endpoint, {\n          timeout: 5000,\n        });\n        \n        if (!this.isOnline && response.status === 200) {\n          this.handleOnlineStatus(true);\n        }\n      } catch (error) {\n        if (this.isOnline) {\n          this.handleOnlineStatus(false);\n        }\n      }\n    }, this.config.networkDetection.checkInterval) as unknown as NodeJS.Timeout;\n  }\n\n  /**\n   * Handle online/offline status change\n   */\n  private handleOnlineStatus(isOnline: boolean): void {\n    if (this.isOnline === isOnline) return;\n    \n    this.isOnline = isOnline;\n    \n    if (isOnline) {\n      this.emit('network:online', { timestamp: new Date() });\n      \n      // Start sync when coming online\n      if (this.statistics.pendingOperations > 0) {\n        this.scheduleSyncWithDelay(1000); // Wait 1 second before syncing\n      }\n    } else {\n      this.emit('network:offline', { timestamp: new Date() });\n      \n      // Cancel any scheduled sync\n      if (this.syncTimeout) {\n        clearTimeout(this.syncTimeout);\n        this.syncTimeout = undefined;\n      }\n    }\n  }\n\n  /**\n   * Schedule sync with delay\n   */\n  private scheduleSyncWithDelay(delay: number): void {\n    if (this.syncTimeout) {\n      clearTimeout(this.syncTimeout);\n    }\n    \n    this.syncTimeout = setTimeout(() => {\n      this.syncNow();\n    }, delay) as unknown as NodeJS.Timeout;\n  }\n\n  /**\n   * Schedule next sync based on pending operations\n   */\n  private scheduleNextSync(): void {\n    // Find the earliest retry time\n    let earliestRetry: Date | null = null;\n    \n    for (const op of this.syncQueue.values()) {\n      if (op.metadata.nextRetry && (!earliestRetry || op.metadata.nextRetry < earliestRetry)) {\n        earliestRetry = op.metadata.nextRetry;\n      }\n    }\n    \n    if (earliestRetry) {\n      const delay = Math.max(0, earliestRetry.getTime() - Date.now());\n      this.scheduleSyncWithDelay(delay);\n      this.statistics.nextSyncTime = earliestRetry;\n    }\n  }\n\n  /**\n   * Load queue from storage\n   */\n  private async loadQueueFromStorage(): Promise<void> {\n    if (!this.storage) return;\n    \n    try {\n      const storageKey = createStorageKey('acube_sync_queue');\n      const result = await this.storage.get(storageKey);\n      if (result && result.data) {\n        const queue = JSON.parse(result.data as string);\n        \n        // Restore queue with proper date objects\n        for (const [id, op] of Object.entries(queue)) {\n          const operation = op as SyncOperation;\n          operation.metadata.createdAt = new Date(operation.metadata.createdAt);\n          operation.metadata.updatedAt = new Date(operation.metadata.updatedAt);\n          \n          if (operation.metadata.lastAttempt) {\n            operation.metadata.lastAttempt = new Date(operation.metadata.lastAttempt);\n          }\n          if (operation.metadata.nextRetry) {\n            operation.metadata.nextRetry = new Date(operation.metadata.nextRetry);\n          }\n          \n          this.syncQueue.set(id, operation);\n        }\n        \n        // Update statistics\n        this.updateStatisticsFromQueue();\n      }\n    } catch (error) {\n      console.error('Failed to load sync queue from storage:', error);\n    }\n  }\n\n  /**\n   * Save queue to storage\n   */\n  private async saveQueueToStorage(): Promise<void> {\n    if (!this.storage) return;\n    \n    try {\n      const queue: Record<string, SyncOperation> = {};\n      \n      for (const [id, op] of this.syncQueue) {\n        queue[id] = op;\n      }\n      \n      const storageKey = createStorageKey('acube_sync_queue');\n      await this.storage.set(storageKey, JSON.stringify(queue), {\n        encrypt: true,\n      });\n    } catch (error) {\n      console.error('Failed to save sync queue to storage:', error);\n    }\n  }\n\n  /**\n   * Update statistics from queue\n   */\n  private updateStatisticsFromQueue(): void {\n    this.statistics.pendingOperations = 0;\n    \n    for (const op of this.syncQueue.values()) {\n      if (op.status === 'pending') {\n        this.statistics.pendingOperations++;\n      }\n    }\n  }\n\n  /**\n   * Update data transfer statistics\n   */\n  private updateDataTransferStats(operation: SyncOperation, response: HttpResponse<any>): void {\n    // Estimate upload size\n    if (operation.data) {\n      const uploadSize = JSON.stringify(operation.data).length;\n      this.statistics.dataTransferred.uploaded += uploadSize;\n    }\n    \n    // Estimate download size\n    if (response.data) {\n      const downloadSize = JSON.stringify(response.data).length;\n      this.statistics.dataTransferred.downloaded += downloadSize;\n    }\n  }\n\n  /**\n   * Merge conflict data (basic implementation)\n   */\n  private async mergeConflict(localData: any, serverData: any): Promise<any> {\n    // This is a basic implementation - in real scenarios,\n    // you would implement domain-specific merge logic\n    return {\n      ...serverData,\n      ...localData,\n      _merged: true,\n      _mergedAt: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Compress data for transmission\n   */\n  private async compressData(data: any): Promise<any> {\n    // This is a placeholder - in production you would use\n    // actual compression like gzip\n    return data;\n  }\n\n  /**\n   * Calculate checksum for data integrity\n   */\n  private calculateChecksum(data: any): string {\n    if (!data) return '';\n    \n    // Simple checksum implementation\n    const str = JSON.stringify(data);\n    let hash = 0;\n    \n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    return Math.abs(hash).toString(16);\n  }\n\n  /**\n   * Generate unique operation ID\n   */\n  private generateOperationId(): string {\n    return `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Generate unique batch ID\n   */\n  private generateBatchId(): string {\n    return `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Get current user ID\n   */\n  private getCurrentUserId(): string | undefined {\n    // This would be implemented based on your auth system\n    return undefined;\n  }\n\n  /**\n   * Get device ID\n   */\n  private getDeviceId(): string {\n    // Try to get or generate a persistent device ID\n    let deviceId = localStorage.getItem('acube_device_id');\n    \n    if (!deviceId) {\n      deviceId = `device_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      localStorage.setItem('acube_device_id', deviceId);\n    }\n    \n    return deviceId;\n  }\n\n  /**\n   * Get sync statistics\n   */\n  getStatistics(): SyncStatistics {\n    return { ...this.statistics };\n  }\n\n  /**\n   * Get operation by ID\n   */\n  getOperation(operationId: string): SyncOperation | undefined {\n    return this.syncQueue.get(operationId);\n  }\n\n  /**\n   * Get all operations\n   */\n  getAllOperations(): SyncOperation[] {\n    return Array.from(this.syncQueue.values());\n  }\n\n  /**\n   * Clear completed operations\n   */\n  clearCompleted(): number {\n    let cleared = 0;\n    \n    for (const [id, op] of this.syncQueue) {\n      if (op.status === 'completed') {\n        this.syncQueue.delete(id);\n        cleared++;\n      }\n    }\n    \n    if (cleared > 0) {\n      this.saveQueueToStorage();\n    }\n    \n    return cleared;\n  }\n\n  /**\n   * Cancel operation\n   */\n  cancelOperation(operationId: string): boolean {\n    const operation = this.syncQueue.get(operationId);\n    \n    if (operation && operation.status === 'pending') {\n      this.syncQueue.delete(operationId);\n      this.statistics.pendingOperations--;\n      this.saveQueueToStorage();\n      return true;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Retry failed operations\n   */\n  retryFailed(): number {\n    let retried = 0;\n    \n    for (const op of this.syncQueue.values()) {\n      if (op.status === 'failed') {\n        op.status = 'pending';\n        op.metadata.attemptCount = 0;\n        delete op.metadata.nextRetry;\n        delete op.error;\n        retried++;\n      }\n    }\n    \n    if (retried > 0) {\n      this.statistics.pendingOperations += retried;\n      this.statistics.failedOperations -= retried;\n      this.saveQueueToStorage();\n      \n      if (this.isOnline && !this.isSyncing) {\n        this.syncNow();\n      }\n    }\n    \n    return retried;\n  }\n\n  /**\n   * Force sync even when offline (for testing)\n   */\n  forceSyncNow(): Promise<void> {\n    const wasOffline = !this.isOnline;\n    this.isOnline = true;\n    \n    return this.syncNow().finally(() => {\n      if (wasOffline) {\n        this.isOnline = false;\n      }\n    });\n  }\n\n  /**\n   * Destroy the sync manager\n   */\n  async destroy(): Promise<void> {\n    // Clear intervals\n    if (this.networkCheckInterval) {\n      clearInterval(this.networkCheckInterval);\n    }\n    \n    if (this.syncTimeout) {\n      clearTimeout(this.syncTimeout);\n    }\n    \n    // Remove event listeners\n    window.removeEventListener('online', () => this.handleOnlineStatus(true));\n    window.removeEventListener('offline', () => this.handleOnlineStatus(false));\n    \n    // Save final state\n    await this.saveQueueToStorage();\n    \n    // Clear memory\n    this.syncQueue.clear();\n    this.removeAllListeners();\n  }\n}","/**\n * Offline Integration for PWA\n * Bridges the PWA Background Sync with the existing offline queue system\n * \n * Features:\n * - Automatic queue migration\n * - Unified offline handling\n * - Receipt-specific sync strategies\n * - Italian tax compliance preservation\n */\n\nimport { BackgroundSyncManager, type SyncOperation, type BackgroundSyncConfig } from './background-sync';\nimport type { EnterpriseQueueManager } from '@/storage/queue/queue-manager';\nimport type { HttpClient } from '@/http/client';\nimport { EventEmitter } from 'eventemitter3';\n\n/**\n * Receipt sync priority determination\n */\nexport function getReceiptSyncPriority(receipt: any): 'critical' | 'high' | 'normal' | 'low' {\n  // Critical: Fiscal receipts that must be transmitted\n  if (receipt.fiscal_required || receipt.lottery_enabled) {\n    return 'critical';\n  }\n  \n  // High: Recent receipts or high-value transactions\n  const isRecent = new Date(receipt.created_at).getTime() > Date.now() - 24 * 60 * 60 * 1000;\n  const isHighValue = parseFloat(receipt.amount) > 1000;\n  \n  if (isRecent || isHighValue) {\n    return 'high';\n  }\n  \n  // Normal: Standard receipts\n  if (receipt.status === 'pending' || receipt.status === 'draft') {\n    return 'normal';\n  }\n  \n  // Low: Updates to existing receipts\n  return 'low';\n}\n\n/**\n * Offline integration configuration\n */\nexport interface OfflineIntegrationConfig {\n  /** Enable automatic queue migration */\n  enableMigration?: boolean;\n  \n  /** Receipt-specific sync settings */\n  receiptSync?: {\n    /** Batch size for receipt sync */\n    batchSize?: number;\n    \n    /** Priority receipts with lottery */\n    prioritizeLottery?: boolean;\n    \n    /** Fiscal compliance timeout */\n    fiscalTimeout?: number;\n  };\n  \n  /** Conflict resolution for receipts */\n  conflictResolution?: {\n    /** Preserve fiscal data */\n    preserveFiscalData?: boolean;\n    \n    /** Auto-resolve duplicates */\n    autoResolveDuplicates?: boolean;\n  };\n}\n\n/**\n * Integration events\n */\nexport interface OfflineIntegrationEvents {\n  'migration:started': { totalOperations: number };\n  'migration:progress': { completed: number; total: number };\n  'migration:completed': { migratedCount: number };\n  'receipt:queued': { receipt: any; priority: string };\n  'receipt:synced': { receipt: any; response: any };\n  'fiscal:timeout': { receipt: any; timeout: number };\n}\n\nconst DEFAULT_CONFIG: Required<OfflineIntegrationConfig> = {\n  enableMigration: true,\n  receiptSync: {\n    batchSize: 20,\n    prioritizeLottery: true,\n    fiscalTimeout: 72 * 60 * 60 * 1000, // 72 hours\n  },\n  conflictResolution: {\n    preserveFiscalData: true,\n    autoResolveDuplicates: true,\n  },\n};\n\n/**\n * PWA Offline Integration\n * Bridges PWA background sync with enterprise queue system\n */\nexport class PWAOfflineIntegration extends EventEmitter<OfflineIntegrationEvents> {\n  private syncManager: BackgroundSyncManager;\n  private queueManager?: EnterpriseQueueManager;\n  private config: Required<OfflineIntegrationConfig>;\n  private migrationInProgress = false;\n\n  constructor(\n    httpClient: HttpClient,\n    config: OfflineIntegrationConfig = {},\n    backgroundSyncConfig?: BackgroundSyncConfig\n  ) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    \n    // Initialize background sync with receipt-optimized settings\n    const syncConfig: BackgroundSyncConfig = {\n      ...backgroundSyncConfig,\n      defaultConflictStrategy: this.config.conflictResolution.preserveFiscalData\n        ? 'merge'\n        : 'server-wins',\n    };\n    if (this.config.receiptSync.batchSize !== undefined) {\n      syncConfig.batchSize = this.config.receiptSync.batchSize;\n    }\n    this.syncManager = new BackgroundSyncManager(httpClient, syncConfig);\n    \n    this.setupEventForwarding();\n  }\n\n  /**\n   * Set the enterprise queue manager for migration\n   */\n  setQueueManager(queueManager: EnterpriseQueueManager): void {\n    this.queueManager = queueManager;\n    \n    if (this.config.enableMigration && !this.migrationInProgress) {\n      this.migrateExistingQueue();\n    }\n  }\n\n  /**\n   * Setup event forwarding from sync manager\n   */\n  private setupEventForwarding(): void {\n    // Forward relevant sync events\n    this.syncManager.on('operation:completed', ({ operation, response }) => {\n      if (operation.endpoint.includes('/receipts')) {\n        this.emit('receipt:synced', { \n          receipt: operation.data, \n          response \n        });\n      }\n    });\n    \n    this.syncManager.on('operation:queued', ({ operation }) => {\n      if (operation.endpoint.includes('/receipts')) {\n        this.emit('receipt:queued', { \n          receipt: operation.data, \n          priority: operation.priority \n        });\n      }\n    });\n  }\n\n  /**\n   * Migrate existing offline queue to background sync\n   */\n  private async migrateExistingQueue(): Promise<void> {\n    if (!this.queueManager || this.migrationInProgress) {\n      return;\n    }\n    \n    this.migrationInProgress = true;\n    \n    try {\n      const existingItems = await this.queueManager.getQueueItems();\n      \n      if (existingItems.length === 0) {\n        this.migrationInProgress = false;\n        return;\n      }\n      \n      this.emit('migration:started', { totalOperations: existingItems.length });\n      \n      let migratedCount = 0;\n      \n      for (const item of existingItems) {\n        try {\n          // Convert queue item to sync operation\n          const syncOp = await this.convertQueueItemToSyncOp(item);\n          \n          if (syncOp) {\n            await this.syncManager.queueOperation(syncOp);\n            \n            // Remove from old queue\n            await this.queueManager!.dequeue(item.id);\n            \n            migratedCount++;\n            this.emit('migration:progress', { \n              completed: migratedCount, \n              total: existingItems.length \n            });\n          }\n        } catch (error) {\n          console.error('Failed to migrate queue item:', item.id, error);\n        }\n      }\n      \n      this.emit('migration:completed', { migratedCount });\n      \n    } catch (error) {\n      console.error('Queue migration failed:', error);\n    } finally {\n      this.migrationInProgress = false;\n    }\n  }\n\n  /**\n   * Convert queue item to sync operation\n   */\n  private async convertQueueItemToSyncOp(item: any): Promise<Omit<SyncOperation, 'id' | 'metadata' | 'status'> | null> {\n    // Extract request details from queue item\n    const { request } = item;\n    \n    if (!request) {\n      return null;\n    }\n    \n    // Determine priority based on content\n    let priority: 'critical' | 'high' | 'normal' | 'low' = 'normal';\n    \n    if (request.url?.includes('/receipts') && request.data) {\n      priority = getReceiptSyncPriority(request.data);\n    }\n    \n    return {\n      type: this.getOperationType(request.method),\n      priority,\n      endpoint: request.url || '',\n      method: request.method || 'POST',\n      data: request.data,\n      headers: request.headers,\n    };\n  }\n\n  /**\n   * Get operation type from HTTP method\n   */\n  private getOperationType(method?: string): 'create' | 'update' | 'delete' | 'batch' {\n    switch (method?.toUpperCase()) {\n      case 'POST':\n        return 'create';\n      case 'PUT':\n      case 'PATCH':\n        return 'update';\n      case 'DELETE':\n        return 'delete';\n      default:\n        return 'create';\n    }\n  }\n\n  /**\n   * Queue a receipt for sync with intelligent priority\n   */\n  async queueReceipt(receipt: any, endpoint: string): Promise<void> {\n    const priority = getReceiptSyncPriority(receipt);\n    \n    // Check fiscal timeout\n    if (receipt.fiscal_required) {\n      const createdAt = new Date(receipt.created_at).getTime();\n      const timeElapsed = Date.now() - createdAt;\n      \n      if (\n        this.config.receiptSync &&\n        typeof this.config.receiptSync.fiscalTimeout === 'number' &&\n        timeElapsed > this.config.receiptSync.fiscalTimeout\n      ) {\n        this.emit('fiscal:timeout', { \n          receipt, \n          timeout: this.config.receiptSync.fiscalTimeout \n        });\n      }\n    }\n    \n    await this.syncManager.queueOperation({\n      type: 'create',\n      priority,\n      endpoint,\n      method: 'POST',\n      data: receipt,\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Receipt-Type': receipt.type || 'standard',\n        'X-Fiscal-Required': receipt.fiscal_required ? 'true' : 'false',\n      },\n    });\n  }\n\n  /**\n   * Queue multiple receipts as a batch\n   */\n  async queueReceiptBatch(receipts: any[], endpoint: string): Promise<void> {\n    // Sort receipts by priority\n    const sortedReceipts = receipts.sort((a, b) => {\n      const priorityMap = { critical: 0, high: 1, normal: 2, low: 3 };\n      const aPriority = priorityMap[getReceiptSyncPriority(a)];\n      const bPriority = priorityMap[getReceiptSyncPriority(b)];\n      return aPriority - bPriority;\n    });\n    \n    // Create batch operations\n    const operations = sortedReceipts.map(receipt => ({\n      type: 'create' as const,\n      priority: getReceiptSyncPriority(receipt),\n      endpoint,\n      method: 'POST' as const,\n      data: receipt,\n    }));\n    \n    await this.syncManager.queueBatch(operations, 'high');\n  }\n\n  /**\n   * Get sync statistics\n   */\n  getSyncStatistics() {\n    return this.syncManager.getStatistics();\n  }\n\n  /**\n   * Get pending receipts\n   */\n  getPendingReceipts(): any[] {\n    const allOperations = this.syncManager.getAllOperations();\n    \n    return allOperations\n      .filter(op => op.endpoint.includes('/receipts') && op.status === 'pending')\n      .map(op => op.data);\n  }\n\n  /**\n   * Force sync now (useful for testing or manual trigger)\n   */\n  forceSyncNow(): Promise<void> {\n    return this.syncManager.syncNow();\n  }\n\n  /**\n   * Retry failed receipt operations\n   */\n  retryFailedReceipts(): number {\n    return this.syncManager.retryFailed();\n  }\n\n  /**\n   * Clear completed receipt operations\n   */\n  clearCompletedReceipts(): number {\n    return this.syncManager.clearCompleted();\n  }\n\n  /**\n   * Check if a receipt is pending sync\n   */\n  isReceiptPending(receiptId: string): boolean {\n    const operations = this.syncManager.getAllOperations();\n    \n    return operations.some(op => \n      op.status === 'pending' &&\n      op.data?.id === receiptId\n    );\n  }\n\n  /**\n   * Cancel a pending receipt sync\n   */\n  cancelReceiptSync(receiptId: string): boolean {\n    const operations = this.syncManager.getAllOperations();\n    const receiptOp = operations.find(op => op.data?.id === receiptId);\n    \n    if (receiptOp) {\n      return this.syncManager.cancelOperation(receiptOp.id);\n    }\n    \n    return false;\n  }\n\n  /**\n   * Destroy the integration\n   */\n  async destroy(): Promise<void> {\n    await this.syncManager.destroy();\n    this.removeAllListeners();\n  }\n}\n\n/**\n * Create offline integration helper\n */\nexport function createOfflineIntegration(\n  httpClient: HttpClient,\n  config?: OfflineIntegrationConfig\n): PWAOfflineIntegration {\n  return new PWAOfflineIntegration(httpClient, config);\n}","/**\n * PWA (Progressive Web App) Module for A-Cube E-Receipt SDK\n * \n * Provides comprehensive PWA functionality including:\n * - Service worker management\n * - Advanced caching strategies\n * - Offline-first functionality\n * - App install prompts\n * - Push notifications\n * - Background sync\n * - Manifest generation\n * \n * @example Basic Usage\n * ```typescript\n * import { PWAManager, ManifestGenerator } from '@a-cube-io/ereceipts-js-sdk/pwa';\n * \n * // Initialize PWA manager\n * const pwa = new PWAManager({\n *   autoRegister: true,\n *   enableInstallPrompts: true,\n * });\n * \n * // Generate manifest\n * const manifestGenerator = new ManifestGenerator({\n *   name: 'My E-Receipt App',\n *   themeColor: '#1976d2',\n * });\n * \n * const manifest = manifestGenerator.generateManifestJSON();\n * ```\n * \n * @example Advanced PWA Setup\n * ```typescript\n * import { PWAManager, ManifestGenerator } from '@a-cube-io/ereceipts-js-sdk/pwa';\n * \n * const pwa = new PWAManager({\n *   serviceWorkerPath: '/custom-sw.js',\n *   cacheStrategy: {\n *     apiCacheDuration: 10 * 60 * 1000, // 10 minutes\n *     staleWhileRevalidate: true,\n *   },\n *   pushNotifications: {\n *     enabled: true,\n *     vapidPublicKey: 'your-vapid-key',\n *   },\n * });\n * \n * // Listen for PWA events\n * pwa.on('sw:registered', ({ registration }) => {\n *   console.log('Service worker registered:', registration);\n * });\n * \n * pwa.on('install:available', ({ prompt }) => {\n *   // Show custom install UI\n *   showInstallButton();\n * });\n * \n * pwa.on('offline:synced', ({ request, id }) => {\n *   console.log('Offline request synced:', request);\n * });\n * ```\n */\n\n// Core PWA exports\nexport { PWAManager } from './pwa-manager.js';\nexport type { \n  PWAManagerConfig, \n  PWAEvents, \n  CacheInfo \n} from './pwa-manager.js';\n\n// Manifest generator exports\nexport { ManifestGenerator } from './manifest-generator.js';\nexport type { \n  PWAManifestConfig, \n  WebAppManifest \n} from './manifest-generator.js';\n\n// Background sync exports\nexport { BackgroundSyncManager } from './background-sync.js';\nexport type {\n  BackgroundSyncConfig,\n  BackgroundSyncEvents,\n  SyncOperation,\n  SyncOperationType,\n  SyncPriority,\n  ConflictStrategy,\n  SyncStatus,\n  SyncBatch,\n  SyncStatistics,\n} from './background-sync.js';\n\n// Offline integration exports\nexport { PWAOfflineIntegration, createOfflineIntegration, getReceiptSyncPriority } from './offline-integration.js';\nexport type {\n  OfflineIntegrationConfig,\n  OfflineIntegrationEvents,\n} from './offline-integration.js';\n\n// Push notifications exports\nexport { PushNotificationManager } from './push-notifications.js';\nexport type {\n  PushNotificationConfig,\n  PushNotificationEvents,\n  NotificationPayload,\n  NotificationType,\n  NotificationPriority,\n  PushSubscriptionInfo,\n} from './push-notifications.js';\n\n// App installer exports\nexport { AppInstaller } from './app-installer.js';\nexport type {\n  AppInstallerConfig,\n  AppInstallerEvents,\n  InstallCriteria,\n} from './app-installer.js';\n\n// Service worker types (for TypeScript support)\nexport interface ServiceWorkerMessage {\n  type: string;\n  data?: any;\n}\n\nexport interface CacheUpdateEvent {\n  cacheName: string;\n  size: number;\n  lastUpdated?: Date;\n}\n\nexport interface OfflineQueueEvent {\n  request: string;\n  id: string;\n  timestamp?: number;\n}\n\n/**\n * PWA utility functions\n */\nexport const PWAUtils = {\n  /**\n   * Check if the app is running in standalone mode (installed as PWA)\n   */\n  isStandalone(): boolean {\n    if (typeof window === 'undefined') return false;\n    \n    return (\n      window.matchMedia('(display-mode: standalone)').matches ||\n      window.matchMedia('(display-mode: fullscreen)').matches ||\n      (window.navigator as any).standalone === true\n    );\n  },\n\n  /**\n   * Check if PWA features are supported\n   */\n  isPWASupported(): boolean {\n    if (typeof window === 'undefined') return false;\n    \n    return (\n      'serviceWorker' in navigator &&\n      'caches' in window &&\n      'fetch' in window\n    );\n  },\n\n  /**\n   * Check if background sync is supported\n   */\n  isBackgroundSyncSupported(): boolean {\n    if (typeof window === 'undefined') return false;\n    \n    return 'serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype;\n  },\n\n  /**\n   * Check if push notifications are supported\n   */\n  isPushNotificationSupported(): boolean {\n    if (typeof window === 'undefined') return false;\n    \n    return (\n      'serviceWorker' in navigator &&\n      'PushManager' in window &&\n      'Notification' in window\n    );\n  },\n\n  /**\n   * Check if periodic background sync is supported\n   */\n  isPeriodicSyncSupported(): boolean {\n    if (typeof window === 'undefined') return false;\n    \n    return 'serviceWorker' in navigator && 'periodicSync' in window.ServiceWorkerRegistration.prototype;\n  },\n\n  /**\n   * Get display mode\n   */\n  getDisplayMode(): 'browser' | 'standalone' | 'minimal-ui' | 'fullscreen' {\n    if (typeof window === 'undefined') return 'browser';\n    \n    if (window.matchMedia('(display-mode: fullscreen)').matches) {\n      return 'fullscreen';\n    }\n    if (window.matchMedia('(display-mode: standalone)').matches) {\n      return 'standalone';\n    }\n    if (window.matchMedia('(display-mode: minimal-ui)').matches) {\n      return 'minimal-ui';\n    }\n    return 'browser';\n  },\n\n  /**\n   * Get network status\n   */\n  getNetworkStatus(): {\n    online: boolean;\n    effectiveType?: '2g' | '3g' | '4g' | 'slow-2g';\n    downlink?: number;\n    rtt?: number;\n  } {\n    if (typeof navigator === 'undefined') {\n      return { online: true };\n    }\n\n    const connection = (navigator as any).connection || (navigator as any).mozConnection || (navigator as any).webkitConnection;\n    \n    return {\n      online: navigator.onLine,\n      effectiveType: connection?.effectiveType,\n      downlink: connection?.downlink,\n      rtt: connection?.rtt,\n    };\n  },\n\n  /**\n   * Estimate cache storage quota\n   */\n  async getStorageEstimate(): Promise<{\n    quota?: number;\n    usage?: number;\n    usagePercentage?: number;\n  }> {\n    if (typeof navigator === 'undefined' || !('storage' in navigator)) {\n      return {};\n    }\n\n    try {\n      const estimate = await navigator.storage.estimate();\n      const quota = estimate.quota || 0;\n      const usage = estimate.usage || 0;\n      const usagePercentage = quota > 0 ? Math.round((usage / quota) * 100) : 0;\n\n      return {\n        quota,\n        usage,\n        usagePercentage,\n      };\n    } catch (error) {\n      console.warn('Failed to get storage estimate:', error);\n      return {};\n    }\n  },\n\n  /**\n   * Convert bytes to human readable format\n   */\n  formatBytes(bytes: number, decimals: number = 2): string {\n    if (bytes === 0) return '0 Bytes';\n\n    const k = 1024;\n    const dm = decimals < 0 ? 0 : decimals;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n  },\n\n  /**\n   * Create a debounced function\n   */\n  debounce<T extends (...args: any[]) => any>(\n    func: T,\n    wait: number,\n    immediate: boolean = false\n  ): (...args: Parameters<T>) => void {\n    let timeout: NodeJS.Timeout | null = null;\n    \n    return function executedFunction(...args: Parameters<T>) {\n      const later = () => {\n        timeout = null;\n        if (!immediate) func(...args);\n      };\n      \n      const callNow = immediate && !timeout;\n      \n      if (timeout) clearTimeout(timeout);\n      timeout = setTimeout(later, wait) as unknown as NodeJS.Timeout;\n      \n      if (callNow) func(...args);\n    };\n  },\n};\n\n/**\n * PWA constants\n */\nexport const PWA_CONSTANTS = {\n  // Cache names\n  STATIC_CACHE_PREFIX: 'acube-static-',\n  API_CACHE_PREFIX: 'acube-api-',\n  RUNTIME_CACHE_PREFIX: 'acube-runtime-',\n  \n  // Default cache durations (in milliseconds)\n  DEFAULT_API_CACHE_DURATION: 5 * 60 * 1000, // 5 minutes\n  DEFAULT_STATIC_CACHE_DURATION: 24 * 60 * 60 * 1000, // 24 hours\n  DEFAULT_RUNTIME_CACHE_DURATION: 60 * 60 * 1000, // 1 hour\n  \n  // Offline queue settings\n  DEFAULT_QUEUE_NAME: 'acube-offline-queue',\n  DEFAULT_MAX_QUEUE_SIZE: 1000,\n  DEFAULT_MAX_RETENTION_TIME: 7 * 24 * 60 * 60 * 1000, // 7 days\n  \n  // Background sync settings\n  DEFAULT_MIN_SYNC_INTERVAL: 15 * 60 * 1000, // 15 minutes\n  \n  // Manifest defaults\n  DEFAULT_THEME_COLOR: '#1976d2',\n  DEFAULT_BACKGROUND_COLOR: '#ffffff',\n  DEFAULT_DISPLAY_MODE: 'standalone',\n  DEFAULT_ORIENTATION: 'portrait',\n  \n  // Service worker events\n  SW_EVENTS: {\n    REGISTERED: 'sw:registered',\n    UPDATED: 'sw:updated',\n    ERROR: 'sw:error',\n    INSTALL_AVAILABLE: 'install:available',\n    INSTALL_COMPLETED: 'install:completed',\n    CACHE_UPDATED: 'cache:updated',\n    OFFLINE_QUEUED: 'offline:queued',\n    OFFLINE_SYNCED: 'offline:synced',\n    PUSH_RECEIVED: 'push:received',\n    SYNC_COMPLETED: 'sync:completed',\n  } as const,\n  \n  // Italian e-receipt specific categories\n  ERECEIPT_CATEGORIES: [\n    'business',\n    'finance',\n    'productivity',\n    'utilities',\n  ] as const,\n  \n  // Recommended icon sizes for PWA\n  RECOMMENDED_ICON_SIZES: [\n    '72x72',\n    '96x96',\n    '128x128',\n    '144x144',\n    '152x152',\n    '192x192',\n    '384x384',\n    '512x512',\n  ] as const,\n  \n  // Maskable icon sizes\n  MASKABLE_ICON_SIZES: [\n    '192x192',\n    '512x512',\n  ] as const,\n} as const;\n\n// Import classes for default export\nimport { PWAManager } from './pwa-manager.js';\nimport { ManifestGenerator } from './manifest-generator.js';\nimport { AppInstaller } from './app-installer.js';\n\n/**\n * Default export for convenient access\n */\nexport default {\n  PWAManager,\n  ManifestGenerator,\n  PWAUtils,\n  PWA_CONSTANTS,\n  AppInstaller,\n};","/**\n * A-Cube E-Receipts SDK - Main Entry Point\n * Enterprise-grade TypeScript SDK for A-Cube e-receipt system integration\n */\n\n// Core SDK\nexport { ACubeSDK, createACubeSDK, type ACubeSDKConfig, DEFAULT_SDK_CONFIG } from './core/sdk';\nimport { ACubeSDK, createACubeSDK, type ACubeSDKConfig } from './core/sdk';\n\n// HTTP Client and Configuration\nexport { \n  HttpClient, \n  type HttpClientConfig, \n  type RequestOptions, \n  type HttpResponse,\n  DEFAULT_HTTP_CONFIG,\n  AUTH_HTTP_CONFIG \n} from './http/client';\n\n\n// OpenAPI Endpoints\nexport { \n  CashierEndpoints,\n  ReceiptEndpoints,\n  CashRegisterEndpoints,\n  MerchantEndpoints,\n  PEMEndpoints,\n  PointOfSalesEndpoints,\n  type EndpointDefinition,\n} from './generated/endpoints';\n\n// OpenAPI Resources\nexport {\n  CashiersResource,\n  Cashiers,\n} from './resources/cashiers';\n\nexport {\n  ReceiptsResource,\n  Receipts,\n} from './resources/receipts';\n\nexport {\n  CashRegistersResource,\n  CashRegisters,\n} from './resources/cash-registers';\n\nexport {\n  MerchantsResource,\n  Merchants,\n} from './resources/merchants';\n\nexport {\n  PEMsResource,\n  PEMs,\n} from './resources/pems';\n\nexport {\n  PointOfSalesResource,\n  PointOfSales,\n} from './resources/point-of-sales';\n\n// Base OpenAPI Resource\nexport {\n  BaseOpenAPIResource,\n  type BaseResourceConfig,\n  type RequestOptions as OpenAPIRequestOptions,\n  type ValidationContext,\n} from './resources/base-openapi';\n\n// Types\nexport * from './types/branded';\nexport * from './types/events';\n\n// Authentication Types\nexport type {\n  AuthState,\n  AuthUser,\n  LoginCredentials,\n  LogoutOptions,\n  UserRole,\n  SimpleUserRole,\n  AuthError,\n  PermissionCheck,\n  PermissionResult,\n  SessionInfo,\n  OAuth2TokenResponse,\n  StoredAuthData,\n} from './auth/types';\n\n// Storage Layer\nexport {\n  // Unified Storage Interface\n  type UnifiedStorage,\n  type StorageAdapter,\n  type StorageKey,\n  type StorageValue,\n  type StorageEntry,\n  type StorageOptions,\n  type QueryOptions,\n  type StorageTransaction,\n  type StorageStats,\n  createStorageKey,\n  STORAGE_NAMESPACES,\n  \n  // Storage Errors\n  StorageError,\n  StorageConnectionError,\n  StorageCapacityError,\n  StorageEncryptionError,\n  StorageTransactionError,\n} from './storage/unified-storage';\n\nexport {\n  // Platform Detection\n  type PlatformType,\n  type PlatformCapabilities,\n  type EnvironmentInfo,\n  platformDetector,\n  getPlatform,\n  getEnvironmentInfo,\n  hasCapability,\n  getRecommendedStorageAdapter,\n  getPerformanceTier,\n} from './storage/platform-detector';\n\nexport {\n  // Storage Adapters\n  IndexedDBAdapter,\n} from './storage/adapters/indexeddb-adapter';\n\nexport {\n  LocalStorageAdapter,\n} from './storage/adapters/localstorage-adapter';\n\nexport {\n  // Encryption Service\n  type StorageEncryptionConfig,\n  type EncryptionMetadata,\n  type EncryptionKeyManager,\n  StorageEncryptionService,\n  createEncryptionService,\n  createSecureEncryptionService,\n  createMinimalEncryptionService,\n} from './storage/encryption-service';\n\nexport {\n  // Storage Factory\n  type StorageFactoryConfig,\n  StorageFactory,\n  storageFactory,\n  createStorage,\n  createSecureStorage,\n  createHighPerformanceStorage,\n  createCompatibilityStorage,\n} from './storage/storage-factory';\n\n// Offline System Components\nexport {\n  // Queue Management\n  type QueueItem,\n  type QueueOperationType,\n  type QueuePriority,\n  type QueueStats,\n  type ConflictResolutionStrategy,\n  type QueueConfig,\n  type BatchOperation,\n  EnterpriseQueueManager,\n  RetryManager,\n  ConflictResolverManager,\n  BatchProcessor,\n  PriorityQueue,\n  QueueAnalytics,\n} from './storage/queue/index';\n\nexport {\n  // Enhanced Offline Hook\n  type EnhancedOfflineOptions,\n  type EnhancedOfflineResult,\n  useEnhancedACubeOffline,\n} from './storage/queue/enhanced-offline-hook';\n\nexport {\n  // Sync System\n  type SyncResult,\n  type SyncOptions,\n  type SyncConflict,\n  type ConnectionInfo,\n} from './sync/types';\n\nexport {\n  // React Provider System\n  ACubeProvider,\n  useACube,\n  useACubeSDK,\n  useACubeStorage,\n  useACubeQueueManager,\n  useACubeSyncEngine,\n  useACubeNetworkManager,\n  useACubeNetworkStatus,\n  type ACubeContextValue,\n  type ACubeProviderProps,\n  \n  // React Hooks for Data Management\n  useACubeOffline,\n  useACubeQuery,\n  useACubeMutation,\n  useACubeCache,\n  useACubeSubscription,\n  \n  // Authentication System\n  AuthProvider,\n  useAuthContext,\n  useAuthAvailable,\n  useAuth,\n  useLogin,\n  useLogout,\n  useUser,\n  useRoles,\n  usePermissions,\n  useSession,\n  useRequireAuth,\n  useRequireRole,\n  LoginForm,\n  UserProfile,\n  RoleSwitcher,\n  AuthStatus,\n  ProtectedRoute,\n  PermissionGate,\n  type AuthProviderProps,\n  type AuthContextValue,\n  type LoginFormProps,\n  type UserProfileProps,\n  type RoleSwitcherProps,\n  type AuthStatusProps,\n  type ProtectedRouteProps,\n  type PermissionGateProps,\n} from './hooks/react/index';\n\nexport {\n  // Compliance and Security\n  type AccessControlConfig,\n  type Role,\n  type Permission,\n  type User,\n  type GDPRConfig,\n  type FiscalConfig,\n  AccessControlManager,\n  GDPRComplianceManager,\n  FiscalAuditManager,\n} from './compliance/index';\n\nexport {\n  // Security Services\n  type EncryptionConfig,\n  type KeyRotationConfig,\n  type SignatureConfig,\n} from './security/index';\n\nexport {\n  // Plugin System\n  type PluginConfig,\n  type PluginContext,\n  type BasePlugin,\n  PluginManager,\n  AnalyticsPlugin,\n  AuditPlugin,\n  CachePlugin,\n  DebugPlugin,\n  PerformancePlugin,\n} from './plugins/index';\n\nexport {\n  // Quality Gates\n  type DependencyConfig,\n  QualityManager,\n  DependencyManager,\n} from './quality/index';\n\nexport {\n  // Validation System\n  type ValidationConfig,\n  type ValidationResult,\n  type ValidationIssue,\n} from './validation/index';\n\nexport {\n  // PWA (Progressive Web App) System\n  PWAManager,\n  ManifestGenerator,\n  PWAUtils,\n  PWA_CONSTANTS,\n  type PWAManagerConfig,\n  type PWAEvents,\n  type CacheInfo,\n  type PWAManifestConfig,\n  type WebAppManifest,\n  type ServiceWorkerMessage,\n  type CacheUpdateEvent,\n  type OfflineQueueEvent,\n} from './pwa/index';\n\n// Error Handling\nexport {\n  ACubeSDKError,\n  NetworkError,\n  AuthenticationError,\n  AuthorizationError,\n  ValidationError,\n  FiscalError,\n  RateLimitError,\n  ConfigurationError,\n  NotFoundError,\n  CircuitBreakerError,\n  createErrorFromResponse,\n  type AuditInfo,\n  type ValidationViolation,\n} from './errors/index';\n\n// Circuit Breaker\nexport {\n  CircuitBreaker,\n  type CircuitBreakerConfig,\n  type CircuitBreakerState,\n  type CircuitBreakerMetrics,\n} from './http/circuit-breaker';\n\n// Retry Handler\nexport {\n  RetryHandler,\n  type RetryConfig,\n  type RetryAttempt,\n  type RetryMetrics,\n  DEFAULT_RETRY_CONFIG,\n  AGGRESSIVE_RETRY_CONFIG,\n  CONSERVATIVE_RETRY_CONFIG,\n} from './http/retry';\n\n// Middleware\nexport {\n  MiddlewareStack,\n  type Middleware,\n  type RequestContext,\n  type ResponseContext,\n  AuthenticationMiddleware,\n  RequestIdMiddleware,\n  UserAgentMiddleware,\n  ContentTypeMiddleware,\n  LoggingMiddleware,\n  RateLimitingMiddleware,\n  PerformanceMiddleware,\n} from './http/middleware';\n\n// Convenience functions for quick setup\n\n/**\n * Initialize SDK with sandbox configuration\n */\nexport function initializeSandboxSDK(config: Partial<ACubeSDKConfig> = {}): ACubeSDK {\n  return createACubeSDK({\n    environment: 'sandbox',\n    ...config,\n  });\n}\n\n/**\n * Initialize SDK with production configuration\n */\nexport function initializeProductionSDK(config: Partial<ACubeSDKConfig> = {}): ACubeSDK {\n  return createACubeSDK({\n    environment: 'production',\n    ...config,\n  });\n}\n\n/**\n * Initialize SDK with development configuration\n */\nexport function initializeDevelopmentSDK(config: Partial<ACubeSDKConfig> = {}): ACubeSDK {\n  return createACubeSDK({\n    environment: 'development',\n    ...config,\n  });\n}\n\n// Version information\nexport const SDK_VERSION = '2.0.0';\nexport const API_VERSION = '1.0.0';\n\n// Default export\nexport default ACubeSDK;","/**\n * SDK Initialization and Management\n * Handles SDK lifecycle, authentication restoration, and cleanup\n */\n\nimport { createACubeSDK, type ACubeSDK, type ACubeSDKConfig } from '../../index.js';\nimport { loadConfig, loadAuth } from '../config/index.js';\nimport type { CLIAuthState } from '../types.js';\nimport { AuthenticationRequiredError } from '../types.js';\n\n// Global SDK instance\nlet sdk: ACubeSDK | null = null;\n\nexport async function initializeSDK(requireAuth = true): Promise<ACubeSDK> {\n  const config = await loadConfig();\n  const auth = await loadAuth(config.currentProfile);\n  \n  // Create SDK configuration\n  const sdkConfig: ACubeSDKConfig = {\n    environment: config.environment,\n  };\n  \n  // Add custom base URLs if configured\n  if (config.baseUrls?.api || config.baseUrls?.auth) {\n    // Note: Custom base URLs would be configured here when SDK supports it\n    console.log(' Debug: Custom URLs configured:', {\n      api: config.baseUrls?.api,\n      auth: config.baseUrls?.auth\n    });\n  }\n  \n  // Initialize SDK\n  sdk = createACubeSDK(sdkConfig);\n  \n  // Initialize the SDK (this sets up auth service and middleware)\n  await sdk.initialize();\n  \n  // Restore authentication if available\n  if (auth && (auth.accessToken || auth.user)) {\n    try {\n      await restoreAuthentication(auth);\n    } catch (error) {\n      if (requireAuth) {\n        // Provide user-friendly authentication error\n        throw new AuthenticationRequiredError('Please login to continue: acube auth login');\n      }\n    }\n  } else if (requireAuth) {\n    throw new AuthenticationRequiredError('Please login to continue: acube auth login');\n  }\n  \n  return sdk;\n}\n\nasync function restoreAuthentication(auth: CLIAuthState): Promise<void> {\n  if (!sdk) {\n    throw new Error('SDK not initialized');\n  }\n  \n  // For CLI, we need both user and access token for API requests\n  if (!auth.user) {\n    throw new Error('No user authentication data available');\n  }\n  \n  if (!auth.accessToken) {\n    throw new Error('No access token available. Please run \"acube auth login\" to re-authenticate.');\n  }\n  \n  // Extract expiration from JWT token if not in stored data\n  let expiresAt = auth.expiresAt;\n  if (!expiresAt && auth.accessToken) {\n    try {\n      // Simple JWT parsing for CLI\n      const parts = auth.accessToken.split('.');\n      if (parts.length === 3 && parts[1]) {\n        const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString());\n        if (payload && payload.exp) {\n          expiresAt = payload.exp * 1000; // Convert to milliseconds\n        }\n      }\n    } catch (error) {\n      console.log(' Debug: Failed to parse token:', error);\n    }\n  }\n  \n  // Check if token is expired\n  if (expiresAt && Date.now() >= expiresAt) {\n    throw new Error('Access token has expired. Please login again.');\n  }\n  \n  // Directly update the auth service state (most reliable method for CLI)\n  try {\n    const authService = sdk.authService;\n    (authService as any).updateState({\n      isAuthenticated: true,\n      user: auth.user,\n      accessToken: auth.accessToken || null,\n      refreshToken: auth.refreshToken || null,\n      expiresAt,\n      isLoading: false,\n      error: null\n    });\n    \n  } catch (error) {\n    throw new Error('Failed to restore authentication state in SDK');\n  }\n}\n\nexport async function cleanupSDK(): Promise<void> {\n  if (sdk) {\n    try {\n      // Cleanup SDK resources with timeout\n      const cleanupPromise = sdk.destroy();\n      const timeoutPromise = new Promise((_, reject) => \n        setTimeout(() => reject(new Error('Cleanup timeout')), 2000)\n      );\n      \n      await Promise.race([cleanupPromise, timeoutPromise]);\n    } catch (error) {\n      // Ignore cleanup errors - we're shutting down anyway\n    } finally {\n      sdk = null;\n    }\n  }\n  \n  // Force cleanup of any remaining timers/handles\n  if (global.gc) {\n    global.gc();\n  }\n}\n\nexport function getSDK(): ACubeSDK | null {\n  return sdk;\n}\n\nexport function requireSDK(): ACubeSDK {\n  if (!sdk) {\n    throw new Error('SDK not initialized. Call initializeSDK() first.');\n  }\n  return sdk;\n}","/**\n * A-Cube E-Receipt SDK CLI Entry Point\n * \n * This file has been refactored into a modular architecture.\n * The original implementation is backed up as cli.ts.backup\n * \n * New architecture:\n * - src/cli/index.ts - Main CLI with command registration\n * - src/cli/commands/ - Individual command implementations\n * - src/cli/utils/ - Shared utilities\n * - src/cli/config/ - Configuration management\n */\n\n// Re-export the modular CLI\nexport * from './cli/index.js';","/**\n * A-Cube E-Receipt SDK CLI\n * Refactored modular CLI with clean command architecture\n */\n\nimport { Command } from 'commander';\nimport {\n  // Auth commands\n  LoginCommand,\n  LogoutCommand,\n  StatusCommand,\n  RefreshCommand,\n  \n  // Config commands\n  SetupCommand,\n  ShowConfigCommand,\n  \n  // Resource commands\n  ReceiptsCommand,\n  CashiersCommand,\n  MerchantsCommand,\n  PointOfSalesCommand,\n  \n  // Profile commands\n  ProfileListCommand,\n  ProfileSwitchCommand,\n  ProfileDeleteCommand,\n  \n  // Other commands\n  InteractiveCommand,\n  VersionCommand,\n} from './commands/index.js';\n\nconst program = new Command();\n\n// CLI metadata\nprogram\n  .name('acube')\n  .description('A-Cube E-Receipt SDK CLI')\n  .version('1.0.0');\n\n// Authentication commands\nconst authCmd = program\n  .command('auth')\n  .description('Authentication management');\n\nauthCmd\n  .command('login')\n  .description('Login to your account')\n  .option('-u, --username <username>', 'Username')\n  .option('-p, --password <password>', 'Password')\n  .option('--profile <profile>', 'Environment profile (sandbox/production/development)')\n  .option('-r, --remember', 'Remember credentials')\n  .option('-f, --force', 'Force login even if already authenticated')\n  .action(async (options) => {\n    await new LoginCommand().execute(options);\n  });\n\nauthCmd\n  .command('logout')\n  .description('Logout from your account')\n  .option('-f, --force', 'Force logout without confirmation')\n  .action(async (options) => {\n    await new LogoutCommand().execute(options);\n  });\n\nauthCmd\n  .command('status')\n  .description('Show authentication status')\n  .option('-v, --verbose', 'Show detailed information')\n  .action(async (options) => {\n    await new StatusCommand().execute(options);\n  });\n\nauthCmd\n  .command('refresh')\n  .description('Refresh authentication token')\n  .action(async (options) => {\n    await new RefreshCommand().execute(options);\n  });\n\n// Configuration commands\nconst configCmd = program\n  .command('config')\n  .description('Configuration management');\n\nconfigCmd\n  .command('setup')\n  .description('Interactive configuration setup')\n  .action(async (options) => {\n    await new SetupCommand().execute(options);\n  });\n\nconfigCmd\n  .command('show')\n  .description('Show current configuration')\n  .action(async (options) => {\n    await new ShowConfigCommand().execute(options);\n  });\n\n// Profile commands\nconst profileCmd = program\n  .command('profile')\n  .description('Profile management');\n\nprofileCmd\n  .command('list')\n  .description('List available profiles')\n  .action(async (options) => {\n    await new ProfileListCommand().execute(options);\n  });\n\nprofileCmd\n  .command('switch <name>')\n  .description('Switch to a different profile')\n  .action(async (name: string, options) => {\n    await new ProfileSwitchCommand(name).execute(options);\n  });\n\nprofileCmd\n  .command('delete <name>')\n  .description('Delete a profile')\n  .action(async (name: string, options) => {\n    await new ProfileDeleteCommand(name).execute(options);\n  });\n\n// Resource commands - Receipts\nconst receiptCmd = program\n  .command('receipt')\n  .alias('receipts')\n  .description('Manage receipts');\n\nreceiptCmd\n  .command('create')\n  .description('Create a new receipt')\n  .action(async (options) => {\n    await new ReceiptsCommand().create(options);\n  });\n\nreceiptCmd\n  .command('get <id>')\n  .description('Get a receipt by ID')\n  .action(async (id: string, options) => {\n    await new ReceiptsCommand().get(id, options);\n  });\n\nreceiptCmd\n  .command('list')\n  .description('List receipts')\n  .option('-l, --limit <number>', 'Number of receipts to fetch', '10')\n  .option('-o, --offset <number>', 'Number of receipts to skip', '0')\n  .option('--format <format>', 'Output format (table|json)', 'json')\n  .action(async (options) => {\n    await new ReceiptsCommand().list(options);\n  });\n\nreceiptCmd\n  .command('delete <id>')\n  .description('Delete a receipt')\n  .action(async (id: string, options) => {\n    await new ReceiptsCommand().delete(id, options);\n  });\n\n// Resource commands - Cashiers\nconst cashierCmd = program\n  .command('cashier')\n  .alias('cashiers')\n  .description('Manage cashiers');\n\ncashierCmd\n  .command('list')\n  .description('List cashiers')\n  .option('-l, --limit <number>', 'Number of cashiers to fetch', '10')\n  .option('-o, --offset <number>', 'Number of cashiers to skip', '0')\n  .option('--format <format>', 'Output format (table|json)', 'json')\n  .action(async (options) => {\n    await new CashiersCommand().list(options);\n  });\n\n// Resource commands - Merchants\nconst merchantCmd = program\n  .command('merchant')\n  .alias('merchants')\n  .description('Manage merchants');\n\nmerchantCmd\n  .command('list')\n  .description('List merchants')\n  .option('-l, --limit <number>', 'Number of merchants to fetch', '10')\n  .option('--format <format>', 'Output format (table|json)', 'json')\n  .action(async (options) => {\n    await new MerchantsCommand().list(options);\n  });\n\n// Resource commands - Point of Sales\nconst posCmd = program\n  .command('pos')\n  .alias('point-of-sale')\n  .description('Manage point of sales');\n\nposCmd\n  .command('list')\n  .description('List point of sales')\n  .option('-l, --limit <number>', 'Number of point of sales to fetch', '10')\n  .option('-o, --offset <number>', 'Number of point of sales to skip', '0')\n  .option('--format <format>', 'Output format (table|json)', 'json')\n  .action(async (options) => {\n    await new PointOfSalesCommand().execute(options);\n  });\n\n// Interactive mode\nprogram\n  .command('interactive')\n  .alias('i')\n  .description('Start interactive mode')\n  .action(async (options) => {\n    await new InteractiveCommand().execute(options);\n  });\n\n// Version command\nprogram\n  .command('version')\n  .description('Show version information')\n  .action(async (options) => {\n    await new VersionCommand().execute(options);\n  });\n\n// Parse command line arguments\nprogram.parse();\n\nexport { program };","/**\n * Commands Index\n * Exports all command classes for CLI registration\n */\n\n// Auth commands\nexport * from './auth/index.js';\n\n// Config commands\nexport * from './config/index.js';\n\n// Resource commands\nexport * from './resources/index.js';\n\n// Profile commands\nexport * from './profile.js';\n\n// Other commands\nexport { InteractiveCommand } from './interactive.js';\nexport { VersionCommand } from './version.js';","/**\n * Auth Commands Index\n * Exports all authentication command classes\n */\n\nexport { LoginCommand } from './login.js';\nexport { LogoutCommand } from './logout.js';\nexport { StatusCommand } from './status.js';\nexport { RefreshCommand } from './refresh.js';","/**\n * Login Command Implementation\n * Handles user authentication\n */\n\nimport chalk from 'chalk';\nimport inquirer from 'inquirer';\nimport ora from 'ora';\nimport { BaseCommand } from '../base/command.js';\nimport { initializeSDK } from '../../utils/sdk.js';\nimport { saveAuth, loadConfig, saveConfig } from '../../config/index.js';\nimport type { AuthCommandOptions } from '../../types.js';\n\ninterface LoginOptions extends AuthCommandOptions {\n  username?: string;\n  password?: string;\n  profile?: string;\n}\n\nexport class LoginCommand extends BaseCommand {\n  protected commandName = 'login';\n  \n  protected async executeCommand(options: LoginOptions): Promise<void> {\n    console.log(chalk.blue('A-Cube E-Receipt Authentication'));\n    \n    // Get current config\n    let config = await loadConfig();\n    \n    // Handle --profile option\n    if (options.profile) {\n      // Update environment based on profile\n      const envMap: Record<string, 'sandbox' | 'production' | 'development'> = {\n        'sandbox': 'sandbox',\n        'production': 'production', \n        'development': 'development',\n        'dev': 'development',\n        'prod': 'production'\n      };\n      \n      const environment = envMap[options.profile.toLowerCase()] || 'sandbox';\n      config = { ...config, environment };\n      \n      // Save updated config\n      await saveConfig(config);\n      console.log(chalk.gray(`Environment set to: ${environment}`));\n    }\n    \n    // Get credentials from options or prompt user\n    let credentials: { username: string; password: string };\n    \n    if (options.username && options.password) {\n      credentials = {\n        username: options.username,\n        password: options.password\n      };\n      console.log(chalk.gray(`Logging in as: ${options.username}`));\n    } else {\n      const prompts = [];\n      \n      if (!options.username) {\n        prompts.push({\n          type: 'input',\n          name: 'username',\n          message: 'Username:',\n          validate: (input: string) => input.length > 0 || 'Please enter a username',\n        });\n      }\n      \n      if (!options.password) {\n        prompts.push({\n          type: 'password',\n          name: 'password',\n          message: 'Password:',\n          mask: '*',\n        });\n      }\n      \n      const prompted = await inquirer.prompt(prompts);\n      credentials = {\n        username: options.username || prompted.username,\n        password: options.password || prompted.password\n      };\n    }\n    \n    const spinner = ora('Authenticating...').start();\n    \n    try {\n      // Initialize SDK (without requiring auth)\n      const sdk = await initializeSDK(false);\n      \n      // Perform login\n      const user = await sdk.login({\n        username: credentials.username,\n        password: credentials.password,\n      });\n      \n      // Get the auth state from the SDK to retrieve the access token\n      const authState = sdk.getAuthState();\n      \n      // Calculate expiration from token or default to 24 hours\n      let expiresAt = Date.now() + (24 * 60 * 60 * 1000); // 24 hours default\n      if (authState && authState.expiresAt) {\n        expiresAt = authState.expiresAt;\n      }\n      \n      // Config already loaded and potentially updated above\n      \n      // Save authentication state with token\n      await saveAuth({\n        user,\n        accessToken: authState?.accessToken || null,\n        refreshToken: authState?.refreshToken || null,\n        expiresAt,\n      }, config.currentProfile);\n      \n      spinner.succeed('Authentication successful');\n      \n      console.log(`Welcome, ${chalk.green(user.email)}!`);\n      console.log(`Roles: ${chalk.cyan(user.roles?.join(', ') || 'N/A')}`);\n      console.log(`Session expires: ${chalk.gray(new Date(expiresAt).toLocaleString())}`);\n      \n    } catch (error: any) {\n      spinner.fail('Authentication failed');\n      throw error;\n    }\n  }\n}","/**\n * Base Command Class\n * Abstract base class for all CLI commands with common functionality\n */\n\nimport chalk from 'chalk';\nimport type { BaseCommandOptions } from '../../types.js';\nimport { AuthenticationRequiredError } from '../../types.js';\nimport { handleError } from '../../utils/errors.js';\nimport { exitWithStatus, setupGracefulShutdown } from '../../utils/process.js';\n\nexport abstract class BaseCommand {\n  protected abstract commandName: string;\n  \n  /**\n   * Execute the command with error handling and process management\n   */\n  async execute(options: BaseCommandOptions): Promise<void> {\n    setupGracefulShutdown(this.commandName);\n    \n    try {\n      await this.run(options);\n      \n      // Cleanup SDK connections to allow process exit\n      const { cleanupSDK } = await import('../../utils/sdk.js');\n      try {\n        await Promise.race([\n          cleanupSDK(),\n          new Promise((_, reject) => setTimeout(() => reject(new Error('Cleanup timeout')), 1000))\n        ]);\n      } catch {\n        // Ignore cleanup timeout - we'll exit anyway\n      }\n      \n      exitWithStatus(this.commandName, 'success');\n    } catch (error) {\n      // Handle authentication errors with user-friendly messages\n      if (error instanceof AuthenticationRequiredError) {\n        console.error(chalk.red('\\n Authentication Required'));\n        console.error(chalk.yellow(' ' + error.message));\n        console.error(chalk.gray('\\nExample: acube auth login --profile sandbox -u user@example.com -p password\\n'));\n        \n        // Cleanup before exit\n        const { cleanupSDK } = await import('../../utils/sdk.js');\n        try {\n          await Promise.race([\n            cleanupSDK(),\n            new Promise((_, reject) => setTimeout(() => reject(new Error('Cleanup timeout')), 1000))\n          ]);\n        } catch {\n          // Ignore cleanup timeout - we'll exit anyway\n        }\n        \n        process.exit(1);\n      }\n      \n      await handleError(error, { command: this.commandName }, options);\n      \n      // Cleanup before exit\n      const { cleanupSDK } = await import('../../utils/sdk.js');\n      try {\n        await Promise.race([\n          cleanupSDK(),\n          new Promise((_, reject) => setTimeout(() => reject(new Error('Cleanup timeout')), 1000))\n        ]);\n      } catch {\n        // Ignore cleanup timeout - we'll exit anyway\n      }\n      \n      exitWithStatus(this.commandName, 'error', error instanceof Error ? error.message : 'Unknown error', 1);\n    }\n  }\n  \n  /**\n   * Execute the command with error handling but without process exit\n   * Useful for interactive mode or when commands are called programmatically\n   */\n  async run(options: BaseCommandOptions): Promise<void> {\n    try {\n      await this.executeCommand(options);\n    } catch (error) {\n      await this.handleError(error, options);\n      throw error;\n    }\n  }\n  \n  /**\n   * Main command logic - implemented by subclasses\n   */\n  protected abstract executeCommand(options: BaseCommandOptions): Promise<void>;\n  \n  /**\n   * Handle command-specific errors\n   */\n  protected async handleError(error: any, options: BaseCommandOptions): Promise<void> {\n    await handleError(error, { command: this.commandName }, options);\n  }\n  \n  /**\n   * Validate command options - override in subclasses\n   */\n  protected validateOptions(_options: BaseCommandOptions): void {\n    // Base validation - can be overridden\n  }\n}","/**\n * Error Handling and Tracing Utilities\n * Comprehensive error formatting and tracing system\n */\n\nimport chalk from 'chalk';\nimport type { TraceConfig } from '../types.js';\nimport { loadConfig } from '../config/index.js';\nimport { DEFAULT_TRACE_CONFIG } from '../config/constants.js';\n\nexport function formatErrorTrace(error: any, context?: any, config?: TraceConfig): string {\n  const traceConfig = config || DEFAULT_TRACE_CONFIG;\n  \n  if (!traceConfig.enabled) {\n    return error.message || 'Unknown error';\n  }\n\n  const timestamp = traceConfig.includeTimestamp \n    ? `[${new Date().toISOString()}] ` \n    : '';\n\n  let output = '';\n\n  switch (traceConfig.outputFormat) {\n    case 'json':\n      output = formatErrorTraceJSON(error, context, traceConfig);\n      break;\n    case 'compact':\n      output = formatErrorTraceCompact(error, context, traceConfig);\n      break;\n    case 'pretty':\n    default:\n      output = formatErrorTracePretty(error, context, traceConfig);\n      break;\n  }\n\n  return timestamp + output;\n}\n\nfunction formatErrorTracePretty(error: any, context?: any, config?: TraceConfig): string {\n  const traceConfig = config || DEFAULT_TRACE_CONFIG;\n  \n  let output = chalk.red(' Error Details \\n');\n  \n  // Basic error information\n  output += chalk.red(' ') + chalk.bold('Message: ') + (error.message || 'Unknown error') + '\\n';\n  \n  if (error.name) {\n    output += chalk.red(' ') + chalk.bold('Type: ') + error.name + '\\n';\n  }\n  \n  if (error.code) {\n    output += chalk.red(' ') + chalk.bold('Code: ') + error.code + '\\n';\n  }\n  \n  // HTTP-specific information\n  if (error.status || error.statusCode) {\n    output += chalk.red(' ') + chalk.bold('Status: ') + (error.status || error.statusCode) + '\\n';\n  }\n  \n  if (error.response?.data) {\n    output += chalk.red(' ') + chalk.bold('Response: ') + JSON.stringify(error.response.data, null, 2).replace(/\\\\n/g, '\\n   ') + '\\n';\n  }\n  \n  // Context information\n  if (traceConfig.includeContext && context) {\n    output += chalk.red(' ') + chalk.bold('Context: ') + '\\n';\n    Object.entries(context).forEach(([key, value]) => {\n      output += chalk.red('   ') + chalk.cyan(key + ': ') + String(value) + '\\n';\n    });\n  }\n  \n  // Stack trace\n  if (traceConfig.includeStack && error.stack) {\n    output += chalk.red(' ') + chalk.bold('Stack Trace: ') + '\\n';\n    const stackLines = error.stack.split('\\n').slice(1); // Remove first line (it's the message)\n    stackLines.forEach((line: string) => {\n      output += chalk.red('   ') + chalk.gray(line.trim()) + '\\n';\n    });\n  }\n  \n  output += chalk.red('');\n  \n  return output;\n}\n\nfunction formatErrorTraceCompact(error: any, context?: any, _config?: TraceConfig): string {\n  const parts = [error.message || 'Unknown error'];\n  \n  if (error.code) parts.push(`[${error.code}]`);\n  if (error.status || error.statusCode) parts.push(`HTTP:${error.status || error.statusCode}`);\n  if (context?.operation) parts.push(`Op:${context.operation}`);\n  \n  return parts.join(' ');\n}\n\nfunction formatErrorTraceJSON(error: any, context?: any, config?: TraceConfig): string {\n  const errorObject: any = {\n    message: error.message || 'Unknown error',\n    type: error.name || 'Error',\n    timestamp: new Date().toISOString(),\n  };\n  \n  if (error.code) errorObject.code = error.code;\n  if (error.status || error.statusCode) errorObject.status = error.status || error.statusCode;\n  if (error.response?.data) errorObject.response = error.response.data;\n  \n  if (config?.includeContext && context) {\n    errorObject.context = context;\n  }\n  \n  if (config?.includeStack && error.stack) {\n    errorObject.stack = error.stack.split('\\n');\n  }\n  \n  return JSON.stringify(errorObject, null, 2);\n}\n\nexport async function getTraceConfig(commandOptions?: any): Promise<TraceConfig> {\n  try {\n    const config = await loadConfig();\n    const baseConfig = config.trace || DEFAULT_TRACE_CONFIG;\n    \n    // Override with command-line options\n    if (commandOptions?.trace) {\n      return {\n        ...baseConfig,\n        enabled: true,\n        level: commandOptions.verbose ? 'verbose' : baseConfig.level,\n      };\n    }\n    \n    return baseConfig;\n  } catch (error) {\n    return DEFAULT_TRACE_CONFIG;\n  }\n}\n\nexport async function handleError(error: any, context?: any, commandOptions?: any): Promise<void> {\n  const traceConfig = await getTraceConfig(commandOptions);\n  const formattedError = formatErrorTrace(error, context, traceConfig);\n  console.error(formattedError);\n}","/**\n * Process Management Utilities\n * Handles process lifecycle, status reporting, and graceful exits\n */\n\nimport chalk from 'chalk';\nimport type { ProcessStatus } from '../types.js';\n\n// Process status stamping utility\nexport function stampProcessStatus(commandName: string, status: ProcessStatus, details?: string): void {\n  const timestamp = new Date().toISOString();\n  const statusIcon = status === 'success' ? '' : status === 'error' ? '' : '';\n  const statusColor = status === 'success' ? 'green' : status === 'error' ? 'red' : 'yellow';\n  \n  console.log(chalk.gray('\\n' + ''.repeat(60)));\n  console.log(chalk[statusColor](`${statusIcon} Process: ${commandName}`));\n  console.log(chalk.gray(`   Status: ${status.toUpperCase()}`));\n  console.log(chalk.gray(`   Time: ${timestamp}`));\n  if (details) {\n    console.log(chalk.gray(`   Details: ${details}`));\n  }\n  console.log(chalk.gray(''.repeat(60)));\n}\n\nexport function exitWithStatus(\n  commandName: string, \n  status: ProcessStatus, \n  details?: string, \n  exitCode = 0\n): never {\n  stampProcessStatus(commandName, status, details);\n  \n  // In CLI environments, we need to force exit to prevent hanging\n  // This is necessary because HTTP clients, timers, or other resources \n  // might keep the event loop alive\n  process.exit(exitCode);\n}\n\n// Graceful shutdown handler\nexport function setupGracefulShutdown(commandName: string): void {\n  const handleShutdown = (signal: string) => {\n    console.log(chalk.yellow(`\\n\\nReceived ${signal}. Shutting down gracefully...`));\n    exitWithStatus(commandName, 'cancelled', `Interrupted by ${signal}`, 130);\n  };\n\n  process.on('SIGINT', () => handleShutdown('SIGINT'));\n  process.on('SIGTERM', () => handleShutdown('SIGTERM'));\n}","/**\n * Logout Command Implementation\n * Handles user logout and session cleanup\n */\n\nimport chalk from 'chalk';\nimport inquirer from 'inquirer';\nimport ora from 'ora';\nimport { BaseCommand } from '../base/command.js';\nimport { initializeSDK, cleanupSDK } from '../../utils/sdk.js';\nimport { clearAuth, loadConfig } from '../../config/index.js';\nimport type { AuthCommandOptions } from '../../types.js';\n\nexport class LogoutCommand extends BaseCommand {\n  protected commandName = 'logout';\n  \n  protected async executeCommand(options: AuthCommandOptions): Promise<void> {\n    const config = await loadConfig();\n    const profileText = config.currentProfile ? ` (profile: ${config.currentProfile})` : '';\n    \n    if (!options.force) {\n      const { confirm } = await inquirer.prompt([{\n        type: 'confirm',\n        name: 'confirm',\n        message: `Are you sure you want to logout${profileText}?`,\n        default: false,\n      }]);\n      \n      if (!confirm) {\n        console.log(chalk.yellow('Logout cancelled'));\n        return;\n      }\n    }\n    \n    const spinner = ora('Logging out...').start();\n    \n    try {\n      // Try to properly logout from the server\n      try {\n        const sdk = await initializeSDK(false);\n        await sdk.logout();\n      } catch (error) {\n        // Ignore server logout errors - we'll clear local auth anyway\n        console.log(' Debug: Server logout failed, clearing local auth:', error);\n      }\n      \n      // Clear authentication state\n      await clearAuth(config.currentProfile);\n      \n      // Cleanup SDK\n      await cleanupSDK();\n      \n      spinner.succeed('Logged out successfully');\n      console.log(chalk.green(`You have been logged out${profileText}`));\n      \n    } catch (error: any) {\n      spinner.fail('Logout failed');\n      throw error;\n    }\n  }\n}","/**\n * Auth Status Command Implementation\n * Shows current authentication status\n */\n\nimport chalk from 'chalk';\nimport { BaseCommand } from '../base/command.js';\nimport { loadAuth, loadConfig } from '../../config/index.js';\nimport type { AuthCommandOptions } from '../../types.js';\n\nexport class StatusCommand extends BaseCommand {\n  protected commandName = 'auth-status';\n  \n  protected async executeCommand(_options: AuthCommandOptions): Promise<void> {\n    const config = await loadConfig();\n    const auth = await loadAuth(config.currentProfile);\n    \n    console.log(chalk.blue('Authentication Status'));\n    console.log(''.repeat(40));\n    \n    if (!auth || !auth.accessToken) {\n      console.log(chalk.red(' Not authenticated'));\n      console.log(chalk.gray('Run \"acube auth login\" to authenticate'));\n      return;\n    }\n    \n    // Parse token to get expiration info\n    let tokenInfo: any = null;\n    let isExpired = false;\n    \n    try {\n      // Simple token parsing for CLI (without full TokenManager)\n      if (auth.accessToken) {\n        const parts = auth.accessToken.split('.');\n        if (parts.length === 3 && parts[1]) {\n          const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString());\n          tokenInfo = payload;\n        }\n      }\n      \n      const expiresAt = auth.expiresAt || (tokenInfo?.exp ? tokenInfo.exp * 1000 : null);\n      isExpired = expiresAt ? Date.now() >= expiresAt : false;\n      \n    } catch (error) {\n      console.log(' Debug: Failed to parse token:', error);\n    }\n    \n    if (isExpired) {\n      console.log(chalk.red(' Token expired'));\n      console.log(chalk.gray('Run \"acube auth login\" to re-authenticate'));\n      return;\n    }\n    \n    console.log(chalk.green(' Authenticated'));\n    \n    if (auth.user) {\n      console.log(`Email: ${chalk.cyan(auth.user.email)}`);\n      console.log(`Roles: ${chalk.cyan(auth.user.roles?.join(', ') || 'N/A')}`);\n    }\n    \n    if (config.currentProfile) {\n      console.log(`Profile: ${chalk.cyan(config.currentProfile)}`);\n    }\n    \n    if (auth.expiresAt) {\n      console.log(`Expires: ${chalk.gray(new Date(auth.expiresAt).toLocaleString())}`);\n    }\n    \n    console.log(`Environment: ${chalk.cyan(config.environment)}`);\n    console.log(`Token length: ${chalk.gray(auth.accessToken.length)} characters`);\n  }\n}","/**\n * Refresh Token Command Implementation\n * Refreshes authentication tokens\n */\n\nimport chalk from 'chalk';\nimport ora from 'ora';\nimport { BaseCommand } from '../base/command.js';\nimport { loadAuth, loadConfig } from '../../config/index.js';\nimport type { AuthCommandOptions } from '../../types.js';\n\nexport class RefreshCommand extends BaseCommand {\n  protected commandName = 'refresh';\n  \n  protected async executeCommand(_options: AuthCommandOptions): Promise<void> {\n    const config = await loadConfig();\n    const auth = await loadAuth(config.currentProfile);\n    \n    if (!auth || !auth.refreshToken) {\n      throw new Error('No refresh token available. Please login again.');\n    }\n    \n    const spinner = ora('Refreshing authentication token...').start();\n    \n    try {\n      // Token refresh not yet implemented in SDK\n      throw new Error('Token refresh not yet implemented. Please login again.');\n      \n    } catch (error: any) {\n      spinner.fail('Token refresh failed');\n      console.log(chalk.yellow('Your refresh token may have expired. Please login again.'));\n      throw error;\n    }\n  }\n}","/**\n * Config Commands Index\n * Exports all configuration command classes\n */\n\nexport { SetupCommand } from './setup.js';\nexport { ShowConfigCommand } from './show.js';","/**\n * Setup Command Implementation\n * Interactive CLI configuration setup\n */\n\nimport chalk from 'chalk';\nimport inquirer from 'inquirer';\nimport { BaseCommand } from '../base/command.js';\nimport { saveConfig, loadConfig } from '../../config/index.js';\nimport type { BaseCommandOptions } from '../../types.js';\n\nexport class SetupCommand extends BaseCommand {\n  protected commandName = 'setup';\n  \n  protected async executeCommand(_options: BaseCommandOptions): Promise<void> {\n    console.log(chalk.blue('A-Cube E-Receipt CLI Setup'));\n    console.log(chalk.gray('Configure your CLI settings\\n'));\n    \n    const config = await loadConfig();\n    \n    // Environment configuration\n    const envAnswers = await inquirer.prompt([\n      {\n        type: 'list',\n        name: 'environment',\n        message: 'Select environment:',\n        choices: [\n          { name: 'Sandbox (development/testing)', value: 'sandbox' },\n          { name: 'Production (live system)', value: 'production' },\n          { name: 'Development (local)', value: 'development' },\n        ],\n        default: config.environment || 'sandbox',\n      },\n    ]);\n\n    config.environment = envAnswers.environment;\n\n    // Base URLs configuration (optional)\n    const { customUrls } = await inquirer.prompt([{\n      type: 'confirm',\n      name: 'customUrls',\n      message: 'Configure custom base URLs?',\n      default: false,\n    }]);\n\n    if (customUrls) {\n      const urlAnswers = await inquirer.prompt([\n        {\n          type: 'input',\n          name: 'apiUrl',\n          message: 'API base URL:',\n          default: config.baseUrls?.api || '',\n          validate: (input) => !input || input.startsWith('http') || 'Must be a valid HTTP URL',\n        },\n        {\n          type: 'input',\n          name: 'authUrl',\n          message: 'Auth base URL:',\n          default: config.baseUrls?.auth || '',\n          validate: (input) => !input || input.startsWith('http') || 'Must be a valid HTTP URL',\n        },\n      ]);\n\n      if (urlAnswers.apiUrl || urlAnswers.authUrl) {\n        config.baseUrls = {\n          ...(urlAnswers.apiUrl && { api: urlAnswers.apiUrl }),\n          ...(urlAnswers.authUrl && { auth: urlAnswers.authUrl }),\n        };\n      }\n    }\n\n    // Trace configuration\n    const { configureTrace } = await inquirer.prompt([{\n      type: 'confirm',\n      name: 'configureTrace',\n      message: 'Configure error tracing?',\n      default: config.trace?.enabled || false,\n    }]);\n\n    if (configureTrace) {\n      const traceAnswers = await inquirer.prompt([\n        {\n          type: 'confirm',\n          name: 'enabled',\n          message: 'Enable error tracing?',\n          default: config.trace?.enabled !== false,\n        },\n        {\n          type: 'list',\n          name: 'level',\n          message: 'Trace level:',\n          choices: ['basic', 'detailed', 'verbose', 'debug'],\n          default: config.trace?.level || 'basic',\n          when: (answers: any) => answers.enabled,\n        },\n        {\n          type: 'list',\n          name: 'outputFormat',\n          message: 'Output format:',\n          choices: ['pretty', 'compact', 'json'],\n          default: config.trace?.outputFormat || 'pretty',\n          when: (answers: any) => answers.enabled,\n        },\n        {\n          type: 'confirm',\n          name: 'includeStack',\n          message: 'Include stack traces?',\n          default: config.trace?.includeStack || false,\n          when: (answers: any) => answers.enabled,\n        },\n        {\n          type: 'confirm',\n          name: 'includeContext',\n          message: 'Include context information?',\n          default: config.trace?.includeContext !== false,\n          when: (answers: any) => answers.enabled,\n        },\n        {\n          type: 'confirm',\n          name: 'includeTimestamp',\n          message: 'Include timestamps?',\n          default: config.trace?.includeTimestamp !== false,\n          when: (answers: any) => answers.enabled,\n        },\n      ]);\n\n      if (traceAnswers.enabled !== undefined) {\n        config.trace = {\n          enabled: traceAnswers.enabled,\n          level: traceAnswers.level || 'basic',\n          outputFormat: traceAnswers.outputFormat || 'pretty',\n          includeStack: traceAnswers.includeStack || false,\n          includeContext: traceAnswers.includeContext !== false,\n          includeTimestamp: traceAnswers.includeTimestamp !== false,\n        };\n      }\n    }\n\n    await saveConfig(config);\n    console.log(chalk.green(' Configuration saved'));\n  }\n}","/**\n * Show Config Command Implementation\n * Displays current CLI configuration\n */\n\nimport chalk from 'chalk';\nimport { BaseCommand } from '../base/command.js';\nimport { loadConfig } from '../../config/index.js';\nimport type { BaseCommandOptions } from '../../types.js';\n\nexport class ShowConfigCommand extends BaseCommand {\n  protected commandName = 'config-show';\n  \n  protected async executeCommand(_options: BaseCommandOptions): Promise<void> {\n    const config = await loadConfig();\n    \n    console.log(chalk.blue('Current Configuration'));\n    console.log(''.repeat(40));\n    \n    console.log(`Environment: ${chalk.cyan(config.environment)}`);\n    \n    if (config.currentProfile) {\n      console.log(`Current Profile: ${chalk.cyan(config.currentProfile)}`);\n    }\n    \n    if (config.baseUrls) {\n      console.log('\\nCustom URLs:');\n      if (config.baseUrls.api) {\n        console.log(`  API: ${chalk.gray(config.baseUrls.api)}`);\n      }\n      if (config.baseUrls.auth) {\n        console.log(`  Auth: ${chalk.gray(config.baseUrls.auth)}`);\n      }\n    }\n    \n    if (config.trace) {\n      console.log('\\nError Tracing:');\n      console.log(`  Enabled: ${config.trace.enabled ? chalk.green('') : chalk.red('')}`);\n      console.log(`  Level: ${chalk.cyan(config.trace.level)}`);\n      console.log(`  Format: ${chalk.cyan(config.trace.outputFormat)}`);\n      console.log(`  Stack traces: ${config.trace.includeStack ? chalk.green('') : chalk.red('')}`);\n      console.log(`  Context: ${config.trace.includeContext ? chalk.green('') : chalk.red('')}`);\n      console.log(`  Timestamps: ${config.trace.includeTimestamp ? chalk.green('') : chalk.red('')}`);\n    }\n  }\n}","/**\n * Resource Commands Index\n * Exports all resource command classes\n */\n\nexport { ReceiptsCommand } from './receipts.js';\nexport { CashiersCommand } from './cashiers.js';\nexport { MerchantsCommand } from './merchants.js';\nexport { PointOfSalesCommand } from './point-of-sales.js';","/**\n * Receipts Command Implementation\n * Handles receipt management operations\n */\n\nimport chalk from 'chalk';\nimport inquirer from 'inquirer';\nimport ora from 'ora';\nimport { BaseResourceCommand } from '../base/resource.js';\nimport { initializeSDK } from '../../utils/sdk.js';\nimport type { ACubeSDK } from '../../../index.js';\nimport type { BaseCommandOptions } from '../../types.js';\n\nexport class ReceiptsCommand extends BaseResourceCommand {\n  protected commandName = 'receipts';\n  protected resourceName = 'receipt';\n  protected resourceNamePlural = 'receipts';\n  \n  protected getSDKResource(sdk: ACubeSDK) {\n    return sdk.receipts;\n  }\n  \n  protected displayItems(receipts: any[]): void {\n    receipts.forEach((receipt) => {\n      console.log(`\n${this.formatItemHeader(receipt.uuid, receipt.document_number)}\n${this.formatProperty('Type', receipt.type)}\n${this.formatProperty('Amount', `${receipt.total_amount}`)}\n${this.formatProperty('Date', new Date(receipt.created_at).toLocaleDateString())}\n${this.formatProperty('Lottery', receipt.customer_lottery_code)}\n`);\n    });\n  }\n  \n  /**\n   * Create a new receipt interactively\n   */\n  async create(_options: BaseCommandOptions): Promise<void> {\n    console.log(chalk.blue('Creating a new receipt'));\n    \n    const answers = await inquirer.prompt([\n      {\n        type: 'number',\n        name: 'totalAmount',\n        message: 'Total amount (in euros):',\n        validate: (input) => input > 0 || 'Amount must be positive',\n      },\n      {\n        type: 'input',\n        name: 'customerLotteryCode',\n        message: 'Customer lottery code (optional):',\n      },\n    ]);\n    \n    const receiptData = {\n      total_amount: answers.totalAmount.toFixed(2),\n      ...(answers.customerLotteryCode && { customer_lottery_code: answers.customerLotteryCode }),\n    };\n    \n    const spinner = ora('Creating receipt...').start();\n    \n    try {\n      const sdk = await initializeSDK();\n      const receipt = await sdk.receipts.create(receiptData);\n      \n      spinner.succeed('Receipt created successfully');\n      console.log(`Receipt ID: ${chalk.green(receipt.uuid)}`);\n      \n    } catch (error: any) {\n      spinner.fail('Failed to create receipt');\n      throw error;\n    }\n  }\n  \n  protected async executeCommand(_options: any): Promise<void> {\n    // This method is called by the base class\n    // The specific operation (list, create, get, delete) is handled by individual methods\n    throw new Error('ReceiptsCommand.executeCommand should not be called directly');\n  }\n}","/**\n * Base Resource Command Class\n * Abstract base class for resource management commands (CRUD operations)\n */\n\nimport ora from 'ora';\nimport chalk from 'chalk';\nimport { BaseCommand } from './command.js';\nimport { initializeSDK } from '../../utils/sdk.js';\nimport type { ACubeSDK } from '../../../index.js';\nimport type { ResourceListOptions, BaseCommandOptions } from '../../types.js';\n\nexport abstract class BaseResourceCommand extends BaseCommand {\n  protected abstract resourceName: string;\n  protected abstract resourceNamePlural: string;\n  \n  /**\n   * Get the SDK resource instance (e.g., sdk.receipts, sdk.cashiers)\n   */\n  protected abstract getSDKResource(sdk: ACubeSDK): any;\n  \n  /**\n   * Display a list of resource items\n   */\n  protected abstract displayItems(items: any[]): void;\n  \n  /**\n   * List resources with common pagination and error handling\n   */\n  async list(options: ResourceListOptions): Promise<void> {\n    const spinner = ora(`Fetching ${this.resourceNamePlural}...`).start();\n    \n    try {\n      const sdk = await initializeSDK();\n      const resource = this.getSDKResource(sdk);\n      \n      // Prepare API parameters\n      const params: any = {};\n      if (options.limit) params.limit = parseInt(options.limit.toString());\n      if (options.offset) params.offset = parseInt(options.offset.toString());\n      \n      // Call the API\n      const response = await resource.list(params);\n      const items = this.extractItemsFromResponse(response);\n      \n      spinner.succeed(`Found ${items.length} ${this.resourceNamePlural}`);\n      \n      if (items.length === 0) {\n        console.log(chalk.gray(`No ${this.resourceNamePlural} found`));\n      } else {\n        // Support different output formats\n        if (options.format === 'json') {\n          console.log(JSON.stringify(items, null, 2));\n        } else {\n          this.displayItems(items);\n        }\n      }\n      \n      // Ensure the method completes to allow proper exit\n      return;\n      \n    } catch (error: any) {\n      spinner.fail(`Failed to fetch ${this.resourceNamePlural}`);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get a single resource by ID\n   */\n  async get(id: string, _options: BaseCommandOptions): Promise<void> {\n    const spinner = ora(`Fetching ${this.resourceName}...`).start();\n    \n    try {\n      const sdk = await initializeSDK();\n      const resource = this.getSDKResource(sdk);\n      \n      const item = await resource.retrieve(id);\n      \n      spinner.succeed(`Found ${this.resourceName}`);\n      this.displaySingleItem(item);\n      \n    } catch (error: any) {\n      spinner.fail(`Failed to fetch ${this.resourceName}`);\n      throw error;\n    }\n  }\n  \n  /**\n   * Delete a resource by ID\n   */\n  async delete(id: string, _options: BaseCommandOptions): Promise<void> {\n    const spinner = ora(`Deleting ${this.resourceName}...`).start();\n    \n    try {\n      const sdk = await initializeSDK();\n      const resource = this.getSDKResource(sdk);\n      \n      await resource.delete(id);\n      \n      spinner.succeed(`${this.resourceName} deleted successfully`);\n      \n    } catch (error: any) {\n      spinner.fail(`Failed to delete ${this.resourceName}`);\n      throw error;\n    }\n  }\n  \n  /**\n   * Extract items from API response - handles both direct arrays and paginated responses\n   */\n  protected extractItemsFromResponse(response: any): any[] {\n    if (Array.isArray(response)) {\n      return response;\n    }\n    if (response.members && Array.isArray(response.members)) {\n      return response.members;\n    }\n    return [];\n  }\n  \n  /**\n   * Display a single item - default implementation, can be overridden\n   */\n  protected displaySingleItem(item: any): void {\n    console.log(JSON.stringify(item, null, 2));\n  }\n  \n  /**\n   * Format item display with consistent styling\n   */\n  protected formatItemHeader(id: string, title?: string): string {\n    if (title) {\n      return `${chalk.bold(id)} - ${title}`;\n    }\n    return chalk.bold(id);\n  }\n  \n  /**\n   * Format property display with consistent styling\n   */\n  protected formatProperty(label: string, value: any, fallback = 'N/A'): string {\n    const displayValue = value ?? fallback;\n    return `  ${label}: ${displayValue}`;\n  }\n}","/**\n * Cashiers Command Implementation\n * Handles cashier management operations\n */\n\nimport { BaseResourceCommand } from '../base/resource.js';\nimport type { ACubeSDK } from '../../../index.js';\nimport type { BaseCommandOptions } from '../../types.js';\n\nexport class CashiersCommand extends BaseResourceCommand {\n  protected commandName = 'cashiers';\n  protected resourceName = 'cashier';\n  protected resourceNamePlural = 'cashiers';\n  \n  protected getSDKResource(sdk: ACubeSDK) {\n    return sdk.cashiers;\n  }\n  \n  protected displayItems(cashiers: any[]): void {\n    cashiers.forEach((cashier) => {\n      console.log(`\n${this.formatItemHeader(cashier.id.toString())}\n${this.formatProperty('Email', cashier.email)}\n`);\n    });\n  }\n  \n  protected async executeCommand(_options: BaseCommandOptions): Promise<void> {\n    // This method is called by the base class\n    // The specific operation (list, get) is handled by individual methods\n    throw new Error('CashiersCommand.executeCommand should not be called directly');\n  }\n}","/**\n * Merchants Command Implementation\n * Handles merchant management operations\n */\n\nimport { BaseResourceCommand } from '../base/resource.js';\nimport type { ACubeSDK } from '../../../index.js';\nimport type { BaseCommandOptions } from '../../types.js';\n\nexport class MerchantsCommand extends BaseResourceCommand {\n  protected commandName = 'merchants';\n  protected resourceName = 'merchant';\n  protected resourceNamePlural = 'merchants';\n  \n  protected getSDKResource(sdk: ACubeSDK) {\n    return sdk.merchants;\n  }\n  \n  protected displayItems(merchants: any[]): void {\n    merchants.forEach((merchant) => {\n      const address = merchant.address \n        ? `${merchant.address.street_address || ''}, ${merchant.address.city || ''}`.trim().replace(/^,\\s*/, '')\n        : 'N/A';\n      \n      console.log(`\n${this.formatItemHeader(merchant.uuid, merchant.name)}\n${this.formatProperty('Fiscal ID', merchant.fiscal_id)}\n${this.formatProperty('Email', merchant.email)}\n${this.formatProperty('Address', address)}\n`);\n    });\n  }\n  \n  protected async executeCommand(_options: BaseCommandOptions): Promise<void> {\n    // This method is called by the base class\n    // The specific operation (list, get) is handled by individual methods\n    throw new Error('MerchantsCommand.executeCommand should not be called directly');\n  }\n}","/**\n * Point of Sales Command Implementation\n * Handles POS device management operations\n */\n\nimport { BaseResourceCommand } from '../base/resource.js';\nimport type { ACubeSDK } from '../../../index.js';\nimport type { BaseCommandOptions } from '../../types.js';\n\nexport class PointOfSalesCommand extends BaseResourceCommand {\n  protected commandName = 'point-of-sales';\n  protected resourceName = 'point of sale';\n  protected resourceNamePlural = 'point of sales';\n  \n  protected getSDKResource(sdk: ACubeSDK) {\n    return sdk.pointOfSales;\n  }\n  \n  protected displayItems(posList: any[]): void {\n    posList.forEach((pos) => {\n      const address = pos.address \n        ? `${pos.address.street_address || ''}, ${pos.address.city || ''} ${pos.address.zip_code || ''}`.trim().replace(/^,\\s*/, '')\n        : 'N/A';\n      \n      console.log(`\n${this.formatItemHeader(pos.serial_number)}\n${this.formatProperty('Status', pos.status)}\n${this.formatProperty('Address', address)}\n`);\n    });\n  }\n  \n  protected async executeCommand(options: BaseCommandOptions): Promise<void> {\n    // Default to list operation for resource commands\n    // Individual operations can be specified via options or extending classes\n    const resourceOptions = options as any;\n    await this.list(resourceOptions);\n  }\n}","/**\n * Profile Management Commands\n * Handles user profile switching and management\n */\n\nimport chalk from 'chalk';\nimport inquirer from 'inquirer';\nimport { BaseCommand } from './base/command.js';\nimport { loadConfig, saveConfig, listProfiles, deleteProfile } from '../config/index.js';\nimport type { BaseCommandOptions } from '../types.js';\n\nexport class ProfileListCommand extends BaseCommand {\n  protected commandName = 'profile-list';\n  \n  protected async executeCommand(_options: BaseCommandOptions): Promise<void> {\n    const config = await loadConfig();\n    const profiles = await listProfiles();\n    \n    console.log(chalk.blue('Available Profiles'));\n    console.log(''.repeat(30));\n    \n    if (profiles.length === 0) {\n      console.log(chalk.gray('No profiles found'));\n      return;\n    }\n    \n    profiles.forEach(profile => {\n      const isCurrent = config.currentProfile === profile;\n      const marker = isCurrent ? chalk.green('') : ' ';\n      const name = isCurrent ? chalk.green(profile) : profile;\n      console.log(`${marker} ${name}`);\n    });\n  }\n}\n\nexport class ProfileSwitchCommand extends BaseCommand {\n  protected commandName = 'profile-switch';\n  \n  constructor(private profileName: string) {\n    super();\n  }\n  \n  protected async executeCommand(_options: BaseCommandOptions): Promise<void> {\n    const profiles = await listProfiles();\n    \n    if (!profiles.includes(this.profileName)) {\n      throw new Error(`Profile '${this.profileName}' not found. Available profiles: ${profiles.join(', ')}`);\n    }\n    \n    const config = await loadConfig();\n    config.currentProfile = this.profileName;\n    await saveConfig(config);\n    \n    console.log(chalk.green(` Switched to profile: ${this.profileName}`));\n  }\n}\n\nexport class ProfileDeleteCommand extends BaseCommand {\n  protected commandName = 'profile-delete';\n  \n  constructor(private profileName: string) {\n    super();\n  }\n  \n  protected async executeCommand(_options: BaseCommandOptions): Promise<void> {\n    const profiles = await listProfiles();\n    \n    if (!profiles.includes(this.profileName)) {\n      throw new Error(`Profile '${this.profileName}' not found`);\n    }\n    \n    const { confirm } = await inquirer.prompt([{\n      type: 'confirm',\n      name: 'confirm',\n      message: `Are you sure you want to delete profile '${this.profileName}'?`,\n      default: false,\n    }]);\n    \n    if (!confirm) {\n      console.log(chalk.yellow('Profile deletion cancelled'));\n      return;\n    }\n    \n    await deleteProfile(this.profileName);\n    \n    // If we deleted the current profile, clear it\n    const config = await loadConfig();\n    if (config.currentProfile === this.profileName) {\n      delete config.currentProfile;\n      await saveConfig(config);\n    }\n    \n    console.log(chalk.green(` Profile '${this.profileName}' deleted`));\n  }\n}","/**\n * Interactive Mode Command\n * Provides an interactive CLI experience\n */\n\nimport chalk from 'chalk';\nimport inquirer from 'inquirer';\nimport { BaseCommand } from './base/command.js';\nimport { ReceiptsCommand, CashiersCommand, MerchantsCommand, PointOfSalesCommand } from './resources/index.js';\nimport { LoginCommand, LogoutCommand, StatusCommand } from './auth/index.js';\nimport type { BaseCommandOptions } from '../types.js';\n\nexport class InteractiveCommand extends BaseCommand {\n  protected commandName = 'interactive';\n  \n  protected async executeCommand(options: BaseCommandOptions): Promise<void> {\n    console.log(chalk.blue.bold('A-Cube E-Receipt Interactive Mode'));\n    console.log(chalk.gray('Select an option to continue\\n'));\n    \n    while (true) {\n      const { action } = await inquirer.prompt([{\n        type: 'list',\n        name: 'action',\n        message: 'What would you like to do?',\n        choices: [\n          { name: 'Authentication', value: 'auth' },\n          { name: 'Manage Receipts', value: 'receipts' },\n          { name: 'Manage Cashiers', value: 'cashiers' },\n          { name: 'Manage Merchants', value: 'merchants' },\n          { name: 'Manage Point of Sales', value: 'pos' },\n          { name: 'Exit', value: 'exit' },\n        ],\n      }]);\n      \n      if (action === 'exit') {\n        console.log(chalk.green('Goodbye! '));\n        break;\n      }\n      \n      try {\n        await this.handleAction(action, options);\n      } catch (error) {\n        console.error(chalk.red(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`));\n        console.log(chalk.gray('Press any key to continue...'));\n        await inquirer.prompt([{ type: 'input', name: 'continue', message: '' }]);\n      }\n    }\n  }\n  \n  private async handleAction(action: string, options: BaseCommandOptions): Promise<void> {\n    switch (action) {\n      case 'auth':\n        await this.handleAuthMenu(options);\n        break;\n      case 'receipts':\n        await this.handleResourceMenu('receipts', new ReceiptsCommand(), options);\n        break;\n      case 'cashiers':\n        await this.handleResourceMenu('cashiers', new CashiersCommand(), options);\n        break;\n      case 'merchants':\n        await this.handleResourceMenu('merchants', new MerchantsCommand(), options);\n        break;\n      case 'pos':\n        await this.handleResourceMenu('point of sales', new PointOfSalesCommand(), options);\n        break;\n    }\n  }\n  \n  private async handleAuthMenu(options: BaseCommandOptions): Promise<void> {\n    const { authAction } = await inquirer.prompt([{\n      type: 'list',\n      name: 'authAction',\n      message: 'Authentication:',\n      choices: [\n        { name: 'Login', value: 'login' },\n        { name: 'Show Status', value: 'status' },\n        { name: 'Logout', value: 'logout' },\n        { name: 'Back', value: 'back' },\n      ],\n    }]);\n    \n    if (authAction === 'back') return;\n    \n    switch (authAction) {\n      case 'login':\n        await new LoginCommand().run(options);\n        break;\n      case 'status':\n        await new StatusCommand().run(options);\n        break;\n      case 'logout':\n        await new LogoutCommand().run(options);\n        break;\n    }\n  }\n  \n  private async handleResourceMenu(resourceName: string, command: any, options: BaseCommandOptions): Promise<void> {\n    const { resourceAction } = await inquirer.prompt([{\n      type: 'list',\n      name: 'resourceAction',\n      message: `${resourceName}:`,\n      choices: [\n        { name: 'List', value: 'list' },\n        ...(command instanceof ReceiptsCommand ? [{ name: 'Create', value: 'create' }] : []),\n        { name: 'Back', value: 'back' },\n      ],\n    }]);\n    \n    if (resourceAction === 'back') return;\n    \n    switch (resourceAction) {\n      case 'list':\n        await command.list({ limit: 10, ...options });\n        break;\n      case 'create':\n        if (command instanceof ReceiptsCommand) {\n          await command.create(options);\n        }\n        break;\n    }\n  }\n}","/**\n * Version Command Implementation\n * Displays CLI and SDK version information\n */\n\nimport chalk from 'chalk';\nimport { BaseCommand } from './base/command.js';\nimport type { BaseCommandOptions } from '../types.js';\n\nexport class VersionCommand extends BaseCommand {\n  protected commandName = 'version';\n  \n  protected async executeCommand(_options: BaseCommandOptions): Promise<void> {\n    // Import package.json to get version info\n    try {\n      // Read package.json from the project root\n      const fs = await import('fs/promises');\n      const path = await import('path');\n      const packagePath = path.join(process.cwd(), 'package.json');\n      const packageData = JSON.parse(await fs.readFile(packagePath, 'utf-8'));\n      \n      console.log(chalk.blue('A-Cube E-Receipt SDK'));\n      console.log(`Version: ${chalk.green(packageData.version)}`);\n      console.log(`Node.js: ${chalk.gray(process.version)}`);\n      console.log(`Platform: ${chalk.gray(process.platform)} ${chalk.gray(process.arch)}`);\n      \n    } catch (error) {\n      console.log(chalk.blue('A-Cube E-Receipt SDK'));\n      console.log(`Version: ${chalk.gray('Unknown')}`);\n      console.log(`Node.js: ${chalk.gray(process.version)}`);\n      console.log(`Platform: ${chalk.gray(process.platform)} ${chalk.gray(process.arch)}`);\n    }\n  }\n}"],"mappings":"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","names":["path","path","EventEmitter","EventEmitter","path","EventEmitter","isReactNative","DEFAULT_CONFIG","EventEmitter","isReactNative","DEFAULT_CONFIG","EventEmitter","isReactNative","DEFAULT_CONFIG","EventEmitter","init_types","init_types","key","crypto","keyInfo","EventEmitter","DEFAULT_CONFIG","EventEmitter","DEFAULT_CONFIG","EventEmitter","DEFAULT_CONFIG","EventEmitter","DEFAULT_CONFIG","EventEmitter","DEFAULT_CONFIG","EventEmitter","init_types","EventEmitter","init_types","DEFAULT_CONFIG","init_types","EventEmitter","DEFAULT_CONFIG","EventEmitter","keyStorageKey","LRUCache","DEFAULT_CONFIG","init_types","EventEmitter","DEFAULT_CONFIG","init_types","EventEmitter","EventEmitter","isReactNative","OptimizedReactNativeStorageAdapter","ConnectivityManager","BackgroundProcessor","PerformanceMonitor","CashiersResource","ReceiptsResource","PointOfSalesResource","CashRegistersResource","MerchantsResource","PEMsResource","PWAManager","ManifestGenerator","ProgressiveSyncEngine","UnifiedStorage","EnterpriseQueueManager","TokenManager","AuthService","AuthStorage","EnhancedAuthMiddleware","DEFAULT_CONFIG","isReactNative","DEFAULT_CONFIG","init_types","React","import_react","React","import_react","import_react","init_types","import_react","import_react","import_react","import_react","import_jsx_runtime","import_react","import_react","import_jsx_runtime","DEFAULT_CONFIG","init_sdk","chalk","chalk","chalk","cleanupSDK","chalk","init_sdk","chalk","sdk","chalk","inquirer","ora","init_sdk","inquirer","chalk","ora","sdk","chalk","chalk","chalk","ora","ora","chalk","chalk","inquirer","chalk","inquirer","chalk","chalk","chalk","inquirer","ora","ora","chalk","init_sdk","ora","sdk","chalk","init_sdk","sdk","chalk","inquirer","ora","sdk","sdk","sdk","chalk","inquirer","chalk","inquirer","chalk","inquirer","chalk","inquirer","chalk","fs","path","chalk"]}
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/tsup/assets/esm_shims.js
import path from "path";
import { fileURLToPath } from "url";
var init_esm_shims = __esm({
  "node_modules/tsup/assets/esm_shims.js"() {
    "use strict";
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/eventemitter3/index.mjs
var import_index;
var init_eventemitter3 = __esm({
  "node_modules/eventemitter3/index.mjs"() {
    "use strict";
    init_esm_shims();
    import_index = __toESM(require_eventemitter3(), 1);
  }
});

// src/errors/index.ts
function generateRequestId() {
  return `req_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
}
function createErrorFromResponse(response, operation, requestId) {
  const message = getErrorMessage(response.data) || response.statusText;
  switch (response.status) {
    case 401:
      return new AuthenticationError(message, operation, {
        statusCode: response.status,
        ...requestId !== void 0 && { requestId }
      });
    case 403:
      return new AuthorizationError(message, operation, {
        statusCode: response.status,
        ...requestId !== void 0 && { requestId }
      });
    case 404:
      const resourceType = extractResourceType(response.data);
      const resourceId = extractResourceId(response.data);
      if (resourceType && resourceId) {
        return new NotFoundError(resourceType, resourceId, operation, {
          ...requestId !== void 0 && { requestId }
        });
      }
      return new NotFoundError("Resource", "unknown", operation, {
        ...requestId !== void 0 && { requestId }
      });
    case 422:
      const violations = extractValidationViolations(response.data);
      return new ValidationError(message, operation, violations, {
        ...requestId !== void 0 && { requestId }
      });
    case 429:
      const retryAfter = extractRetryAfter(response.data);
      return new RateLimitError(message, operation, {
        ...retryAfter !== void 0 && { retryAfter },
        ...requestId !== void 0 && { requestId }
      });
    case 500:
    case 502:
    case 503:
    case 504:
      return new NetworkError(message, operation, {
        statusCode: response.status,
        ...requestId !== void 0 && { requestId },
        retryable: true
      });
    default:
      return new NetworkError(message, operation, {
        statusCode: response.status,
        ...requestId !== void 0 && { requestId },
        retryable: response.status >= 500
      });
  }
}
function getErrorMessage(data) {
  if (typeof data === "object" && data !== null) {
    const obj = data;
    return obj.message || obj.detail || null;
  }
  return null;
}
function extractResourceType(data) {
  if (typeof data === "object" && data !== null) {
    const obj = data;
    return obj.resourceType || null;
  }
  return null;
}
function extractResourceId(data) {
  if (typeof data === "object" && data !== null) {
    const obj = data;
    return obj.resourceId || null;
  }
  return null;
}
function extractValidationViolations(data) {
  if (typeof data === "object" && data !== null) {
    const obj = data;
    if (Array.isArray(obj.violations)) {
      return obj.violations.map((v) => ({
        field: v.propertyPath || v.field || "unknown",
        message: v.message || "Validation failed",
        code: v.code || "VALIDATION_FAILED",
        value: v.value
      }));
    }
    if (Array.isArray(obj.detail)) {
      return obj.detail.map((v) => ({
        field: v.loc?.join(".") || "unknown",
        message: v.msg || "Validation failed",
        code: v.type || "VALIDATION_FAILED",
        value: v.input
      }));
    }
  }
  return [];
}
function extractRetryAfter(data) {
  if (typeof data === "object" && data !== null) {
    const obj = data;
    const retryAfter = obj.retryAfter || obj.retry_after;
    return typeof retryAfter === "number" ? retryAfter : void 0;
  }
  return void 0;
}
var ACubeSDKError, NetworkError, AuthenticationError, AuthorizationError, ValidationError, FiscalError, RateLimitError, ConfigurationError, NotFoundError, CircuitBreakerError;
var init_errors = __esm({
  "src/errors/index.ts"() {
    "use strict";
    init_esm_shims();
    ACubeSDKError = class extends Error {
      constructor(message, code, options) {
        super(message);
        this.code = code;
        if (options.cause) {
          this.cause = options.cause;
        }
        this.name = this.constructor.name;
        this.timestamp = /* @__PURE__ */ new Date();
        this.requestId = options.requestId ?? generateRequestId();
        this.operation = options.operation;
        this.retryable = options.retryable ?? false;
        if (options.statusCode !== void 0) {
          this.statusCode = options.statusCode;
        }
        if (options.auditInfo !== void 0) {
          this.auditInfo = options.auditInfo;
        }
        Object.setPrototypeOf(this, new.target.prototype);
      }
      timestamp;
      requestId;
      operation;
      retryable;
      statusCode;
      auditInfo;
      cause;
      toJSON() {
        return {
          name: this.name,
          message: this.message,
          code: this.code,
          operation: this.operation,
          retryable: this.retryable,
          statusCode: this.statusCode,
          timestamp: this.timestamp.toISOString(),
          requestId: this.requestId,
          auditInfo: this.auditInfo,
          stack: this.stack
        };
      }
    };
    NetworkError = class extends ACubeSDKError {
      constructor(message, operation, options = {}) {
        super(message, "NETWORK_ERROR", {
          operation,
          retryable: options.retryable ?? true,
          ...options.statusCode !== void 0 && { statusCode: options.statusCode },
          ...options.requestId !== void 0 && { requestId: options.requestId },
          ...options.cause !== void 0 && { cause: options.cause }
        });
      }
    };
    AuthenticationError = class extends ACubeSDKError {
      constructor(message, operation, options = {}) {
        super(message, "AUTHENTICATION_ERROR", {
          operation,
          retryable: false,
          statusCode: options.statusCode ?? 401,
          ...options.requestId !== void 0 && { requestId: options.requestId },
          ...options.auditInfo !== void 0 && { auditInfo: options.auditInfo }
        });
      }
    };
    AuthorizationError = class extends ACubeSDKError {
      constructor(message, operation, options = {}) {
        super(message, "AUTHORIZATION_ERROR", {
          operation,
          retryable: false,
          statusCode: options.statusCode ?? 403,
          ...options.requestId !== void 0 && { requestId: options.requestId },
          ...options.auditInfo !== void 0 && { auditInfo: options.auditInfo }
        });
      }
    };
    ValidationError = class extends ACubeSDKError {
      violations;
      constructor(message, operation, violations, options = {}) {
        super(message, "VALIDATION_ERROR", {
          operation,
          retryable: false,
          statusCode: 422,
          ...options.requestId !== void 0 && { requestId: options.requestId },
          ...options.auditInfo !== void 0 && { auditInfo: options.auditInfo }
        });
        this.violations = violations;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          violations: this.violations
        };
      }
    };
    FiscalError = class extends ACubeSDKError {
      fiscalCode;
      documentNumber;
      constructor(message, operation, options = {}) {
        super(message, "FISCAL_ERROR", {
          operation,
          retryable: options.retryable ?? false,
          statusCode: options.statusCode ?? 400,
          ...options.requestId !== void 0 && { requestId: options.requestId },
          ...options.auditInfo !== void 0 && { auditInfo: options.auditInfo }
        });
        if (options.fiscalCode !== void 0) {
          this.fiscalCode = options.fiscalCode;
        }
        if (options.documentNumber !== void 0) {
          this.documentNumber = options.documentNumber;
        }
      }
      toJSON() {
        return {
          ...super.toJSON(),
          fiscalCode: this.fiscalCode,
          documentNumber: this.documentNumber
        };
      }
    };
    RateLimitError = class extends ACubeSDKError {
      retryAfter;
      constructor(message, operation, options = {}) {
        super(message, "RATE_LIMIT_ERROR", {
          operation,
          retryable: true,
          statusCode: 429,
          ...options.requestId !== void 0 && { requestId: options.requestId }
        });
        if (options.retryAfter !== void 0) {
          this.retryAfter = options.retryAfter;
        }
      }
      toJSON() {
        return {
          ...super.toJSON(),
          retryAfter: this.retryAfter
        };
      }
    };
    ConfigurationError = class extends ACubeSDKError {
      constructor(message, operation, options = {}) {
        super(message, "CONFIGURATION_ERROR", {
          operation,
          retryable: false,
          ...options.requestId !== void 0 && { requestId: options.requestId }
        });
      }
    };
    NotFoundError = class extends ACubeSDKError {
      resourceType;
      resourceId;
      constructor(resourceType, resourceId, operation, options = {}) {
        super(
          `${resourceType} with id ${resourceId} not found`,
          "NOT_FOUND_ERROR",
          {
            operation,
            retryable: false,
            statusCode: 404,
            ...options.requestId !== void 0 && { requestId: options.requestId },
            ...options.auditInfo !== void 0 && { auditInfo: options.auditInfo }
          }
        );
        this.resourceType = resourceType;
        this.resourceId = resourceId;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          resourceType: this.resourceType,
          resourceId: this.resourceId
        };
      }
    };
    CircuitBreakerError = class extends ACubeSDKError {
      state;
      constructor(message, operation, state, options = {}) {
        super(message, "CIRCUIT_BREAKER_ERROR", {
          operation,
          retryable: true,
          ...options.requestId !== void 0 && { requestId: options.requestId }
        });
        this.state = state;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          state: this.state
        };
      }
    };
  }
});

// src/storage/adapters/optimized-react-native-storage.ts
var optimized_react_native_storage_exports = {};
__export(optimized_react_native_storage_exports, {
  OptimizedReactNativeStorageAdapter: () => OptimizedReactNativeStorageAdapter
});
var isReactNative, LRUCache, WriteBatchManager, DEFAULT_CONFIG, OptimizedReactNativeStorageAdapter;
var init_optimized_react_native_storage = __esm({
  "src/storage/adapters/optimized-react-native-storage.ts"() {
    "use strict";
    init_esm_shims();
    init_eventemitter3();
    isReactNative = typeof navigator !== "undefined" && (navigator.product === "ReactNative" || global.__REACT_NATIVE__);
    LRUCache = class {
      cache = /* @__PURE__ */ new Map();
      maxSize;
      ttl;
      constructor(maxSize = 1e3, ttl = 5 * 60 * 1e3) {
        this.maxSize = maxSize;
        this.ttl = ttl;
      }
      get(key) {
        const entry = this.cache.get(key);
        if (!entry) return null;
        if (Date.now() - entry.timestamp > this.ttl) {
          this.cache.delete(key);
          return null;
        }
        this.cache.delete(key);
        this.cache.set(key, entry);
        return entry.value;
      }
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.delete(key);
        } else if (this.cache.size >= this.maxSize) {
          const firstKey = this.cache.keys().next().value;
          if (firstKey) {
            this.cache.delete(firstKey);
          }
        }
        this.cache.set(key, { value, timestamp: Date.now() });
      }
      delete(key) {
        return this.cache.delete(key);
      }
      clear() {
        this.cache.clear();
      }
      size() {
        return this.cache.size;
      }
      // Cleanup expired entries
      cleanup() {
        const now = Date.now();
        let cleaned = 0;
        for (const [key, entry] of this.cache.entries()) {
          if (now - entry.timestamp > this.ttl) {
            this.cache.delete(key);
            cleaned++;
          }
        }
        return cleaned;
      }
    };
    WriteBatchManager = class {
      pendingWrites = /* @__PURE__ */ new Map();
      batchTimer;
      batchDelay;
      maxBatchSize;
      constructor(batchDelay = 50, maxBatchSize = 100) {
        this.batchDelay = batchDelay;
        this.maxBatchSize = maxBatchSize;
      }
      enqueue(key, value) {
        return new Promise((resolve, reject) => {
          const existing = this.pendingWrites.get(key);
          if (existing) {
            existing.resolve();
          }
          this.pendingWrites.set(key, {
            value,
            timestamp: Date.now(),
            resolve,
            reject
          });
          if (!this.batchTimer) {
            this.batchTimer = setTimeout(() => this.processBatch(), this.batchDelay);
          }
          if (this.pendingWrites.size >= this.maxBatchSize) {
            this.processBatch();
          }
        });
      }
      async processBatch() {
        if (this.batchTimer) {
          clearTimeout(this.batchTimer);
          this.batchTimer = void 0;
        }
        if (this.pendingWrites.size === 0) return;
        const batch = Array.from(this.pendingWrites.entries());
        this.pendingWrites.clear();
        try {
          const AsyncStorageModule = await import("@react-native-async-storage/async-storage");
          const AsyncStorage = AsyncStorageModule.default;
          const multiSetArray = batch.map(([key, data]) => [key, data.value]);
          await AsyncStorage.multiSet(multiSetArray);
          batch.forEach(([, data]) => data.resolve());
        } catch (error) {
          batch.forEach(([, data]) => data.reject(error));
        }
      }
      async flush() {
        return this.processBatch();
      }
      clear() {
        if (this.batchTimer) {
          clearTimeout(this.batchTimer);
          this.batchTimer = void 0;
        }
        for (const [, data] of this.pendingWrites) {
          data.reject(new Error("Batch manager cleared"));
        }
        this.pendingWrites.clear();
      }
    };
    DEFAULT_CONFIG = {
      keyPrefix: "acube_optimized",
      enableCache: true,
      cacheSize: 1e3,
      cacheTTL: 5 * 60 * 1e3,
      // 5 minutes
      enableBatching: true,
      batchDelay: 50,
      // 50ms
      maxBatchSize: 100,
      enableCompression: true,
      compressionThreshold: 1024,
      // 1KB
      enableBackgroundCleanup: true,
      cleanupInterval: 10 * 60 * 1e3,
      // 10 minutes
      enableMetrics: true,
      enableMemoryPressureHandling: true,
      memoryPressureThreshold: 50 * 1024 * 1024
      // 50MB
    };
    OptimizedReactNativeStorageAdapter = class extends import_index.default {
      name = "OptimizedReactNativeStorage";
      isAvailable = isReactNative;
      capabilities = {
        supportsTransactions: false,
        supportsIndexing: false,
        maxKeyLength: 1e3,
        maxValueSize: 6 * 1024 * 1024,
        // 6MB (iOS limit)
        supportsCompression: true,
        supportsEncryption: false,
        supportsTTL: true
      };
      config;
      cache;
      writeBatch;
      AsyncStorage;
      isInitialized = false;
      metrics;
      cleanupTimer;
      memoryUsage = 0;
      constructor(config = {}) {
        super();
        this.config = { ...DEFAULT_CONFIG, ...config };
        this.cache = new LRUCache(this.config.cacheSize, this.config.cacheTTL);
        this.writeBatch = new WriteBatchManager(this.config.batchDelay, this.config.maxBatchSize);
        this.metrics = this.initializeMetrics();
        this.initialize();
      }
      initializeMetrics() {
        return {
          cacheHits: 0,
          cacheMisses: 0,
          reads: 0,
          writes: 0,
          batches: 0,
          compressionSaved: 0,
          avgReadTime: 0,
          avgWriteTime: 0,
          memoryPressureEvents: 0,
          backgroundCleanups: 0
        };
      }
      async initialize() {
        if (this.isInitialized || !this.isAvailable) return;
        try {
          const AsyncStorageModule = await import("@react-native-async-storage/async-storage");
          this.AsyncStorage = AsyncStorageModule.default;
          if (this.config.enableBackgroundCleanup) {
            this.startBackgroundCleanup();
          }
          if (this.config.enableMemoryPressureHandling) {
            this.setupMemoryPressureHandling();
          }
          this.isInitialized = true;
        } catch (error) {
          throw new Error(`Failed to initialize OptimizedReactNativeStorageAdapter: ${error}`);
        }
      }
      startBackgroundCleanup() {
        this.cleanupTimer = setInterval(async () => {
          const startTime = Date.now();
          try {
            const cacheCleanedCount = this.cache.cleanup();
            const storageCleanedCount = await this.cleanupExpiredStorage();
            const duration = Date.now() - startTime;
            const totalCleaned = cacheCleanedCount + storageCleanedCount;
            this.metrics.backgroundCleanups++;
            this.emit("background:cleanup", { cleaned: totalCleaned, duration });
            if (this.config.enableMetrics && this.metrics.backgroundCleanups % 10 === 0) {
              this.emit("performance:metrics", { metrics: { ...this.metrics } });
            }
          } catch (error) {
            console.warn("Background cleanup failed:", error);
          }
        }, this.config.cleanupInterval);
      }
      setupMemoryPressureHandling() {
        setInterval(() => {
          if (this.memoryUsage > this.config.memoryPressureThreshold) {
            this.handleMemoryPressure();
          }
        }, 3e4);
      }
      handleMemoryPressure() {
        this.metrics.memoryPressureEvents++;
        this.emit("memory:pressure", {
          usage: this.memoryUsage,
          threshold: this.config.memoryPressureThreshold
        });
        this.cache.clear();
        this.writeBatch.flush();
      }
      async set(key, value, options = {}) {
        await this.initialize();
        const startTime = Date.now();
        try {
          const entry = {
            data: value,
            metadata: {
              key,
              createdAt: Date.now(),
              updatedAt: Date.now(),
              expiresAt: options.ttl ? Date.now() + options.ttl : void 0,
              encrypted: false,
              compressed: false,
              version: options.version || "1.0.0"
            }
          };
          let serialized = JSON.stringify(entry);
          const originalSize = new Blob([serialized]).size;
          if (this.config.enableCompression && originalSize > this.config.compressionThreshold) {
            serialized = await this.compress(serialized);
            entry.metadata.compressed = true;
            const compressedSize = new Blob([serialized]).size;
            const saved = originalSize - compressedSize;
            this.metrics.compressionSaved += saved;
            this.emit("compression:applied", {
              key,
              originalSize,
              compressedSize
            });
          }
          const storageKey = this.getPrefixedKey(key);
          if (this.config.enableCache) {
            this.cache.set(storageKey, entry);
          }
          if (this.config.enableBatching) {
            await this.writeBatch.enqueue(storageKey, serialized);
          } else {
            await this.AsyncStorage.setItem(storageKey, serialized);
          }
          this.metrics.writes++;
          const duration = Date.now() - startTime;
          this.metrics.avgWriteTime = (this.metrics.avgWriteTime + duration) / 2;
          this.memoryUsage += originalSize;
        } catch (error) {
          throw new Error(`Failed to set ${key}: ${error}`);
        }
      }
      async get(key) {
        await this.initialize();
        const startTime = Date.now();
        const storageKey = this.getPrefixedKey(key);
        try {
          if (this.config.enableCache) {
            const cached = this.cache.get(storageKey);
            if (cached) {
              this.metrics.cacheHits++;
              this.emit("cache:hit", { key });
              if (this.isExpired(cached)) {
                this.cache.delete(storageKey);
                await this.delete(key);
                return null;
              }
              return cached;
            } else {
              this.metrics.cacheMisses++;
              this.emit("cache:miss", { key });
            }
          }
          const serialized = await this.AsyncStorage.getItem(storageKey);
          if (!serialized) return null;
          let data = serialized;
          try {
            const entry = JSON.parse(data);
            if (entry.metadata.compressed) {
              const decompressed = await this.decompress(data);
              const decompressedEntry = JSON.parse(decompressed);
              data = JSON.stringify(decompressedEntry);
            }
            const finalEntry = JSON.parse(data);
            if (this.isExpired(finalEntry)) {
              await this.delete(key);
              return null;
            }
            if (this.config.enableCache) {
              this.cache.set(storageKey, finalEntry);
            }
            this.metrics.reads++;
            const duration = Date.now() - startTime;
            this.metrics.avgReadTime = (this.metrics.avgReadTime + duration) / 2;
            return finalEntry;
          } catch (error) {
            console.warn(`Corrupted data for key ${key}:`, error);
            await this.delete(key);
            return null;
          }
        } catch (error) {
          console.warn(`Failed to get ${key}:`, error);
          return null;
        }
      }
      async delete(key) {
        await this.initialize();
        const storageKey = this.getPrefixedKey(key);
        try {
          if (this.config.enableCache) {
            this.cache.delete(storageKey);
          }
          await this.AsyncStorage.removeItem(storageKey);
          return true;
        } catch (error) {
          console.warn(`Failed to delete ${key}:`, error);
          return false;
        }
      }
      async exists(key) {
        const entry = await this.get(key);
        return entry !== null;
      }
      async clear(namespace) {
        await this.initialize();
        try {
          if (namespace) {
            const keys = await this.getAllKeys();
            const namespacedKeys = keys.filter((k) => k.startsWith(namespace));
            await this.deleteMany(namespacedKeys);
          } else {
            const keys = await this.getAllKeys();
            const prefixedKeys = keys.map((k) => this.getPrefixedKey(k));
            await this.AsyncStorage.multiRemove(prefixedKeys);
            if (this.config.enableCache) {
              this.cache.clear();
            }
          }
          this.memoryUsage = 0;
        } catch (error) {
          throw new Error(`Failed to clear storage: ${error}`);
        }
      }
      async setMany(entries) {
        await this.initialize();
        if (this.config.enableBatching) {
          for (const entry of entries) {
            await this.set(entry.key, entry.value, entry.options);
          }
        } else {
          const serializedEntries = [];
          for (const { key, value, options = {} } of entries) {
            const entry = {
              data: value,
              metadata: {
                key,
                createdAt: Date.now(),
                updatedAt: Date.now(),
                expiresAt: options.ttl ? Date.now() + options.ttl : void 0,
                encrypted: false,
                compressed: false,
                version: options.version || "1.0.0"
              }
            };
            const serialized = JSON.stringify(entry);
            const storageKey = this.getPrefixedKey(key);
            serializedEntries.push([storageKey, serialized]);
            if (this.config.enableCache) {
              this.cache.set(storageKey, entry);
            }
          }
          await this.AsyncStorage.multiSet(serializedEntries);
          this.metrics.writes += entries.length;
        }
      }
      async getMany(keys) {
        await this.initialize();
        const results = [];
        const uncachedKeys = [];
        const keyMap = /* @__PURE__ */ new Map();
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (!key) {
            results[i] = null;
            continue;
          }
          const storageKey = this.getPrefixedKey(key);
          if (this.config.enableCache) {
            const cached = this.cache.get(storageKey);
            if (cached) {
              results[i] = this.isExpired(cached) ? null : cached;
              this.metrics.cacheHits++;
              continue;
            } else {
              this.metrics.cacheMisses++;
            }
          }
          uncachedKeys.push(key);
          keyMap.set(this.getPrefixedKey(key), i);
        }
        if (uncachedKeys.length > 0) {
          const prefixedKeys = uncachedKeys.map((k) => this.getPrefixedKey(k));
          const storageResults = await this.AsyncStorage.multiGet(prefixedKeys);
          for (const [storageKey, serialized] of storageResults) {
            const index = keyMap.get(storageKey);
            if (index === void 0 || index === null) continue;
            if (!serialized) {
              results[index] = null;
              continue;
            }
            try {
              const entry = JSON.parse(serialized);
              if (this.isExpired(entry)) {
                results[index] = null;
                const keyToDelete = keys[index];
                if (keyToDelete) {
                  await this.delete(keyToDelete);
                }
              } else {
                results[index] = entry;
                if (this.config.enableCache) {
                  this.cache.set(storageKey, entry);
                }
              }
            } catch (error) {
              const keyForLog = keys[index] || "unknown";
              console.warn(`Corrupted data for key ${keyForLog}:`, error);
              results[index] = null;
            }
          }
        }
        this.metrics.reads += keys.length;
        return results;
      }
      async deleteMany(keys) {
        await this.initialize();
        try {
          const prefixedKeys = keys.map((k) => this.getPrefixedKey(k));
          if (this.config.enableCache) {
            for (const prefixedKey of prefixedKeys) {
              this.cache.delete(prefixedKey);
            }
          }
          await this.AsyncStorage.multiRemove(prefixedKeys);
          return keys.length;
        } catch (error) {
          console.warn("Failed to delete multiple keys:", error);
          return 0;
        }
      }
      async query(options = {}) {
        await this.initialize();
        const keys = await this.getAllKeys();
        let filteredKeys = keys;
        if (options.prefix || options.keyPrefix) {
          const prefix = options.prefix || options.keyPrefix;
          filteredKeys = keys.filter((k) => k.startsWith(prefix));
        }
        if (options.namespace) {
          filteredKeys = filteredKeys.filter((k) => k.includes(options.namespace));
        }
        if (options.offset) {
          filteredKeys = filteredKeys.slice(options.offset);
        }
        if (options.limit) {
          filteredKeys = filteredKeys.slice(0, options.limit);
        }
        const entries = await this.getMany(filteredKeys);
        const validEntries = entries.filter((entry) => {
          if (!entry) return false;
          if (!options.includeExpired && this.isExpired(entry)) return false;
          return true;
        });
        if (options.sortBy) {
          validEntries.sort((a, b) => {
            let aValue;
            let bValue;
            switch (options.sortBy) {
              case "createdAt":
                aValue = a.metadata.createdAt;
                bValue = b.metadata.createdAt;
                break;
              case "updatedAt":
                aValue = a.metadata.updatedAt;
                bValue = b.metadata.updatedAt;
                break;
              case "key":
              default:
                aValue = a.metadata.key.localeCompare(b.metadata.key);
                bValue = 0;
                break;
            }
            const result = aValue - bValue;
            return options.sortOrder === "desc" ? -result : result;
          });
        }
        return validEntries;
      }
      // StorageAdapter interface methods
      async keys(options) {
        await this.initialize();
        try {
          const allKeys = await this.getAllKeys();
          let filteredKeys = allKeys;
          if (options?.prefix || options?.keyPrefix) {
            const prefix = options.prefix || options.keyPrefix;
            filteredKeys = allKeys.filter((k) => k.startsWith(prefix));
          }
          if (options?.namespace) {
            filteredKeys = filteredKeys.filter((k) => k.includes(options.namespace));
          }
          if (options?.offset) {
            filteredKeys = filteredKeys.slice(options.offset);
          }
          if (options?.limit) {
            filteredKeys = filteredKeys.slice(0, options.limit);
          }
          return filteredKeys.map((k) => k);
        } catch (error) {
          console.warn("Failed to get keys:", error);
          return [];
        }
      }
      async values(options) {
        const keys = await this.keys(options);
        const entries = await this.getMany(keys);
        return entries.filter((entry) => entry !== null);
      }
      async entries(options) {
        return this.values(options);
      }
      async count(options) {
        const keys = await this.keys(options);
        return keys.length;
      }
      // Transaction support (basic implementation)
      async beginTransaction() {
        throw new Error("Transactions not supported in AsyncStorage adapter");
      }
      // Lifecycle methods
      async connect() {
        await this.initialize();
      }
      async disconnect() {
        this.destroy();
      }
      isConnected() {
        return this.isInitialized;
      }
      // Maintenance methods
      async optimize() {
        const cleaned = this.cache.cleanup();
        await this.writeBatch.flush();
        console.log(`Storage optimized: cleaned ${cleaned} cache entries`);
      }
      async getStats() {
        const keys = await this.getAllKeys();
        const entries = await this.getMany(keys);
        const validEntries = entries.filter((entry) => entry !== null);
        let totalSize = 0;
        let encryptedCount = 0;
        let compressedCount = 0;
        let oldestTimestamp = Date.now();
        let newestTimestamp = 0;
        const namespaces = /* @__PURE__ */ new Set();
        for (const entry of validEntries) {
          if (entry) {
            totalSize += JSON.stringify(entry).length;
            if (entry.metadata.encrypted) encryptedCount++;
            if (entry.metadata.compressed) compressedCount++;
            oldestTimestamp = Math.min(oldestTimestamp, entry.metadata.createdAt);
            newestTimestamp = Math.max(newestTimestamp, entry.metadata.updatedAt);
            const keyStr = entry.metadata.key;
            const namespace = keyStr.split(":")[0];
            if (namespace) namespaces.add(namespace);
          }
        }
        return {
          totalKeys: validEntries.length,
          totalSize,
          namespaces: Array.from(namespaces),
          oldestEntry: oldestTimestamp,
          newestEntry: newestTimestamp,
          expiredEntries: 0,
          // Would need to check expiration
          encryptedEntries: encryptedCount,
          compressedEntries: compressedCount
        };
      }
      // Utility methods
      getPrefixedKey(key) {
        return `${this.config.keyPrefix}:${key}`;
      }
      isExpired(entry) {
        return entry.metadata.expiresAt ? Date.now() > entry.metadata.expiresAt : false;
      }
      async getAllKeys() {
        const allKeys = await this.AsyncStorage.getAllKeys();
        return allKeys.filter((key) => key.startsWith(`${this.config.keyPrefix}:`)).map((key) => key.substring(this.config.keyPrefix.length + 1));
      }
      async cleanupExpiredStorage() {
        const keys = await this.getAllKeys();
        const expiredKeys = [];
        for (const key of keys) {
          const entry = await this.get(key);
          if (!entry || this.isExpired(entry)) {
            expiredKeys.push(key);
          }
        }
        if (expiredKeys.length > 0) {
          await this.deleteMany(expiredKeys);
        }
        return expiredKeys.length;
      }
      // Compression utilities (simplified for demo - in production use a proper compression library)
      async compress(data) {
        return data;
      }
      async decompress(data) {
        return data;
      }
      /**
       * Get performance metrics
       */
      getMetrics() {
        return { ...this.metrics };
      }
      /**
       * Get cache statistics
       */
      getCacheStats() {
        return {
          size: this.cache.size(),
          maxSize: this.config.cacheSize,
          hitRate: this.metrics.cacheHits / (this.metrics.cacheHits + this.metrics.cacheMisses) || 0
        };
      }
      /**
       * Force cleanup
       */
      async cleanup() {
        const cleaned = await this.cleanupExpiredStorage();
        this.cache.cleanup();
        console.log(`Cleaned ${cleaned} expired entries`);
        return cleaned;
      }
      /**
       * Destroy adapter and cleanup resources
       */
      async destroy() {
        if (this.cleanupTimer) {
          clearInterval(this.cleanupTimer);
        }
        this.writeBatch.clear();
        this.cache.clear();
        this.removeAllListeners();
      }
    };
  }
});

// src/react-native/connectivity-manager.ts
var connectivity_manager_exports = {};
__export(connectivity_manager_exports, {
  ConnectivityManager: () => ConnectivityManager
});
var isReactNative2, DEFAULT_QUALITY_THRESHOLDS, DEFAULT_RETRY_CONFIGS, DEFAULT_TIMEOUT_CONFIGS, DEFAULT_CONFIG2, ConnectivityManager;
var init_connectivity_manager = __esm({
  "src/react-native/connectivity-manager.ts"() {
    "use strict";
    init_esm_shims();
    init_eventemitter3();
    isReactNative2 = typeof navigator !== "undefined" && (navigator.product === "ReactNative" || global.__REACT_NATIVE__);
    DEFAULT_QUALITY_THRESHOLDS = {
      excellent: { minDownlink: 10, maxRtt: 50 },
      good: { minDownlink: 2, maxRtt: 150 },
      fair: { minDownlink: 0.5, maxRtt: 300 },
      poor: { minDownlink: 0, maxRtt: 1e3 }
    };
    DEFAULT_RETRY_CONFIGS = {
      excellent: { maxRetries: 2, baseDelay: 500, maxDelay: 2e3, backoffMultiplier: 1.5, jitter: true },
      good: { maxRetries: 3, baseDelay: 1e3, maxDelay: 5e3, backoffMultiplier: 2, jitter: true },
      fair: { maxRetries: 4, baseDelay: 2e3, maxDelay: 1e4, backoffMultiplier: 2, jitter: true },
      poor: { maxRetries: 5, baseDelay: 3e3, maxDelay: 15e3, backoffMultiplier: 2.5, jitter: true },
      unknown: { maxRetries: 3, baseDelay: 1500, maxDelay: 8e3, backoffMultiplier: 2, jitter: true }
    };
    DEFAULT_TIMEOUT_CONFIGS = {
      excellent: 5e3,
      good: 1e4,
      fair: 15e3,
      poor: 3e4,
      unknown: 15e3
    };
    DEFAULT_CONFIG2 = {
      enableQualityMonitoring: true,
      qualityCheckInterval: 3e4,
      // 30 seconds
      enableAdaptiveRetry: true,
      enableDataOptimization: true,
      enableAppStateOptimization: true,
      qualityThresholds: DEFAULT_QUALITY_THRESHOLDS,
      retryConfigs: DEFAULT_RETRY_CONFIGS,
      timeoutConfigs: DEFAULT_TIMEOUT_CONFIGS,
      enableHealthMonitoring: true,
      healthCheckUrl: "https://ereceipts-it.acubeapi.com/health",
      healthCheckInterval: 6e4
      // 1 minute
    };
    ConnectivityManager = class extends import_index.default {
      config;
      currentState;
      previousState;
      isInitialized = false;
      // React Native modules
      NetInfo;
      AppState;
      // Monitoring timers
      qualityTimer;
      healthTimer;
      // Connection health tracking
      healthHistory = [];
      currentAppState = "active";
      constructor(config = {}) {
        super();
        this.config = { ...DEFAULT_CONFIG2, ...config };
        this.currentState = this.getInitialState();
        this.initialize();
      }
      getInitialState() {
        return {
          isConnected: false,
          connectionType: "unknown",
          quality: "unknown",
          timestamp: Date.now()
        };
      }
      async initialize() {
        if (this.isInitialized || !isReactNative2) return;
        try {
          const NetInfoModule = await import("@react-native-community/netinfo");
          this.NetInfo = NetInfoModule.default;
          const AppStateModule = await import("react-native");
          this.AppState = AppStateModule.AppState;
          this.setupNetworkListener();
          this.setupAppStateListener();
          if (this.config.enableQualityMonitoring) {
            this.startQualityMonitoring();
          }
          if (this.config.enableHealthMonitoring) {
            this.startHealthMonitoring();
          }
          await this.updateNetworkState();
          this.isInitialized = true;
        } catch (error) {
          console.warn("Failed to initialize ConnectivityManager:", error);
          this.setupFallbackDetection();
        }
      }
      setupNetworkListener() {
        if (!this.NetInfo) return;
        this.NetInfo.addEventListener((state) => {
          this.handleNetworkStateChange(state);
        });
      }
      setupAppStateListener() {
        if (!this.AppState) return;
        this.AppState.addEventListener("change", (nextAppState) => {
          const previousAppState = this.currentAppState;
          this.currentAppState = nextAppState;
          if (previousAppState === "background" && nextAppState === "active") {
            this.emit("app:foreground", { networkState: this.currentState });
            this.updateNetworkState();
          } else if (previousAppState === "active" && nextAppState === "background") {
            this.emit("app:background", { networkState: this.currentState });
          }
        });
      }
      setupFallbackDetection() {
        if (typeof window !== "undefined") {
          window.addEventListener("online", () => {
            this.currentState = {
              ...this.currentState,
              isConnected: true,
              timestamp: Date.now()
            };
            this.emit("connection:restored", { newState: this.currentState });
          });
          window.addEventListener("offline", () => {
            const lastState = { ...this.currentState };
            this.currentState = {
              ...this.currentState,
              isConnected: false,
              timestamp: Date.now()
            };
            this.emit("connection:lost", { lastState });
          });
        }
      }
      async handleNetworkStateChange(netInfoState) {
        this.previousState = { ...this.currentState };
        const newState = {
          isConnected: netInfoState.isConnected,
          connectionType: this.mapConnectionType(netInfoState.type, netInfoState.details),
          quality: this.calculateNetworkQuality(netInfoState),
          effectiveType: netInfoState.details?.effectiveType,
          downlink: netInfoState.details?.downlink,
          rtt: netInfoState.details?.rtt,
          saveData: netInfoState.details?.saveData,
          isExpensive: netInfoState.details?.isConnectionExpensive,
          strength: netInfoState.details?.strength,
          timestamp: Date.now()
        };
        this.currentState = newState;
        this.emit("network:change", { current: newState, previous: this.previousState });
        if (this.previousState.quality !== newState.quality) {
          this.emit("quality:change", {
            quality: newState.quality,
            previous: this.previousState.quality
          });
        }
        if (!this.previousState.isConnected && newState.isConnected) {
          this.emit("connection:restored", { newState });
        } else if (this.previousState.isConnected && !newState.isConnected) {
          this.emit("connection:lost", { lastState: this.previousState });
        }
        if (this.config.enableDataOptimization) {
          this.handleDataOptimization(newState);
        }
      }
      mapConnectionType(type, details) {
        if (!type || type === "none") return "none";
        switch (type.toLowerCase()) {
          case "wifi":
            return "wifi";
          case "cellular":
            if (details?.cellularGeneration) {
              switch (details.cellularGeneration) {
                case "2g":
                  return "2g";
                case "3g":
                  return "3g";
                case "4g":
                  return "4g";
                case "5g":
                  return "5g";
                default:
                  return "cellular";
              }
            }
            return "cellular";
          case "ethernet":
            return "ethernet";
          case "bluetooth":
            return "bluetooth";
          default:
            return "unknown";
        }
      }
      calculateNetworkQuality(netInfoState) {
        const { details } = netInfoState;
        if (!details) return "unknown";
        const downlink = details.downlink || 0;
        const rtt = details.rtt || 1e3;
        const qualityThresholds = {
          ...DEFAULT_QUALITY_THRESHOLDS,
          ...this.config.qualityThresholds
        };
        if (downlink >= qualityThresholds.excellent.minDownlink && rtt <= qualityThresholds.excellent.maxRtt) {
          return "excellent";
        } else if (downlink >= qualityThresholds.good.minDownlink && rtt <= qualityThresholds.good.maxRtt) {
          return "good";
        } else if (downlink >= qualityThresholds.fair.minDownlink && rtt <= qualityThresholds.fair.maxRtt) {
          return "fair";
        } else if (downlink >= qualityThresholds.poor.minDownlink && rtt <= qualityThresholds.poor.maxRtt) {
          return "poor";
        }
        return "unknown";
      }
      handleDataOptimization(networkState) {
        const shouldOptimize = networkState.saveData || networkState.isExpensive || networkState.quality === "poor" || ["2g", "3g"].includes(networkState.connectionType);
        if (shouldOptimize) {
          const reason = networkState.saveData ? "data_saver" : networkState.isExpensive ? "expensive_connection" : networkState.quality === "poor" ? "poor_quality" : "slow_connection";
          this.emit("data:optimization", { enabled: true, reason });
        } else {
          this.emit("data:optimization", { enabled: false, reason: "good_connection" });
        }
      }
      startQualityMonitoring() {
        this.qualityTimer = setInterval(async () => {
          if (this.currentAppState === "active") {
            await this.updateNetworkState();
          }
        }, this.config.qualityCheckInterval);
      }
      startHealthMonitoring() {
        this.healthTimer = setInterval(async () => {
          if (this.currentState.isConnected && this.currentAppState === "active") {
            await this.performHealthCheck();
          }
        }, this.config.healthCheckInterval);
      }
      async updateNetworkState() {
        if (!this.NetInfo) return;
        try {
          const netInfoState = await this.NetInfo.fetch();
          await this.handleNetworkStateChange(netInfoState);
        } catch (error) {
          console.warn("Failed to fetch network state:", error);
        }
      }
      async performHealthCheck() {
        try {
          const startTime = Date.now();
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 5e3);
          const response = await fetch(this.config.healthCheckUrl, {
            method: "HEAD",
            signal: controller.signal
          });
          clearTimeout(timeout);
          const latency = Date.now() - startTime;
          const healthy = response.ok;
          this.healthHistory.push(healthy);
          if (this.healthHistory.length > 10) {
            this.healthHistory.shift();
          }
          this.emit("health:check", { healthy, latency });
        } catch (error) {
          this.healthHistory.push(false);
          if (this.healthHistory.length > 10) {
            this.healthHistory.shift();
          }
          this.emit("health:check", { healthy: false });
        }
      }
      /**
       * Get current network state
       */
      getNetworkState() {
        return { ...this.currentState };
      }
      /**
       * Check if network is available
       */
      isConnected() {
        return this.currentState.isConnected;
      }
      /**
       * Get current network quality
       */
      getNetworkQuality() {
        return this.currentState.quality;
      }
      /**
       * Get retry configuration for current network conditions
       */
      getRetryConfig() {
        return this.config.retryConfigs[this.currentState.quality];
      }
      /**
       * Get timeout for current network conditions
       */
      getTimeout() {
        return this.config.timeoutConfigs[this.currentState.quality];
      }
      /**
       * Check if data optimization should be enabled
       */
      shouldOptimizeData() {
        return this.currentState.saveData || this.currentState.isExpensive || this.currentState.quality === "poor" || ["2g", "3g"].includes(this.currentState.connectionType);
      }
      /**
       * Get connection health score (0-1)
       */
      getHealthScore() {
        if (this.healthHistory.length === 0) return 1;
        const successCount = this.healthHistory.filter((h) => h).length;
        return successCount / this.healthHistory.length;
      }
      /**
       * Wait for network connection to be restored
       */
      async waitForConnection(timeout = 3e4) {
        if (this.currentState.isConnected) return true;
        return new Promise((resolve) => {
          const timer = setTimeout(() => {
            this.off("connection:restored", onRestored);
            resolve(false);
          }, timeout);
          const onRestored = () => {
            clearTimeout(timer);
            resolve(true);
          };
          this.once("connection:restored", onRestored);
        });
      }
      /**
       * Execute a network operation with intelligent retry
       */
      async executeWithRetry(operation, customRetryConfig) {
        const config = { ...this.getRetryConfig(), ...customRetryConfig };
        let lastError;
        for (let attempt = 0; attempt <= config.maxRetries; attempt++) {
          try {
            if (!this.currentState.isConnected) {
              const connected = await this.waitForConnection(1e4);
              if (!connected) {
                throw new Error("Network not available");
              }
            }
            return await operation();
          } catch (error) {
            lastError = error;
            if (attempt === config.maxRetries) break;
            let delay = Math.min(
              config.baseDelay * Math.pow(config.backoffMultiplier, attempt),
              config.maxDelay
            );
            if (config.jitter) {
              delay *= 0.5 + Math.random() * 0.5;
            }
            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }
        throw lastError;
      }
      /**
       * Get adaptive batch size based on network conditions
       */
      getAdaptiveBatchSize(baseBatchSize = 50) {
        switch (this.currentState.quality) {
          case "excellent":
            return Math.min(baseBatchSize * 2, 200);
          case "good":
            return baseBatchSize;
          case "fair":
            return Math.max(Math.floor(baseBatchSize * 0.7), 10);
          case "poor":
            return Math.max(Math.floor(baseBatchSize * 0.3), 5);
          default:
            return Math.max(Math.floor(baseBatchSize * 0.5), 10);
        }
      }
      /**
       * Destroy the connectivity manager
       */
      destroy() {
        if (this.qualityTimer) {
          clearInterval(this.qualityTimer);
        }
        if (this.healthTimer) {
          clearInterval(this.healthTimer);
        }
        this.removeAllListeners();
      }
    };
  }
});

// src/react-native/background-processor.ts
var background_processor_exports = {};
__export(background_processor_exports, {
  BackgroundProcessor: () => BackgroundProcessor
});
var isReactNative3, DEFAULT_CONFIG3, BackgroundProcessor;
var init_background_processor = __esm({
  "src/react-native/background-processor.ts"() {
    "use strict";
    init_esm_shims();
    init_eventemitter3();
    isReactNative3 = typeof navigator !== "undefined" && (navigator.product === "ReactNative" || global.__REACT_NATIVE__);
    DEFAULT_CONFIG3 = {
      maxConcurrentTasks: 3,
      defaultTaskTimeout: 3e4,
      // 30 seconds
      enableBatteryOptimization: true,
      minBatteryLevel: 0.15,
      // 15%
      enableAppStateManagement: true,
      maxBackgroundTime: 3e4,
      // 30 seconds (iOS limit)
      enableTaskPersistence: true,
      persistenceKey: "acube_background_tasks",
      enableResourceMonitoring: true,
      cpuThrottleThreshold: 80,
      // 80%
      memoryThrottleThreshold: 80
      // 80%
    };
    BackgroundProcessor = class extends import_index.default {
      config;
      taskQueue = [];
      activeTasks = /* @__PURE__ */ new Map();
      taskExecutors = /* @__PURE__ */ new Map();
      isInitialized = false;
      isPaused = false;
      // React Native modules
      AppState;
      BackgroundTask;
      AsyncStorage;
      // State tracking
      currentAppState = "active";
      batteryState = { level: 1, isCharging: false };
      backgroundTaskId;
      resourceMonitorTimer;
      // Performance tracking
      executionStats = {
        totalTasks: 0,
        successfulTasks: 0,
        failedTasks: 0,
        avgExecutionTime: 0,
        totalExecutionTime: 0
      };
      constructor(config = {}) {
        super();
        this.config = { ...DEFAULT_CONFIG3, ...config };
        this.initialize();
      }
      async initialize() {
        if (this.isInitialized || !isReactNative3) return;
        try {
          const RNModules = await import("react-native");
          this.AppState = RNModules.AppState;
          const AsyncStorageModule = await import("@react-native-async-storage/async-storage");
          this.AsyncStorage = AsyncStorageModule.default;
          if (this.config.enableAppStateManagement) {
            this.setupAppStateListener();
          }
          if (this.config.enableBatteryOptimization) {
            this.setupBatteryMonitoring();
          }
          if (this.config.enableResourceMonitoring) {
            this.startResourceMonitoring();
          }
          if (this.config.enableTaskPersistence) {
            await this.loadPersistedTasks();
          }
          this.registerDefaultExecutors();
          this.isInitialized = true;
          console.log("BackgroundProcessor initialized");
        } catch (error) {
          console.warn("Failed to initialize BackgroundProcessor:", error);
        }
      }
      setupAppStateListener() {
        if (!this.AppState) return;
        this.AppState.addEventListener("change", (nextAppState) => {
          const previousAppState = this.currentAppState;
          this.currentAppState = nextAppState;
          if (previousAppState === "active" && nextAppState === "background") {
            this.handleAppBackground();
          } else if (previousAppState === "background" && nextAppState === "active") {
            this.handleAppForeground();
          }
        });
      }
      async setupBatteryMonitoring() {
        try {
          const DeviceInfo = await import("react-native-device-info");
          const batteryLevel = await DeviceInfo.default.getBatteryLevel();
          const isCharging = (await DeviceInfo.default.getPowerState()).batteryState === "charging";
          const isPowerSaveMode = (await DeviceInfo.default.getPowerState()).lowPowerMode;
          this.batteryState = {
            level: batteryLevel,
            isCharging,
            isLowPowerMode: !!isPowerSaveMode
          };
          setInterval(async () => {
            const newLevel = await DeviceInfo.default.getBatteryLevel();
            const newCharging = (await DeviceInfo.default.getPowerState()).batteryState === "charging";
            const newPowerSave = (await DeviceInfo.default.getPowerState()).lowPowerMode;
            const previousCharging = this.batteryState.isCharging;
            const previousLevel = this.batteryState.level;
            this.batteryState = {
              level: newLevel,
              isCharging: newCharging,
              isLowPowerMode: !!newPowerSave
            };
            if (newCharging !== previousCharging) {
              this.emit("battery:charging", { isCharging: newCharging });
            }
            if (newLevel < this.config.minBatteryLevel && previousLevel >= this.config.minBatteryLevel) {
              this.emit("battery:low", { level: newLevel });
              this.pauseNonCriticalTasks();
            }
          }, 3e4);
        } catch (error) {
          console.warn("Battery monitoring not available:", error);
        }
      }
      startResourceMonitoring() {
        this.resourceMonitorTimer = setInterval(async () => {
          try {
            const memoryInfo = await this.getMemoryInfo();
            const cpuUsage = await this.getCPUUsage();
            if (memoryInfo.usage > this.config.memoryThrottleThreshold) {
              this.emit("resource:throttle", { reason: "memory" });
              this.throttleExecution();
            } else if (cpuUsage > this.config.cpuThrottleThreshold) {
              this.emit("resource:throttle", { reason: "cpu" });
              this.throttleExecution();
            } else if (this.isPaused) {
              this.emit("resource:resume", { reason: "resources_available" });
              this.resumeExecution();
            }
          } catch (error) {
            console.warn("Resource monitoring failed:", error);
          }
        }, 1e4);
      }
      async getMemoryInfo() {
        return { usage: 50, total: 100 };
      }
      async getCPUUsage() {
        return 30;
      }
      handleAppBackground() {
        console.log("App went to background");
        if (this.BackgroundTask && this.taskQueue.length > 0) {
          this.backgroundTaskId = this.BackgroundTask.start({
            taskName: "ACubeBackgroundSync",
            taskDescriptor: "Syncing e-receipt data"
          });
          setTimeout(() => {
            this.handleBackgroundTimeExpired();
          }, this.config.maxBackgroundTime);
        }
        this.emit("app:background", { remainingTime: this.config.maxBackgroundTime });
        this.processCriticalTasks();
      }
      handleAppForeground() {
        console.log("App came to foreground");
        if (this.backgroundTaskId && this.BackgroundTask) {
          this.BackgroundTask.finish(this.backgroundTaskId);
          this.backgroundTaskId = void 0;
        }
        this.emit("app:foreground", {});
        this.resumeExecution();
        this.processQueue();
      }
      handleBackgroundTimeExpired() {
        console.log("Background time expired, pausing non-critical tasks");
        for (const [taskId, { task, controller }] of this.activeTasks) {
          if (task.priority !== "critical") {
            controller.abort();
            this.activeTasks.delete(taskId);
          }
        }
        if (this.backgroundTaskId && this.BackgroundTask) {
          this.BackgroundTask.finish(this.backgroundTaskId);
          this.backgroundTaskId = void 0;
        }
      }
      async processCriticalTasks() {
        const criticalTasks = this.taskQueue.filter((task) => task.priority === "critical");
        for (const task of criticalTasks) {
          if (this.activeTasks.size < this.config.maxConcurrentTasks) {
            await this.executeTask(task);
          }
        }
      }
      pauseNonCriticalTasks() {
        this.isPaused = true;
        for (const [taskId, { task, controller }] of this.activeTasks) {
          if (task.priority !== "critical") {
            controller.abort();
            this.activeTasks.delete(taskId);
            this.taskQueue.unshift(task);
          }
        }
      }
      throttleExecution() {
        this.isPaused = true;
        console.log("Throttling background execution due to resource constraints");
      }
      resumeExecution() {
        if (this.isPaused) {
          this.isPaused = false;
          console.log("Resuming background execution");
          this.processQueue();
        }
      }
      registerDefaultExecutors() {
        this.registerExecutor("sync", async (_task, signal) => {
          const startTime = Date.now();
          try {
            await new Promise((resolve, reject) => {
              const timeout = setTimeout(resolve, Math.random() * 2e3 + 1e3);
              signal.addEventListener("abort", () => {
                clearTimeout(timeout);
                reject(new Error("Task aborted"));
              });
            });
            return {
              success: true,
              data: { syncedItems: Math.floor(Math.random() * 10) + 1 },
              executionTime: Date.now() - startTime
            };
          } catch (error) {
            return {
              success: false,
              error,
              executionTime: Date.now() - startTime
            };
          }
        });
        this.registerExecutor("cleanup", async (_task, signal) => {
          const startTime = Date.now();
          try {
            await new Promise((resolve, reject) => {
              const timeout = setTimeout(resolve, 500);
              signal.addEventListener("abort", () => {
                clearTimeout(timeout);
                reject(new Error("Task aborted"));
              });
            });
            return {
              success: true,
              data: { cleanedItems: Math.floor(Math.random() * 5) + 1 },
              executionTime: Date.now() - startTime
            };
          } catch (error) {
            return {
              success: false,
              error,
              executionTime: Date.now() - startTime
            };
          }
        });
      }
      /**
       * Register a task executor
       */
      registerExecutor(type, executor) {
        this.taskExecutors.set(type, executor);
      }
      /**
       * Schedule a new background task
       */
      async scheduleTask(task) {
        const fullTask = {
          ...task,
          id: this.generateTaskId(),
          createdAt: Date.now(),
          retryCount: 0,
          maxRetries: task.maxRetries || 3
        };
        this.taskQueue.push(fullTask);
        this.sortTaskQueue();
        this.emit("task:scheduled", { task: fullTask });
        if (this.config.enableTaskPersistence) {
          await this.persistTasks();
        }
        if (!this.isPaused) {
          this.processQueue();
        }
        return fullTask.id;
      }
      /**
       * Cancel a scheduled task
       */
      async cancelTask(taskId) {
        const queueIndex = this.taskQueue.findIndex((task) => task.id === taskId);
        if (queueIndex >= 0) {
          this.taskQueue.splice(queueIndex, 1);
          await this.persistTasks();
          return true;
        }
        const activeTask = this.activeTasks.get(taskId);
        if (activeTask) {
          activeTask.controller.abort();
          this.activeTasks.delete(taskId);
          return true;
        }
        return false;
      }
      /**
       * Get task status
       */
      getTaskStatus(taskId) {
        if (this.taskQueue.some((task) => task.id === taskId)) {
          return "queued";
        }
        if (this.activeTasks.has(taskId)) {
          return "running";
        }
        return "not_found";
      }
      /**
       * Get queue statistics
       */
      getQueueStats() {
        return {
          queued: this.taskQueue.length,
          running: this.activeTasks.size,
          isPaused: this.isPaused,
          currentAppState: this.currentAppState,
          batteryLevel: this.batteryState.level,
          isCharging: this.batteryState.isCharging,
          ...this.executionStats
        };
      }
      sortTaskQueue() {
        this.taskQueue.sort((a, b) => {
          const priorityOrder = { critical: 4, high: 3, normal: 2, low: 1 };
          const aPriority = priorityOrder[a.priority];
          const bPriority = priorityOrder[b.priority];
          if (aPriority !== bPriority) {
            return bPriority - aPriority;
          }
          const aTime = a.executionTime || a.createdAt + (a.delay || 0);
          const bTime = b.executionTime || b.createdAt + (b.delay || 0);
          return aTime - bTime;
        });
      }
      async processQueue() {
        if (this.isPaused || this.taskQueue.length === 0) return;
        const now = Date.now();
        while (this.taskQueue.length > 0 && this.activeTasks.size < this.config.maxConcurrentTasks && !this.isPaused) {
          const task = this.taskQueue[0];
          if (!task) break;
          const executionTime = task.executionTime || task.createdAt + (task.delay || 0);
          if (executionTime > now) {
            break;
          }
          if (!this.canExecuteTask(task)) {
            break;
          }
          this.taskQueue.shift();
          await this.executeTask(task);
        }
        if (this.taskQueue.length > 0) {
          const nextTask = this.taskQueue[0];
          if (nextTask) {
            const nextExecutionTime = nextTask.executionTime || nextTask.createdAt + (nextTask.delay || 0);
            const delay = Math.max(0, nextExecutionTime - now);
            setTimeout(() => this.processQueue(), delay);
          }
        } else {
          this.emit("queue:empty", {});
        }
      }
      canExecuteTask(task) {
        if (this.config.enableBatteryOptimization && task.priority !== "critical" && this.batteryState.level < this.config.minBatteryLevel && !this.batteryState.isCharging) {
          return false;
        }
        if (task.requiresDeviceIdle && this.currentAppState === "active") {
          return false;
        }
        return true;
      }
      async executeTask(task) {
        const executor = this.taskExecutors.get(task.type);
        if (!executor) {
          console.warn(`No executor found for task type: ${task.type}`);
          return;
        }
        const controller = new AbortController();
        this.activeTasks.set(task.id, { task, controller });
        this.emit("task:started", { task });
        const timeout = setTimeout(() => {
          controller.abort();
        }, task.maxExecutionTime || this.config.defaultTaskTimeout);
        try {
          const result = await executor(task, controller.signal);
          clearTimeout(timeout);
          this.handleTaskResult(task, result);
        } catch (error) {
          clearTimeout(timeout);
          this.handleTaskError(task, error);
        } finally {
          this.activeTasks.delete(task.id);
          await this.persistTasks();
        }
      }
      handleTaskResult(task, result) {
        this.executionStats.totalTasks++;
        this.executionStats.totalExecutionTime += result.executionTime;
        this.executionStats.avgExecutionTime = this.executionStats.totalExecutionTime / this.executionStats.totalTasks;
        if (result.success) {
          this.executionStats.successfulTasks++;
          this.emit("task:completed", { task, result });
        } else {
          this.handleTaskError(task, result.error || new Error("Task failed"));
        }
      }
      async handleTaskError(task, error) {
        this.executionStats.failedTasks++;
        const retryCount = task.retryCount || 0;
        if (retryCount < (task.maxRetries || 3)) {
          const retryTask = {
            ...task,
            retryCount: retryCount + 1,
            delay: Math.pow(2, retryCount) * 1e3
            // Exponential backoff
          };
          this.taskQueue.unshift(retryTask);
          this.emit("task:retry", { task: retryTask, attempt: retryCount + 1 });
          setTimeout(() => this.processQueue(), 1e3);
        } else {
          this.emit("task:failed", { task, error });
        }
      }
      generateTaskId() {
        return `task_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
      }
      async persistTasks() {
        if (!this.AsyncStorage) return;
        try {
          const tasksToSave = this.taskQueue.filter(
            (task) => (
              // Only persist tasks that should survive app restarts
              task.type === "sync" || task.priority === "critical"
            )
          );
          await this.AsyncStorage.setItem(
            this.config.persistenceKey,
            JSON.stringify(tasksToSave)
          );
        } catch (error) {
          console.warn("Failed to persist tasks:", error);
        }
      }
      async loadPersistedTasks() {
        if (!this.AsyncStorage) return;
        try {
          const persistedTasks = await this.AsyncStorage.getItem(this.config.persistenceKey);
          if (persistedTasks) {
            const tasks = JSON.parse(persistedTasks);
            this.taskQueue.push(...tasks);
            this.sortTaskQueue();
            await this.AsyncStorage.removeItem(this.config.persistenceKey);
          }
        } catch (error) {
          console.warn("Failed to load persisted tasks:", error);
        }
      }
      /**
       * Force process all critical tasks immediately
       */
      async processCriticalTasksImmediately() {
        const criticalTasks = this.taskQueue.filter((task) => task.priority === "critical");
        for (const task of criticalTasks) {
          await this.executeTask(task);
          this.taskQueue = this.taskQueue.filter((t) => t.id !== task.id);
        }
        await this.persistTasks();
      }
      /**
       * Pause all background processing
       */
      pause() {
        this.isPaused = true;
      }
      /**
       * Resume background processing
       */
      resume() {
        this.isPaused = false;
        this.processQueue();
      }
      /**
       * Clear all queued tasks
       */
      async clearQueue() {
        this.taskQueue = [];
        await this.persistTasks();
      }
      /**
       * Destroy the background processor
       */
      destroy() {
        for (const [, { controller }] of this.activeTasks) {
          controller.abort();
        }
        this.activeTasks.clear();
        if (this.resourceMonitorTimer) {
          clearInterval(this.resourceMonitorTimer);
        }
        if (this.backgroundTaskId && this.BackgroundTask) {
          this.BackgroundTask.finish(this.backgroundTaskId);
        }
        this.removeAllListeners();
      }
    };
  }
});

// src/react-native/performance-monitor.ts
var performance_monitor_exports = {};
__export(performance_monitor_exports, {
  PerformanceMonitor: () => PerformanceMonitor
});
var isReactNative4, DEFAULT_THRESHOLDS, DEFAULT_CONFIG4, PerformanceMonitor;
var init_performance_monitor = __esm({
  "src/react-native/performance-monitor.ts"() {
    "use strict";
    init_esm_shims();
    init_eventemitter3();
    isReactNative4 = typeof navigator !== "undefined" && (navigator.product === "ReactNative" || global.__REACT_NATIVE__);
    DEFAULT_THRESHOLDS = {
      maxMemoryUsage: 512,
      // 512MB
      minFrameRate: 55,
      // 55 FPS
      maxResponseTime: 100,
      // 100ms
      maxBatteryDrainRate: 5,
      // 5%/hour
      maxErrorRate: 0.01,
      // 1%
      maxNetworkFailureRate: 0.05
      // 5%
    };
    DEFAULT_CONFIG4 = {
      enabled: true,
      monitoringInterval: 1e4,
      // 10 seconds
      enableMemoryMonitoring: true,
      enableFrameRateMonitoring: true,
      enableNetworkMonitoring: true,
      enableBatteryMonitoring: true,
      enableInteractionMonitoring: true,
      enableCrashReporting: true,
      thresholds: DEFAULT_THRESHOLDS,
      maxHistorySize: 100,
      enableProfiling: false,
      profilingSampleRate: 0.1,
      enableAutoOptimization: true,
      enableRemoteReporting: false,
      reportingEndpoint: "/api/performance"
    };
    PerformanceMonitor = class extends import_index.default {
      config;
      isInitialized = false;
      isMonitoring = false;
      // React Native modules
      PerformanceObserver;
      AppState;
      DeviceInfo;
      // Monitoring state
      startTime;
      lastMetrics;
      metricsHistory = [];
      monitoringTimer;
      // Performance tracking
      memoryPeakUsage = 0;
      frameDropCount = 0;
      networkRequests = [];
      userInteractions = [];
      errorCount = 0;
      crashCount = 0;
      gcEventCount = 0;
      memoryWarningCount = 0;
      // Battery tracking
      batteryHistory = [];
      constructor(config = {}) {
        super();
        this.config = { ...DEFAULT_CONFIG4, ...config };
        this.startTime = Date.now();
        if (this.config.enabled) {
          this.initialize();
        }
      }
      async initialize() {
        if (this.isInitialized || !isReactNative4) return;
        try {
          const RNModules = await import("react-native");
          this.AppState = RNModules.AppState;
          try {
            const PerformanceModule = await import("react-native-performance");
            this.PerformanceObserver = PerformanceModule.PerformanceObserver;
          } catch {
            console.warn("Performance API not available");
          }
          try {
            const DeviceInfoModule = await import("react-native-device-info");
            this.DeviceInfo = DeviceInfoModule.default;
          } catch {
            console.warn("DeviceInfo not available");
          }
          this.setupMemoryMonitoring();
          this.setupFrameRateMonitoring();
          this.setupNetworkMonitoring();
          this.setupErrorMonitoring();
          this.setupInteractionMonitoring();
          if (this.config.enableBatteryMonitoring) {
            this.setupBatteryMonitoring();
          }
          this.isInitialized = true;
          this.startMonitoring();
          console.log("PerformanceMonitor initialized");
        } catch (error) {
          console.warn("Failed to initialize PerformanceMonitor:", error);
        }
      }
      setupMemoryMonitoring() {
        if (!this.config.enableMemoryMonitoring) return;
        if (this.AppState) {
          try {
            const MemoryWarningHandler = __require("react-native").DeviceEventEmitter;
            MemoryWarningHandler.addListener("memoryWarning", () => {
              this.memoryWarningCount++;
              const currentMemory = this.getMemoryUsage();
              this.emit("memory:warning", {
                usage: currentMemory.used,
                available: currentMemory.total - currentMemory.used
              });
              if (this.config.enableAutoOptimization) {
                this.applyMemoryOptimization();
              }
            });
          } catch (error) {
            console.warn("Memory warning monitoring not available:", error);
          }
        }
        if (global.gc) {
          const originalGC = global.gc;
          global.gc = async () => {
            this.gcEventCount++;
            return originalGC();
          };
        }
      }
      setupFrameRateMonitoring() {
        if (!this.config.enableFrameRateMonitoring) return;
        if (this.PerformanceObserver) {
          try {
            const observer = new this.PerformanceObserver((list) => {
              const entries = list.getEntries();
              for (const entry of entries) {
                if (entry.entryType === "measure" && entry.name.includes("frame")) {
                  if (entry.duration > 16.67) {
                    this.frameDropCount++;
                    this.emit("frame:drop", {
                      droppedFrames: 1,
                      duration: entry.duration
                    });
                  }
                }
              }
            });
            observer.observe({ entryTypes: ["measure"] });
          } catch (error) {
            console.warn("Frame monitoring not available:", error);
          }
        }
      }
      setupNetworkMonitoring() {
        if (!this.config.enableNetworkMonitoring) return;
        const originalFetch = global.fetch;
        global.fetch = async (input, init) => {
          const url = typeof input === "string" ? input : input instanceof URL ? input.href : input.url;
          const startTime = Date.now();
          const requestInfo = { url, startTime };
          this.networkRequests.push(requestInfo);
          try {
            const response = await originalFetch(input, init);
            const endTime = Date.now();
            const duration = endTime - startTime;
            requestInfo.endTime = endTime;
            requestInfo.success = response.ok;
            if (duration > 3e3) {
              this.emit("network:slow", { url, duration });
            }
            return response;
          } catch (error) {
            requestInfo.endTime = Date.now();
            requestInfo.success = false;
            throw error;
          }
        };
      }
      setupErrorMonitoring() {
        if (!this.config.enableCrashReporting) return;
        const originalErrorHandler = ErrorUtils?.getGlobalHandler?.();
        ErrorUtils?.setGlobalHandler?.((error, isFatal) => {
          this.errorCount++;
          if (isFatal) {
            this.crashCount++;
            this.emit("crash:detected", { error, context: { isFatal } });
          }
          if (originalErrorHandler) {
            originalErrorHandler(error, isFatal);
          }
        });
        const handleUnhandledRejection = (event) => {
          this.errorCount++;
          console.warn("Unhandled promise rejection:", event.reason);
        };
        if (typeof process !== "undefined") {
          process.on("unhandledRejection", handleUnhandledRejection);
        }
      }
      setupInteractionMonitoring() {
        if (!this.config.enableInteractionMonitoring) return;
      }
      setupBatteryMonitoring() {
        setInterval(async () => {
          if (this.DeviceInfo) {
            try {
              const batteryLevel = await this.DeviceInfo.getBatteryLevel();
              const timestamp = Date.now();
              this.batteryHistory.push({ level: batteryLevel, timestamp });
              const oneDayAgo = timestamp - 24 * 60 * 60 * 1e3;
              this.batteryHistory = this.batteryHistory.filter((entry) => entry.timestamp > oneDayAgo);
              if (this.batteryHistory.length >= 2) {
                const drainRate = this.calculateBatteryDrainRate();
                if (drainRate > (this.config.thresholds.maxBatteryDrainRate || 5)) {
                  this.emit("battery:drain", { rate: drainRate, cause: "unknown" });
                }
              }
            } catch (error) {
              console.warn("Battery monitoring failed:", error);
            }
          }
        }, 6e4);
      }
      calculateBatteryDrainRate() {
        if (this.batteryHistory.length < 2) return 0;
        const now = Date.now();
        const oneHourAgo = now - 60 * 60 * 1e3;
        const recentHistory = this.batteryHistory.filter((entry) => entry.timestamp > oneHourAgo);
        if (recentHistory.length < 2) return 0;
        const oldest = recentHistory[0];
        const newest = recentHistory[recentHistory.length - 1];
        if (!oldest || !newest) return 0;
        const timeDiff = newest.timestamp - oldest.timestamp;
        const batteryDiff = oldest.level - newest.level;
        const hoursElapsed = timeDiff / (60 * 60 * 1e3);
        return hoursElapsed > 0 ? batteryDiff / hoursElapsed * 100 : 0;
      }
      startMonitoring() {
        if (this.isMonitoring) return;
        this.isMonitoring = true;
        this.monitoringTimer = setInterval(() => {
          this.collectMetrics();
        }, this.config.monitoringInterval);
        console.log("Performance monitoring started");
      }
      collectMetrics() {
        try {
          const metrics = {
            appStartTime: this.startTime,
            timeToInteractive: Date.now() - this.startTime,
            memoryUsage: this.getMemoryUsage(),
            cpuUsage: this.getCPUUsage(),
            frameRate: this.getFrameRateMetrics(),
            networkPerformance: this.getNetworkMetrics(),
            userInteractions: this.getInteractionMetrics(),
            batteryImpact: this.getBatteryMetrics(),
            errorRate: this.calculateErrorRate(),
            crashCount: this.crashCount,
            timestamp: Date.now()
          };
          this.lastMetrics = metrics;
          this.metricsHistory.push(metrics);
          if (this.metricsHistory.length > this.config.maxHistorySize) {
            this.metricsHistory.shift();
          }
          this.emit("metrics:updated", { metrics });
          this.checkThresholds(metrics);
          if (this.config.enableRemoteReporting) {
            this.sendMetricsToServer(metrics);
          }
        } catch (error) {
          console.warn("Failed to collect metrics:", error);
        }
      }
      getMemoryUsage() {
        let heapUsed = 0;
        let heapTotal = 0;
        if (performance.memory) {
          const memoryInfo = performance.memory;
          heapUsed = memoryInfo.usedJSHeapSize / (1024 * 1024);
          heapTotal = memoryInfo.totalJSHeapSize / (1024 * 1024);
        }
        const estimated = heapUsed * 2;
        this.memoryPeakUsage = Math.max(this.memoryPeakUsage, estimated);
        return {
          used: estimated,
          total: 1024,
          // Assume 1GB total (would get from device info)
          peak: this.memoryPeakUsage,
          heapUsed,
          heapTotal,
          gcEvents: this.gcEventCount,
          memoryWarnings: this.memoryWarningCount
        };
      }
      getCPUUsage() {
        return Math.random() * 30 + 10;
      }
      getFrameRateMetrics() {
        const currentFPS = 60 - this.frameDropCount * 0.1;
        return {
          current: Math.max(currentFPS, 30),
          average: 58,
          // Placeholder
          drops: this.frameDropCount,
          jankCount: Math.floor(this.frameDropCount * 0.3)
        };
      }
      getNetworkMetrics() {
        const recentRequests = this.networkRequests.slice(-100);
        if (recentRequests.length === 0) {
          return {
            avgRequestTime: 0,
            failureRate: 0,
            bytesTransferred: 0,
            requestCount: 0,
            slowRequestCount: 0
          };
        }
        const completedRequests = recentRequests.filter((req) => req.endTime);
        const failedRequests = completedRequests.filter((req) => !req.success);
        const slowRequests = completedRequests.filter(
          (req) => req.endTime && req.endTime - req.startTime > 3e3
        );
        const totalTime = completedRequests.reduce(
          (sum, req) => sum + (req.endTime - req.startTime),
          0
        );
        return {
          avgRequestTime: completedRequests.length > 0 ? totalTime / completedRequests.length : 0,
          failureRate: completedRequests.length > 0 ? failedRequests.length / completedRequests.length : 0,
          bytesTransferred: 0,
          // Would need actual byte counting
          requestCount: recentRequests.length,
          slowRequestCount: slowRequests.length
        };
      }
      getInteractionMetrics() {
        const recentInteractions = this.userInteractions.slice(-50);
        if (recentInteractions.length === 0) {
          return {
            avgResponseTime: 0,
            slowInteractions: 0,
            totalInteractions: 0,
            userSatisfactionScore: 1
          };
        }
        const totalTime = recentInteractions.reduce(
          (sum, interaction) => sum + (interaction.endTime - interaction.startTime),
          0
        );
        const slowInteractions = recentInteractions.filter(
          (interaction) => interaction.endTime - interaction.startTime > 100
        );
        const avgResponseTime = totalTime / recentInteractions.length;
        const satisfactionScore = Math.max(0, 1 - slowInteractions.length / recentInteractions.length);
        return {
          avgResponseTime,
          slowInteractions: slowInteractions.length,
          totalInteractions: recentInteractions.length,
          userSatisfactionScore: satisfactionScore
        };
      }
      getBatteryMetrics() {
        const drainRate = this.calculateBatteryDrainRate();
        return {
          drainRate,
          networkDrain: drainRate * 0.3,
          // Estimate 30% from network
          cpuDrain: drainRate * 0.4,
          // Estimate 40% from CPU
          backgroundDrain: drainRate * 0.2
          // Estimate 20% from background
        };
      }
      calculateErrorRate() {
        const timeWindow = 10 * 60 * 1e3;
        const now = Date.now();
        return this.errorCount / Math.max(1, (now - this.startTime) / timeWindow);
      }
      checkThresholds(metrics) {
        const { thresholds } = this.config;
        const maxMemory = thresholds.maxMemoryUsage || 512;
        if (metrics.memoryUsage.used > maxMemory) {
          this.emit("threshold:exceeded", {
            metric: "memory",
            value: metrics.memoryUsage.used,
            threshold: maxMemory
          });
        }
        const minFrameRate = thresholds.minFrameRate || 55;
        if (metrics.frameRate.current < minFrameRate) {
          this.emit("threshold:exceeded", {
            metric: "frameRate",
            value: metrics.frameRate.current,
            threshold: minFrameRate
          });
        }
        const maxResponseTime = thresholds.maxResponseTime || 100;
        if (metrics.userInteractions.avgResponseTime > maxResponseTime) {
          this.emit("threshold:exceeded", {
            metric: "responseTime",
            value: metrics.userInteractions.avgResponseTime,
            threshold: maxResponseTime
          });
        }
        const maxBatteryDrain = thresholds.maxBatteryDrainRate || 5;
        if (metrics.batteryImpact.drainRate > maxBatteryDrain) {
          this.emit("threshold:exceeded", {
            metric: "batteryDrain",
            value: metrics.batteryImpact.drainRate,
            threshold: maxBatteryDrain
          });
        }
        const maxErrorRate = thresholds.maxErrorRate || 0.01;
        if (metrics.errorRate > maxErrorRate) {
          this.emit("threshold:exceeded", {
            metric: "errorRate",
            value: metrics.errorRate,
            threshold: maxErrorRate
          });
        }
        const maxNetworkFailureRate = thresholds.maxNetworkFailureRate || 0.05;
        if (metrics.networkPerformance.failureRate > maxNetworkFailureRate) {
          this.emit("threshold:exceeded", {
            metric: "networkFailureRate",
            value: metrics.networkPerformance.failureRate,
            threshold: maxNetworkFailureRate
          });
        }
      }
      applyMemoryOptimization() {
        if (global.gc) {
          global.gc();
          this.emit("optimization:applied", {
            type: "garbage_collection",
            impact: "memory_freed"
          });
        }
      }
      async sendMetricsToServer(metrics) {
        try {
          const response = await fetch(this.config.reportingEndpoint, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              metrics,
              deviceInfo: await this.getDeviceInfo(),
              timestamp: Date.now()
            })
          });
          this.emit("report:sent", {
            success: response.ok,
            data: response.ok ? void 0 : response.statusText
          });
        } catch (error) {
          this.emit("report:sent", { success: false, data: error });
        }
      }
      async getDeviceInfo() {
        if (!this.DeviceInfo) return {};
        try {
          return {
            model: await this.DeviceInfo.getModel(),
            systemVersion: await this.DeviceInfo.getSystemVersion(),
            brand: await this.DeviceInfo.getBrand(),
            deviceId: await this.DeviceInfo.getUniqueId(),
            totalMemory: await this.DeviceInfo.getTotalMemory(),
            isEmulator: await this.DeviceInfo.isEmulator()
          };
        } catch (error) {
          return {};
        }
      }
      /**
       * Record a user interaction for monitoring
       */
      recordInteraction(type, startTime, endTime) {
        if (!this.config.enableInteractionMonitoring) return;
        const interaction = {
          type,
          startTime,
          endTime: endTime || Date.now()
        };
        this.userInteractions.push(interaction);
        if (this.userInteractions.length > 1e3) {
          this.userInteractions = this.userInteractions.slice(-500);
        }
        const duration = interaction.endTime - interaction.startTime;
        if (duration > 100) {
          this.emit("interaction:slow", { type, duration });
        }
      }
      /**
       * Get current performance metrics
       */
      getCurrentMetrics() {
        return this.lastMetrics;
      }
      /**
       * Get performance history
       */
      getMetricsHistory() {
        return [...this.metricsHistory];
      }
      /**
       * Get performance summary
       */
      getPerformanceSummary() {
        const history = this.metricsHistory;
        if (history.length === 0) return null;
        const latest = history[history.length - 1];
        const avgMemory = history.reduce((sum, m) => sum + m.memoryUsage.used, 0) / history.length;
        const avgFrameRate = history.reduce((sum, m) => sum + m.frameRate.current, 0) / history.length;
        const avgResponseTime = history.reduce((sum, m) => sum + m.userInteractions.avgResponseTime, 0) / history.length;
        return {
          current: latest,
          averages: {
            memoryUsage: avgMemory,
            frameRate: avgFrameRate,
            responseTime: avgResponseTime
          },
          totals: {
            errors: this.errorCount,
            crashes: this.crashCount,
            frameDrops: this.frameDropCount,
            memoryWarnings: this.memoryWarningCount
          }
        };
      }
      /**
       * Force metrics collection
       */
      collectMetricsNow() {
        this.collectMetrics();
      }
      /**
       * Reset performance counters
       */
      resetCounters() {
        this.errorCount = 0;
        this.crashCount = 0;
        this.frameDropCount = 0;
        this.memoryWarningCount = 0;
        this.gcEventCount = 0;
        this.networkRequests = [];
        this.userInteractions = [];
        this.batteryHistory = [];
      }
      /**
       * Stop monitoring
       */
      stopMonitoring() {
        if (this.monitoringTimer) {
          clearInterval(this.monitoringTimer);
          this.monitoringTimer = void 0;
        }
        this.isMonitoring = false;
      }
      /**
       * Start monitoring
       */
      resumeMonitoring() {
        if (!this.isMonitoring && this.isInitialized) {
          this.startMonitoring();
        }
      }
      /**
       * Destroy the performance monitor
       */
      destroy() {
        this.stopMonitoring();
        this.removeAllListeners();
      }
    };
  }
});

// src/generated/endpoints.ts
var CashierEndpoints, PointOfSalesEndpoints, ReceiptEndpoints, CashRegisterEndpoints, MerchantEndpoints, PEMEndpoints, EndpointUtils;
var init_endpoints = __esm({
  "src/generated/endpoints.ts"() {
    "use strict";
    init_esm_shims();
    CashierEndpoints = class {
      static LIST = {
        path: "/mf1/cashiers",
        method: "GET",
        operationId: "read_cashiers_mf1_cashiers_get",
        summary: "Read Cashiers",
        description: "Get a paginated list of cashiers",
        tags: ["Cashier"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        parameters: {
          query: {
            page: "integer",
            size: "integer"
          }
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_Page__T_Customized_CashierOutput_"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "404": {
            description: "Not Found",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel404NotFound"
          },
          "422": {
            description: "Validation Error",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_HTTPValidationError"
          }
        },
        metadata: {
          resource: "cashiers",
          operation: "list",
          authRequired: true,
          retryable: true
        }
      };
      static CREATE = {
        path: "/mf1/cashiers",
        method: "POST",
        operationId: "create_cashier_mf1_cashiers_post",
        summary: "Create Cashier",
        description: "Create a new cashier account",
        tags: ["Cashier"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        requestBody: {
          required: true,
          contentType: "application/json",
          schema: "E-Receipt_IT_API_CashierCreateInput"
        },
        responses: {
          "201": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_CashierOutput"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "422": {
            description: "Validation Error",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_HTTPValidationError"
          }
        },
        metadata: {
          resource: "cashiers",
          operation: "create",
          authRequired: true,
          retryable: false
        }
      };
      static ME = {
        path: "/mf1/cashiers/me",
        method: "GET",
        operationId: "read_cashier_me_mf1_cashiers_me_get",
        summary: "Read Cashier Me",
        description: "Read currently authenticated cashier's information",
        tags: ["Cashier"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_CashierOutput"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "404": {
            description: "Not Found",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel404NotFound"
          }
        },
        metadata: {
          resource: "cashiers",
          operation: "me",
          authRequired: true,
          retryable: true
        }
      };
      static GET_BY_ID = {
        path: "/mf1/cashiers/{cashier_id}",
        method: "GET",
        operationId: "read_cashier_by_id_mf1_cashiers__cashier_id__get",
        summary: "Read Cashier By Id",
        description: "Get a specific user by id",
        tags: ["Cashier"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        parameters: {
          path: {
            cashier_id: "integer"
          }
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_CashierOutput"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "404": {
            description: "Not Found",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel404NotFound"
          },
          "422": {
            description: "Validation Error",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_HTTPValidationError"
          }
        },
        metadata: {
          resource: "cashiers",
          operation: "get",
          authRequired: true,
          retryable: true
        }
      };
      static DELETE = {
        path: "/mf1/cashiers/{cashier_id}",
        method: "DELETE",
        operationId: "delete_cashier_mf1_cashiers__cashier_id__delete",
        summary: "Delete Cashier",
        description: "Delete a cashier",
        tags: ["Cashier"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        parameters: {
          path: {
            cashier_id: "integer"
          }
        },
        responses: {
          "204": {
            description: "Successful Response"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "404": {
            description: "Not Found",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel404NotFound"
          },
          "422": {
            description: "Validation Error",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_HTTPValidationError"
          }
        },
        metadata: {
          resource: "cashiers",
          operation: "delete",
          authRequired: true,
          retryable: false
        }
      };
    };
    PointOfSalesEndpoints = class {
      static LIST = {
        path: "/mf1/point-of-sales",
        method: "GET",
        operationId: "read_point_of_sales_mf1_point_of_sales_get",
        summary: "Read Point Of Sales",
        description: "Retrieve PEMs",
        tags: ["Point of Sale"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_Page__T_Customized_PointOfSaleOutput_"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          }
        },
        metadata: {
          resource: "point-of-sales",
          operation: "list",
          authRequired: true,
          retryable: true
        }
      };
      static GET_BY_SERIAL = {
        path: "/mf1/point-of-sales/{serial_number}",
        method: "GET",
        operationId: "read_point_of_sale_mf1_point_of_sales__serial_number__get",
        summary: "Read Point Of Sale",
        description: "Get a specific Point of Sale by serial number",
        tags: ["Point of Sale"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        parameters: {
          path: {
            serial_number: "string"
          }
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_PointOfSaleOutput"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "404": {
            description: "Not Found",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel404NotFound"
          }
        },
        metadata: {
          resource: "point-of-sales",
          operation: "get",
          authRequired: true,
          retryable: true
        }
      };
      static CLOSE_JOURNAL = {
        path: "/mf1/point-of-sales/close",
        method: "POST",
        operationId: "close_journal_mf1_point_of_sales_close_post",
        summary: "Close Journal",
        description: "Close the daily journal for Point of Sales",
        tags: ["Point of Sale"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        requestBody: {
          required: true,
          contentType: "application/json",
          schema: "E-Receipt_IT_API_CloseJournalRequest"
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_CloseJournalOutput"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          }
        },
        metadata: {
          resource: "point-of-sales",
          operation: "close_journal",
          authRequired: true,
          retryable: false
        }
      };
      static ACTIVATION = {
        path: "/mf1/point-of-sales/{serial_number}/activation",
        method: "POST",
        operationId: "post_activation_mf1_point_of_sales__serial_number__activation_post",
        summary: "Post Activation",
        description: "Trigger the activation process of a Point of Sale by requesting a certificate to the Italian Tax Agency",
        tags: ["Point of Sale"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        parameters: {
          path: {
            serial_number: "string"
          }
        },
        requestBody: {
          required: true,
          contentType: "application/json",
          schema: "E-Receipt_IT_API_ActivationRequest"
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ActivationOutput"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          }
        },
        metadata: {
          resource: "point-of-sales",
          operation: "activation",
          authRequired: true,
          retryable: false
        }
      };
      static CREATE_INACTIVITY = {
        path: "/mf1/point-of-sales/{serial_number}/inactivity",
        method: "POST",
        operationId: "create_inactivity_period_mf1_point_of_sales__serial_number__inactivity_post",
        summary: "Create Inactivity Period",
        description: "Create a new inactivity period",
        tags: ["Point of Sale"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        parameters: {
          path: {
            serial_number: "string"
          }
        },
        requestBody: {
          required: true,
          contentType: "application/json",
          schema: "E-Receipt_IT_API_InactivityRequest"
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          }
        },
        metadata: {
          resource: "point-of-sales",
          operation: "create_inactivity",
          authRequired: true,
          retryable: false
        }
      };
      static SET_OFFLINE = {
        path: "/mf1/point-of-sales/{serial_number}/status/offline",
        method: "POST",
        operationId: "post_offline_mf1_point_of_sales__serial_number__status_offline_post",
        summary: "Post Offline",
        description: "Change the state of the Point of Sale to 'offline'",
        tags: ["Point of Sale"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        parameters: {
          path: {
            serial_number: "string"
          }
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          }
        },
        metadata: {
          resource: "point-of-sales",
          operation: "set_offline",
          authRequired: true,
          retryable: false
        }
      };
    };
    ReceiptEndpoints = class {
      static LIST = {
        path: "/mf1/receipts",
        method: "GET",
        operationId: "get_receipts_mf1_receipts_get",
        summary: "Get Receipts",
        description: "Get a list of electronic receipts",
        tags: ["Receipt"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        parameters: {
          query: {
            page: "integer",
            size: "integer",
            start_date: "string",
            end_date: "string",
            serial_number: "string"
          }
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_Page__T_Customized_ReceiptOutput_"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          }
        },
        metadata: {
          resource: "receipts",
          operation: "list",
          authRequired: true,
          retryable: true
        }
      };
      static CREATE = {
        path: "/mf1/receipts",
        method: "POST",
        operationId: "create_receipt_mf1_receipts_post",
        summary: "Create Receipt",
        description: "Create a new electronic receipt",
        tags: ["Receipt"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        requestBody: {
          required: true,
          contentType: "application/json",
          schema: "E-Receipt_IT_API_ReceiptInput"
        },
        responses: {
          "201": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ReceiptOutput"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "422": {
            description: "Validation Error",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_HTTPValidationError"
          }
        },
        metadata: {
          resource: "receipts",
          operation: "create",
          authRequired: true,
          retryable: false
        }
      };
      static VOID = {
        path: "/mf1/receipts",
        method: "DELETE",
        operationId: "void_receipt_mf1_receipts_delete",
        summary: "Void Receipt",
        description: "Void an electronic receipt",
        tags: ["Receipt"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        requestBody: {
          required: true,
          contentType: "application/json",
          schema: "E-Receipt_IT_API_VoidReceiptRequest"
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_VoidReceiptOutput"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          }
        },
        metadata: {
          resource: "receipts",
          operation: "void",
          authRequired: true,
          retryable: false
        }
      };
      static GET_BY_UUID = {
        path: "/mf1/receipts/{receipt_uuid}",
        method: "GET",
        operationId: "get_receipt_mf1_receipts__receipt_uuid__get",
        summary: "Get Receipt",
        description: "Get an electronic receipt",
        tags: ["Receipt"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        parameters: {
          path: {
            receipt_uuid: "string"
          }
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ReceiptOutput"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "404": {
            description: "Not Found",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel404NotFound"
          }
        },
        metadata: {
          resource: "receipts",
          operation: "get",
          authRequired: true,
          retryable: true
        }
      };
      static VOID_WITH_PROOF = {
        path: "/mf1/receipts/void-with-proof",
        method: "DELETE",
        operationId: "void_receipt_via_proof_mf1_receipts_void_with_proof_delete",
        summary: "Void Receipt Via Proof",
        description: "Void an electronic receipt identified by a proof of purchase",
        tags: ["Receipt"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        requestBody: {
          required: true,
          contentType: "application/json",
          schema: "E-Receipt_IT_API_VoidReceiptWithProofRequest"
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_VoidReceiptOutput"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          }
        },
        metadata: {
          resource: "receipts",
          operation: "void_with_proof",
          authRequired: true,
          retryable: false
        }
      };
      static GET_DETAILS = {
        path: "/mf1/receipts/{receipt_uuid}/details",
        method: "GET",
        operationId: "get_receipt_details_mf1_receipts__receipt_uuid__details_get",
        summary: "Get Receipt Details",
        description: "Get the details or the PDF of an electronic receipt",
        tags: ["Receipt"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        parameters: {
          path: {
            receipt_uuid: "string"
          },
          header: {
            Accept: "string"
          }
        },
        responses: {
          "200": {
            description: "Successful Response"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "404": {
            description: "Not Found",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel404NotFound"
          }
        },
        metadata: {
          resource: "receipts",
          operation: "get_details",
          authRequired: true,
          retryable: true
        }
      };
      static RETURN_ITEMS = {
        path: "/mf1/receipts/return",
        method: "POST",
        operationId: "return_receipt_items_mf1_receipts_return_post",
        summary: "Return Receipt Items",
        description: "Return items from an electronic receipt (same PEM or other PEM)",
        tags: ["Receipt"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        requestBody: {
          required: true,
          contentType: "application/json",
          schema: "E-Receipt_IT_API_ReturnRequest"
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ReceiptOutput"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          }
        },
        metadata: {
          resource: "receipts",
          operation: "return_items",
          authRequired: true,
          retryable: false
        }
      };
      static RETURN_ITEMS_WITH_PROOF = {
        path: "/mf1/receipts/return-with-proof",
        method: "POST",
        operationId: "return_receipt_items_via_proof_mf1_receipts_return_with_proof_post",
        summary: "Return Receipt Items Via Proof",
        description: "Return items from an electronic receipt identified by a proof of purchase",
        tags: ["Receipt"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        requestBody: {
          required: true,
          contentType: "application/json",
          schema: "E-Receipt_IT_API_ReturnWithProofRequest"
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ReceiptOutput"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          }
        },
        metadata: {
          resource: "receipts",
          operation: "return_items_with_proof",
          authRequired: true,
          retryable: false
        }
      };
    };
    CashRegisterEndpoints = class {
      static CREATE = {
        path: "/mf1/cash-register",
        method: "POST",
        operationId: "create_cash_register_mf1_cash_register_post",
        summary: "Create Cash Register",
        description: "Create a new cash register",
        tags: ["Cash Register"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        requestBody: {
          required: true,
          contentType: "application/json",
          schema: "E-Receipt_IT_API_CashRegisterInput"
        },
        responses: {
          "201": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_CashRegisterOutput"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "422": {
            description: "Validation Error",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_HTTPValidationError"
          }
        },
        metadata: {
          resource: "cash-registers",
          operation: "create",
          authRequired: true,
          retryable: false
        }
      };
      static LIST = {
        path: "/mf1/cash-register",
        method: "GET",
        operationId: "get_cash_registers_mf1_cash_register_get",
        summary: "Get Cash Registers",
        description: "Get a list of cash registers",
        tags: ["Cash Register"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_Page__T_Customized_CashRegisterOutput_"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          }
        },
        metadata: {
          resource: "cash-registers",
          operation: "list",
          authRequired: true,
          retryable: true
        }
      };
      static GET_BY_ID = {
        path: "/mf1/cash-register/{id}",
        method: "GET",
        operationId: "get_cash_register_mf1_cash_register__id__get",
        summary: "Get Cash Register",
        description: "Get a specific cash register by ID",
        tags: ["Cash Register"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        parameters: {
          path: {
            id: "integer"
          }
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_CashRegisterOutput"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "404": {
            description: "Not Found",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel404NotFound"
          }
        },
        metadata: {
          resource: "cash-registers",
          operation: "get",
          authRequired: true,
          retryable: true
        }
      };
    };
    MerchantEndpoints = class {
      static LIST = {
        path: "/mf2/merchants",
        method: "GET",
        operationId: "api_merchants_get_collection",
        summary: "Get Merchants",
        description: "Get a list of merchants",
        tags: ["Merchant"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          }
        },
        metadata: {
          resource: "merchants",
          operation: "list",
          authRequired: true,
          retryable: true
        }
      };
      static CREATE = {
        path: "/mf2/merchants",
        method: "POST",
        operationId: "api_merchants_post",
        summary: "Create Merchant",
        description: "Create a new merchant",
        tags: ["Merchant"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        requestBody: {
          required: true,
          contentType: "application/json",
          schema: "Merchant-create"
        },
        responses: {
          "201": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "Merchant-read"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "422": {
            description: "Validation Error",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_HTTPValidationError"
          }
        },
        metadata: {
          resource: "merchants",
          operation: "create",
          authRequired: true,
          retryable: false
        }
      };
      static GET_BY_UUID = {
        path: "/mf2/merchants/{uuid}",
        method: "GET",
        operationId: "api_merchants_uuid_get",
        summary: "Get Merchant",
        description: "Get a specific merchant by UUID",
        tags: ["Merchant"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        parameters: {
          path: {
            uuid: "string"
          }
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "Merchant-read"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "404": {
            description: "Not Found",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel404NotFound"
          }
        },
        metadata: {
          resource: "merchants",
          operation: "get",
          authRequired: true,
          retryable: true
        }
      };
      static UPDATE = {
        path: "/mf2/merchants/{uuid}",
        method: "PUT",
        operationId: "api_merchants_uuid_put",
        summary: "Update Merchant",
        description: "Update a merchant",
        tags: ["Merchant"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        parameters: {
          path: {
            uuid: "string"
          }
        },
        requestBody: {
          required: true,
          contentType: "application/json",
          schema: "Merchant-update"
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "Merchant-read"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "404": {
            description: "Not Found",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel404NotFound"
          },
          "422": {
            description: "Validation Error",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_HTTPValidationError"
          }
        },
        metadata: {
          resource: "merchants",
          operation: "update",
          authRequired: true,
          retryable: false
        }
      };
    };
    PEMEndpoints = class {
      static CREATE_POS = {
        path: "/mf2/point-of-sales",
        method: "POST",
        operationId: "api_point-of-sales_post",
        summary: "Create Point of Sale",
        description: "Create a new Point of Sale",
        tags: ["Pem"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        requestBody: {
          required: true,
          contentType: "application/json",
          schema: "PointOfSale-create"
        },
        responses: {
          "201": {
            description: "Successful Response",
            contentType: "application/json",
            schema: "PointOfSale-read"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "422": {
            description: "Validation Error",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_HTTPValidationError"
          }
        },
        metadata: {
          resource: "pems",
          operation: "create_pos",
          authRequired: true,
          retryable: false
        }
      };
      static GET_CERTIFICATES = {
        path: "/mf2/point-of-sales/{id}/certificates",
        method: "GET",
        operationId: "api_point-of-sales_idcertificates_get",
        summary: "Get PEM Certificates",
        description: "Get certificates for a Point of Sale",
        tags: ["Pem"],
        security: [{ "E-Receipt_IT_API_OAuth2PasswordBearer": [] }],
        parameters: {
          path: {
            id: "string"
          }
        },
        responses: {
          "200": {
            description: "Successful Response",
            contentType: "application/json"
          },
          "403": {
            description: "Forbidden",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel403Forbidden"
          },
          "404": {
            description: "Not Found",
            contentType: "application/json",
            schema: "E-Receipt_IT_API_ErrorModel404NotFound"
          }
        },
        metadata: {
          resource: "pems",
          operation: "get_certificates",
          authRequired: true,
          retryable: true
        }
      };
    };
    EndpointUtils = class {
      /**
       * Get all endpoints for a specific resource
       */
      static getResourceEndpoints(resource) {
        switch (resource.toLowerCase()) {
          case "cashiers":
            return Object.values(CashierEndpoints);
          case "point-of-sales":
            return Object.values(PointOfSalesEndpoints);
          case "receipts":
            return Object.values(ReceiptEndpoints);
          case "cash-registers":
            return Object.values(CashRegisterEndpoints);
          case "merchants":
            return Object.values(MerchantEndpoints);
          case "pems":
            return Object.values(PEMEndpoints);
          default:
            return [];
        }
      }
      /**
       * Find endpoint by operation ID
       */
      static findEndpointByOperationId(operationId) {
        const allClasses = [
          CashierEndpoints,
          PointOfSalesEndpoints,
          ReceiptEndpoints,
          CashRegisterEndpoints,
          MerchantEndpoints,
          PEMEndpoints
        ];
        for (const endpointClass of allClasses) {
          for (const endpoint of Object.values(endpointClass)) {
            if (endpoint.operationId === operationId) {
              return endpoint;
            }
          }
        }
        return null;
      }
      /**
       * Build URL with path parameters
       */
      static buildUrl(endpoint, pathParams = {}) {
        let url = endpoint.path;
        for (const [key, value] of Object.entries(pathParams)) {
          url = url.replace(`{${key}}`, String(value));
        }
        return url;
      }
      /**
       * Check if endpoint requires authentication
       */
      static requiresAuth(endpoint) {
        return endpoint.metadata?.authRequired ?? false;
      }
      /**
       * Check if endpoint operation is retryable
       */
      static isRetryable(endpoint) {
        return endpoint.metadata?.retryable ?? false;
      }
      /**
       * Get expected content type for request body
       */
      static getRequestContentType(endpoint) {
        return endpoint.requestBody?.contentType ?? null;
      }
      /**
       * Get expected response content type
       */
      static getResponseContentType(endpoint, statusCode) {
        return endpoint.responses[statusCode]?.contentType ?? null;
      }
    };
  }
});

// src/storage/queue/types.ts
var createQueueItemId;
var init_types = __esm({
  "src/storage/queue/types.ts"() {
    "use strict";
    init_esm_shims();
    createQueueItemId = (id) => id;
  }
});

// src/resources/base-openapi.ts
var BaseOpenAPIResource;
var init_base_openapi = __esm({
  "src/resources/base-openapi.ts"() {
    "use strict";
    init_esm_shims();
    init_endpoints();
    init_errors();
    init_types();
    BaseOpenAPIResource = class {
      client;
      endpoints;
      storage;
      queueManager;
      offlineEnabled;
      constructor(config) {
        this.client = config.client;
        this.endpoints = config.endpoints;
        this.storage = config.storage || void 0;
        this.queueManager = config.queueManager || void 0;
        this.offlineEnabled = config.offlineEnabled ?? false;
      }
      /**
       * Execute a type-safe API request based on OpenAPI endpoint definition
       * Enhanced with offline-first capabilities
       * 
       * @template TRequest - Type of request data
       * @template TResponse - Type of response data
       * @param endpointKey - Key to identify the endpoint in the endpoints map
       * @param data - Request body data (for POST/PUT/PATCH requests)
       * @param options - Additional request options including offline preferences
       * @returns Promise resolving to typed response data
       */
      async executeRequest(endpointKey, data, options = {}) {
        const endpoint = this.endpoints[endpointKey];
        if (!endpoint) {
          throw new ValidationError(
            `Unknown endpoint: ${endpointKey}`,
            "execute_request",
            [{ field: "endpointKey", message: `Endpoint '${endpointKey}' not found`, code: "UNKNOWN_ENDPOINT" }]
          );
        }
        this.validateRequest({ endpoint, operation: endpointKey, data, ...options });
        if (this.offlineEnabled && this.storage) {
          return this.executeOfflineFirstRequest(endpoint, endpointKey, data, options);
        }
        return this.executeOnlineRequest(endpoint, endpointKey, data, options);
      }
      /**
       * Execute offline-first request with intelligent fallback
       */
      async executeOfflineFirstRequest(endpoint, endpointKey, data, options = {}) {
        const cacheKey = this.buildCacheKey(endpoint, options.pathParams, options.queryParams);
        const isReadOperation = endpoint.method === "GET";
        const isWriteOperation = ["POST", "PUT", "PATCH", "DELETE"].includes(endpoint.method);
        try {
          if (isReadOperation && !options.skipCache && !options.preferOffline) {
            const cachedResult = await this.getCachedResponse(cacheKey);
            if (cachedResult) {
              return cachedResult;
            }
          }
          if (options.preferOffline && isReadOperation) {
            const offlineResult = await this.getOfflineData(cacheKey);
            if (offlineResult) {
              return offlineResult;
            }
          }
          const result = await this.executeOnlineRequest(endpoint, endpointKey, data, options);
          if (isReadOperation && result) {
            await this.cacheResponse(cacheKey, result, options.cacheTTL);
          }
          return result;
        } catch (error) {
          if (isWriteOperation && options.queueIfOffline && this.queueManager) {
            return this.queueWriteOperation(endpoint, endpointKey, data, options, error);
          }
          if (isReadOperation) {
            const offlineResult = await this.getOfflineData(cacheKey);
            if (offlineResult) {
              return offlineResult;
            }
          }
          throw error;
        }
      }
      /**
       * Execute standard online request (original implementation)
       */
      async executeOnlineRequest(endpoint, endpointKey, data, options = {}) {
        const url = this.buildRequestUrl(endpoint, options.pathParams);
        const httpOptions = {
          method: endpoint.method,
          url,
          data,
          headers: {
            ...this.getDefaultHeaders(endpoint),
            ...options.headers
          },
          metadata: {
            operationId: endpoint.operationId,
            resource: endpoint.metadata?.resource,
            operation: endpoint.metadata?.operation,
            ...options.metadata
          },
          skipRetry: options.skipRetry ?? !EndpointUtils.isRetryable(endpoint)
        };
        if (options.queryParams) {
          httpOptions.params = options.queryParams;
        }
        if (options.timeout) {
          httpOptions.timeout = options.timeout;
        }
        if (options.skipCircuitBreaker !== void 0) {
          httpOptions.skipCircuitBreaker = options.skipCircuitBreaker;
        }
        try {
          const response = await this.client.request(httpOptions);
          this.validateResponse(endpoint, response.data);
          return response.data;
        } catch (error) {
          throw this.enhanceError(error, endpoint, endpointKey, options);
        }
      }
      /**
       * Cache response data with TTL
       */
      async cacheResponse(cacheKey, data, ttl) {
        if (!this.storage) return;
        try {
          const ttlSeconds = ttl || 3600;
          const expiresAt = new Date(Date.now() + ttlSeconds * 1e3);
          await this.storage.set(cacheKey, {
            data,
            timestamp: /* @__PURE__ */ new Date(),
            expiresAt
          });
        } catch (error) {
          console.warn("Failed to cache response:", error);
        }
      }
      /**
       * Get cached response if valid
       */
      async getCachedResponse(cacheKey) {
        if (!this.storage) return null;
        try {
          const cached = await this.storage.get(cacheKey);
          if (cached && cached.data && "expiresAt" in cached.data && /* @__PURE__ */ new Date() < new Date(cached.data.expiresAt)) {
            return cached.data.data;
          }
          if (cached) {
            await this.storage.delete(cacheKey);
          }
          return null;
        } catch (error) {
          console.warn("Failed to get cached response:", error);
          return null;
        }
      }
      /**
       * Get offline data (persistent storage)
       */
      async getOfflineData(cacheKey) {
        if (!this.storage) return null;
        try {
          const offlineKey = `offline:${cacheKey}`;
          const offlineEntry = await this.storage.get(offlineKey);
          return offlineEntry?.data || null;
        } catch (error) {
          console.warn("Failed to get offline data:", error);
          return null;
        }
      }
      /**
       * Queue write operation for later execution
       */
      async queueWriteOperation(endpoint, endpointKey, data, options = {}, networkError) {
        if (!this.queueManager) {
          throw networkError || new Error("Network unavailable and queue not configured");
        }
        const queueItem = {
          id: createQueueItemId(`${endpointKey}_${Date.now()}_${Math.random().toString(36).substring(2)}`),
          operation: this.mapHttpMethodToQueueOperation(endpoint.method),
          resource: "receipts",
          // Default resource type - should be passed as parameter
          data: {
            endpoint: endpointKey,
            requestData: data,
            pathParams: options.pathParams,
            queryParams: options.queryParams,
            headers: options.headers
          },
          priority: this.determinePriority(endpoint),
          status: "pending",
          createdAt: Date.now(),
          updatedAt: Date.now(),
          retryCount: 0,
          maxRetries: 3,
          retryStrategy: "exponential",
          conflictResolution: "client-wins",
          ...options.metadata && { metadata: options.metadata }
        };
        await this.queueManager.add(queueItem);
        if (options.optimistic) {
          return this.createOptimisticResponse(endpoint, data, options);
        }
        throw new ValidationError(
          "Operation queued for later execution",
          "queued_operation",
          [{ field: "network", message: "Operation will be executed when network is available", code: "QUEUED" }]
        );
      }
      /**
       * Build cache key for request
       */
      buildCacheKey(endpoint, pathParams, queryParams) {
        let key = `${endpoint.method}:${endpoint.path}`;
        if (pathParams) {
          const sortedParams = Object.keys(pathParams).sort();
          const pathParamString = sortedParams.map((key2) => `${key2}=${pathParams[key2]}`).join("&");
          key += `?path=${pathParamString}`;
        }
        if (queryParams) {
          const sortedParams = Object.keys(queryParams).sort();
          const queryParamString = sortedParams.map((key2) => `${key2}=${queryParams[key2]}`).join("&");
          key += `&query=${queryParamString}`;
        }
        return `api_cache:${key}`;
      }
      /**
       * Map HTTP method to queue operation type
       */
      mapHttpMethodToQueueOperation(method) {
        switch (method.toUpperCase()) {
          case "POST":
            return "create";
          case "PUT":
          case "PATCH":
            return "update";
          case "DELETE":
            return "delete";
          default:
            return "custom";
        }
      }
      /**
       * Determine queue priority based on endpoint
       */
      determinePriority(endpoint) {
        if (endpoint.path.includes("/receipts") || endpoint.path.includes("/cashiers")) {
          return "high";
        }
        return "normal";
      }
      /**
       * Create optimistic response for write operations
       */
      createOptimisticResponse(endpoint, data, _options) {
        if (endpoint.method === "POST") {
          return {
            ...data && typeof data === "object" ? data : {},
            id: `temp_${Date.now()}`,
            _optimistic: true
          };
        }
        if (endpoint.method === "PUT" || endpoint.method === "PATCH") {
          return {
            ...data && typeof data === "object" ? data : {},
            _optimistic: true
          };
        }
        if (endpoint.method === "DELETE") {
          return {
            success: true,
            _optimistic: true
          };
        }
        return {
          success: true,
          _optimistic: true
        };
      }
      /**
       * Build complete request URL with path parameter substitution
       */
      buildRequestUrl(endpoint, pathParams = {}) {
        return EndpointUtils.buildUrl(endpoint, pathParams);
      }
      /**
       * Get default headers based on endpoint requirements
       */
      getDefaultHeaders(endpoint) {
        const headers = {};
        if (endpoint.requestBody) {
          headers["Content-Type"] = endpoint.requestBody.contentType;
        }
        const successResponse = endpoint.responses["200"] || endpoint.responses["201"];
        if (successResponse?.contentType) {
          headers["Accept"] = successResponse.contentType;
        }
        return headers;
      }
      /**
       * Validate request data against OpenAPI specification
       */
      validateRequest(context) {
        const { endpoint, operation, data, pathParams, queryParams } = context;
        const errors = [];
        if (endpoint.parameters?.path) {
          for (const [paramName, paramType] of Object.entries(endpoint.parameters.path)) {
            if (!pathParams || !(paramName in pathParams)) {
              errors.push({
                field: `path.${paramName}`,
                message: `Required path parameter '${paramName}' is missing`,
                code: "MISSING_PATH_PARAM"
              });
            } else {
              const value = pathParams[paramName];
              if (!this.validateParameterType(value, paramType)) {
                errors.push({
                  field: `path.${paramName}`,
                  message: `Path parameter '${paramName}' must be of type ${paramType}`,
                  code: "INVALID_PATH_PARAM_TYPE"
                });
              }
            }
          }
        }
        if (endpoint.requestBody?.required && !data) {
          errors.push({
            field: "body",
            message: "Request body is required",
            code: "MISSING_BODY"
          });
        }
        if (endpoint.parameters?.query && queryParams) {
          for (const [paramName, paramType] of Object.entries(endpoint.parameters.query)) {
            const value = queryParams[paramName];
            if (value !== void 0 && !this.validateParameterType(value, paramType)) {
              errors.push({
                field: `query.${paramName}`,
                message: `Query parameter '${paramName}' must be of type ${paramType}`,
                code: "INVALID_QUERY_PARAM_TYPE"
              });
            }
          }
        }
        if (errors.length > 0) {
          throw new ValidationError(
            `Request validation failed for operation '${operation}'`,
            operation,
            errors
          );
        }
      }
      /**
       * Basic type validation for parameters
       */
      validateParameterType(value, expectedType) {
        switch (expectedType) {
          case "string":
            return typeof value === "string";
          case "integer":
          case "number":
            return typeof value === "number" || typeof value === "string" && !isNaN(Number(value));
          case "boolean":
            return typeof value === "boolean";
          default:
            return true;
        }
      }
      /**
       * Validate response data (can be extended for schema validation)
       */
      validateResponse(endpoint, data) {
        if (data === null || data === void 0) {
          const hasNullableResponse = Object.keys(endpoint.responses).some(
            (code) => code === "204" || endpoint.responses[code]?.description?.toLowerCase().includes("no content")
          );
          if (!hasNullableResponse) {
            console.warn(`Received null/undefined response for ${endpoint.operationId}`);
          }
        }
      }
      /**
       * Enhance errors with OpenAPI-specific context
       */
      enhanceError(error, endpoint, operation, _options) {
        const enhancedError = new error.constructor(
          error.message,
          error.code,
          {
            operation: error.operation || endpoint.operationId,
            retryable: error.retryable !== void 0 ? error.retryable : EndpointUtils.isRetryable(endpoint),
            statusCode: error.statusCode,
            requestId: error.requestId,
            auditInfo: {
              ...error.auditInfo,
              // Add OpenAPI-specific audit information
              pemId: endpoint.metadata?.resource === "point-of-sales" ? String(_options.pathParams?.serial_number || "") : error.auditInfo?.pemId
            },
            cause: error.cause
          }
        );
        Object.defineProperty(enhancedError, "openapiMetadata", {
          value: {
            resource: endpoint.metadata?.resource,
            endpointOperation: operation,
            httpMethod: endpoint.method,
            path: endpoint.path
          },
          writable: false,
          enumerable: false,
          configurable: false
        });
        return enhancedError;
      }
      /**
       * Utility method to check if an operation is available
       */
      hasOperation(operationKey) {
        return operationKey in this.endpoints;
      }
      /**
       * Get endpoint definition for an operation
       */
      getEndpoint(operationKey) {
        return this.endpoints[operationKey] || null;
      }
      /**
       * Get all available operations for this resource
       */
      getAvailableOperations() {
        return Object.keys(this.endpoints);
      }
      /**
       * Create a standardized error for missing operations
       */
      createUnsupportedOperationError(operation) {
        return new ValidationError(
          `Operation '${operation}' is not supported by this resource`,
          "unsupported_operation",
          [{
            field: "operation",
            message: `Available operations: ${this.getAvailableOperations().join(", ")}`,
            code: "UNSUPPORTED_OPERATION"
          }]
        );
      }
      // Static utility methods for common patterns
      /**
       * Format validation errors for user-friendly display
       */
      static formatValidationErrors(errors) {
        return errors.map((error) => `${error.field}: ${error.message}`).join(", ");
      }
      /**
       * Extract error details from API response
       */
      static extractErrorDetails(error) {
        if (error instanceof ValidationError) {
          return {
            message: error.message,
            details: error.violations
          };
        }
        if (error instanceof Error) {
          return { message: error.message };
        }
        return { message: "Unknown error occurred" };
      }
      /**
       * Check if error indicates a temporary failure
       */
      static isTemporaryError(error) {
        if (error.name === "NetworkError") {
          return true;
        }
        if (error.statusCode) {
          return [429, 500, 502, 503, 504].includes(error.statusCode);
        }
        return error.retryable ?? false;
      }
      /**
       * Get retry delay for temporary errors
       */
      static getRetryDelay(_error, attempt) {
        const baseDelay = 1e3;
        const maxDelay = 3e4;
        let delay = Math.min(baseDelay * Math.pow(2, attempt - 1), maxDelay);
        const jitter = delay * 0.25;
        delay += (Math.random() * 2 - 1) * jitter;
        return Math.floor(delay);
      }
      // Offline utility methods
      /**
       * Check if offline capabilities are enabled for this resource
       */
      isOfflineEnabled() {
        return this.offlineEnabled && Boolean(this.storage);
      }
      /**
       * Check if queue capabilities are enabled for this resource
       */
      isQueueEnabled() {
        return this.offlineEnabled && Boolean(this.queueManager);
      }
      /**
       * Store data for offline use (persistent across sessions)
       */
      async storeOfflineData(key, data) {
        if (!this.storage) return;
        try {
          const offlineKey = `offline:${key}`;
          await this.storage.set(offlineKey, data);
        } catch (error) {
          console.warn("Failed to store offline data:", error);
        }
      }
      /**
       * Clear cached data for a specific key pattern
       */
      async clearCache(keyPattern) {
        if (!this.storage) return;
        try {
          if (keyPattern) {
            const results = await this.storage.query({ keyPrefix: `api_cache:${keyPattern}` });
            for (const entry of results) {
              await this.storage.delete(entry.key);
            }
          } else {
            const results = await this.storage.query({ keyPrefix: "api_cache:" });
            for (const entry of results) {
              await this.storage.delete(entry.key);
            }
          }
        } catch (error) {
          console.warn("Failed to clear cache:", error);
        }
      }
      /**
       * Get offline queue statistics for this resource
       */
      async getOfflineStats() {
        const stats = {
          queuedOperations: 0,
          cachedEntries: 0,
          offlineEntries: 0
        };
        try {
          if (this.queueManager) {
            const queueStats = this.queueManager.getStats();
            stats.queuedOperations = queueStats.totalItems;
          }
          if (this.storage) {
            const cacheEntries = await this.storage.query({ keyPrefix: "api_cache:" });
            stats.cachedEntries = cacheEntries.length;
            const offlineEntries = await this.storage.query({ keyPrefix: "offline:" });
            stats.offlineEntries = offlineEntries.length;
          }
        } catch (error) {
          console.warn("Failed to get offline stats:", error);
        }
        return stats;
      }
      /**
       * Force sync of queued operations for this resource
       */
      async syncQueuedOperations() {
        if (!this.queueManager) return;
        try {
          await this.queueManager.processAll();
        } catch (error) {
          console.warn("Failed to sync queued operations:", error);
          throw error;
        }
      }
    };
  }
});

// src/resources/cashiers.ts
var cashiers_exports = {};
__export(cashiers_exports, {
  Cashiers: () => CashiersResource,
  CashiersResource: () => CashiersResource
});
var CashiersResource;
var init_cashiers = __esm({
  "src/resources/cashiers.ts"() {
    "use strict";
    init_esm_shims();
    init_base_openapi();
    init_endpoints();
    init_errors();
    CashiersResource = class _CashiersResource extends BaseOpenAPIResource {
      constructor(client, storage, queueManager) {
        super({
          client,
          storage: storage || void 0,
          queueManager: queueManager || void 0,
          offlineEnabled: Boolean(storage || queueManager),
          endpoints: {
            list: CashierEndpoints.LIST,
            create: CashierEndpoints.CREATE,
            me: CashierEndpoints.ME,
            getById: CashierEndpoints.GET_BY_ID,
            delete: CashierEndpoints.DELETE
          }
        });
      }
      /**
       * Get a list of cashiers with pagination
       * Enhanced with offline-first capabilities
       * 
       * @param params - Pagination parameters
       * @param options - Request options including offline preferences
       * @returns Promise resolving to paginated cashier list
       */
      async list(params, options = {}) {
        return this.executeRequest("list", void 0, {
          ...params && { queryParams: params },
          cacheTTL: 600,
          // Cache for 10 minutes
          queueIfOffline: false,
          ...options,
          metadata: {
            operation: "list_cashiers",
            ...options.metadata
          }
        });
      }
      /**
       * Create a new cashier
       * Enhanced with offline queuing and optimistic updates
       * 
       * @param data - Cashier creation input data
       * @param validationOptions - Validation options
       * @param requestOptions - Request options including offline preferences
       * @returns Promise resolving to created cashier
       */
      async create(data, validationOptions = {}, requestOptions = {}) {
        await this.validateCashierInput(data, validationOptions);
        return this.executeRequest("create", data, {
          queueIfOffline: true,
          optimistic: true,
          ...requestOptions,
          metadata: {
            operation: "create_cashier",
            email: data.email,
            ...requestOptions.metadata
          }
        });
      }
      /**
       * Get current cashier information
       * Enhanced with intelligent caching
       * 
       * @param options - Request options including offline preferences
       * @returns Promise resolving to current cashier details
       */
      async me(options = {}) {
        return this.executeRequest("me", void 0, {
          cacheTTL: 300,
          // Cache for 5 minutes
          queueIfOffline: false,
          ...options,
          metadata: {
            operation: "get_current_cashier",
            ...options.metadata
          }
        });
      }
      /**
       * Get a specific cashier by ID
       * 
       * @param cashierId - Cashier ID (branded or number)
       * @returns Promise resolving to cashier details
       */
      async retrieve(cashierId) {
        return this.executeRequest("getById", void 0, {
          pathParams: { cashier_id: cashierId },
          metadata: {
            operation: "get_cashier",
            cashierId
          }
        });
      }
      /**
       * Delete a cashier
       * 
       * @param cashierId - Cashier ID (branded or number)
       * @returns Promise resolving when deletion is complete
       */
      async delete(cashierId) {
        return this.executeRequest("delete", void 0, {
          pathParams: { cashier_id: cashierId },
          metadata: {
            operation: "delete_cashier",
            cashierId
          }
        });
      }
      /**
       * Update a cashier's profile (future enhancement)
       * Note: This endpoint is not yet available in the OpenAPI spec
       */
      async update(cashierId, data) {
        if (!this.hasOperation("update")) {
          throw this.createUnsupportedOperationError("update");
        }
        return this.executeRequest("update", data, {
          pathParams: { cashier_id: cashierId },
          metadata: {
            operation: "update_cashier",
            cashierId
          }
        });
      }
      // Validation methods
      /**
       * Comprehensive cashier input validation
       */
      async validateCashierInput(data, options = {}) {
        const errors = [];
        if (!data.email || !this.isValidEmail(data.email)) {
          errors.push({
            field: "email",
            message: "Invalid email format",
            code: "INVALID_EMAIL"
          });
        } else {
          if (options.allowedEmailDomains && options.allowedEmailDomains.length > 0) {
            if (!_CashiersResource.isAllowedEmailDomain(data.email, options.allowedEmailDomains)) {
              errors.push({
                field: "email",
                message: `Email domain not allowed. Allowed domains: ${options.allowedEmailDomains.join(", ")}`,
                code: "DOMAIN_NOT_ALLOWED"
              });
            }
          }
          if (options.checkEmailUniqueness) {
            const isDuplicate = await this.checkEmailExists(data.email);
            if (isDuplicate) {
              errors.push({
                field: "email",
                message: "Email address is already in use",
                code: "EMAIL_EXISTS"
              });
            }
          }
        }
        const passwordCheck = _CashiersResource.checkPasswordStrength(data.password);
        if (!passwordCheck.isValid) {
          if (options.enforceStrongPassword) {
            errors.push({
              field: "password",
              message: passwordCheck.message || "Password does not meet security requirements",
              code: "WEAK_PASSWORD"
            });
          } else {
            console.warn(`Weak password detected for ${data.email}: ${passwordCheck.suggestions.join(", ")}`);
          }
        }
        if (errors.length > 0) {
          throw new ValidationError("Invalid cashier input", "create_cashier", errors);
        }
      }
      /**
       * Check if email already exists (placeholder for future implementation)
       */
      async checkEmailExists(email) {
        console.warn(`Email uniqueness check not implemented for: ${email}`);
        return false;
      }
      /**
       * Validate email format
       */
      isValidEmail(email) {
        return _CashiersResource.isValidEmail(email);
      }
      // Static utility methods
      /**
       * Validate email format (static utility)
       */
      static isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
      }
      /**
       * Check password strength with detailed analysis
       */
      static checkPasswordStrength(password) {
        const suggestions = [];
        let score = 0;
        if (password.length >= 8) score++;
        if (password.length >= 12) score++;
        if (password.length < 8) {
          suggestions.push("Use at least 8 characters");
        }
        if (/[a-z]/.test(password)) score++;
        else suggestions.push("Include lowercase letters");
        if (/[A-Z]/.test(password)) score++;
        else suggestions.push("Include uppercase letters");
        if (/\d/.test(password)) score++;
        else suggestions.push("Include numbers");
        if (/[^a-zA-Z0-9]/.test(password)) score++;
        else suggestions.push("Include special characters");
        if (/(.)\\1{2,}/.test(password)) {
          score--;
          suggestions.push("Avoid repeating characters");
        }
        const commonPasswords = [
          "password",
          "password123",
          "12345678",
          "qwerty",
          "abc123",
          "password1",
          "123456789",
          "welcome",
          "admin",
          "letmein"
        ];
        if (commonPasswords.some((common) => password.toLowerCase().includes(common.toLowerCase()))) {
          score = 0;
          suggestions.push("Avoid common passwords");
        }
        if (/^[a-zA-Z]+$/.test(password) && password.length < 12) {
          score--;
          suggestions.push("Avoid using only dictionary words");
        }
        const isValid = score >= 4 && password.length >= 8;
        const message = isValid ? "Strong password" : "Password too weak";
        return { isValid, score, message, suggestions };
      }
      /**
       * Generate a secure password
       */
      static generateSecurePassword(length = 12) {
        const lowercase = "abcdefghijklmnopqrstuvwxyz";
        const uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        const numbers = "0123456789";
        const symbols = "!@#$%^&*()_+-=[]{}|;:,.<>?";
        const allChars = lowercase + uppercase + numbers + symbols;
        let password = "";
        password += lowercase[Math.floor(Math.random() * lowercase.length)];
        password += uppercase[Math.floor(Math.random() * uppercase.length)];
        password += numbers[Math.floor(Math.random() * numbers.length)];
        password += symbols[Math.floor(Math.random() * symbols.length)];
        for (let i = password.length; i < length; i++) {
          password += allChars[Math.floor(Math.random() * allChars.length)];
        }
        return password.split("").sort(() => Math.random() - 0.5).join("");
      }
      /**
       * Format email for display (partial masking for privacy)
       */
      static formatEmailForDisplay(email) {
        const [localPart, domain] = email.split("@");
        if (!localPart || !domain) return email;
        if (localPart.length <= 3) {
          return `${localPart[0]}**@${domain}`;
        }
        const visibleChars = Math.min(3, Math.floor(localPart.length / 2));
        const maskedPart = "*".repeat(localPart.length - visibleChars);
        return `${localPart.substring(0, visibleChars)}${maskedPart}@${domain}`;
      }
      /**
       * Extract domain from email
       */
      static getEmailDomain(email) {
        const parts = email.split("@");
        return parts.length === 2 ? parts[1] || null : null;
      }
      /**
       * Validate email domain against allowed domains
       */
      static isAllowedEmailDomain(email, allowedDomains) {
        const domain = this.getEmailDomain(email);
        return domain ? allowedDomains.includes(domain.toLowerCase()) : false;
      }
      /**
       * Generate username suggestion from email
       */
      static generateUsername(email) {
        const [localPart] = email.split("@");
        if (!localPart) return "user";
        return localPart.toLowerCase().replace(/[^a-z0-9]/g, "").substring(0, 20);
      }
      /**
       * Validate cashier creation rate limits (placeholder for future implementation)
       */
      static checkCreationRateLimit(ipAddress) {
        console.warn(`Rate limit check not implemented for IP: ${ipAddress}`);
        return true;
      }
      /**
       * Get cashier role permissions (placeholder for future implementation)
       */
      static getCashierPermissions() {
        return [
          "create_receipt",
          "view_receipts",
          "void_receipt",
          "return_items",
          "view_daily_summary"
        ];
      }
      /**
       * Format cashier for display in UI
       */
      static formatCashierForDisplay(cashier) {
        return {
          displayName: cashier.email.split("@")[0] || "Unknown",
          maskedEmail: this.formatEmailForDisplay(cashier.email),
          status: "active",
          // This would come from the API response
          permissions: this.getCashierPermissions()
        };
      }
      /**
       * Validate cashier session (placeholder for future implementation)
       */
      static validateCashierSession(cashierId) {
        console.warn(`Session validation not implemented for cashier: ${cashierId}`);
        return Promise.resolve(true);
      }
    };
  }
});

// src/resources/receipts.ts
var receipts_exports = {};
__export(receipts_exports, {
  Receipts: () => ReceiptsResource,
  ReceiptsResource: () => ReceiptsResource
});
var ReceiptsResource;
var init_receipts = __esm({
  "src/resources/receipts.ts"() {
    "use strict";
    init_esm_shims();
    init_base_openapi();
    init_endpoints();
    init_errors();
    ReceiptsResource = class extends BaseOpenAPIResource {
      constructor(client, storage, queueManager) {
        super({
          client,
          storage: storage || void 0,
          queueManager: queueManager || void 0,
          offlineEnabled: Boolean(storage || queueManager),
          endpoints: {
            list: ReceiptEndpoints.LIST,
            create: ReceiptEndpoints.CREATE,
            void: ReceiptEndpoints.VOID,
            getByUuid: ReceiptEndpoints.GET_BY_UUID,
            voidWithProof: ReceiptEndpoints.VOID_WITH_PROOF,
            getDetails: ReceiptEndpoints.GET_DETAILS,
            returnItems: ReceiptEndpoints.RETURN_ITEMS,
            returnItemsWithProof: ReceiptEndpoints.RETURN_ITEMS_WITH_PROOF
          }
        });
      }
      /**
       * Get a list of receipts with filtering and pagination
       * Enhanced with offline-first capabilities
       * 
       * @param params - List parameters including filters and pagination
       * @param options - Request options including offline preferences
       * @returns Promise resolving to paginated receipt list
       */
      async list(params, options = {}) {
        return this.executeRequest("list", void 0, {
          ...params && { queryParams: params },
          cacheTTL: 300,
          // Cache for 5 minutes
          queueIfOffline: false,
          // Read operations don't need queuing
          ...options,
          metadata: {
            operation: "list_receipts",
            dateRange: params?.start_date && params?.end_date ? `${params.start_date} to ${params.end_date}` : void 0,
            ...options.metadata
          }
        });
      }
      /**
       * Create a new electronic receipt
       * Enhanced with offline queuing and optimistic updates
       * 
       * @param data - Receipt input data with items and payment information
       * @param validationOptions - Validation options for fiscal compliance
       * @param requestOptions - Request options including offline preferences
       * @returns Promise resolving to created receipt
       */
      async create(data, validationOptions = {}, requestOptions = {}) {
        await this.validateReceiptInput(data, validationOptions);
        return this.executeRequest("create", data, {
          queueIfOffline: true,
          // Queue receipts when offline
          optimistic: true,
          // Provide immediate feedback
          ...requestOptions,
          metadata: {
            operation: "create_receipt",
            itemCount: data.items.length,
            totalAmount: this.calculateTotalAmount(data).totalAmount
          }
        });
      }
      /**
       * Void an electronic receipt
       * Enhanced with offline queuing for critical operations
       * 
       * @param voidData - Void request data
       * @param options - Request options including offline preferences
       * @returns Promise resolving to void confirmation
       */
      async void(voidData, options = {}) {
        return this.executeRequest("void", voidData, {
          queueIfOffline: true,
          // Critical operation - queue when offline
          optimistic: false,
          // Don't provide optimistic response for fiscal operations
          ...options,
          metadata: {
            operation: "void_receipt",
            ...options.metadata
          }
        });
      }
      /**
       * Get a specific receipt by UUID
       * Enhanced with intelligent caching for frequent lookups
       * 
       * @param receiptId - Receipt UUID
       * @param options - Request options including offline preferences
       * @returns Promise resolving to receipt details
       */
      async retrieve(receiptId, options = {}) {
        return this.executeRequest("getByUuid", void 0, {
          pathParams: { receipt_uuid: receiptId },
          cacheTTL: 600,
          // Cache individual receipts for 10 minutes
          queueIfOffline: false,
          // Read operations don't need queuing
          ...options,
          metadata: {
            operation: "get_receipt",
            receiptId,
            ...options.metadata
          }
        });
      }
      /**
       * Void a receipt using proof of purchase
       * 
       * @param voidData - Void request with proof data
       * @returns Promise resolving to void confirmation
       */
      async voidWithProof(voidData) {
        return this.executeRequest("voidWithProof", voidData, {
          metadata: {
            operation: "void_receipt_with_proof"
          }
        });
      }
      /**
       * Get receipt details or PDF
       * 
       * @param receiptId - Receipt UUID
       * @param format - Response format ('json' or 'pdf')
       * @returns Promise resolving to receipt details or PDF blob
       */
      async getDetails(receiptId, format = "json") {
        const acceptHeader = format === "pdf" ? "application/pdf" : "application/json";
        return this.executeRequest("getDetails", void 0, {
          pathParams: { receipt_uuid: receiptId },
          headers: { Accept: acceptHeader },
          metadata: {
            operation: "get_receipt_details",
            receiptId,
            format
          }
        });
      }
      /**
       * Return items from a receipt
       * 
       * @param returnData - Return request data
       * @returns Promise resolving to return receipt
       */
      async returnItems(returnData) {
        return this.executeRequest("returnItems", returnData, {
          metadata: {
            operation: "return_receipt_items"
          }
        });
      }
      /**
       * Return items from a receipt using proof of purchase
       * 
       * @param returnData - Return request with proof data
       * @returns Promise resolving to return receipt
       */
      async returnItemsWithProof(returnData) {
        return this.executeRequest("returnItemsWithProof", returnData, {
          metadata: {
            operation: "return_receipt_items_with_proof"
          }
        });
      }
      /**
       * Update an existing receipt
       * 
       * @param receiptId - The receipt ID to update
       * @param updateData - Update data for the receipt
       * @returns Promise resolving to updated receipt
       */
      async update(receiptId, updateData) {
        if (!this.hasOperation("updateReceipt")) {
          throw this.createUnsupportedOperationError("updateReceipt");
        }
        return this.executeRequest("updateReceipt", {
          id: String(receiptId),
          ...updateData
        }, {
          metadata: {
            operation: "update_receipt",
            receiptId: String(receiptId)
          }
        });
      }
      /**
       * Delete a receipt
       * 
       * @param receiptId - The receipt ID to delete
       * @returns Promise resolving to deletion confirmation
       */
      async delete(receiptId) {
        if (!this.hasOperation("deleteReceipt")) {
          throw this.createUnsupportedOperationError("deleteReceipt");
        }
        return this.executeRequest("deleteReceipt", {
          id: String(receiptId)
        }, {
          metadata: {
            operation: "delete_receipt",
            receiptId: String(receiptId)
          }
        });
      }
      // Validation methods
      /**
       * Comprehensive receipt input validation
       */
      async validateReceiptInput(data, options = {}) {
        const errors = [];
        if (!data.items || data.items.length === 0) {
          errors.push({
            field: "items",
            message: "Receipt must contain at least one item",
            code: "NO_ITEMS"
          });
        }
        if (options.maxReceiptItems && data.items.length > options.maxReceiptItems) {
          errors.push({
            field: "items",
            message: `Receipt cannot contain more than ${options.maxReceiptItems} items`,
            code: "TOO_MANY_ITEMS"
          });
        }
        for (let i = 0; i < data.items.length; i++) {
          const item = data.items[i];
          if (!item) continue;
          const itemErrors = this.validateReceiptItem(item, i, options);
          errors.push(...itemErrors);
        }
        const paymentErrors = this.validatePaymentAmounts(data);
        errors.push(...paymentErrors);
        if (options.checkTotalCalculations) {
          const calculationErrors = this.validateCalculations(data);
          errors.push(...calculationErrors);
        }
        if (options.enforceItalianFiscalRules) {
          const fiscalErrors = this.validateItalianFiscalRules(data);
          errors.push(...fiscalErrors);
        }
        if (errors.length > 0) {
          throw new ValidationError("Invalid receipt input", "create_receipt", errors);
        }
      }
      /**
       * Validate individual receipt item
       */
      validateReceiptItem(item, index, options) {
        const errors = [];
        const prefix = `items[${index}]`;
        if (!item.description || item.description.trim().length === 0) {
          errors.push({
            field: `${prefix}.description`,
            message: "Item description is required",
            code: "REQUIRED"
          });
        }
        if (!item.quantity || parseFloat(item.quantity) <= 0) {
          errors.push({
            field: `${prefix}.quantity`,
            message: "Item quantity must be greater than 0",
            code: "INVALID_QUANTITY"
          });
        }
        if (!item.unit_price || parseFloat(item.unit_price) < 0) {
          errors.push({
            field: `${prefix}.unit_price`,
            message: "Item unit price cannot be negative",
            code: "INVALID_PRICE"
          });
        }
        if (options.validateVATRates && item.vat_rate_code) {
          const validVATRates = ["0", "4", "5", "10", "22"];
          if (!validVATRates.includes(item.vat_rate_code)) {
            errors.push({
              field: `${prefix}.vat_rate_code`,
              message: `Invalid VAT rate. Valid rates: ${validVATRates.join(", ")}`,
              code: "INVALID_VAT_RATE"
            });
          }
        }
        if (item.description && item.description.length > 200) {
          errors.push({
            field: `${prefix}.description`,
            message: "Item description cannot exceed 200 characters",
            code: "DESCRIPTION_TOO_LONG"
          });
        }
        return errors;
      }
      /**
       * Validate payment amounts
       */
      validatePaymentAmounts(data) {
        const errors = [];
        const cashAmount = parseFloat(data.cash_payment_amount || "0");
        const electronicAmount = parseFloat(data.electronic_payment_amount || "0");
        const ticketAmount = parseFloat(data.ticket_restaurant_payment_amount || "0");
        if (cashAmount <= 0 && electronicAmount <= 0 && ticketAmount <= 0) {
          errors.push({
            field: "payment",
            message: "At least one payment method must have a positive amount",
            code: "NO_PAYMENT"
          });
        }
        if (cashAmount < 0) {
          errors.push({
            field: "cash_payment_amount",
            message: "Cash payment amount cannot be negative",
            code: "NEGATIVE_AMOUNT"
          });
        }
        if (electronicAmount < 0) {
          errors.push({
            field: "electronic_payment_amount",
            message: "Electronic payment amount cannot be negative",
            code: "NEGATIVE_AMOUNT"
          });
        }
        if (ticketAmount < 0) {
          errors.push({
            field: "ticket_restaurant_payment_amount",
            message: "Ticket restaurant payment amount cannot be negative",
            code: "NEGATIVE_AMOUNT"
          });
        }
        return errors;
      }
      /**
       * Validate calculation accuracy
       */
      validateCalculations(data) {
        const errors = [];
        try {
          const calculated = this.calculateTotalAmount(data);
          const totalPayments = parseFloat(data.cash_payment_amount || "0") + parseFloat(data.electronic_payment_amount || "0") + parseFloat(data.ticket_restaurant_payment_amount || "0");
          const tolerance = 0.01;
          if (Math.abs(totalPayments - parseFloat(calculated.totalAmount)) > tolerance) {
            errors.push({
              field: "payment_total",
              message: `Payment total (${totalPayments.toFixed(2)}) does not match calculated total (${calculated.totalAmount})`,
              code: "PAYMENT_MISMATCH"
            });
          }
        } catch (error) {
          errors.push({
            field: "calculation",
            message: "Failed to validate receipt calculations",
            code: "CALCULATION_ERROR"
          });
        }
        return errors;
      }
      /**
       * Validate Italian fiscal compliance rules
       */
      validateItalianFiscalRules(data) {
        const errors = [];
        const totalAmount = parseFloat(this.calculateTotalAmount(data).totalAmount);
        if (totalAmount > 3e3) {
          const cashAmount = parseFloat(data.cash_payment_amount || "0");
          if (cashAmount > 1e3) {
            errors.push({
              field: "cash_payment_amount",
              message: "Cash payments over \u20AC1000 require additional documentation for transactions above \u20AC3000",
              code: "HIGH_VALUE_CASH_LIMIT"
            });
          }
        }
        if (data.customer_lottery_code && !/^[A-Z0-9]{16}$/.test(data.customer_lottery_code)) {
          errors.push({
            field: "customer_lottery_code",
            message: "Lottery code must be 16 alphanumeric characters",
            code: "INVALID_LOTTERY_CODE"
          });
        }
        return errors;
      }
      // Calculation methods
      /**
       * Calculate total receipt amount with VAT breakdown
       */
      calculateTotalAmount(data) {
        let subtotal = 0;
        let totalVAT = 0;
        let totalDiscount = parseFloat(data.discount || "0");
        const vatBreakdown = /* @__PURE__ */ new Map();
        for (const item of data.items) {
          const quantity = parseFloat(item.quantity);
          const unitPrice = parseFloat(item.unit_price);
          const itemDiscount = parseFloat(item.discount || "0");
          const vatRate = parseFloat(item.vat_rate_code || "0") / 100;
          const itemNetTotal = quantity * unitPrice - itemDiscount;
          const itemVAT = itemNetTotal * vatRate;
          const itemGrossTotal = itemNetTotal + itemVAT;
          subtotal += itemNetTotal;
          totalVAT += itemVAT;
          const vatKey = item.vat_rate_code || "0";
          if (!vatBreakdown.has(vatKey)) {
            vatBreakdown.set(vatKey, { net: 0, vat: 0, gross: 0 });
          }
          const breakdown = vatBreakdown.get(vatKey);
          breakdown.net += itemNetTotal;
          breakdown.vat += itemVAT;
          breakdown.gross += itemGrossTotal;
        }
        const finalSubtotal = subtotal - totalDiscount;
        const finalTotal = finalSubtotal + totalVAT;
        return {
          subtotal: finalSubtotal.toFixed(2),
          vatAmount: totalVAT.toFixed(2),
          totalAmount: finalTotal.toFixed(2),
          discountAmount: (totalDiscount + data.items.reduce((sum, item) => sum + parseFloat(item.discount || "0"), 0)).toFixed(2),
          itemCount: data.items.length,
          breakdown: Array.from(vatBreakdown.entries()).map(([vatRate, amounts]) => ({
            vatRate,
            netAmount: amounts.net.toFixed(2),
            vatAmount: amounts.vat.toFixed(2),
            grossAmount: amounts.gross.toFixed(2)
          }))
        };
      }
      // Static utility methods
      /**
       * Format receipt for display
       */
      static formatReceiptForDisplay(receipt) {
        const date = new Date(receipt.created_at);
        return {
          receiptNumber: receipt.uuid.split("-")[0]?.toUpperCase() || "UNKNOWN",
          date: date.toLocaleDateString("it-IT"),
          time: date.toLocaleTimeString("it-IT"),
          formattedTotal: `\u20AC ${receipt.total_amount}`,
          paymentMethod: this.determinePaymentMethod(receipt),
          itemSummary: `0 items`
          // items field not available in OpenAPI schema
        };
      }
      /**
       * Determine primary payment method
       */
      static determinePaymentMethod(_receipt) {
        return "cash";
      }
      /**
       * Generate receipt summary for reports
       */
      static generateReceiptSummary(receipts) {
        const summary = {
          totalCount: receipts.length,
          totalAmount: "0.00",
          vatAmount: "0.00",
          averageAmount: "0.00",
          paymentMethodBreakdown: {
            cash: { count: 0, amount: "0.00" },
            electronic: { count: 0, amount: "0.00" },
            ticket_restaurant: { count: 0, amount: "0.00" },
            mixed: { count: 0, amount: "0.00" }
          },
          dateRange: { from: "", to: "" }
        };
        if (receipts.length === 0) return summary;
        let totalAmount = 0;
        let totalVAT = 0;
        const dates = receipts.map((r) => new Date(r.created_at)).sort((a, b) => a.getTime() - b.getTime());
        for (const receipt of receipts) {
          const amount = parseFloat(receipt.total_amount);
          totalAmount += amount;
          totalVAT += amount * 0.15;
          const paymentMethod = this.determinePaymentMethod(receipt);
          summary.paymentMethodBreakdown[paymentMethod].count++;
          summary.paymentMethodBreakdown[paymentMethod].amount = (parseFloat(summary.paymentMethodBreakdown[paymentMethod].amount) + amount).toFixed(2);
        }
        summary.totalAmount = totalAmount.toFixed(2);
        summary.vatAmount = totalVAT.toFixed(2);
        summary.averageAmount = (totalAmount / receipts.length).toFixed(2);
        summary.dateRange.from = dates[0]?.toISOString().split("T")[0] || "";
        summary.dateRange.to = dates[dates.length - 1]?.toISOString().split("T")[0] || "";
        return summary;
      }
      /**
       * Validate receipt return eligibility
       */
      static validateReturnEligibility(receipt, returnDate = /* @__PURE__ */ new Date()) {
        const receiptDate = new Date(receipt.created_at);
        const daysSinceReceipt = Math.floor((returnDate.getTime() - receiptDate.getTime()) / (1e3 * 60 * 60 * 24));
        const returnPeriodDays = 30;
        if (daysSinceReceipt > returnPeriodDays) {
          return {
            eligible: false,
            reason: `Return period expired. Returns allowed within ${returnPeriodDays} days.`
          };
        }
        if (receipt.document_number && receipt.document_number.includes("VOID")) {
          return {
            eligible: false,
            reason: "Receipt has already been voided"
          };
        }
        return {
          eligible: true,
          daysRemaining: returnPeriodDays - daysSinceReceipt
        };
      }
      /**
       * Generate fiscal code for lottery participation
       */
      static generateLotteryCode() {
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        let result = "";
        for (let i = 0; i < 16; i++) {
          result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
      }
      // Offline-specific convenience methods
      /**
       * Get offline receipt statistics
       */
      async getOfflineReceiptStats() {
        const baseStats = await this.getOfflineStats();
        return {
          ...baseStats,
          resourceType: "receipts",
          capabilities: {
            canCreateOffline: this.isQueueEnabled(),
            canReadOffline: this.isOfflineEnabled(),
            canCacheReceipts: this.isOfflineEnabled()
          }
        };
      }
      /**
       * Sync all queued receipt operations
       */
      async syncQueuedReceipts() {
        if (!this.isQueueEnabled()) {
          throw new ValidationError("Queue not enabled", "sync_error", [
            { field: "queue", message: "Offline queue is not configured", code: "QUEUE_NOT_ENABLED" }
          ]);
        }
        await this.syncQueuedOperations();
      }
      /**
       * Clear receipt cache (useful for data refresh)
       */
      async clearReceiptCache() {
        await this.clearCache("receipts");
      }
      /**
       * Store receipt for offline access
       */
      async storeReceiptOffline(receiptId, receipt) {
        const cacheKey = `GET:/receipts/{receipt_uuid}?path=receipt_uuid=${receiptId}`;
        await this.storeOfflineData(cacheKey, receipt);
      }
    };
  }
});

// src/resources/point-of-sales.ts
var point_of_sales_exports = {};
__export(point_of_sales_exports, {
  PointOfSales: () => PointOfSalesResource,
  PointOfSalesResource: () => PointOfSalesResource
});
var PointOfSalesResource;
var init_point_of_sales = __esm({
  "src/resources/point-of-sales.ts"() {
    "use strict";
    init_esm_shims();
    init_base_openapi();
    init_endpoints();
    init_errors();
    PointOfSalesResource = class _PointOfSalesResource extends BaseOpenAPIResource {
      constructor(client) {
        super({
          client,
          endpoints: {
            list: PointOfSalesEndpoints.LIST,
            getBySerial: PointOfSalesEndpoints.GET_BY_SERIAL,
            closeJournal: PointOfSalesEndpoints.CLOSE_JOURNAL,
            activation: PointOfSalesEndpoints.ACTIVATION,
            createInactivity: PointOfSalesEndpoints.CREATE_INACTIVITY,
            setOffline: PointOfSalesEndpoints.SET_OFFLINE
          }
        });
      }
      /**
       * Get a list of Point of Sales devices
       * 
       * @returns Promise resolving to paginated PEM list
       */
      async list() {
        return this.executeRequest("list", void 0, {
          metadata: {
            operation: "list_point_of_sales"
          }
        });
      }
      /**
       * Get a specific Point of Sale by serial number
       * 
       * @param serialNumber - Device serial number
       * @returns Promise resolving to PEM details
       */
      async retrieve(serialNumber) {
        return this.executeRequest("getBySerial", void 0, {
          pathParams: { serial_number: serialNumber },
          metadata: {
            operation: "get_point_of_sale",
            serialNumber
          }
        });
      }
      /**
       * Close the daily journal for a Point of Sale
       * 
       * @returns Promise resolving to close confirmation
       */
      async closeJournal() {
        return this.executeRequest("closeJournal", void 0, {
          metadata: {
            operation: "close_journal"
          }
        });
      }
      /**
       * Trigger activation process for a Point of Sale
       * 
       * @param serialNumber - Device serial number
       * @param activationData - Activation request data
       * @param options - Validation options
       * @returns Promise resolving to activation status
       */
      async activate(serialNumber, activationData, options = {}) {
        await this.validateActivationRequest(serialNumber, activationData, options);
        return this.executeRequest("activation", activationData, {
          pathParams: { serial_number: serialNumber },
          metadata: {
            operation: "activate_point_of_sale",
            serialNumber,
            registrationKey: activationData.registration_key
          }
        });
      }
      /**
       * Create an inactivity period for a Point of Sale
       * 
       * @param serialNumber - Device serial number
       * @param inactivityData - Inactivity period request data
       * @returns Promise resolving when inactivity period is created
       */
      async createInactivityPeriod(serialNumber, inactivityData) {
        return this.executeRequest("createInactivity", inactivityData, {
          pathParams: { serial_number: serialNumber },
          metadata: {
            operation: "create_inactivity_period",
            serialNumber
          }
        });
      }
      /**
       * Set Point of Sale status to offline
       * 
       * @param serialNumber - Device serial number
       * @returns Promise resolving when status is updated
       */
      async setOffline(serialNumber) {
        return this.executeRequest("setOffline", void 0, {
          pathParams: { serial_number: serialNumber },
          metadata: {
            operation: "set_point_of_sale_offline",
            serialNumber
          }
        });
      }
      /**
       * Get device status summary
       * 
       * @param serialNumber - Device serial number
       * @returns Promise resolving to device status
       */
      async getDeviceStatus(serialNumber) {
        const device = await this.retrieve(serialNumber);
        return _PointOfSalesResource.analyzeDeviceStatus(device);
      }
      /**
       * Get journal summary for a specific date
       * 
       * @param serialNumber - Device serial number
       * @param date - Date in YYYY-MM-DD format
       * @returns Promise resolving to journal summary
       */
      async getJournalSummary(_serialNumber, date = (/* @__PURE__ */ new Date()).toISOString().split("T")[0]) {
        return {
          date,
          transactionCount: 0,
          totalAmount: "0.00",
          vatAmount: "0.00",
          status: "open"
        };
      }
      // Validation methods
      /**
       * Validate activation request
       */
      async validateActivationRequest(serialNumber, activationData, options = {}) {
        const errors = [];
        if (options.validateSerialNumber) {
          const serialValidation = _PointOfSalesResource.validateSerialNumber(serialNumber);
          if (!serialValidation.isValid) {
            errors.push({
              field: "serial_number",
              message: serialValidation.error || "Invalid serial number format",
              code: "INVALID_SERIAL_NUMBER"
            });
          }
        }
        if (!activationData.registration_key || activationData.registration_key.length === 0) {
          errors.push({
            field: "registration_key",
            message: "Registration key is required",
            code: "REQUIRED"
          });
        } else {
          const keyValidation = this.validateRegistrationKey(activationData.registration_key);
          if (!keyValidation.isValid) {
            errors.push({
              field: "registration_key",
              message: keyValidation.error || "Invalid registration key format",
              code: "INVALID_REGISTRATION_KEY"
            });
          }
        }
        if (options.checkActivationStatus) {
          try {
            const device = await this.retrieve(serialNumber);
            if (device.status === "ACTIVE") {
              errors.push({
                field: "status",
                message: "Device is already activated",
                code: "ALREADY_ACTIVATED"
              });
            }
          } catch (error) {
            if (error instanceof Error && !error.message.includes("404")) {
              errors.push({
                field: "device",
                message: "Unable to verify device status",
                code: "STATUS_CHECK_FAILED"
              });
            }
          }
        }
        if (errors.length > 0) {
          throw new ValidationError("Invalid activation request", "activate_point_of_sale", errors);
        }
      }
      /**
       * Validate registration key format
       */
      validateRegistrationKey(key) {
        if (key.length < 16) {
          return { isValid: false, error: "Registration key must be at least 16 characters" };
        }
        if (!/^[A-Z0-9-]+$/.test(key)) {
          return { isValid: false, error: "Registration key contains invalid characters" };
        }
        return { isValid: true };
      }
      // Static utility methods
      /**
       * Validate serial number format
       */
      static validateSerialNumber(serialNumber) {
        const serialStr = String(serialNumber);
        if (serialStr.length < 8 || serialStr.length > 20) {
          return { isValid: false, error: "Serial number must be between 8 and 20 characters" };
        }
        if (!/^[A-Z0-9]+$/.test(serialStr)) {
          return { isValid: false, error: "Serial number must contain only uppercase letters and numbers" };
        }
        return { isValid: true };
      }
      /**
       * Analyze device status from device data
       */
      static analyzeDeviceStatus(device) {
        return {
          serialNumber: device.serial_number,
          status: device.status,
          lastSeen: (/* @__PURE__ */ new Date()).toISOString(),
          // last_seen field not available in OpenAPI schema
          certificateExpiry: void 0,
          // certificate_expiry field not available in OpenAPI schema
          firmwareVersion: void 0,
          // firmware_version field not available in OpenAPI schema
          batteryLevel: void 0,
          // battery_level field not available in OpenAPI schema
          connectivity: this.determineConnectivityStatus(device)
        };
      }
      /**
       * Determine connectivity status from device data
       */
      static determineConnectivityStatus(_device) {
        const lastSeenTime = (/* @__PURE__ */ new Date()).getTime();
        const now = Date.now();
        const minutesSinceLastSeen = (now - lastSeenTime) / (1e3 * 60);
        if (minutesSinceLastSeen <= 5) return "online";
        if (minutesSinceLastSeen <= 30) return "intermittent";
        return "offline";
      }
      /**
       * Format device for display
       */
      static formatDeviceForDisplay(device) {
        const status = device.status || "unknown";
        const lastSeen = /* @__PURE__ */ new Date();
        return {
          displayName: `PEM ${device.serial_number}`,
          statusBadge: status.toUpperCase(),
          location: device.address?.city || "Unknown Location",
          lastActivity: lastSeen.toLocaleString(),
          certificateStatus: "Not Available"
          // certificate_expiry field not available in OpenAPI schema
        };
      }
      /**
       * Calculate device uptime
       */
      static calculateUptime(_device) {
        const lastSeenTime = Date.now();
        const now = Date.now();
        const hoursSinceLastSeen = (now - lastSeenTime) / (1e3 * 60 * 60);
        const uptimeHours = Math.max(0, 24 - hoursSinceLastSeen);
        const uptimePercentage = Math.round(uptimeHours / 24 * 100);
        let availabilityStatus = "excellent";
        if (uptimePercentage < 95) availabilityStatus = "good";
        if (uptimePercentage < 85) availabilityStatus = "poor";
        if (uptimePercentage < 70) availabilityStatus = "critical";
        return {
          uptimeHours: Math.round(uptimeHours * 100) / 100,
          uptimePercentage,
          availabilityStatus
        };
      }
      /**
       * Generate device health report
       */
      static generateHealthReport(devices) {
        const report = {
          totalDevices: devices.length,
          activeDevices: 0,
          offlineDevices: 0,
          devicesRequiringAttention: 0,
          avgUptimePercentage: 0,
          certificateExpiringCount: 0,
          statusBreakdown: {}
        };
        let totalUptime = 0;
        for (const device of devices) {
          const status = device.status;
          report.statusBreakdown[status] = (report.statusBreakdown[status] || 0) + 1;
          if (status === "ACTIVE") {
            report.activeDevices++;
          } else if (status === "OFFLINE") {
            report.offlineDevices++;
          }
          if (["DISCARDED"].includes(status)) {
            report.devicesRequiringAttention++;
          }
          const uptime = this.calculateUptime(device);
          totalUptime += uptime.uptimePercentage;
        }
        report.avgUptimePercentage = devices.length > 0 ? Math.round(totalUptime / devices.length) : 0;
        return report;
      }
      /**
       * Validate journal closing eligibility
       */
      static validateJournalClosingEligibility(device, _date) {
        const reasons = [];
        const requirements = [];
        if (device.status !== "ACTIVE") {
          reasons.push("Device must be in active status");
        }
        requirements.push("All transactions must be transmitted to tax authority");
        requirements.push("Device must be connected to network");
        requirements.push("No active receipt printing operations");
        return {
          canClose: reasons.length === 0,
          reasons,
          requirements
        };
      }
      /**
       * Get recommended maintenance schedule
       */
      static getMaintenanceSchedule(_device) {
        const now = /* @__PURE__ */ new Date();
        return {
          nextMaintenance: new Date(now.getTime() + 90 * 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
          maintenanceType: "routine",
          priority: "low",
          description: "Routine maintenance and inspection",
          estimatedDuration: "30-60 minutes"
        };
      }
      /**
       * Check if firmware version is outdated
       * @deprecated This method is not used since firmware_version is not available in OpenAPI schema
       */
      // private static isOutdatedFirmware(version: string): boolean {
      //   // Simple version comparison (in reality, this would be more sophisticated)
      //   const currentVersion = '2.1.0'; // Mock current version
      //   return version < currentVersion;
      // }
      /**
       * Generate activation code for new devices
       */
      static generateActivationCode() {
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        let result = "";
        for (let group = 0; group < 4; group++) {
          if (group > 0) result += "-";
          for (let i = 0; i < 4; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
          }
        }
        return result;
      }
    };
  }
});

// src/storage/unified-storage.ts
var unified_storage_exports = {};
__export(unified_storage_exports, {
  DEFAULT_STORAGE_OPTIONS: () => DEFAULT_STORAGE_OPTIONS,
  STORAGE_NAMESPACES: () => STORAGE_NAMESPACES,
  StorageCapacityError: () => StorageCapacityError,
  StorageConnectionError: () => StorageConnectionError,
  StorageEncryptionError: () => StorageEncryptionError,
  StorageError: () => StorageError,
  StorageTransactionError: () => StorageTransactionError,
  createCacheKey: () => createCacheKey,
  createCashRegisterKey: () => createCashRegisterKey,
  createCashierKey: () => createCashierKey,
  createConfigKey: () => createConfigKey,
  createMerchantKey: () => createMerchantKey,
  createPEMKey: () => createPEMKey,
  createReceiptKey: () => createReceiptKey,
  createSecureKey: () => createSecureKey,
  createSessionKey: () => createSessionKey,
  createStorageKey: () => createStorageKey
});
var createStorageKey, StorageError, StorageConnectionError, StorageCapacityError, StorageEncryptionError, StorageTransactionError, DEFAULT_STORAGE_OPTIONS, STORAGE_NAMESPACES, createReceiptKey, createCashierKey, createMerchantKey, createPEMKey, createCashRegisterKey, createCacheKey, createSessionKey, createSecureKey, createConfigKey;
var init_unified_storage = __esm({
  "src/storage/unified-storage.ts"() {
    "use strict";
    init_esm_shims();
    createStorageKey = (key) => key;
    StorageError = class extends Error {
      constructor(message, code, operation, key, cause) {
        super(message);
        this.code = code;
        this.operation = operation;
        this.key = key;
        this.cause = cause;
        this.name = "StorageError";
      }
    };
    StorageConnectionError = class extends StorageError {
      constructor(adapter, cause) {
        super(
          `Failed to connect to storage adapter: ${adapter}`,
          "STORAGE_CONNECTION_ERROR",
          "connect",
          void 0,
          cause
        );
      }
    };
    StorageCapacityError = class extends StorageError {
      constructor(key, size, maxSize) {
        super(
          `Storage capacity exceeded for key ${key}: ${size} > ${maxSize}`,
          "STORAGE_CAPACITY_ERROR",
          "set",
          key
        );
      }
    };
    StorageEncryptionError = class extends StorageError {
      constructor(key, operation, cause) {
        super(
          `Encryption/decryption failed for key ${key}`,
          "STORAGE_ENCRYPTION_ERROR",
          operation,
          key,
          cause
        );
      }
    };
    StorageTransactionError = class extends StorageError {
      constructor(transactionId, operation, cause) {
        super(
          `Transaction ${transactionId} failed during ${operation}`,
          "STORAGE_TRANSACTION_ERROR",
          operation,
          void 0,
          cause
        );
      }
    };
    DEFAULT_STORAGE_OPTIONS = {
      encrypt: false,
      compress: false,
      ttl: 0,
      // No expiration
      namespace: "default",
      version: "1.0.0"
    };
    STORAGE_NAMESPACES = {
      RECEIPTS: "receipts",
      CASHIERS: "cashiers",
      MERCHANTS: "merchants",
      PEMS: "pems",
      CASH_REGISTERS: "cash_registers",
      CACHE: "cache",
      SESSION: "session",
      SECURE: "secure",
      CONFIG: "config",
      OFFLINE_QUEUE: "offline_queue",
      ANALYTICS: "analytics",
      AUDIT: "audit"
    };
    createReceiptKey = (id) => createStorageKey(`${STORAGE_NAMESPACES.RECEIPTS}:${id}`);
    createCashierKey = (id) => createStorageKey(`${STORAGE_NAMESPACES.CASHIERS}:${id}`);
    createMerchantKey = (id) => createStorageKey(`${STORAGE_NAMESPACES.MERCHANTS}:${id}`);
    createPEMKey = (id) => createStorageKey(`${STORAGE_NAMESPACES.PEMS}:${id}`);
    createCashRegisterKey = (id) => createStorageKey(`${STORAGE_NAMESPACES.CASH_REGISTERS}:${id}`);
    createCacheKey = (key) => createStorageKey(`${STORAGE_NAMESPACES.CACHE}:${key}`);
    createSessionKey = (key) => createStorageKey(`${STORAGE_NAMESPACES.SESSION}:${key}`);
    createSecureKey = (key) => createStorageKey(`${STORAGE_NAMESPACES.SECURE}:${key}`);
    createConfigKey = (key) => createStorageKey(`${STORAGE_NAMESPACES.CONFIG}:${key}`);
  }
});

// src/storage/platform-detector.ts
var PlatformDetector, platformDetector, getPlatform, getEnvironmentInfo, hasCapability, getRecommendedStorageAdapter, getPerformanceTier;
var init_platform_detector = __esm({
  "src/storage/platform-detector.ts"() {
    "use strict";
    init_esm_shims();
    PlatformDetector = class _PlatformDetector {
      static instance = null;
      cachedInfo = null;
      constructor() {
      }
      /**
       * Get singleton instance
       */
      static getInstance() {
        if (!_PlatformDetector.instance) {
          _PlatformDetector.instance = new _PlatformDetector();
        }
        return _PlatformDetector.instance;
      }
      /**
       * Detect current platform type
       */
      detectPlatform() {
        if (typeof process !== "undefined" && process.versions && process.versions.node && typeof window === "undefined") {
          return "node";
        }
        if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
          return "react-native";
        }
        if (typeof window !== "undefined" && typeof document !== "undefined") {
          return "web";
        }
        return "unknown";
      }
      /**
       * Get comprehensive environment information
       */
      getEnvironmentInfo() {
        if (this.cachedInfo) {
          return this.cachedInfo;
        }
        const platform = this.detectPlatform();
        this.cachedInfo = {
          ...this.detectCapabilities(platform),
          ...this.detectDeviceInfo(platform),
          ...this.detectNetworkInfo(),
          ...this.detectLocaleInfo()
        };
        return this.cachedInfo;
      }
      /**
       * Detect storage and API capabilities
       */
      detectCapabilities(platform) {
        const baseCapabilities = {
          platform,
          hasIndexedDB: false,
          hasLocalStorage: false,
          hasAsyncStorage: false,
          hasFileSystem: false,
          hasWebCrypto: false,
          hasCompressionStreams: false,
          supportsWorkers: false,
          supportsNotifications: false,
          isSecureContext: false,
          maxStorageSize: 0
        };
        switch (platform) {
          case "web":
            return {
              ...baseCapabilities,
              hasIndexedDB: this.checkIndexedDBSupport(),
              hasLocalStorage: this.checkLocalStorageSupport(),
              hasWebCrypto: this.checkWebCryptoSupport(),
              hasCompressionStreams: this.checkCompressionStreamsSupport(),
              supportsWorkers: this.checkWebWorkersSupport(),
              supportsNotifications: this.checkNotificationSupport(),
              isSecureContext: this.checkSecureContext(),
              maxStorageSize: this.estimateWebStorageQuota()
            };
          case "react-native":
            return {
              ...baseCapabilities,
              hasAsyncStorage: this.checkAsyncStorageSupport(),
              hasFileSystem: this.checkFileSystemSupport(),
              hasWebCrypto: this.checkWebCryptoSupport(),
              supportsNotifications: this.checkNotificationSupport(),
              isSecureContext: true,
              // React Native is always secure
              maxStorageSize: 0
              // Unlimited for mobile
            };
          case "node":
            return {
              ...baseCapabilities,
              hasFileSystem: true,
              hasWebCrypto: this.checkNodeCryptoSupport(),
              hasCompressionStreams: this.checkNodeCompressionSupport(),
              supportsWorkers: this.checkWorkerThreadsSupport(),
              isSecureContext: true,
              maxStorageSize: 0
              // Unlimited for server
            };
          default:
            return baseCapabilities;
        }
      }
      /**
       * Detect device and browser information
       */
      detectDeviceInfo(platform) {
        const info = {
          deviceType: "unknown"
        };
        if (platform === "node") {
          info.nodeVersion = process.version;
          info.osName = process.platform;
          info.deviceType = "server";
        } else if (platform === "react-native") {
          info.reactNativeVersion = this.getReactNativeVersion();
          info.deviceType = this.detectMobileDeviceType();
          info.osName = this.getReactNativeOS();
        } else if (platform === "web") {
          info.userAgent = navigator.userAgent;
          const browserInfo = this.parseBrowserInfo(navigator.userAgent);
          info.browserName = browserInfo.name;
          info.browserVersion = browserInfo.version;
          info.osName = this.parseOSInfo(navigator.userAgent);
          info.deviceType = this.detectWebDeviceType();
        }
        return info;
      }
      /**
       * Detect network information
       */
      detectNetworkInfo() {
        let isOnline = true;
        let connectionType = "unknown";
        if (typeof navigator !== "undefined") {
          isOnline = navigator.onLine;
          const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
          if (connection) {
            const effectiveType = connection.effectiveType;
            if (effectiveType === "slow-2g" || effectiveType === "2g" || effectiveType === "3g" || effectiveType === "4g") {
              connectionType = "cellular";
            } else {
              connectionType = "wifi";
            }
          }
        }
        return { isOnline, connectionType };
      }
      /**
       * Detect locale information
       */
      detectLocaleInfo() {
        let language = "en-US";
        let timezone = "UTC";
        if (typeof navigator !== "undefined") {
          language = navigator.language || "en-US";
        }
        if (typeof Intl !== "undefined") {
          timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        }
        return { language, timezone };
      }
      // Capability detection methods
      checkIndexedDBSupport() {
        try {
          return typeof window !== "undefined" && "indexedDB" in window && window.indexedDB !== null;
        } catch {
          return false;
        }
      }
      checkLocalStorageSupport() {
        try {
          if (typeof window === "undefined" || !window.localStorage) {
            return false;
          }
          const testKey = "__localStorage_test__";
          window.localStorage.setItem(testKey, "test");
          window.localStorage.removeItem(testKey);
          return true;
        } catch {
          return false;
        }
      }
      checkAsyncStorageSupport() {
        try {
          return typeof __require !== "undefined" && __require("@react-native-async-storage/async-storage") !== null;
        } catch {
          return false;
        }
      }
      checkFileSystemSupport() {
        try {
          return typeof __require !== "undefined" && (__require("fs") !== null || __require("react-native-fs") !== null);
        } catch {
          return false;
        }
      }
      checkWebCryptoSupport() {
        try {
          if (typeof crypto !== "undefined" && crypto.subtle) {
            return true;
          }
          if (typeof __require !== "undefined") {
            const nodeCrypto = __require("crypto");
            return nodeCrypto && nodeCrypto.webcrypto;
          }
          return false;
        } catch {
          return false;
        }
      }
      checkCompressionStreamsSupport() {
        try {
          return typeof CompressionStream !== "undefined" && typeof DecompressionStream !== "undefined";
        } catch {
          return false;
        }
      }
      checkNodeCompressionSupport() {
        try {
          return typeof __require !== "undefined" && __require("zlib") !== null;
        } catch {
          return false;
        }
      }
      checkWebWorkersSupport() {
        try {
          return typeof Worker !== "undefined";
        } catch {
          return false;
        }
      }
      checkWorkerThreadsSupport() {
        try {
          return typeof __require !== "undefined" && __require("worker_threads") !== null;
        } catch {
          return false;
        }
      }
      checkNotificationSupport() {
        try {
          return typeof Notification !== "undefined" || typeof __require !== "undefined" && __require("react-native-push-notification") !== null;
        } catch {
          return false;
        }
      }
      checkSecureContext() {
        if (typeof window !== "undefined") {
          return window.isSecureContext || location.protocol === "https:";
        }
        return true;
      }
      checkNodeCryptoSupport() {
        try {
          const crypto2 = __require("crypto");
          return crypto2 && (crypto2.webcrypto || crypto2.subtle);
        } catch {
          return false;
        }
      }
      estimateWebStorageQuota() {
        if (typeof navigator !== "undefined" && "storage" in navigator && "estimate" in navigator.storage) {
          navigator.storage.estimate().then((estimate) => {
            return estimate.quota || 0;
          });
        }
        const userAgent = navigator?.userAgent || "";
        if (userAgent.includes("Chrome")) {
          return 1024 * 1024 * 1024;
        } else if (userAgent.includes("Firefox")) {
          return 2 * 1024 * 1024 * 1024;
        } else if (userAgent.includes("Safari")) {
          return 1024 * 1024 * 1024;
        }
        return 50 * 1024 * 1024;
      }
      getReactNativeVersion() {
        try {
          const Platform = __require("react-native").Platform;
          return Platform.constants?.reactNativeVersion?.string || "unknown";
        } catch {
          return "unknown";
        }
      }
      getReactNativeOS() {
        try {
          const Platform = __require("react-native").Platform;
          return Platform.OS;
        } catch {
          return "unknown";
        }
      }
      detectMobileDeviceType() {
        try {
          const Dimensions = __require("react-native").Dimensions;
          const { width, height } = Dimensions.get("window");
          const aspectRatio = Math.max(width, height) / Math.min(width, height);
          return aspectRatio < 1.6 ? "tablet" : "mobile";
        } catch {
          return "mobile";
        }
      }
      detectWebDeviceType() {
        if (typeof window === "undefined") return "desktop";
        const userAgent = navigator.userAgent;
        if (/iPad|Android(?!.*Mobile)/i.test(userAgent)) {
          return "tablet";
        } else if (/iPhone|iPod|Android.*Mobile|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
          return "mobile";
        } else {
          return "desktop";
        }
      }
      parseBrowserInfo(userAgent) {
        const browsers = [
          { name: "Chrome", regex: /Chrome\/(\d+\.\d+)/ },
          { name: "Firefox", regex: /Firefox\/(\d+\.\d+)/ },
          { name: "Safari", regex: /Safari\/(\d+\.\d+)/ },
          { name: "Edge", regex: /Edge\/(\d+\.\d+)/ },
          { name: "Opera", regex: /Opera\/(\d+\.\d+)/ }
        ];
        for (const browser of browsers) {
          const match = userAgent.match(browser.regex);
          if (match) {
            return { name: browser.name, version: match[1] || "0.0" };
          }
        }
        return { name: "Unknown", version: "0.0" };
      }
      parseOSInfo(userAgent) {
        if (userAgent.includes("Windows")) return "Windows";
        if (userAgent.includes("Mac OS")) return "macOS";
        if (userAgent.includes("Linux")) return "Linux";
        if (userAgent.includes("Android")) return "Android";
        if (userAgent.includes("iOS")) return "iOS";
        return "Unknown";
      }
      /**
       * Clear cached information (useful for testing)
       */
      clearCache() {
        this.cachedInfo = null;
      }
      /**
       * Check if specific capability is available
       */
      hasCapability(capability) {
        const info = this.getEnvironmentInfo();
        return info[capability];
      }
      /**
       * Get optimal storage adapter for current platform
       */
      getRecommendedStorageAdapter() {
        const capabilities = this.getEnvironmentInfo();
        if (capabilities.hasIndexedDB) {
          return "indexeddb";
        } else if (capabilities.hasAsyncStorage) {
          return "asyncstorage";
        } else if (capabilities.hasLocalStorage) {
          return "localstorage";
        } else if (capabilities.hasFileSystem) {
          return "filesystem";
        } else {
          return "memory";
        }
      }
      /**
       * Get performance tier based on platform capabilities
       */
      getPerformanceTier() {
        const info = this.getEnvironmentInfo();
        if (info.platform === "node" || info.platform === "web" && info.deviceType === "desktop") {
          return "high";
        } else if (info.platform === "react-native" && info.deviceType === "tablet") {
          return "medium";
        } else {
          return "low";
        }
      }
    };
    platformDetector = PlatformDetector.getInstance();
    getPlatform = () => platformDetector.detectPlatform();
    getEnvironmentInfo = () => platformDetector.getEnvironmentInfo();
    hasCapability = (capability) => platformDetector.hasCapability(capability);
    getRecommendedStorageAdapter = () => platformDetector.getRecommendedStorageAdapter();
    getPerformanceTier = () => platformDetector.getPerformanceTier();
  }
});

// src/storage/adapters/indexeddb-adapter.ts
var IndexedDBTransaction, IndexedDBAdapter;
var init_indexeddb_adapter = __esm({
  "src/storage/adapters/indexeddb-adapter.ts"() {
    "use strict";
    init_esm_shims();
    init_unified_storage();
    IndexedDBTransaction = class {
      constructor(adapter, idbTransaction) {
        this.adapter = adapter;
        this.idbTransaction = idbTransaction;
        this.id = `txn_${Date.now()}_${Math.random().toString(36).substring(2)}`;
        this.idbTransaction.addEventListener("abort", () => {
          this.isActive = false;
        });
        this.idbTransaction.addEventListener("complete", () => {
          this.isActive = false;
        });
        this.idbTransaction.addEventListener("error", () => {
          this.isActive = false;
        });
      }
      id;
      isActive = true;
      operations = [];
      rollbackOperations = [];
      async set(key, value, options) {
        if (!this.isActive) {
          throw new StorageTransactionError(this.id, "set", new Error("Transaction not active"));
        }
        const operation = async () => {
          await this.adapter.setWithTransaction(key, value, options, this.idbTransaction);
        };
        const rollback = async () => {
          await this.adapter.deleteWithTransaction(key, this.idbTransaction);
        };
        this.operations.push(operation);
        this.rollbackOperations.unshift(rollback);
      }
      async get(key) {
        if (!this.isActive) {
          throw new StorageTransactionError(this.id, "get", new Error("Transaction not active"));
        }
        return this.adapter.getWithTransaction(key, this.idbTransaction);
      }
      async delete(key) {
        if (!this.isActive) {
          throw new StorageTransactionError(this.id, "delete", new Error("Transaction not active"));
        }
        const originalValue = await this.get(key);
        const operation = async () => {
          await this.adapter.deleteWithTransaction(key, this.idbTransaction);
        };
        const rollback = async () => {
          if (originalValue) {
            await this.adapter.setWithTransaction(key, originalValue.data, void 0, this.idbTransaction);
          }
        };
        this.operations.push(operation);
        this.rollbackOperations.unshift(rollback);
        return true;
      }
      async commit() {
        if (!this.isActive) {
          throw new StorageTransactionError(this.id, "commit", new Error("Transaction not active"));
        }
        try {
          for (const operation of this.operations) {
            await operation();
          }
          this.isActive = false;
        } catch (error) {
          await this.rollback();
          throw new StorageTransactionError(this.id, "commit", error);
        }
      }
      async rollback() {
        if (!this.isActive) {
          return;
        }
        try {
          for (const rollback of this.rollbackOperations) {
            await rollback();
          }
        } catch (error) {
          console.warn(`Failed to rollback transaction ${this.id}:`, error);
        } finally {
          this.idbTransaction.abort();
          this.isActive = false;
        }
      }
    };
    IndexedDBAdapter = class {
      name = "IndexedDB";
      db = null;
      config;
      connectionPromise = null;
      capabilities = {
        supportsTransactions: true,
        supportsIndexing: true,
        maxKeyLength: 1024,
        maxValueSize: 256 * 1024 * 1024,
        // 256MB
        supportsCompression: true,
        supportsEncryption: true,
        supportsTTL: true
      };
      constructor(config = {}) {
        this.config = {
          databaseName: config.databaseName || "acube-sdk-storage",
          version: config.version || 1,
          schema: config.schema || this.getDefaultSchema(),
          migrations: config.migrations || [],
          timeout: config.timeout || 3e4,
          maxRetries: config.maxRetries || 3
        };
      }
      get isAvailable() {
        return typeof indexedDB !== "undefined" && indexedDB !== null;
      }
      isConnected() {
        return this.db !== null && this.db.objectStoreNames.length > 0;
      }
      async connect() {
        if (this.db) {
          return;
        }
        if (this.connectionPromise) {
          await this.connectionPromise;
          return;
        }
        this.connectionPromise = this.establishConnection();
        try {
          this.db = await this.connectionPromise;
        } finally {
          this.connectionPromise = null;
        }
      }
      async establishConnection() {
        if (!this.isAvailable) {
          throw new StorageConnectionError("IndexedDB not available");
        }
        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new StorageConnectionError("IndexedDB connection timeout"));
          }, this.config.timeout);
          const request = indexedDB.open(this.config.databaseName, this.config.version);
          request.onerror = () => {
            clearTimeout(timeout);
            reject(new StorageConnectionError("IndexedDB", request.error || void 0));
          };
          request.onsuccess = () => {
            clearTimeout(timeout);
            resolve(request.result);
          };
          request.onupgradeneeded = (event) => {
            const db = request.result;
            this.handleUpgrade(db, event.oldVersion, event.newVersion || this.config.version);
          };
          request.onblocked = () => {
            console.warn("IndexedDB upgrade blocked. Close other tabs using this database.");
          };
        });
      }
      handleUpgrade(db, oldVersion, newVersion) {
        for (const [storeName, storeConfig] of Object.entries(this.config.schema.stores)) {
          if (!db.objectStoreNames.contains(storeName)) {
            const store = db.createObjectStore(storeName, {
              ...storeConfig.keyPath && { keyPath: storeConfig.keyPath },
              ...storeConfig.autoIncrement && { autoIncrement: storeConfig.autoIncrement }
            });
            if (storeConfig.indexes) {
              for (const [indexName, indexConfig] of Object.entries(storeConfig.indexes)) {
                store.createIndex(indexName, indexConfig.keyPath, {
                  ...indexConfig.unique !== void 0 && { unique: indexConfig.unique },
                  ...indexConfig.multiEntry !== void 0 && { multiEntry: indexConfig.multiEntry }
                });
              }
            }
          }
        }
        const relevantMigrations = this.config.migrations.filter(
          (migration) => migration.version > oldVersion && migration.version <= newVersion
        );
        for (const migration of relevantMigrations.sort((a, b) => a.version - b.version)) {
          try {
            migration.up(db, db.transaction(Array.from(db.objectStoreNames), "readwrite"));
          } catch (error) {
            console.error(`Migration ${migration.version} failed:`, error);
            throw error;
          }
        }
      }
      getDefaultSchema() {
        return {
          version: 1,
          stores: {
            storage: {
              keyPath: "key",
              indexes: {
                namespace: { keyPath: "namespace" },
                createdAt: { keyPath: "createdAt" },
                expiresAt: { keyPath: "expiresAt" }
              }
            }
          }
        };
      }
      async disconnect() {
        if (this.db) {
          this.db.close();
          this.db = null;
        }
      }
      async set(key, value, options) {
        await this.connect();
        const mergedOptions = { ...DEFAULT_STORAGE_OPTIONS, ...options };
        const entry = this.createStorageEntry(key, value, mergedOptions);
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(["storage"], "readwrite");
          const store = transaction.objectStore("storage");
          const request = store.put({
            key,
            ...entry,
            namespace: mergedOptions.namespace
          });
          request.onsuccess = () => resolve();
          request.onerror = () => reject(new StorageError(
            `Failed to set key: ${key}`,
            "STORAGE_SET_ERROR",
            "set",
            key,
            request.error || void 0
          ));
        });
      }
      async setWithTransaction(key, value, options = {}, transaction) {
        const mergedOptions = { ...DEFAULT_STORAGE_OPTIONS, ...options };
        const entry = this.createStorageEntry(key, value, mergedOptions);
        return new Promise((resolve, reject) => {
          const store = transaction.objectStore("storage");
          const request = store.put({
            key,
            ...entry,
            namespace: mergedOptions.namespace
          });
          request.onsuccess = () => resolve();
          request.onerror = () => reject(new StorageError(
            `Failed to set key in transaction: ${key}`,
            "STORAGE_TRANSACTION_SET_ERROR",
            "set",
            key,
            request.error || void 0
          ));
        });
      }
      async get(key) {
        await this.connect();
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(["storage"], "readonly");
          const store = transaction.objectStore("storage");
          const request = store.get(key);
          request.onsuccess = () => {
            const result = request.result;
            if (!result) {
              resolve(null);
              return;
            }
            if (result.metadata.expiresAt && result.metadata.expiresAt < Date.now()) {
              this.delete(key).catch(console.warn);
              resolve(null);
              return;
            }
            resolve(result);
          };
          request.onerror = () => reject(new StorageError(
            `Failed to get key: ${key}`,
            "STORAGE_GET_ERROR",
            "get",
            key,
            request.error || void 0
          ));
        });
      }
      async getWithTransaction(key, transaction) {
        return new Promise((resolve, reject) => {
          const store = transaction.objectStore("storage");
          const request = store.get(key);
          request.onsuccess = () => {
            const result = request.result;
            if (!result) {
              resolve(null);
              return;
            }
            if (result.metadata.expiresAt && result.metadata.expiresAt < Date.now()) {
              resolve(null);
              return;
            }
            resolve(result);
          };
          request.onerror = () => reject(new StorageError(
            `Failed to get key in transaction: ${key}`,
            "STORAGE_TRANSACTION_GET_ERROR",
            "get",
            key,
            request.error || void 0
          ));
        });
      }
      async delete(key) {
        await this.connect();
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(["storage"], "readwrite");
          const store = transaction.objectStore("storage");
          const request = store.delete(key);
          request.onsuccess = () => resolve(true);
          request.onerror = () => reject(new StorageError(
            `Failed to delete key: ${key}`,
            "STORAGE_DELETE_ERROR",
            "delete",
            key,
            request.error || void 0
          ));
        });
      }
      async deleteWithTransaction(key, transaction) {
        return new Promise((resolve, reject) => {
          const store = transaction.objectStore("storage");
          const request = store.delete(key);
          request.onsuccess = () => resolve(true);
          request.onerror = () => reject(new StorageError(
            `Failed to delete key in transaction: ${key}`,
            "STORAGE_TRANSACTION_DELETE_ERROR",
            "delete",
            key,
            request.error || void 0
          ));
        });
      }
      async exists(key) {
        const entry = await this.get(key);
        return entry !== null;
      }
      async clear(namespace) {
        await this.connect();
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(["storage"], "readwrite");
          const store = transaction.objectStore("storage");
          if (namespace) {
            const index = store.index("namespace");
            const request = index.openCursor(IDBKeyRange.only(namespace));
            request.onsuccess = (event) => {
              const cursor = event.target.result;
              if (cursor) {
                cursor.delete();
                cursor.continue();
              } else {
                resolve();
              }
            };
            request.onerror = () => reject(new StorageError(
              `Failed to clear namespace: ${namespace}`,
              "STORAGE_CLEAR_ERROR",
              "clear",
              void 0,
              request.error || void 0
            ));
          } else {
            const request = store.clear();
            request.onsuccess = () => resolve();
            request.onerror = () => reject(new StorageError(
              "Failed to clear storage",
              "STORAGE_CLEAR_ERROR",
              "clear",
              void 0,
              request.error || void 0
            ));
          }
        });
      }
      async setMany(entries) {
        await this.connect();
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(["storage"], "readwrite");
          const store = transaction.objectStore("storage");
          let completed = 0;
          for (const entry of entries) {
            const mergedOptions = { ...DEFAULT_STORAGE_OPTIONS, ...entry.options };
            const storageEntry = this.createStorageEntry(entry.key, entry.value, mergedOptions);
            const request = store.put({
              key: entry.key,
              ...storageEntry,
              namespace: mergedOptions.namespace
            });
            request.onsuccess = () => {
              completed++;
              if (completed === entries.length) {
                resolve();
              }
            };
            request.onerror = () => reject(new StorageError(
              `Failed to set key in batch: ${entry.key}`,
              "STORAGE_BATCH_SET_ERROR",
              "setMany",
              entry.key,
              request.error || void 0
            ));
          }
        });
      }
      async getMany(keys) {
        await this.connect();
        const results = [];
        for (const key of keys) {
          results.push(await this.get(key));
        }
        return results;
      }
      async deleteMany(keys) {
        await this.connect();
        let deletedCount = 0;
        for (const key of keys) {
          const deleted = await this.delete(key);
          if (deleted) deletedCount++;
        }
        return deletedCount;
      }
      async keys(options = {}) {
        await this.connect();
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(["storage"], "readonly");
          const store = transaction.objectStore("storage");
          const keys = [];
          const request = store.openCursor();
          request.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
              const entry = cursor.value;
              if (this.matchesQuery(entry, options)) {
                keys.push(entry.key);
              }
              cursor.continue();
            } else {
              resolve(this.applySortingAndPaging(keys, options));
            }
          };
          request.onerror = () => reject(new StorageError(
            "Failed to get keys",
            "STORAGE_KEYS_ERROR",
            "keys",
            void 0,
            request.error || void 0
          ));
        });
      }
      async values(options = {}) {
        await this.connect();
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(["storage"], "readonly");
          const store = transaction.objectStore("storage");
          const values = [];
          const request = store.openCursor();
          request.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
              const entry = cursor.value;
              if (this.matchesQuery(entry, options)) {
                values.push(entry);
              }
              cursor.continue();
            } else {
              resolve(this.applySortingAndPaging(values, options));
            }
          };
          request.onerror = () => reject(new StorageError(
            "Failed to get values",
            "STORAGE_VALUES_ERROR",
            "values",
            void 0,
            request.error || void 0
          ));
        });
      }
      async entries(options = {}) {
        return this.values(options);
      }
      async count(options = {}) {
        await this.connect();
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(["storage"], "readonly");
          const store = transaction.objectStore("storage");
          let count = 0;
          const request = store.openCursor();
          request.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
              const entry = cursor.value;
              if (this.matchesQuery(entry, options)) {
                count++;
              }
              cursor.continue();
            } else {
              resolve(count);
            }
          };
          request.onerror = () => reject(new StorageError(
            "Failed to count entries",
            "STORAGE_COUNT_ERROR",
            "count",
            void 0,
            request.error || void 0
          ));
        });
      }
      async beginTransaction() {
        await this.connect();
        const idbTransaction = this.db.transaction(["storage"], "readwrite");
        return new IndexedDBTransaction(this, idbTransaction);
      }
      async cleanup() {
        await this.connect();
        const now = Date.now();
        let cleanedCount = 0;
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(["storage"], "readwrite");
          const store = transaction.objectStore("storage");
          const request = store.openCursor();
          request.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
              const entry = cursor.value;
              if (entry.metadata.expiresAt && entry.metadata.expiresAt < now) {
                cursor.delete();
                cleanedCount++;
              }
              cursor.continue();
            } else {
              resolve(cleanedCount);
            }
          };
          request.onerror = () => reject(new StorageError(
            "Failed to cleanup expired entries",
            "STORAGE_CLEANUP_ERROR",
            "cleanup",
            void 0,
            request.error || void 0
          ));
        });
      }
      async optimize() {
        await this.cleanup();
      }
      async getStats() {
        await this.connect();
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(["storage"], "readonly");
          const store = transaction.objectStore("storage");
          const request = store.openCursor();
          const stats = {
            totalKeys: 0,
            totalSize: 0,
            namespaces: [],
            oldestEntry: Date.now(),
            newestEntry: 0,
            expiredEntries: 0,
            encryptedEntries: 0,
            compressedEntries: 0
          };
          const namespaceSet = /* @__PURE__ */ new Set();
          request.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
              const entry = cursor.value;
              stats.totalKeys++;
              stats.totalSize += this.estimateEntrySize(entry);
              namespaceSet.add(entry.namespace);
              if (entry.metadata.createdAt < stats.oldestEntry) {
                stats.oldestEntry = entry.metadata.createdAt;
              }
              if (entry.metadata.createdAt > stats.newestEntry) {
                stats.newestEntry = entry.metadata.createdAt;
              }
              if (entry.metadata.expiresAt && entry.metadata.expiresAt < Date.now()) {
                stats.expiredEntries++;
              }
              if (entry.metadata.encrypted) {
                stats.encryptedEntries++;
              }
              if (entry.metadata.compressed) {
                stats.compressedEntries++;
              }
              cursor.continue();
            } else {
              stats.namespaces = Array.from(namespaceSet);
              resolve(stats);
            }
          };
          request.onerror = () => reject(new StorageError(
            "Failed to get storage stats",
            "STORAGE_STATS_ERROR",
            "getStats",
            void 0,
            request.error || void 0
          ));
        });
      }
      createStorageEntry(key, value, options) {
        const now = Date.now();
        return {
          data: value,
          metadata: {
            key,
            createdAt: now,
            updatedAt: now,
            ...options.ttl > 0 && { expiresAt: now + options.ttl },
            encrypted: options.encrypt,
            compressed: options.compress,
            version: options.version
          }
        };
      }
      matchesQuery(entry, options) {
        const now = Date.now();
        if (!options.includeExpired && entry.metadata.expiresAt && entry.metadata.expiresAt < now) {
          return false;
        }
        if (options.namespace && entry.namespace !== options.namespace) {
          return false;
        }
        if (options.prefix && !entry.key.startsWith(options.prefix)) {
          return false;
        }
        return true;
      }
      applySortingAndPaging(items, options) {
        let result = [...items];
        if (options.sortBy) {
          result.sort((a, b) => {
            const sortBy = options.sortBy;
            if (!sortBy) return 0;
            const aVal = sortBy === "key" ? a.key || a : a.metadata?.[sortBy] || 0;
            const bVal = sortBy === "key" ? b.key || b : b.metadata?.[sortBy] || 0;
            const comparison = aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
            return options.sortOrder === "desc" ? -comparison : comparison;
          });
        }
        const offset = options.offset || 0;
        const limit = options.limit;
        if (limit) {
          result = result.slice(offset, offset + limit);
        } else if (offset) {
          result = result.slice(offset);
        }
        return result;
      }
      estimateEntrySize(entry) {
        const jsonString = JSON.stringify(entry);
        return new Blob([jsonString]).size;
      }
    };
  }
});

// src/storage/adapters/localstorage-adapter.ts
var LocalStorageTransactionImpl, LocalStorageAdapter;
var init_localstorage_adapter = __esm({
  "src/storage/adapters/localstorage-adapter.ts"() {
    "use strict";
    init_esm_shims();
    init_unified_storage();
    LocalStorageTransactionImpl = class {
      constructor(adapter) {
        this.adapter = adapter;
        this.id = `txn_${Date.now()}_${Math.random().toString(36).substring(2)}`;
      }
      id;
      isActive = true;
      pendingOperations = /* @__PURE__ */ new Map();
      originalValues = /* @__PURE__ */ new Map();
      async set(key, value, options) {
        if (!this.isActive) {
          throw new StorageTransactionError(this.id, "set", new Error("Transaction not active"));
        }
        if (!this.originalValues.has(key)) {
          try {
            const originalValue = localStorage.getItem(this.adapter.getStorageKey(key));
            this.originalValues.set(key, originalValue);
          } catch {
            this.originalValues.set(key, null);
          }
        }
        this.pendingOperations.set(key, { action: "set", value, ...options && { options } });
      }
      async get(key) {
        if (!this.isActive) {
          throw new StorageTransactionError(this.id, "get", new Error("Transaction not active"));
        }
        const pending = this.pendingOperations.get(key);
        if (pending) {
          if (pending.action === "delete") {
            return null;
          } else if (pending.action === "set") {
            const mergedOptions = { ...DEFAULT_STORAGE_OPTIONS, ...pending.options };
            return this.adapter.createStorageEntry(key, pending.value, mergedOptions);
          }
        }
        return this.adapter.get(key);
      }
      async delete(key) {
        if (!this.isActive) {
          throw new StorageTransactionError(this.id, "delete", new Error("Transaction not active"));
        }
        if (!this.originalValues.has(key)) {
          try {
            const originalValue = localStorage.getItem(this.adapter.getStorageKey(key));
            this.originalValues.set(key, originalValue);
          } catch {
            this.originalValues.set(key, null);
          }
        }
        this.pendingOperations.set(key, { action: "delete" });
        return true;
      }
      async commit() {
        if (!this.isActive) {
          throw new StorageTransactionError(this.id, "commit", new Error("Transaction not active"));
        }
        try {
          for (const [key, operation] of this.pendingOperations) {
            if (operation.action === "set") {
              await this.adapter.set(key, operation.value, operation.options);
            } else if (operation.action === "delete") {
              await this.adapter.delete(key);
            }
          }
          this.isActive = false;
        } catch (error) {
          await this.rollback();
          throw new StorageTransactionError(this.id, "commit", error);
        }
      }
      async rollback() {
        if (!this.isActive) {
          return;
        }
        try {
          for (const [key, originalValue] of this.originalValues) {
            const storageKey = this.adapter.getStorageKey(key);
            if (originalValue === null) {
              localStorage.removeItem(storageKey);
            } else {
              localStorage.setItem(storageKey, originalValue);
            }
          }
        } catch (error) {
          console.warn(`Failed to rollback transaction ${this.id}:`, error);
        } finally {
          this.isActive = false;
        }
      }
    };
    LocalStorageAdapter = class {
      name = "LocalStorage";
      keyPrefix;
      capabilities = {
        supportsTransactions: true,
        // Simulated transactions
        supportsIndexing: false,
        maxKeyLength: 256,
        maxValueSize: 5 * 1024 * 1024,
        // 5MB typical localStorage limit
        supportsCompression: true,
        supportsEncryption: true,
        supportsTTL: true
      };
      constructor(keyPrefix = "acube_sdk_") {
        this.keyPrefix = keyPrefix;
      }
      get isAvailable() {
        try {
          if (typeof Storage === "undefined" || typeof localStorage === "undefined") {
            return false;
          }
          const testKey = "__localStorage_test__";
          localStorage.setItem(testKey, "test");
          localStorage.removeItem(testKey);
          return true;
        } catch {
          return false;
        }
      }
      isConnected() {
        return this.isAvailable;
      }
      async connect() {
        if (!this.isAvailable) {
          throw new StorageConnectionError("LocalStorage not available");
        }
      }
      async disconnect() {
      }
      getStorageKey(key) {
        return `${this.keyPrefix}${key}`;
      }
      createStorageEntry(key, value, options) {
        const now = Date.now();
        return {
          data: value,
          metadata: {
            key,
            createdAt: now,
            updatedAt: now,
            ...options.ttl > 0 && { expiresAt: now + options.ttl },
            encrypted: options.encrypt,
            compressed: options.compress,
            version: options.version
          }
        };
      }
      async set(key, value, options) {
        await this.connect();
        const mergedOptions = { ...DEFAULT_STORAGE_OPTIONS, ...options };
        const entry = this.createStorageEntry(key, value, mergedOptions);
        const storageKey = this.getStorageKey(key);
        let serialized = "";
        try {
          serialized = JSON.stringify(entry);
          if (serialized.length > this.capabilities.maxValueSize) {
            throw new StorageCapacityError(key, serialized.length, this.capabilities.maxValueSize);
          }
          localStorage.setItem(storageKey, serialized);
        } catch (error) {
          if (error instanceof StorageCapacityError) {
            throw error;
          }
          if (error instanceof DOMException && (error.code === 22 || // QUOTA_EXCEEDED_ERR
          error.code === 1014 || // NS_ERROR_DOM_QUOTA_REACHED
          error.name === "QuotaExceededError")) {
            const size = serialized ? serialized.length : 0;
            throw new StorageCapacityError(key, size, this.getAvailableSpace());
          }
          throw new StorageError(
            `Failed to set key: ${key}`,
            "STORAGE_SET_ERROR",
            "set",
            key,
            error
          );
        }
      }
      async get(key) {
        await this.connect();
        const storageKey = this.getStorageKey(key);
        try {
          const serialized = localStorage.getItem(storageKey);
          if (!serialized) {
            return null;
          }
          const entry = JSON.parse(serialized);
          if (entry.metadata.expiresAt && entry.metadata.expiresAt < Date.now()) {
            this.delete(key).catch(console.warn);
            return null;
          }
          return entry;
        } catch (error) {
          throw new StorageError(
            `Failed to get key: ${key}`,
            "STORAGE_GET_ERROR",
            "get",
            key,
            error
          );
        }
      }
      async delete(key) {
        await this.connect();
        const storageKey = this.getStorageKey(key);
        try {
          const existed = localStorage.getItem(storageKey) !== null;
          localStorage.removeItem(storageKey);
          return existed;
        } catch (error) {
          throw new StorageError(
            `Failed to delete key: ${key}`,
            "STORAGE_DELETE_ERROR",
            "delete",
            key,
            error
          );
        }
      }
      async exists(key) {
        await this.connect();
        const storageKey = this.getStorageKey(key);
        return localStorage.getItem(storageKey) !== null;
      }
      async clear(namespace) {
        await this.connect();
        try {
          if (namespace) {
            const namespacePrefix = `${this.keyPrefix}${namespace}:`;
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith(namespacePrefix)) {
                keysToRemove.push(key);
              }
            }
            for (const key of keysToRemove) {
              localStorage.removeItem(key);
            }
          } else {
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith(this.keyPrefix)) {
                keysToRemove.push(key);
              }
            }
            for (const key of keysToRemove) {
              localStorage.removeItem(key);
            }
          }
        } catch (error) {
          throw new StorageError(
            `Failed to clear storage${namespace ? ` for namespace: ${namespace}` : ""}`,
            "STORAGE_CLEAR_ERROR",
            "clear",
            void 0,
            error
          );
        }
      }
      async setMany(entries) {
        for (const entry of entries) {
          await this.set(entry.key, entry.value, entry.options);
        }
      }
      async getMany(keys) {
        const results = [];
        for (const key of keys) {
          results.push(await this.get(key));
        }
        return results;
      }
      async deleteMany(keys) {
        let deletedCount = 0;
        for (const key of keys) {
          const deleted = await this.delete(key);
          if (deleted) deletedCount++;
        }
        return deletedCount;
      }
      async keys(options = {}) {
        await this.connect();
        const keys = [];
        const now = Date.now();
        for (let i = 0; i < localStorage.length; i++) {
          const storageKey = localStorage.key(i);
          if (!storageKey || !storageKey.startsWith(this.keyPrefix)) {
            continue;
          }
          try {
            const originalKey = storageKey.substring(this.keyPrefix.length);
            const entry = await this.get(originalKey);
            if (entry && this.matchesQuery(entry, options, now)) {
              keys.push(originalKey);
            }
          } catch {
            continue;
          }
        }
        return this.applySortingAndPaging(keys, options);
      }
      async values(options = {}) {
        await this.connect();
        const values = [];
        const now = Date.now();
        for (let i = 0; i < localStorage.length; i++) {
          const storageKey = localStorage.key(i);
          if (!storageKey || !storageKey.startsWith(this.keyPrefix)) {
            continue;
          }
          try {
            const originalKey = storageKey.substring(this.keyPrefix.length);
            const entry = await this.get(originalKey);
            if (entry && this.matchesQuery(entry, options, now)) {
              values.push(entry);
            }
          } catch {
            continue;
          }
        }
        return this.applySortingAndPaging(values, options);
      }
      async entries(options = {}) {
        return this.values(options);
      }
      async count(options = {}) {
        const keys = await this.keys(options);
        return keys.length;
      }
      async beginTransaction() {
        await this.connect();
        return new LocalStorageTransactionImpl(this);
      }
      async cleanup() {
        await this.connect();
        const now = Date.now();
        let cleanedCount = 0;
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
          const storageKey = localStorage.key(i);
          if (!storageKey || !storageKey.startsWith(this.keyPrefix)) {
            continue;
          }
          try {
            const serialized = localStorage.getItem(storageKey);
            if (serialized) {
              const entry = JSON.parse(serialized);
              if (entry.metadata.expiresAt && entry.metadata.expiresAt < now) {
                keysToRemove.push(storageKey);
                cleanedCount++;
              }
            }
          } catch {
            keysToRemove.push(storageKey);
            cleanedCount++;
          }
        }
        for (const key of keysToRemove) {
          localStorage.removeItem(key);
        }
        return cleanedCount;
      }
      async optimize() {
        await this.cleanup();
      }
      async getStats() {
        await this.connect();
        const stats = {
          totalKeys: 0,
          totalSize: 0,
          namespaces: [],
          oldestEntry: Date.now(),
          newestEntry: 0,
          expiredEntries: 0,
          encryptedEntries: 0,
          compressedEntries: 0
        };
        const namespaceSet = /* @__PURE__ */ new Set();
        const now = Date.now();
        for (let i = 0; i < localStorage.length; i++) {
          const storageKey = localStorage.key(i);
          if (!storageKey || !storageKey.startsWith(this.keyPrefix)) {
            continue;
          }
          try {
            const serialized = localStorage.getItem(storageKey);
            if (serialized) {
              const entry = JSON.parse(serialized);
              stats.totalKeys++;
              stats.totalSize += serialized.length;
              const originalKey = storageKey.substring(this.keyPrefix.length);
              const namespacePart = originalKey.split(":")[0];
              if (namespacePart) {
                namespaceSet.add(namespacePart);
              }
              if (entry.metadata.createdAt < stats.oldestEntry) {
                stats.oldestEntry = entry.metadata.createdAt;
              }
              if (entry.metadata.createdAt > stats.newestEntry) {
                stats.newestEntry = entry.metadata.createdAt;
              }
              if (entry.metadata.expiresAt && entry.metadata.expiresAt < now) {
                stats.expiredEntries++;
              }
              if (entry.metadata.encrypted) {
                stats.encryptedEntries++;
              }
              if (entry.metadata.compressed) {
                stats.compressedEntries++;
              }
            }
          } catch {
            continue;
          }
        }
        stats.namespaces = Array.from(namespaceSet);
        return stats;
      }
      matchesQuery(entry, options, now) {
        if (!options.includeExpired && entry.metadata.expiresAt && entry.metadata.expiresAt < now) {
          return false;
        }
        const key = entry.metadata.key;
        const namespacePart = key.split(":")[0];
        if (options.namespace && namespacePart !== options.namespace) {
          return false;
        }
        if (options.prefix && !key.startsWith(options.prefix)) {
          return false;
        }
        return true;
      }
      applySortingAndPaging(items, options) {
        let result = [...items];
        if (options.sortBy) {
          result.sort((a, b) => {
            const sortBy = options.sortBy;
            if (!sortBy) return 0;
            const aVal = sortBy === "key" ? a.key || a : a.metadata?.[sortBy] || 0;
            const bVal = sortBy === "key" ? b.key || b : b.metadata?.[sortBy] || 0;
            const comparison = aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
            return options.sortOrder === "desc" ? -comparison : comparison;
          });
        }
        const offset = options.offset || 0;
        const limit = options.limit;
        if (limit) {
          result = result.slice(offset, offset + limit);
        } else if (offset) {
          result = result.slice(offset);
        }
        return result;
      }
      getAvailableSpace() {
        try {
          let testSize = 1024 * 1024;
          const testKey = "__space_test__";
          while (testSize > 1024) {
            try {
              const testData = "x".repeat(testSize);
              localStorage.setItem(testKey, testData);
              localStorage.removeItem(testKey);
              return testSize;
            } catch {
              testSize = Math.floor(testSize / 2);
            }
          }
          return testSize;
        } catch {
          return this.capabilities.maxValueSize;
        }
      }
    };
  }
});

// src/security/encryption.ts
var AdvancedEncryption;
var init_encryption = __esm({
  "src/security/encryption.ts"() {
    "use strict";
    init_esm_shims();
    AdvancedEncryption = class {
      keys = /* @__PURE__ */ new Map();
      keyPairs = /* @__PURE__ */ new Map();
      config;
      initialized = false;
      constructor(config) {
        this.config = {
          algorithm: "AES-GCM",
          keyLength: 256,
          keyDerivation: {
            algorithm: "PBKDF2",
            iterations: 1e5,
            salt: crypto.getRandomValues(new Uint8Array(16))
          },
          compression: true,
          metadata: {
            version: "1.0.0",
            timestamp: Date.now(),
            keyId: this.generateKeyId()
          },
          ...config
        };
      }
      /**
       * Generate a new symmetric encryption key
       */
      async generateSymmetricKey(keyId) {
        const id = keyId || this.generateKeyId();
        const key = await crypto.subtle.generateKey(
          {
            name: this.config.algorithm,
            length: this.config.keyLength
          },
          true,
          // extractable
          ["encrypt", "decrypt"]
        );
        this.keys.set(id, key);
        return id;
      }
      /**
       * Generate a new asymmetric key pair
       */
      async generateKeyPair(algorithm = "RSA-OAEP", keyId) {
        const id = keyId || this.generateKeyId();
        let keyGenParams;
        let usages;
        if (algorithm === "RSA-OAEP") {
          keyGenParams = {
            name: "RSA-OAEP",
            modulusLength: this.config.keyLength,
            publicExponent: new Uint8Array([1, 0, 1]),
            hash: "SHA-256"
          };
          usages = ["encrypt", "decrypt"];
        } else {
          keyGenParams = {
            name: "ECDSA",
            namedCurve: "P-256"
          };
          usages = ["sign", "verify"];
        }
        const keyPair = await crypto.subtle.generateKey(
          keyGenParams,
          true,
          // extractable
          usages
        );
        const cryptoKeyPair = {
          publicKey: keyPair.publicKey,
          privateKey: keyPair.privateKey,
          keyId: id,
          algorithm,
          extractable: true,
          usages
        };
        this.keyPairs.set(id, cryptoKeyPair);
        return id;
      }
      /**
       * Derive key from password using PBKDF2
       */
      async deriveKeyFromPassword(password, salt) {
        const keyId = this.generateKeyId();
        const usedSalt = salt || crypto.getRandomValues(new Uint8Array(16));
        const encoder = new TextEncoder();
        const passwordBuffer = encoder.encode(password);
        const keyMaterial = await crypto.subtle.importKey(
          "raw",
          passwordBuffer,
          { name: "PBKDF2" },
          false,
          ["deriveKey"]
        );
        const derivedKey = await crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: usedSalt,
            iterations: this.config.keyDerivation.iterations,
            hash: "SHA-256"
          },
          keyMaterial,
          {
            name: this.config.algorithm,
            length: this.config.keyLength
          },
          true,
          ["encrypt", "decrypt"]
        );
        this.keys.set(keyId, derivedKey);
        this.config.keyDerivation.salt = usedSalt;
        return keyId;
      }
      /**
       * Encrypt data with symmetric key
       */
      async encryptSymmetric(data, keyId) {
        const key = this.keys.get(keyId);
        if (!key) {
          throw new Error(`Encryption key not found: ${keyId}`);
        }
        let dataBuffer;
        if (typeof data === "string") {
          dataBuffer = new TextEncoder().encode(data);
        } else {
          dataBuffer = data;
        }
        if (this.config.compression) {
          dataBuffer = await this.compressData(dataBuffer);
        }
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encryptedBuffer = await crypto.subtle.encrypt(
          {
            name: this.config.algorithm,
            iv
          },
          key,
          dataBuffer
        );
        const encryptedArray = new Uint8Array(encryptedBuffer);
        const authTag = this.config.algorithm === "AES-GCM" ? encryptedArray.slice(-16) : void 0;
        const ciphertext = this.config.algorithm === "AES-GCM" ? encryptedArray.slice(0, -16) : encryptedArray;
        return {
          data: ciphertext,
          iv,
          metadata: {
            ...this.config.metadata,
            keyId
          },
          algorithm: this.config.algorithm,
          ...authTag ? { authTag } : {}
        };
      }
      /**
       * Decrypt data with symmetric key
       */
      async decryptSymmetric(encryptedData) {
        const key = this.keys.get(encryptedData.metadata.keyId);
        if (!key) {
          throw new Error(`Decryption key not found: ${encryptedData.metadata.keyId}`);
        }
        let fullEncryptedBuffer;
        if (encryptedData.algorithm === "AES-GCM" && encryptedData.authTag) {
          fullEncryptedBuffer = new Uint8Array(encryptedData.data.length + encryptedData.authTag.length);
          fullEncryptedBuffer.set(encryptedData.data);
          fullEncryptedBuffer.set(encryptedData.authTag, encryptedData.data.length);
        } else {
          fullEncryptedBuffer = encryptedData.data;
        }
        const decryptedBuffer = await crypto.subtle.decrypt(
          {
            name: encryptedData.algorithm,
            iv: encryptedData.iv
          },
          key,
          fullEncryptedBuffer
        );
        let result = new Uint8Array(decryptedBuffer);
        if (this.config.compression) {
          result = new Uint8Array(await this.decompressData(result));
        }
        return result;
      }
      /**
       * Encrypt data with asymmetric key (RSA-OAEP)
       */
      async encryptAsymmetric(data, keyId) {
        const keyPair = this.keyPairs.get(keyId);
        if (!keyPair || keyPair.algorithm !== "RSA-OAEP") {
          throw new Error(`RSA encryption key not found: ${keyId}`);
        }
        let dataBuffer;
        if (typeof data === "string") {
          dataBuffer = new TextEncoder().encode(data);
        } else {
          dataBuffer = data;
        }
        const maxChunkSize = Math.floor(this.config.keyLength / 8) - 42;
        if (dataBuffer.length > maxChunkSize) {
          throw new Error(`Data too large for RSA encryption. Max size: ${maxChunkSize} bytes`);
        }
        const encryptedBuffer = await crypto.subtle.encrypt(
          {
            name: "RSA-OAEP"
          },
          keyPair.publicKey,
          dataBuffer
        );
        return {
          data: new Uint8Array(encryptedBuffer),
          iv: new Uint8Array(0),
          // Not used in RSA
          metadata: {
            ...this.config.metadata,
            keyId
          },
          algorithm: "RSA-OAEP"
        };
      }
      /**
       * Decrypt data with asymmetric key (RSA-OAEP)
       */
      async decryptAsymmetric(encryptedData) {
        const keyPair = this.keyPairs.get(encryptedData.metadata.keyId);
        if (!keyPair || keyPair.algorithm !== "RSA-OAEP") {
          throw new Error(`RSA decryption key not found: ${encryptedData.metadata.keyId}`);
        }
        const decryptedBuffer = await crypto.subtle.decrypt(
          {
            name: "RSA-OAEP"
          },
          keyPair.privateKey,
          encryptedData.data
        );
        return new Uint8Array(decryptedBuffer);
      }
      /**
       * Export key for storage or transmission
       */
      async exportKey(keyId, format = "jwk") {
        const symmetricKey = this.keys.get(keyId);
        if (symmetricKey) {
          if (format === "jwk") {
            return await crypto.subtle.exportKey("jwk", symmetricKey);
          } else {
            return await crypto.subtle.exportKey(format, symmetricKey);
          }
        }
        const keyPair = this.keyPairs.get(keyId);
        if (keyPair) {
          if (format === "jwk") {
            return await crypto.subtle.exportKey("jwk", keyPair.publicKey);
          } else {
            return await crypto.subtle.exportKey(format, keyPair.publicKey);
          }
        }
        throw new Error(`Key not found: ${keyId}`);
      }
      /**
       * Import key from external source
       */
      async importKey(keyData, algorithm, keyId, usages = ["encrypt", "decrypt"]) {
        const id = keyId || this.generateKeyId();
        let algorithmParams;
        let format;
        if (algorithm === "AES-GCM") {
          algorithmParams = { name: "AES-GCM" };
          format = keyData instanceof ArrayBuffer ? "raw" : "jwk";
        } else if (algorithm === "RSA-OAEP") {
          algorithmParams = {
            name: "RSA-OAEP",
            hash: "SHA-256"
          };
          format = keyData instanceof ArrayBuffer ? "spki" : "jwk";
        } else {
          throw new Error(`Unsupported algorithm: ${algorithm}`);
        }
        const importedKey = await (format === "jwk" ? crypto.subtle.importKey("jwk", keyData, algorithmParams, true, usages) : crypto.subtle.importKey(format, keyData, algorithmParams, true, usages));
        if (algorithm === "AES-GCM") {
          this.keys.set(id, importedKey);
        } else {
          throw new Error("Asymmetric key import not fully implemented");
        }
        return id;
      }
      /**
       * Rotate encryption keys
       */
      async rotateKey(oldKeyId) {
        const oldKey = this.keys.get(oldKeyId);
        const oldKeyPair = this.keyPairs.get(oldKeyId);
        if (!oldKey && !oldKeyPair) {
          throw new Error(`Key not found for rotation: ${oldKeyId}`);
        }
        let newKeyId;
        if (oldKey) {
          newKeyId = await this.generateSymmetricKey();
        } else {
          const algorithm = oldKeyPair.algorithm;
          newKeyId = await this.generateKeyPair(algorithm);
        }
        return newKeyId;
      }
      /**
       * Get key information
       */
      getKeyInfo(keyId) {
        const symmetricKey = this.keys.get(keyId);
        if (symmetricKey) {
          return {
            algorithm: symmetricKey.algorithm.name,
            usages: Array.from(symmetricKey.usages),
            extractable: symmetricKey.extractable
          };
        }
        const keyPair = this.keyPairs.get(keyId);
        if (keyPair) {
          return {
            algorithm: keyPair.algorithm,
            usages: keyPair.usages,
            extractable: keyPair.extractable
          };
        }
        return null;
      }
      /**
       * List all available keys
       */
      listKeys() {
        const keys = [];
        for (const [keyId, key] of this.keys.entries()) {
          keys.push({
            keyId,
            type: "symmetric",
            algorithm: key.algorithm.name
          });
        }
        for (const [keyId, keyPair] of this.keyPairs.entries()) {
          keys.push({
            keyId,
            type: "asymmetric",
            algorithm: keyPair.algorithm
          });
        }
        return keys;
      }
      /**
       * Clear all keys from memory
       */
      clearKeys() {
        this.keys.clear();
        this.keyPairs.clear();
      }
      /**
       * Utility: Convert Uint8Array to base64
       */
      static arrayBufferToBase64(buffer) {
        const binary = String.fromCharCode.apply(null, Array.from(buffer));
        return btoa(binary);
      }
      /**
       * Utility: Convert base64 to Uint8Array
       */
      static base64ToArrayBuffer(base64) {
        const binary = atob(base64);
        const buffer = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          buffer[i] = binary.charCodeAt(i);
        }
        return buffer;
      }
      /**
       * Utility: Convert encrypted data to JSON
       */
      static encryptedDataToJSON(encryptedData) {
        return JSON.stringify({
          data: this.arrayBufferToBase64(encryptedData.data),
          iv: this.arrayBufferToBase64(encryptedData.iv),
          authTag: encryptedData.authTag ? this.arrayBufferToBase64(encryptedData.authTag) : void 0,
          metadata: encryptedData.metadata,
          algorithm: encryptedData.algorithm
        });
      }
      /**
       * Utility: Convert JSON to encrypted data
       */
      static encryptedDataFromJSON(json) {
        const obj = JSON.parse(json);
        return {
          data: this.base64ToArrayBuffer(obj.data),
          iv: this.base64ToArrayBuffer(obj.iv),
          metadata: obj.metadata,
          algorithm: obj.algorithm,
          ...obj.authTag ? { authTag: this.base64ToArrayBuffer(obj.authTag) } : {}
        };
      }
      generateKeyId() {
        return `key_${Date.now()}_${Math.random().toString(36).substring(2)}`;
      }
      async compressData(data) {
        if (typeof CompressionStream !== "undefined") {
          const stream = new CompressionStream("gzip");
          const writer = stream.writable.getWriter();
          const reader = stream.readable.getReader();
          writer.write(data);
          writer.close();
          const chunks = [];
          let result;
          while (!(result = await reader.read()).done) {
            chunks.push(result.value);
          }
          const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
          const compressed = new Uint8Array(totalLength);
          let offset = 0;
          for (const chunk of chunks) {
            compressed.set(chunk, offset);
            offset += chunk.length;
          }
          return compressed;
        }
        return data;
      }
      async decompressData(data) {
        if (typeof DecompressionStream !== "undefined") {
          const stream = new DecompressionStream("gzip");
          const writer = stream.writable.getWriter();
          const reader = stream.readable.getReader();
          writer.write(data);
          writer.close();
          const chunks = [];
          let result;
          while (!(result = await reader.read()).done) {
            chunks.push(result.value);
          }
          const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
          const decompressed = new Uint8Array(totalLength);
          let offset = 0;
          for (const chunk of chunks) {
            decompressed.set(chunk, offset);
            offset += chunk.length;
          }
          return decompressed;
        }
        return data;
      }
      /**
       * Initialize the encryption system
       */
      async initialize() {
        if (this.initialized) return;
        await this.generateSymmetricKey("default");
        this.initialized = true;
      }
      /**
       * Simple encrypt method (uses symmetric encryption)
       */
      async encrypt(data, keyId = "default") {
        if (!this.initialized) {
          await this.initialize();
        }
        return this.encryptSymmetric(data, keyId);
      }
      /**
       * Simple decrypt method (uses symmetric decryption)
       */
      async decrypt(encryptedData) {
        if (!this.initialized) {
          await this.initialize();
        }
        return this.decryptSymmetric(encryptedData);
      }
    };
  }
});

// src/storage/encryption-service.ts
var DefaultKeyManager, StorageEncryptionService, createEncryptionService, createSecureEncryptionService, createMinimalEncryptionService;
var init_encryption_service = __esm({
  "src/storage/encryption-service.ts"() {
    "use strict";
    init_esm_shims();
    init_encryption();
    init_unified_storage();
    DefaultKeyManager = class {
      constructor(encryption, config) {
        this.encryption = encryption;
        this.config = config;
      }
      currentKeyId = null;
      keyCache = /* @__PURE__ */ new Map();
      async getCurrentKeyId() {
        if (this.currentKeyId) {
          const keyInfo2 = this.keyCache.get(this.currentKeyId);
          if (keyInfo2 && this.config.keyRotationInterval) {
            const age = Date.now() - keyInfo2.created;
            if (age > this.config.keyRotationInterval) {
              this.currentKeyId = await this.rotateKey();
            }
          }
          return this.currentKeyId;
        }
        if (this.config.masterPassword) {
          this.currentKeyId = await this.deriveKey(this.config.masterPassword, this.config.keyId);
        } else {
          this.currentKeyId = await this.encryption.generateSymmetricKey(this.config.keyId);
        }
        const keyInfo = {
          keyId: this.currentKeyId,
          created: Date.now()
        };
        if (this.config.keyRotationInterval) {
          keyInfo.expires = Date.now() + this.config.keyRotationInterval;
        }
        this.keyCache.set(this.currentKeyId, keyInfo);
        return this.currentKeyId;
      }
      async deriveKey(password, keyId) {
        const derivedKeyId = await this.encryption.deriveKeyFromPassword(password);
        const finalKeyId = keyId || derivedKeyId;
        const keyInfo2 = {
          keyId: finalKeyId,
          created: Date.now()
        };
        if (this.config.keyRotationInterval) {
          keyInfo2.expires = Date.now() + this.config.keyRotationInterval;
        }
        this.keyCache.set(finalKeyId, keyInfo2);
        return finalKeyId;
      }
      async rotateKey() {
        const oldKeyId = this.currentKeyId;
        const newKeyId = await this.encryption.generateSymmetricKey();
        this.currentKeyId = newKeyId;
        const keyInfo3 = {
          keyId: newKeyId,
          created: Date.now()
        };
        if (this.config.keyRotationInterval) {
          keyInfo3.expires = Date.now() + this.config.keyRotationInterval;
        }
        this.keyCache.set(newKeyId, keyInfo3);
        if (oldKeyId) {
          const oldKeyInfo = this.keyCache.get(oldKeyId);
          if (oldKeyInfo) {
            this.keyCache.set(oldKeyId, {
              ...oldKeyInfo,
              expires: Date.now() + 24 * 60 * 60 * 1e3
              // Keep old key for 24 hours
            });
          }
        }
        return newKeyId;
      }
      async getKeyInfo(keyId) {
        const cached = this.keyCache.get(keyId);
        if (cached) {
          const info = this.encryption.getKeyInfo(keyId);
          if (info) {
            const result = {
              algorithm: info.algorithm,
              created: cached.created
            };
            if (cached.expires !== void 0) {
              result.expires = cached.expires;
            }
            return result;
          }
        }
        return null;
      }
      async cleanup() {
        const now = Date.now();
        let cleanedCount = 0;
        const expiredKeys = Array.from(this.keyCache.entries()).filter(([_, info]) => info.expires && info.expires < now).map(([keyId]) => keyId);
        for (const keyId of expiredKeys) {
          this.keyCache.delete(keyId);
          cleanedCount++;
        }
        return cleanedCount;
      }
    };
    StorageEncryptionService = class {
      encryption;
      keyManager;
      config;
      constructor(config = {}) {
        this.config = {
          enabled: true,
          algorithm: "AES-GCM",
          keyLength: 256,
          keyDerivation: {
            algorithm: "PBKDF2",
            iterations: 1e5
          },
          compression: true,
          keyRotationInterval: 7 * 24 * 60 * 60 * 1e3,
          // 7 days
          ...config
        };
        this.encryption = new AdvancedEncryption({
          algorithm: this.config.algorithm,
          keyLength: this.config.keyLength,
          keyDerivation: {
            algorithm: this.config.keyDerivation.algorithm,
            iterations: this.config.keyDerivation.iterations,
            salt: crypto.getRandomValues(new Uint8Array(16))
          },
          compression: this.config.compression,
          metadata: {
            version: "2.0.0",
            timestamp: Date.now(),
            keyId: this.config.keyId || this.generateKeyId()
          }
        });
        this.keyManager = new DefaultKeyManager(this.encryption, this.config);
      }
      /**
       * Encrypt storage value if encryption is enabled
       */
      async encryptValue(value, key, forceEncrypt = false) {
        if (!this.config.enabled && !forceEncrypt) {
          return {
            data: value,
            metadata: {
              encrypted: false,
              version: "2.0.0"
            }
          };
        }
        try {
          const serialized = JSON.stringify(value);
          const keyId = await this.keyManager.getCurrentKeyId();
          const encryptedData = await this.encryption.encryptSymmetric(serialized, keyId);
          const encryptedString = AdvancedEncryption.encryptedDataToJSON(encryptedData);
          const checksum = await this.generateChecksum(serialized);
          return {
            data: encryptedString,
            metadata: {
              encrypted: true,
              algorithm: this.config.algorithm,
              keyId,
              version: "2.0.0",
              checksum
            }
          };
        } catch (error) {
          throw new StorageEncryptionError(key, "encrypt", error);
        }
      }
      /**
       * Decrypt storage value if it was encrypted
       */
      async decryptValue(data, metadata, key) {
        if (!metadata.encrypted) {
          return data;
        }
        try {
          const encryptedData = AdvancedEncryption.encryptedDataFromJSON(data);
          const decryptedBuffer = await this.encryption.decryptSymmetric(encryptedData);
          const decryptedString = new TextDecoder().decode(decryptedBuffer);
          if (metadata.checksum) {
            const actualChecksum = await this.generateChecksum(decryptedString);
            if (actualChecksum !== metadata.checksum) {
              throw new Error("Checksum verification failed - data may be corrupted");
            }
          }
          return JSON.parse(decryptedString);
        } catch (error) {
          throw new StorageEncryptionError(key, "decrypt", error);
        }
      }
      /**
       * Process storage entry for encryption
       */
      async encryptStorageEntry(entry, forceEncrypt = false) {
        const { data, metadata: encryptionMetadata } = await this.encryptValue(
          entry.data,
          entry.metadata.key,
          forceEncrypt
        );
        const resultMetadata = {
          ...entry.metadata,
          encrypted: encryptionMetadata.encrypted
        };
        if (encryptionMetadata.checksum !== void 0) {
          resultMetadata.checksum = encryptionMetadata.checksum;
        }
        return {
          data,
          metadata: resultMetadata
        };
      }
      /**
       * Process storage entry for decryption
       */
      async decryptStorageEntry(entry) {
        const encryptionMetadata = {
          encrypted: entry.metadata.encrypted,
          algorithm: this.config.algorithm,
          version: entry.metadata.version
        };
        if (this.config.keyId) {
          encryptionMetadata.keyId = this.config.keyId;
        }
        if (entry.metadata.checksum !== void 0) {
          encryptionMetadata.checksum = entry.metadata.checksum;
        }
        const decryptedData = await this.decryptValue(
          entry.data,
          encryptionMetadata,
          entry.metadata.key
        );
        return {
          data: decryptedData,
          metadata: {
            ...entry.metadata,
            encrypted: false
            // Mark as decrypted for consumers
          }
        };
      }
      /**
       * Check if encryption is enabled
       */
      isEncryptionEnabled() {
        return this.config.enabled;
      }
      /**
       * Get current encryption configuration
       */
      getConfig() {
        return { ...this.config };
      }
      /**
       * Update encryption configuration
       */
      async updateConfig(newConfig) {
        const oldConfig = this.config;
        this.config = { ...this.config, ...newConfig };
        if (newConfig.algorithm !== oldConfig.algorithm || newConfig.keyLength !== oldConfig.keyLength || newConfig.keyDerivation !== oldConfig.keyDerivation) {
          this.encryption = new AdvancedEncryption({
            algorithm: this.config.algorithm,
            keyLength: this.config.keyLength,
            keyDerivation: {
              algorithm: this.config.keyDerivation.algorithm,
              iterations: this.config.keyDerivation.iterations,
              salt: crypto.getRandomValues(new Uint8Array(16))
            },
            compression: this.config.compression,
            metadata: {
              version: "2.0.0",
              timestamp: Date.now(),
              keyId: this.config.keyId || this.generateKeyId()
            }
          });
          await this.keyManager.rotateKey();
        }
      }
      /**
       * Rotate encryption keys
       */
      async rotateKeys() {
        return this.keyManager.rotateKey();
      }
      /**
       * Get encryption statistics
       */
      async getEncryptionStats() {
        const currentKeyId = await this.keyManager.getCurrentKeyId();
        const keyInfo = await this.keyManager.getKeyInfo(currentKeyId);
        const result = {
          enabled: this.config.enabled,
          algorithm: this.config.algorithm,
          keyLength: this.config.keyLength,
          currentKeyId,
          keyAge: keyInfo ? Date.now() - keyInfo.created : 0
        };
        if (keyInfo?.expires !== void 0) {
          result.nextRotation = keyInfo.expires;
        }
        return result;
      }
      /**
       * Cleanup expired keys
       */
      async cleanup() {
        return this.keyManager.cleanup();
      }
      /**
       * Test encryption/decryption with sample data
       */
      async testEncryption() {
        try {
          const testData = { test: "encryption_test", timestamp: Date.now() };
          const testKey = "test:encryption";
          const { data: encrypted, metadata } = await this.encryptValue(testData, testKey, true);
          const decrypted = await this.decryptValue(encrypted, metadata, testKey);
          return JSON.stringify(testData) === JSON.stringify(decrypted);
        } catch (error) {
          console.error("Encryption test failed:", error);
          return false;
        }
      }
      /**
       * Generate integrity checksum
       */
      async generateChecksum(data) {
        if (typeof crypto !== "undefined" && crypto.subtle) {
          const encoder = new TextEncoder();
          const dataBuffer = encoder.encode(data);
          const hashBuffer = await crypto.subtle.digest("SHA-256", dataBuffer);
          const hashArray = Array.from(new Uint8Array(hashBuffer));
          return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
        } else {
          return this.simpleHash(data);
        }
      }
      /**
       * Simple hash fallback for environments without crypto.subtle
       */
      simpleHash(data) {
        let hash = 0;
        for (let i = 0; i < data.length; i++) {
          const char = data.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash;
        }
        return Math.abs(hash).toString(16);
      }
      /**
       * Generate unique key ID
       */
      generateKeyId() {
        return `storage_key_${Date.now()}_${Math.random().toString(36).substring(2)}`;
      }
    };
    createEncryptionService = (config) => {
      return new StorageEncryptionService(config);
    };
    createSecureEncryptionService = (masterPassword) => {
      return new StorageEncryptionService({
        enabled: true,
        masterPassword,
        keyRotationInterval: 7 * 24 * 60 * 60 * 1e3,
        // 7 days
        compression: true
      });
    };
    createMinimalEncryptionService = () => {
      const config = {
        enabled: true,
        algorithm: "AES-GCM",
        keyLength: 256,
        compression: false
      };
      return new StorageEncryptionService(config);
    };
  }
});

// src/storage/storage-factory.ts
import { EventEmitter as EventEmitter2 } from "events";
var MemoryStorageAdapter, UnifiedStorageImpl, StorageFactory, storageFactory, createStorage, createSecureStorage, createHighPerformanceStorage, createCompatibilityStorage;
var init_storage_factory = __esm({
  "src/storage/storage-factory.ts"() {
    "use strict";
    init_esm_shims();
    init_unified_storage();
    init_platform_detector();
    init_indexeddb_adapter();
    init_localstorage_adapter();
    init_encryption_service();
    MemoryStorageAdapter = class {
      name = "Memory";
      store = /* @__PURE__ */ new Map();
      capabilities = {
        supportsTransactions: false,
        supportsIndexing: false,
        maxKeyLength: Infinity,
        maxValueSize: Infinity,
        supportsCompression: false,
        supportsEncryption: false,
        supportsTTL: true
      };
      get isAvailable() {
        return true;
      }
      isConnected() {
        return true;
      }
      async connect() {
      }
      async disconnect() {
        this.store.clear();
      }
      async set(key, value, options) {
        const mergedOptions = { ...DEFAULT_STORAGE_OPTIONS, ...options };
        const entry = this.createStorageEntry(key, value, mergedOptions);
        this.store.set(key, entry);
      }
      async get(key) {
        const entry = this.store.get(key);
        if (!entry) return null;
        if (entry.metadata.expiresAt && entry.metadata.expiresAt < Date.now()) {
          this.store.delete(key);
          return null;
        }
        return entry;
      }
      async delete(key) {
        return this.store.delete(key);
      }
      async exists(key) {
        return this.store.has(key);
      }
      async clear() {
        this.store.clear();
      }
      async setMany(entries) {
        for (const entry of entries) {
          await this.set(entry.key, entry.value, entry.options);
        }
      }
      async getMany(keys) {
        return Promise.all(keys.map((key) => this.get(key)));
      }
      async deleteMany(keys) {
        let count = 0;
        for (const key of keys) {
          if (await this.delete(key)) count++;
        }
        return count;
      }
      async keys() {
        return Array.from(this.store.keys());
      }
      async values() {
        return Array.from(this.store.values());
      }
      async entries() {
        return this.values();
      }
      async count() {
        return this.store.size;
      }
      async beginTransaction() {
        throw new StorageError("Transactions not supported", "TRANSACTION_NOT_SUPPORTED", "beginTransaction");
      }
      async cleanup() {
        const now = Date.now();
        let cleaned = 0;
        for (const [key, entry] of this.store.entries()) {
          if (entry.metadata.expiresAt && entry.metadata.expiresAt < now) {
            this.store.delete(key);
            cleaned++;
          }
        }
        return cleaned;
      }
      async optimize() {
        await this.cleanup();
      }
      async getStats() {
        const entries = Array.from(this.store.values());
        const now = Date.now();
        return {
          totalKeys: entries.length,
          totalSize: entries.reduce((size, entry) => size + JSON.stringify(entry).length, 0),
          namespaces: [...new Set(entries.map((e) => e.metadata.key.split(":")[0]))],
          oldestEntry: Math.min(...entries.map((e) => e.metadata.createdAt)),
          newestEntry: Math.max(...entries.map((e) => e.metadata.createdAt)),
          expiredEntries: entries.filter((e) => e.metadata.expiresAt && e.metadata.expiresAt < now).length,
          encryptedEntries: entries.filter((e) => e.metadata.encrypted).length,
          compressedEntries: entries.filter((e) => e.metadata.compressed).length
        };
      }
      createStorageEntry(key, value, options) {
        const now = Date.now();
        return {
          data: value,
          metadata: {
            key,
            createdAt: now,
            updatedAt: now,
            ...options.ttl > 0 && { expiresAt: now + options.ttl },
            encrypted: options.encrypt,
            compressed: options.compress,
            version: options.version
          }
        };
      }
    };
    UnifiedStorageImpl = class extends EventEmitter2 {
      constructor(adapter, encryptionService, _config) {
        super();
        this.adapter = adapter;
        this.encryptionService = encryptionService;
        this._config = _config;
        this.name = `Unified-${adapter.name}`;
        this.capabilities = adapter.capabilities;
        this.isAvailable = adapter.isAvailable;
      }
      name;
      capabilities;
      isAvailable;
      // Delegate core methods to adapter
      isConnected() {
        return this.adapter.isConnected();
      }
      async connect() {
        return this.adapter.connect();
      }
      async disconnect() {
        return this.adapter.disconnect();
      }
      async set(key, value, options) {
        const mergedOptions = { ...DEFAULT_STORAGE_OPTIONS, ...options };
        try {
          let finalValue = value;
          if (mergedOptions.encrypt || mergedOptions.namespace === "secure") {
            const encrypted = await this.encryptionService.encryptValue(value, key, true);
            finalValue = encrypted.data;
            mergedOptions.encrypt = true;
          }
          await this.adapter.set(key, finalValue, mergedOptions);
          this.emit("set", key, value, options);
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      }
      async get(key) {
        try {
          const entry = await this.adapter.get(key);
          if (!entry) {
            this.emit("get", key, null);
            return null;
          }
          if (entry.metadata.encrypted) {
            const decrypted = await this.encryptionService.decryptStorageEntry(entry);
            this.emit("get", key, decrypted.data);
            return decrypted;
          }
          this.emit("get", key, entry.data);
          return entry;
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      }
      async delete(key) {
        try {
          const result = await this.adapter.delete(key);
          this.emit("delete", key, result);
          return result;
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      }
      async exists(key) {
        return this.adapter.exists(key);
      }
      async clear(namespace) {
        try {
          await this.adapter.clear(namespace);
          this.emit("clear", namespace);
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      }
      // High-level entity methods
      async setReceipt(id, receipt, options) {
        const key = createReceiptKey(id);
        return this.set(key, receipt, { ...options, namespace: "receipts" });
      }
      async getReceipt(id) {
        const key = createReceiptKey(id);
        const entry = await this.get(key);
        return entry?.data || null;
      }
      async deleteReceipt(id) {
        const key = createReceiptKey(id);
        return this.delete(key);
      }
      async setCashier(id, cashier, options) {
        const key = createCashierKey(id);
        return this.set(key, cashier, { ...options, namespace: "cashiers" });
      }
      async getCashier(id) {
        const key = createCashierKey(id);
        const entry = await this.get(key);
        return entry?.data || null;
      }
      async deleteCashier(id) {
        const key = createCashierKey(id);
        return this.delete(key);
      }
      async setMerchant(id, merchant, options) {
        const key = createMerchantKey(id);
        return this.set(key, merchant, { ...options, namespace: "merchants" });
      }
      async getMerchant(id) {
        const key = createMerchantKey(id);
        const entry = await this.get(key);
        return entry?.data || null;
      }
      async deleteMerchant(id) {
        const key = createMerchantKey(id);
        return this.delete(key);
      }
      async setPEM(id, pem, options) {
        const key = createPEMKey(id);
        return this.set(key, pem, { ...options, namespace: "pems" });
      }
      async getPEM(id) {
        const key = createPEMKey(id);
        const entry = await this.get(key);
        return entry?.data || null;
      }
      async deletePEM(id) {
        const key = createPEMKey(id);
        return this.delete(key);
      }
      async setCashRegister(id, cashRegister, options) {
        const key = createCashRegisterKey(id);
        return this.set(key, cashRegister, { ...options, namespace: "cash_registers" });
      }
      async getCashRegister(id) {
        const key = createCashRegisterKey(id);
        const entry = await this.get(key);
        return entry?.data || null;
      }
      async deleteCashRegister(id) {
        const key = createCashRegisterKey(id);
        return this.delete(key);
      }
      // Cache operations
      async setCache(key, value, ttl) {
        const cacheKey = createCacheKey(key);
        return this.set(cacheKey, value, { namespace: "cache", ...ttl && { ttl } });
      }
      async getCache(key) {
        const cacheKey = createCacheKey(key);
        const entry = await this.get(cacheKey);
        return entry?.data || null;
      }
      async invalidateCache(pattern) {
        const keys = await this.keys({ namespace: "cache", ...pattern && { prefix: pattern } });
        return this.deleteMany(keys);
      }
      // Session storage
      async setSession(key, value) {
        const sessionKey = createSessionKey(key);
        return this.set(sessionKey, value, { namespace: "session" });
      }
      async getSession(key) {
        const sessionKey = createSessionKey(key);
        const entry = await this.get(sessionKey);
        return entry?.data || null;
      }
      async clearSession() {
        return this.clear("session");
      }
      // Secure storage (always encrypted)
      async setSecure(key, value) {
        const secureKey = createSecureKey(key);
        return this.set(secureKey, value, { namespace: "secure", encrypt: true });
      }
      async getSecure(key) {
        const secureKey = createSecureKey(key);
        const entry = await this.get(secureKey);
        return entry?.data || null;
      }
      async deleteSecure(key) {
        const secureKey = createSecureKey(key);
        return this.delete(secureKey);
      }
      // Configuration storage
      async setConfig(key, value) {
        const configKey = createConfigKey(key);
        return this.set(configKey, value, { namespace: "config" });
      }
      async getConfig(key) {
        const configKey = createConfigKey(key);
        const entry = await this.get(configKey);
        return entry?.data || null;
      }
      async deleteConfig(key) {
        const configKey = createConfigKey(key);
        return this.delete(configKey);
      }
      // Backup and restore
      async exportData(namespace) {
        const entries = await this.entries({ ...namespace && { namespace } });
        return JSON.stringify(entries, null, 2);
      }
      async importData(data) {
        const entries = JSON.parse(data);
        let imported = 0;
        for (const entry of entries) {
          try {
            await this.set(entry.metadata.key, entry.data);
            imported++;
          } catch (error) {
            console.warn(`Failed to import entry ${entry.metadata.key}:`, error);
          }
        }
        return imported;
      }
      // Delegate remaining methods to adapter
      async setMany(entries) {
        return this.adapter.setMany(entries);
      }
      async getMany(keys) {
        return this.adapter.getMany(keys);
      }
      async deleteMany(keys) {
        return this.adapter.deleteMany(keys);
      }
      async keys(options) {
        return this.adapter.keys(options);
      }
      async values(options) {
        return this.adapter.values(options);
      }
      async entries(options) {
        return this.adapter.entries(options);
      }
      async count(options) {
        return this.adapter.count(options);
      }
      async beginTransaction() {
        return this.adapter.beginTransaction();
      }
      async cleanup() {
        return this.adapter.cleanup();
      }
      async optimize() {
        return this.adapter.optimize();
      }
      async getStats() {
        return this.adapter.getStats();
      }
      // Missing interface methods
      async query(options) {
        const keys = await this.keys(options);
        const results = [];
        for (const key of keys) {
          try {
            const entry = await this.get(key);
            if (entry?.data) {
              results.push({ key, value: entry.data });
            }
          } catch (error) {
            console.warn(`Failed to query key ${key}:`, error);
          }
        }
        return results;
      }
      async initialize() {
        await this.connect();
      }
      async destroy() {
        await this.disconnect();
        this.removeAllListeners();
      }
    };
    StorageFactory = class _StorageFactory {
      static instance = null;
      storageInstances = /* @__PURE__ */ new Map();
      constructor() {
      }
      static getInstance() {
        if (!_StorageFactory.instance) {
          _StorageFactory.instance = new _StorageFactory();
        }
        return _StorageFactory.instance;
      }
      /**
       * Create storage instance with automatic adapter selection
       */
      async createStorage(config = {}) {
        const instanceKey = this.generateInstanceKey(config);
        if (this.storageInstances.has(instanceKey)) {
          return this.storageInstances.get(instanceKey);
        }
        try {
          const environmentInfo = platformDetector.getEnvironmentInfo();
          const adapter = await this.selectOptimalAdapter(config, environmentInfo);
          const encryptionService = createEncryptionService(config.encryption);
          const storage = new UnifiedStorageImpl(adapter, encryptionService, config);
          await storage.connect();
          this.storageInstances.set(instanceKey, storage);
          if (config.debug) {
            console.log(`Storage created: ${storage.name} for platform: ${environmentInfo.platform}`);
          }
          return storage;
        } catch (error) {
          throw new StorageError(
            "Failed to create storage instance",
            "STORAGE_FACTORY_ERROR",
            "createStorage",
            void 0,
            error
          );
        }
      }
      /**
       * Get environment information
       */
      getEnvironmentInfo() {
        return platformDetector.getEnvironmentInfo();
      }
      /**
       * Test storage compatibility
       */
      async testCompatibility() {
        const environmentInfo = platformDetector.getEnvironmentInfo();
        const availableAdapters = [];
        if (environmentInfo.hasIndexedDB) {
          try {
            const adapter = new IndexedDBAdapter();
            if (adapter.isAvailable) {
              availableAdapters.push("indexeddb");
            }
          } catch {
          }
        }
        if (environmentInfo.hasLocalStorage) {
          try {
            const adapter = new LocalStorageAdapter();
            if (adapter.isAvailable) {
              availableAdapters.push("localstorage");
            }
          } catch {
          }
        }
        availableAdapters.push("memory");
        return {
          platform: environmentInfo.platform,
          availableAdapters,
          recommendedAdapter: platformDetector.getRecommendedStorageAdapter(),
          encryptionSupported: environmentInfo.hasWebCrypto,
          compressionSupported: environmentInfo.hasCompressionStreams
        };
      }
      /**
       * Clear all cached instances
       */
      clearInstances() {
        this.storageInstances.clear();
      }
      async selectOptimalAdapter(config, environmentInfo) {
        const preferredAdapter = config.preferredAdapter || "auto";
        if (preferredAdapter !== "auto") {
          return this.createSpecificAdapter(preferredAdapter, config);
        }
        if (environmentInfo.hasIndexedDB) {
          try {
            const adapter = new IndexedDBAdapter();
            await adapter.connect();
            return adapter;
          } catch (error) {
            console.warn("IndexedDB failed, falling back to localStorage:", error);
          }
        }
        if (environmentInfo.hasLocalStorage) {
          try {
            const adapter = new LocalStorageAdapter(config.keyPrefix);
            await adapter.connect();
            return adapter;
          } catch (error) {
            console.warn("LocalStorage failed, falling back to memory:", error);
          }
        }
        const isCLI = typeof window === "undefined" && typeof process !== "undefined" && process.env.NODE_ENV !== "test";
        if (!isCLI) {
          console.warn("Using memory storage as fallback - data will not persist");
        }
        return new MemoryStorageAdapter();
      }
      createSpecificAdapter(adapterType, config) {
        switch (adapterType) {
          case "indexeddb":
            return new IndexedDBAdapter();
          case "localstorage":
            return new LocalStorageAdapter(config.keyPrefix);
          case "memory":
            return new MemoryStorageAdapter();
          default:
            throw new StorageError(
              `Unknown adapter type: ${adapterType}`,
              "UNKNOWN_ADAPTER",
              "createSpecificAdapter"
            );
        }
      }
      generateInstanceKey(config) {
        const keyParts = [
          config.preferredAdapter || "auto",
          config.keyPrefix || "default",
          config.enableCompression ? "compressed" : "uncompressed",
          config.encryption?.enabled ? "encrypted" : "unencrypted"
        ];
        return keyParts.join("_");
      }
    };
    storageFactory = StorageFactory.getInstance();
    createStorage = (config) => {
      return storageFactory.createStorage(config);
    };
    createSecureStorage = (masterPassword) => {
      return storageFactory.createStorage({
        encryption: {
          enabled: true,
          masterPassword
        }
      });
    };
    createHighPerformanceStorage = () => {
      return storageFactory.createStorage({
        preferredAdapter: "indexeddb",
        performanceMode: "high",
        enableCompression: true
      });
    };
    createCompatibilityStorage = () => {
      return storageFactory.createStorage({
        preferredAdapter: "localstorage",
        performanceMode: "conservative",
        enableCompression: false
      });
    };
  }
});

// src/security/mtls-certificate-manager.ts
var DEFAULT_CONFIG5, MTLSCertificateManager;
var init_mtls_certificate_manager = __esm({
  "src/security/mtls-certificate-manager.ts"() {
    "use strict";
    init_esm_shims();
    init_eventemitter3();
    init_unified_storage();
    init_storage_factory();
    init_encryption();
    DEFAULT_CONFIG5 = {
      storageKey: "acube_mtls_certificates",
      enableEncryption: true,
      storageAdapter: "memory",
      validation: {
        validateFormat: true,
        checkExpiration: true,
        validateChain: false
      }
    };
    MTLSCertificateManager = class extends import_index.default {
      config;
      storage = null;
      encryption = null;
      initialized = false;
      constructor(config = {}) {
        super();
        this.config = { ...DEFAULT_CONFIG5, ...config };
      }
      /**
       * Initialize the certificate manager
       */
      async initialize() {
        try {
          const adapterMapping = {
            "memory": "localstorage",
            "localStorage": "localstorage",
            "indexedDB": "indexeddb",
            "reactNative": "localstorage"
          };
          this.storage = await createStorage({
            preferredAdapter: adapterMapping[this.config.storageAdapter] || "auto",
            encryption: this.config.enableEncryption ? { enabled: true } : { enabled: false }
          });
          if (this.config.enableEncryption) {
            this.encryption = new AdvancedEncryption();
            await this.encryption.initialize();
          }
          this.initialized = true;
        } catch (error) {
          const certificateError = new Error(`Failed to initialize certificate manager: ${error}`);
          this.emit("certificate:error", { error: certificateError, operation: "initialize" });
          throw certificateError;
        }
      }
      /**
       * Store a new mTLS certificate securely
       */
      async storeCertificate(cashRegisterId, pemSerialNumber, name, certificate) {
        this.ensureInitialized();
        try {
          const metadata = this.parseCertificateMetadata(certificate);
          const mtlsCertificate = {
            cashRegisterId,
            pemSerialNumber,
            name,
            certificate,
            metadata,
            storedAt: /* @__PURE__ */ new Date(),
            status: "active"
          };
          if (this.config.validation.validateFormat) {
            this.validateCertificateFormat(certificate);
          }
          const existingData = await this.getStoredData();
          existingData.certificates[cashRegisterId] = mtlsCertificate;
          await this.saveStoredData(existingData);
          this.emit("certificate:stored", { certificate: mtlsCertificate });
          return mtlsCertificate;
        } catch (error) {
          const certificateError = new Error(`Failed to store certificate: ${error}`);
          this.emit("certificate:error", { error: certificateError, operation: "store" });
          throw certificateError;
        }
      }
      /**
       * Retrieve a certificate by cash register ID
       */
      async getCertificate(cashRegisterId) {
        this.ensureInitialized();
        try {
          const storedData = await this.getStoredData();
          const certificate = storedData.certificates[cashRegisterId] || null;
          if (certificate) {
            if (this.config.validation.checkExpiration && this.isCertificateExpired(certificate)) {
              certificate.status = "expired";
              await this.updateCertificateStatus(cashRegisterId, "expired");
              this.emit("certificate:expired", { certificateId: cashRegisterId, certificate });
            }
            this.emit("certificate:retrieved", { certificateId: cashRegisterId, certificate });
          }
          return certificate;
        } catch (error) {
          const certificateError = new Error(`Failed to retrieve certificate: ${error}`);
          this.emit("certificate:error", { error: certificateError, operation: "retrieve" });
          throw certificateError;
        }
      }
      /**
       * Get all stored certificates
       */
      async getAllCertificates() {
        this.ensureInitialized();
        try {
          const storedData = await this.getStoredData();
          return Object.values(storedData.certificates);
        } catch (error) {
          const certificateError = new Error(`Failed to retrieve all certificates: ${error}`);
          this.emit("certificate:error", { error: certificateError, operation: "retrieveAll" });
          throw certificateError;
        }
      }
      /**
       * Update certificate status
       */
      async updateCertificateStatus(cashRegisterId, status) {
        this.ensureInitialized();
        try {
          const storedData = await this.getStoredData();
          const certificate = storedData.certificates[cashRegisterId];
          if (certificate) {
            certificate.status = status;
            await this.saveStoredData(storedData);
          }
        } catch (error) {
          const certificateError = new Error(`Failed to update certificate status: ${error}`);
          this.emit("certificate:error", { error: certificateError, operation: "updateStatus" });
          throw certificateError;
        }
      }
      /**
       * Remove a certificate
       */
      async removeCertificate(cashRegisterId) {
        this.ensureInitialized();
        try {
          const storedData = await this.getStoredData();
          const existed = !!storedData.certificates[cashRegisterId];
          delete storedData.certificates[cashRegisterId];
          await this.saveStoredData(storedData);
          return existed;
        } catch (error) {
          const certificateError = new Error(`Failed to remove certificate: ${error}`);
          this.emit("certificate:error", { error: certificateError, operation: "remove" });
          throw certificateError;
        }
      }
      /**
       * Clear all certificates
       */
      async clearAllCertificates() {
        this.ensureInitialized();
        try {
          const emptyData = {
            certificates: {},
            version: "1.0",
            encryptedAt: Date.now()
          };
          await this.saveStoredData(emptyData);
        } catch (error) {
          const certificateError = new Error(`Failed to clear certificates: ${error}`);
          this.emit("certificate:error", { error: certificateError, operation: "clear" });
          throw certificateError;
        }
      }
      /**
       * Get certificate storage statistics
       */
      async getStorageStats() {
        this.ensureInitialized();
        try {
          const storedData = await this.getStoredData();
          const certificates = Object.values(storedData.certificates);
          const activeCertificates = certificates.filter((cert) => cert.status === "active").length;
          const expiredCertificates = certificates.filter((cert) => cert.status === "expired").length;
          const storageSize = JSON.stringify(storedData).length;
          const lastUpdate = certificates.length > 0 ? new Date(Math.max(...certificates.map((cert) => cert.storedAt.getTime()))) : null;
          return {
            totalCertificates: certificates.length,
            activeCertificates,
            expiredCertificates,
            storageSize,
            lastUpdate
          };
        } catch (error) {
          const certificateError = new Error(`Failed to get storage stats: ${error}`);
          this.emit("certificate:error", { error: certificateError, operation: "stats" });
          throw certificateError;
        }
      }
      /**
       * Cleanup expired certificates
       */
      async cleanupExpiredCertificates() {
        this.ensureInitialized();
        try {
          const storedData = await this.getStoredData();
          const certificates = Object.entries(storedData.certificates);
          let removedCount = 0;
          for (const [cashRegisterId, certificate] of certificates) {
            if (this.isCertificateExpired(certificate)) {
              delete storedData.certificates[cashRegisterId];
              removedCount++;
              this.emit("certificate:expired", { certificateId: cashRegisterId, certificate });
            }
          }
          if (removedCount > 0) {
            await this.saveStoredData(storedData);
          }
          return removedCount;
        } catch (error) {
          const certificateError = new Error(`Failed to cleanup expired certificates: ${error}`);
          this.emit("certificate:error", { error: certificateError, operation: "cleanup" });
          throw certificateError;
        }
      }
      /**
       * Destroy the certificate manager
       */
      async destroy() {
        if (this.storage) {
          await this.storage.destroy();
        }
        this.removeAllListeners();
        this.initialized = false;
      }
      // Private methods
      ensureInitialized() {
        if (!this.initialized) {
          throw new Error("Certificate manager not initialized. Call initialize() first.");
        }
      }
      async getStoredData() {
        if (!this.storage) {
          throw new Error("Storage not initialized");
        }
        try {
          const storageKey = createStorageKey(this.config.storageKey);
          const result = await this.storage.get(storageKey);
          if (!result || !result.data) {
            return {
              certificates: {},
              version: "1.0",
              encryptedAt: Date.now()
            };
          }
          const data = typeof result.data === "string" ? result.data : JSON.stringify(result.data);
          let parsedData;
          if (this.config.enableEncryption && this.encryption) {
            try {
              const encryptedDataObj = JSON.parse(data);
              const decryptedBuffer = await this.encryption.decrypt(encryptedDataObj);
              const decryptedString = new TextDecoder().decode(decryptedBuffer);
              parsedData = JSON.parse(decryptedString);
            } catch (decryptError) {
              console.warn("Failed to decrypt certificate data, falling back to unencrypted:", decryptError);
              parsedData = JSON.parse(data);
            }
          } else {
            parsedData = JSON.parse(data);
          }
          Object.values(parsedData.certificates).forEach((cert) => {
            cert.storedAt = new Date(cert.storedAt);
            cert.metadata.issuedAt = new Date(cert.metadata.issuedAt);
            if (cert.metadata.expiresAt) {
              cert.metadata.expiresAt = new Date(cert.metadata.expiresAt);
            }
          });
          return parsedData;
        } catch (error) {
          console.warn("Failed to retrieve certificate data:", error);
          return {
            certificates: {},
            version: "1.0",
            encryptedAt: Date.now()
          };
        }
      }
      async saveStoredData(data) {
        if (!this.storage) {
          throw new Error("Storage not initialized");
        }
        try {
          data.encryptedAt = Date.now();
          let dataToStore = JSON.stringify(data);
          if (this.config.enableEncryption && this.encryption) {
            const encryptedData = await this.encryption.encrypt(JSON.stringify(data));
            dataToStore = JSON.stringify(encryptedData);
          }
          const storageKey = createStorageKey(this.config.storageKey);
          await this.storage.set(storageKey, dataToStore, {
            encrypt: this.config.enableEncryption
          });
        } catch (error) {
          this.emit("storage:error", { error });
          throw error;
        }
      }
      parseCertificateMetadata(certificate) {
        const metadata = {
          issuedAt: /* @__PURE__ */ new Date()
        };
        try {
          const certLines = certificate.split("\n");
          const certData = certLines.find((line) => line.includes("Subject:"));
          if (certData) {
            metadata.subject = certData.replace("Subject:", "").trim();
          }
          const issuerData = certLines.find((line) => line.includes("Issuer:"));
          if (issuerData) {
            metadata.issuer = issuerData.replace("Issuer:", "").trim();
          }
          let hash = 0;
          for (let i = 0; i < certificate.length; i++) {
            const char = certificate.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
          }
          metadata.fingerprint = Math.abs(hash).toString(16);
        } catch (error) {
          console.warn("Failed to parse certificate metadata:", error);
        }
        return metadata;
      }
      validateCertificateFormat(certificate) {
        if (!certificate.includes("-----BEGIN CERTIFICATE-----") || !certificate.includes("-----END CERTIFICATE-----")) {
          throw new Error("Invalid certificate format: must be PEM format");
        }
      }
      isCertificateExpired(certificate) {
        if (!certificate.metadata.expiresAt) {
          return false;
        }
        return certificate.metadata.expiresAt.getTime() < Date.now();
      }
    };
  }
});

// src/resources/cash-registers.ts
var cash_registers_exports = {};
__export(cash_registers_exports, {
  CashRegisters: () => CashRegistersResource,
  CashRegistersResource: () => CashRegistersResource
});
var CashRegistersResource;
var init_cash_registers = __esm({
  "src/resources/cash-registers.ts"() {
    "use strict";
    init_esm_shims();
    init_base_openapi();
    init_endpoints();
    init_errors();
    init_mtls_certificate_manager();
    CashRegistersResource = class _CashRegistersResource extends BaseOpenAPIResource {
      certificateManager;
      constructor(client) {
        super({
          client,
          endpoints: {
            create: CashRegisterEndpoints.CREATE,
            list: CashRegisterEndpoints.LIST,
            getById: CashRegisterEndpoints.GET_BY_ID
          }
        });
        this.certificateManager = new MTLSCertificateManager({
          storageKey: "acube_cash_register_certificates",
          enableEncryption: true
        });
      }
      /**
       * Initialize the resource (including certificate manager)
       */
      async initialize() {
        await this.certificateManager.initialize();
      }
      /**
       * Register a new cash register and obtain mTLS certificate
       * This method calls the server endpoint and automatically stores the certificate securely
       * 
       * @param request - Cash register creation request
       * @returns Promise resolving to created cash register with certificate info
       */
      async registerWithCertificate(request) {
        try {
          const response = await this.client.post(
            "/mf1/cash-register",
            request,
            {
              headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
              },
              metadata: {
                operation: "registerCashRegister",
                requiresAuth: true
              }
            }
          );
          if (response.status !== 201) {
            throw new ValidationError(
              "CASH_REGISTER_CREATION_FAILED",
              `Failed to create cash register: ${response.status}`,
              [{ field: "request", message: "Cash register creation failed", code: "CREATION_FAILED" }]
            );
          }
          const cashRegisterData = response.data;
          const certificate = await this.certificateManager.storeCertificate(
            cashRegisterData.uuid,
            request.pem_serial_number,
            request.name,
            cashRegisterData.mtls_certificate
          );
          return {
            cashRegister: cashRegisterData,
            certificate
          };
        } catch (error) {
          throw new ValidationError(
            "CASH_REGISTER_REGISTRATION_FAILED",
            `Failed to register cash register: ${error instanceof Error ? error.message : "Unknown error"}`,
            [{ field: "request", message: "Registration failed", code: "REGISTRATION_FAILED" }]
          );
        }
      }
      /**
       * Get mTLS certificate for a cash register
       * 
       * @param cashRegisterId - Cash register ID
       * @returns Promise resolving to certificate or null if not found
       */
      async getCertificate(cashRegisterId) {
        return this.certificateManager.getCertificate(cashRegisterId);
      }
      /**
       * Get all stored mTLS certificates
       * 
       * @returns Promise resolving to array of certificates
       */
      async getAllCertificates() {
        return this.certificateManager.getAllCertificates();
      }
      /**
       * Remove mTLS certificate for a cash register
       * 
       * @param cashRegisterId - Cash register ID
       * @returns Promise resolving to true if certificate was removed
       */
      async removeCertificate(cashRegisterId) {
        return this.certificateManager.removeCertificate(cashRegisterId);
      }
      /**
       * Get certificate storage statistics
       * 
       * @returns Promise resolving to storage statistics
       */
      async getCertificateStats() {
        return this.certificateManager.getStorageStats();
      }
      /**
       * Cleanup expired certificates
       * 
       * @returns Promise resolving to number of certificates removed
       */
      async cleanupExpiredCertificates() {
        return this.certificateManager.cleanupExpiredCertificates();
      }
      /**
       * Create a new cash register (legacy method)
       * 
       * @param data - Cash register input data
       * @param options - Validation options
       * @returns Promise resolving to created cash register
       */
      async create(data, options = {}) {
        await this.validateCashRegisterInput(data, options);
        return this.executeRequest("create", data, {
          metadata: {
            operation: "create_cash_register",
            serialNumber: data.pem_serial_number,
            name: data.name
          }
        });
      }
      /**
       * Get a list of cash registers
       * 
       * @returns Promise resolving to paginated cash register list
       */
      async list() {
        return this.executeRequest("list", void 0, {
          metadata: {
            operation: "list_cash_registers"
          }
        });
      }
      /**
       * Get a specific cash register by ID
       * 
       * @param registerId - Cash register ID
       * @returns Promise resolving to cash register details
       */
      async retrieve(registerId) {
        return this.executeRequest("getById", void 0, {
          pathParams: { id: registerId },
          metadata: {
            operation: "get_cash_register",
            registerId
          }
        });
      }
      /**
       * Get cash register configuration
       * 
       * @param registerId - Cash register ID
       * @returns Promise resolving to configuration
       */
      async getConfiguration(registerId) {
        const register = await this.retrieve(registerId);
        return _CashRegistersResource.buildConfiguration(register);
      }
      /**
       * Get cash register statistics
       * 
       * @param registerId - Cash register ID
       * @returns Promise resolving to statistics
       */
      async getStatistics(registerId) {
        const register = await this.retrieve(registerId);
        return _CashRegistersResource.calculateStatistics(register);
      }
      /**
       * Update cash register settings (future enhancement)
       */
      async updateSettings(registerId, settings) {
        if (!this.hasOperation("update")) {
          throw this.createUnsupportedOperationError("update");
        }
        return this.executeRequest("update", settings, {
          pathParams: { id: registerId },
          metadata: {
            operation: "update_cash_register_settings",
            registerId
          }
        });
      }
      // Validation methods
      /**
       * Validate cash register input
       */
      async validateCashRegisterInput(data, options = {}) {
        const errors = [];
        if (!data.pem_serial_number || data.pem_serial_number.trim().length === 0) {
          errors.push({
            field: "serial_number",
            message: "Serial number is required",
            code: "REQUIRED"
          });
        } else if (options.validateSerialNumber) {
          const serialValidation = _CashRegistersResource.validateSerialNumber(data.pem_serial_number);
          if (!serialValidation.isValid) {
            errors.push({
              field: "serial_number",
              message: serialValidation.error || "Invalid serial number format",
              code: "INVALID_SERIAL_NUMBER"
            });
          }
        }
        if (options.enforceLocationValidation) {
          if (!data.name || data.name.trim().length === 0) {
            errors.push({
              field: "name",
              message: "Name is required",
              code: "REQUIRED"
            });
          } else if (data.name.length > 100) {
            errors.push({
              field: "name",
              message: "Name cannot exceed 100 characters",
              code: "TOO_LONG"
            });
          }
        }
        if (options.checkDuplicateRegistration) {
          const isDuplicate = await this.checkDuplicateSerial(data.pem_serial_number);
          if (isDuplicate) {
            errors.push({
              field: "serial_number",
              message: "Cash register with this serial number is already registered",
              code: "DUPLICATE_SERIAL"
            });
          }
        }
        if (errors.length > 0) {
          throw new ValidationError("Invalid cash register input", "create_cash_register", errors);
        }
      }
      /**
       * Check for duplicate serial number
       */
      async checkDuplicateSerial(serialNumber) {
        try {
          const registers = await this.list();
          return registers.members.some((register) => register.pem_serial_number === serialNumber);
        } catch (error) {
          console.warn(`Unable to check for duplicate serial number: ${error}`);
          return false;
        }
      }
      // Static utility methods
      /**
       * Validate serial number format
       */
      static validateSerialNumber(serialNumber) {
        if (serialNumber.length < 6 || serialNumber.length > 20) {
          return { isValid: false, error: "Serial number must be between 6 and 20 characters" };
        }
        if (!/^[A-Z0-9-]+$/.test(serialNumber)) {
          return { isValid: false, error: "Serial number must contain only uppercase letters, numbers, and hyphens" };
        }
        return { isValid: true };
      }
      /**
       * Build configuration from cash register data
       */
      static buildConfiguration(register) {
        return {
          id: register.id,
          name: register.name || `Cash Register ${register.id}`,
          location: "Unknown Location",
          // location field not available in OpenAPI schema
          serialNumber: register.pem_serial_number,
          model: "Unknown Model",
          // model field not available in OpenAPI schema
          manufacturer: "Unknown Manufacturer",
          // manufacturer field not available in OpenAPI schema
          installationDate: (/* @__PURE__ */ new Date()).toISOString(),
          // installation_date field not available in OpenAPI schema
          lastMaintenance: void 0,
          // last_maintenance field not available in OpenAPI schema
          nextMaintenance: void 0,
          // next_maintenance field not available in OpenAPI schema
          status: "active",
          // status field not available in OpenAPI schema
          settings: this.getDefaultSettings()
        };
      }
      /**
       * Get default settings for cash registers
       */
      static getDefaultSettings() {
        return {
          printReceipts: true,
          enableLottery: true,
          defaultVATRate: "22",
          language: "it",
          currency: "EUR",
          timezone: "Europe/Rome",
          paperSize: "thermal_80mm",
          connectionType: "ethernet"
        };
      }
      /**
       * Calculate statistics for a cash register
       */
      static calculateStatistics(register) {
        const mockTransactionCount = Math.floor(Math.random() * 1e3) + 100;
        const mockTotalAmount = (Math.random() * 5e4 + 1e4).toFixed(2);
        const mockTodayTransactions = Math.floor(Math.random() * 50) + 10;
        const mockTodayAmount = (Math.random() * 2e3 + 500).toFixed(2);
        return {
          registerId: register.id,
          totalTransactions: mockTransactionCount,
          totalAmount: mockTotalAmount,
          averageTransaction: (parseFloat(mockTotalAmount) / mockTransactionCount).toFixed(2),
          transactionsToday: mockTodayTransactions,
          amountToday: mockTodayAmount,
          // lastTransaction field omitted since it's not available in OpenAPI schema
          uptime: {
            hours: 23.5,
            percentage: 97.9
          },
          errorCount: Math.floor(Math.random() * 5),
          maintenanceScore: Math.floor(Math.random() * 20) + 80
        };
      }
      /**
       * Format cash register for display
       */
      static formatForDisplay(register) {
        return {
          displayName: register.name || `Cash Register ${register.id}`,
          statusBadge: "ACTIVE",
          // status field not available in OpenAPI schema
          location: "Unknown Location",
          // location field not available in OpenAPI schema
          lastActivity: "Never",
          // last_activity field not available in OpenAPI schema
          serialNumber: register.pem_serial_number || "Unknown"
        };
      }
      /**
       * Generate maintenance schedule
       */
      static generateMaintenanceSchedule(_register) {
        const now = /* @__PURE__ */ new Date();
        return {
          nextMaintenance: new Date(now.getTime() + 30 * 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
          maintenanceType: "routine",
          priority: "medium",
          description: "Routine maintenance and inspection",
          estimatedDuration: "2 hours"
        };
      }
      /**
       * Validate cash register compatibility with PEM device
       */
      static validatePEMCompatibility(register, pemModel) {
        void register;
        const issues = [];
        const recommendations = [];
        if (pemModel.includes("legacy")) {
          issues.push("Legacy PEM devices may have compatibility issues");
          recommendations.push("Consider upgrading to newer PEM model");
        }
        return {
          compatible: issues.length === 0,
          issues,
          recommendations
        };
      }
      /**
       * Check if firmware is outdated
       * @deprecated This method is not used since firmware_version is not available in OpenAPI schema
       */
      // private static isOutdatedFirmware(_version: string): boolean {
      //   // Simple version comparison
      //   const currentVersion = '3.2.0';
      //   return _version < currentVersion;
      // }
      /**
       * Generate health report for multiple cash registers
       */
      static generateFleetHealthReport(registers) {
        const report = {
          totalRegisters: registers.length,
          activeRegisters: 0,
          registersNeedingMaintenance: 0,
          averageUptime: 0,
          totalTransactionsToday: 0,
          totalRevenueToday: "0.00",
          statusBreakdown: {},
          topPerformers: []
        };
        let totalUptime = 0;
        let totalRevenue = 0;
        const performanceData = [];
        for (const register of registers) {
          const status = "active";
          report.statusBreakdown[status] = (report.statusBreakdown[status] || 0) + 1;
          if (status === "active") {
            report.activeRegisters++;
          }
          if (["maintenance", "error"].includes(status)) {
            report.registersNeedingMaintenance++;
          }
          const stats = this.calculateStatistics(register);
          totalUptime += stats.uptime.percentage;
          report.totalTransactionsToday += stats.transactionsToday;
          const todayRevenue = parseFloat(stats.amountToday);
          totalRevenue += todayRevenue;
          performanceData.push({
            id: register.id,
            name: register.name || `Register ${register.id}`,
            revenue: todayRevenue
          });
        }
        report.averageUptime = registers.length > 0 ? Math.round(totalUptime / registers.length) : 0;
        report.totalRevenueToday = totalRevenue.toFixed(2);
        report.topPerformers = performanceData.sort((a, b) => b.revenue - a.revenue).slice(0, 5).map((item) => ({
          id: item.id,
          name: item.name,
          todayRevenue: item.revenue.toFixed(2)
        }));
        return report;
      }
      /**
       * Generate installation checklist
       */
      static generateInstallationChecklist() {
        return {
          preInstallation: [
            "Verify power supply requirements",
            "Check network connectivity",
            "Prepare installation location",
            "Gather serial numbers and documentation",
            "Backup existing configuration (if upgrading)"
          ],
          installation: [
            "Mount cash register securely",
            "Connect power supply",
            "Establish network connection",
            "Install required software/drivers",
            "Configure basic settings"
          ],
          postInstallation: [
            "Test all basic functions",
            "Configure PEM device integration",
            "Set up receipt printer",
            "Configure tax settings",
            "Train staff on operation"
          ],
          testing: [
            "Process test transaction",
            "Verify receipt printing",
            "Test network connectivity",
            "Validate tax calculations",
            "Check integration with fiscal system"
          ]
        };
      }
      /**
       * Destroy the resource and cleanup certificate manager
       */
      async destroy() {
        await this.certificateManager.destroy();
      }
    };
  }
});

// src/resources/merchants.ts
var merchants_exports = {};
__export(merchants_exports, {
  Merchants: () => MerchantsResource,
  MerchantsResource: () => MerchantsResource
});
var MerchantsResource;
var init_merchants = __esm({
  "src/resources/merchants.ts"() {
    "use strict";
    init_esm_shims();
    init_base_openapi();
    init_endpoints();
    init_errors();
    MerchantsResource = class _MerchantsResource extends BaseOpenAPIResource {
      constructor(client) {
        super({
          client,
          endpoints: {
            list: MerchantEndpoints.LIST,
            create: MerchantEndpoints.CREATE,
            getByUuid: MerchantEndpoints.GET_BY_UUID,
            update: MerchantEndpoints.UPDATE
          }
        });
      }
      /**
       * Get a list of merchants
       * 
       * @returns Promise resolving to merchant list
       */
      async list() {
        return this.executeRequest("list", void 0, {
          metadata: {
            operation: "list_merchants"
          }
        });
      }
      /**
       * Create a new merchant
       * 
       * @param data - Merchant creation input data
       * @param options - Validation options
       * @returns Promise resolving to created merchant
       */
      async create(data, options = {}) {
        await this.validateMerchantCreateInput(data, options);
        return this.executeRequest("create", data, {
          metadata: {
            operation: "create_merchant",
            fiscalId: data.fiscal_id,
            email: data.email,
            businessName: data.name
          }
        });
      }
      /**
       * Get a merchant by UUID
       * 
       * @param merchantId - Merchant UUID
       * @returns Promise resolving to merchant details
       */
      async retrieve(merchantId) {
        return this.executeRequest("getByUuid", void 0, {
          pathParams: { uuid: merchantId },
          metadata: {
            operation: "get_merchant",
            merchantId
          }
        });
      }
      /**
       * Update a merchant's information
       * 
       * @param merchantId - Merchant UUID
       * @param data - Merchant update input data
       * @param options - Validation options
       * @returns Promise resolving to updated merchant
       */
      async update(merchantId, data, options = {}) {
        await this.validateMerchantUpdateInput(data, options);
        return this.executeRequest("update", data, {
          pathParams: { uuid: merchantId },
          metadata: {
            operation: "update_merchant",
            merchantId,
            businessName: data.name
          }
        });
      }
      /**
       * Get merchant business analytics
       * 
       * @param merchantId - Merchant UUID
       * @returns Promise resolving to business analytics
       */
      async getAnalytics(merchantId) {
        const merchant = await this.retrieve(merchantId);
        return _MerchantsResource.analyzeBusinessProfile(merchant);
      }
      /**
       * Validate merchant address
       * 
       * @param address - Address to validate
       * @returns Address validation result
       */
      async validateAddress(address) {
        return _MerchantsResource.validateItalianAddress(address);
      }
      // Validation methods
      /**
       * Comprehensive merchant creation input validation
       */
      async validateMerchantCreateInput(data, options = {}) {
        const errors = [];
        if (!data.fiscal_id) {
          errors.push({
            field: "fiscal_id",
            message: "Fiscal ID is required",
            code: "REQUIRED"
          });
        } else if (options.validateVATNumber) {
          const vatValidation = await this.validateItalianVATNumber(data.fiscal_id);
          if (!vatValidation.isValid) {
            errors.push({
              field: "fiscal_id",
              message: vatValidation.error || "Invalid Italian VAT number",
              code: "INVALID_VAT_NUMBER"
            });
          }
        }
        if (!data.name || data.name.trim().length === 0) {
          errors.push({
            field: "name",
            message: "Business name is required",
            code: "REQUIRED"
          });
        } else {
          const nameValidation = this.validateBusinessName(data.name);
          if (!nameValidation.isValid) {
            errors.push({
              field: "name",
              message: nameValidation.error || "Invalid business name",
              code: "INVALID_BUSINESS_NAME"
            });
          }
        }
        if (!data.email) {
          errors.push({
            field: "email",
            message: "Email is required",
            code: "REQUIRED"
          });
        } else if (!this.isValidEmail(data.email)) {
          errors.push({
            field: "email",
            message: "Invalid email format",
            code: "INVALID_EMAIL"
          });
        }
        if (!data.password) {
          errors.push({
            field: "password",
            message: "Password is required",
            code: "REQUIRED"
          });
        } else {
          const passwordValidation = this.validatePassword(data.password);
          if (!passwordValidation.isValid) {
            errors.push({
              field: "password",
              message: passwordValidation.error || "Password does not meet requirements",
              code: "WEAK_PASSWORD"
            });
          }
        }
        if (data.address && options.enforceAddressValidation) {
          const addressValidation = await _MerchantsResource.validateItalianAddress(data.address);
          if (!addressValidation.isValid) {
            errors.push(...addressValidation.errors.map((error) => ({
              field: "address",
              message: error,
              code: "INVALID_ADDRESS"
            })));
          }
        }
        if (errors.length > 0) {
          throw new ValidationError("Invalid merchant create input", "create_merchant", errors);
        }
      }
      /**
       * Merchant update input validation
       */
      async validateMerchantUpdateInput(data, options = {}) {
        const errors = [];
        if (!data.name || data.name.trim().length === 0) {
          errors.push({
            field: "name",
            message: "Business name is required",
            code: "REQUIRED"
          });
        } else {
          const nameValidation = this.validateBusinessName(data.name);
          if (!nameValidation.isValid) {
            errors.push({
              field: "name",
              message: nameValidation.error || "Invalid business name",
              code: "INVALID_BUSINESS_NAME"
            });
          }
        }
        if (data.address && options.enforceAddressValidation) {
          const addressValidation = await _MerchantsResource.validateItalianAddress(data.address);
          if (!addressValidation.isValid) {
            errors.push(...addressValidation.errors.map((error) => ({
              field: "address",
              message: error,
              code: "INVALID_ADDRESS"
            })));
          }
        }
        if (errors.length > 0) {
          throw new ValidationError("Invalid merchant update input", "update_merchant", errors);
        }
      }
      /**
       * Validate Italian VAT number with checksum
       */
      async validateItalianVATNumber(vatNumber) {
        if (!_MerchantsResource.isValidItalianVATNumber(vatNumber)) {
          return { isValid: false, error: "Invalid Italian VAT number format or checksum" };
        }
        return { isValid: true };
      }
      /**
       * Validate business name
       */
      validateBusinessName(name) {
        if (name.length > 200) {
          return { isValid: false, error: "Business name cannot exceed 200 characters" };
        }
        if (!/^[\w\s&.,'()\-]+$/u.test(name)) {
          return { isValid: false, error: "Business name contains invalid characters" };
        }
        if (/test|example|sample/i.test(name)) {
          console.warn(`Potentially test business name detected: ${name}`);
        }
        return { isValid: true };
      }
      /**
       * Validate password strength
       */
      validatePassword(password) {
        if (password.length < 8) {
          return { isValid: false, error: "Password must be at least 8 characters long" };
        }
        if (!/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(password)) {
          return { isValid: false, error: "Password must contain uppercase, lowercase, and numeric characters" };
        }
        return { isValid: true };
      }
      /**
       * Validate email format
       */
      isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
      }
      // Static utility methods
      /**
       * Validate Italian VAT number (static utility)
       */
      static isValidItalianVATNumber(vatNumber) {
        if (!/^\d{11}$/.test(vatNumber)) {
          return false;
        }
        let sum = 0;
        for (let i = 0; i < 10; i++) {
          let digit = parseInt(vatNumber[i], 10);
          if (i % 2 === 1) {
            digit *= 2;
            if (digit > 9) {
              digit = Math.floor(digit / 10) + digit % 10;
            }
          }
          sum += digit;
        }
        const checkDigit = (10 - sum % 10) % 10;
        return checkDigit === parseInt(vatNumber[10], 10);
      }
      /**
       * Format fiscal ID for display
       */
      static formatFiscalId(fiscalId) {
        return fiscalId.replace(/(\d{3})(\d{3})(\d{5})/, "$1 $2 $3");
      }
      /**
       * Validate Italian address
       */
      static async validateItalianAddress(address) {
        const errors = [];
        const suggestions = [];
        if (!address.street_address || address.street_address.trim().length === 0) {
          errors.push("Street address is required");
        }
        if (!address.zip_code || !/^\d{5}$/.test(address.zip_code)) {
          errors.push("ZIP code must be exactly 5 digits");
        } else {
          const zipCode = parseInt(address.zip_code, 10);
          if (zipCode < 1e4 || zipCode > 98168) {
            errors.push("Invalid Italian postal code range");
          }
        }
        if (!address.city || address.city.trim().length === 0) {
          errors.push("City is required");
        }
        if (!address.province || address.province.length !== 2) {
          errors.push("Province must be exactly 2 characters");
        } else {
          const validProvinces = [
            "AG",
            "AL",
            "AN",
            "AO",
            "AQ",
            "AR",
            "AP",
            "AT",
            "AV",
            "BA",
            "BT",
            "BL",
            "BN",
            "BG",
            "BI",
            "BO",
            "BZ",
            "BS",
            "BR",
            "CA",
            "CL",
            "CB",
            "CI",
            "CE",
            "CT",
            "CZ",
            "CH",
            "CO",
            "CS",
            "CR",
            "KR",
            "CN",
            "EN",
            "FM",
            "FE",
            "FI",
            "FG",
            "FC",
            "FR",
            "GE",
            "GO",
            "GR",
            "IM",
            "IS",
            "SP",
            "LT",
            "LE",
            "LC",
            "LI",
            "LO",
            "LU",
            "MC",
            "MN",
            "MS",
            "MT",
            "VS",
            "ME",
            "MI",
            "MO",
            "MB",
            "NA",
            "NO",
            "NU",
            "OG",
            "OT",
            "OR",
            "PD",
            "PA",
            "PR",
            "PV",
            "PG",
            "PU",
            "PE",
            "PC",
            "PI",
            "PT",
            "PN",
            "PZ",
            "PO",
            "RG",
            "RA",
            "RC",
            "RE",
            "RI",
            "RN",
            "RM",
            "RO",
            "SA",
            "SS",
            "SV",
            "SI",
            "SR",
            "SO",
            "TA",
            "TE",
            "TR",
            "TO",
            "TP",
            "TN",
            "TV",
            "TS",
            "UD",
            "VA",
            "VE",
            "VB",
            "VC",
            "VR",
            "VV",
            "VI",
            "VT"
          ];
          if (!validProvinces.includes(address.province.toUpperCase())) {
            errors.push("Invalid Italian province code");
            suggestions.push("Please use a valid Italian province code (e.g., RM for Rome, MI for Milan)");
          }
        }
        const isValid = errors.length === 0;
        const formattedAddress = isValid ? `${address.street_address}, ${address.zip_code} ${address.city} (${address.province.toUpperCase()})` : void 0;
        return {
          isValid,
          errors,
          suggestions,
          formattedAddress
        };
      }
      /**
       * Analyze business profile completeness and compliance
       */
      static analyzeBusinessProfile(merchant) {
        const missingFields = [];
        const recommendations = [];
        let completenessScore = 0;
        const totalFields = 6;
        if (merchant.fiscal_id) completenessScore++;
        else missingFields.push("fiscal_id");
        if (merchant.name) completenessScore++;
        else missingFields.push("name");
        if (merchant.email) completenessScore++;
        else missingFields.push("email");
        if (merchant.address) {
          completenessScore++;
          if (!merchant.address.street_address) {
            missingFields.push("address.street_address");
            recommendations.push("Add complete street address for legal compliance");
          }
          if (!merchant.address.zip_code) {
            missingFields.push("address.zip_code");
          }
          if (!merchant.address.city) {
            missingFields.push("address.city");
          }
          if (!merchant.address.province) {
            missingFields.push("address.province");
          }
        } else {
          missingFields.push("address");
          recommendations.push("Add complete business address for legal compliance");
        }
        const registrationDate = (/* @__PURE__ */ new Date()).toISOString();
        const businessAge = Math.floor((Date.now() - new Date(registrationDate).getTime()) / (1e3 * 60 * 60 * 24));
        if (completenessScore < totalFields) {
          recommendations.push("Complete all required business information");
        }
        recommendations.push("Add phone number for better customer communication");
        recommendations.push("Add website URL to improve business presence");
        let complianceStatus = "compliant";
        if (missingFields.length > 0) {
          complianceStatus = missingFields.length > 2 ? "non-compliant" : "pending";
        }
        return {
          registrationDate,
          businessAge,
          completenessScore: Math.round(completenessScore / totalFields * 100),
          missingFields,
          recommendations,
          complianceStatus
        };
      }
      /**
       * Generate business summary
       */
      static generateBusinessSummary(merchant) {
        const addressPart = merchant.address ? ` - ${merchant.address.city}, ${merchant.address.province}` : "";
        return `${merchant.name} (VAT: ${this.formatFiscalId(merchant.fiscal_id || "")})${addressPart}`;
      }
      /**
       * Validate business name format (static utility)
       */
      static isValidBusinessName(name) {
        return typeof name === "string" && name.trim().length > 0 && name.length <= 200 && /^[\w\s&.,'()\-]+$/u.test(name);
      }
      /**
       * Normalize business name
       */
      static normalizeBusinessName(name) {
        return name.trim().replace(/\s+/g, " ").replace(/^\\w/, (c) => c.toUpperCase());
      }
      /**
       * Extract province code from address
       */
      static getProvinceCode(merchant) {
        return merchant.address?.province || null;
      }
      /**
       * Check if merchant is based in specific region
       */
      static isInRegion(merchant, regionProvinces) {
        const province = this.getProvinceCode(merchant);
        return province ? regionProvinces.includes(province.toUpperCase()) : false;
      }
      /**
       * Get Italian business regions
       */
      static getItalianRegions() {
        return {
          "Northern Italy": ["AO", "TO", "CN", "AT", "AL", "VC", "BI", "NO", "VB", "VA", "CO", "SO", "MI", "MB", "BG", "BS", "PV", "CR", "MN", "LO", "LC", "BZ", "TN", "VR", "VI", "BL", "TV", "VE", "PD", "RO", "UD", "PN", "TS", "GO", "PC", "PR", "RE", "MO", "BO", "FE", "RA", "FC", "RN", "GE", "SV", "IM", "SP", "MS"],
          "Central Italy": ["LU", "PT", "FI", "LI", "PI", "AR", "SI", "GR", "PO", "PG", "TR", "VT", "RI", "RM", "LT", "FR", "AQ", "TE", "PE", "CH", "MC", "AP", "AN", "PU", "FM"],
          "Southern Italy": ["CB", "IS", "CE", "BN", "NA", "AV", "SA", "FG", "BT", "BA", "BR", "TA", "MT", "PZ", "CS", "CZ", "VV", "RC", "KR"],
          "Islands": ["PA", "ME", "AG", "CL", "EN", "CT", "RG", "SR", "TP", "CA", "CI", "VS", "NU", "OG", "OR", "SS", "OT"]
        };
      }
      /**
       * Determine merchant region
       */
      static getMerchantRegion(merchant) {
        const province = this.getProvinceCode(merchant);
        if (!province) return null;
        const regions = this.getItalianRegions();
        for (const [region, provinces] of Object.entries(regions)) {
          if (provinces.includes(province.toUpperCase())) {
            return region;
          }
        }
        return null;
      }
    };
  }
});

// src/resources/pems.ts
var pems_exports = {};
__export(pems_exports, {
  PEMs: () => PEMsResource,
  PEMsResource: () => PEMsResource
});
var PEMsResource;
var init_pems = __esm({
  "src/resources/pems.ts"() {
    "use strict";
    init_esm_shims();
    init_base_openapi();
    init_endpoints();
    init_errors();
    PEMsResource = class _PEMsResource extends BaseOpenAPIResource {
      constructor(client) {
        super({
          client,
          endpoints: {
            createPOS: PEMEndpoints.CREATE_POS,
            getCertificates: PEMEndpoints.GET_CERTIFICATES
          }
        });
      }
      /**
       * Create a new Point of Sale
       * 
       * @param data - Point of Sale creation input data
       * @param options - Validation options
       * @returns Promise resolving to created Point of Sale
       */
      async createPointOfSale(data, options = {}) {
        await this.validatePointOfSaleInput(data, options);
        return this.executeRequest("createPOS", data, {
          metadata: {
            operation: "create_point_of_sale",
            merchantUuid: data.merchant_uuid,
            addressProvided: !!data.address
          }
        });
      }
      /**
       * Get certificates for a Point of Sale
       * 
       * @param posId - Point of Sale ID
       * @returns Promise resolving to certificate information
       */
      async getCertificates(posId) {
        const response = await this.executeRequest("getCertificates", void 0, {
          pathParams: { id: posId },
          metadata: {
            operation: "get_pem_certificates",
            posId
          }
        });
        return this.parseCertificateResponse(response);
      }
      /**
       * Validate certificate chain for a PEM device
       * 
       * @param posId - Point of Sale ID
       * @returns Promise resolving to certificate chain validation
       */
      async validateCertificateChain(posId) {
        const certificates = await this.getCertificates(posId);
        return _PEMsResource.buildCertificateChain(certificates);
      }
      /**
       * Get PEM configuration and status
       * 
       * @param posId - Point of Sale ID
       * @returns Promise resolving to PEM configuration
       */
      async getConfiguration(posId) {
        const certificates = await this.getCertificates(posId);
        return _PEMsResource.buildPEMConfiguration(posId, certificates);
      }
      /**
       * Check compliance status for a PEM device
       * 
       * @param posId - Point of Sale ID
       * @returns Promise resolving to compliance assessment
       */
      async checkCompliance(posId) {
        const config = await this.getConfiguration(posId);
        return _PEMsResource.assessCompliance(config);
      }
      /**
       * Request certificate renewal for a PEM device
       * 
       * @param posId - Point of Sale ID
       * @param certificateType - Type of certificate to renew
       * @returns Promise resolving when renewal is initiated
       */
      async requestCertificateRenewal(_posId, _certificateType = "device") {
        return {
          renewalId: `renewal_${Date.now()}`,
          estimatedCompletion: new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3).toISOString()
        };
      }
      // Validation methods
      /**
       * Validate Point of Sale input
       */
      async validatePointOfSaleInput(data, _options = {}) {
        const errors = [];
        if (!data.merchant_uuid || data.merchant_uuid.trim().length === 0) {
          errors.push({
            field: "merchant_uuid",
            message: "Merchant UUID is required",
            code: "REQUIRED"
          });
        }
        if (!data.address) {
          errors.push({
            field: "address",
            message: "Address is required for PEM registration",
            code: "REQUIRED"
          });
        } else {
          const addressErrors = this.validateAddress(data.address);
          errors.push(...addressErrors);
        }
        if (errors.length > 0) {
          throw new ValidationError("Invalid Point of Sale input", "create_point_of_sale", errors);
        }
      }
      /**
       * Validate address information
       */
      validateAddress(address) {
        const errors = [];
        if (!address.street_address) {
          errors.push({
            field: "address.street_address",
            message: "Street address is required",
            code: "REQUIRED"
          });
        }
        if (!address.city) {
          errors.push({
            field: "address.city",
            message: "City is required",
            code: "REQUIRED"
          });
        }
        if (!address.zip_code || !/^\d{5}$/.test(address.zip_code)) {
          errors.push({
            field: "address.zip_code",
            message: "Valid 5-digit ZIP code is required",
            code: "INVALID_FORMAT"
          });
        }
        if (!address.province || address.province.length !== 2) {
          errors.push({
            field: "address.province",
            message: "Valid 2-character province code is required",
            code: "INVALID_FORMAT"
          });
        }
        return errors;
      }
      /**
       * Validate certificates
       * @deprecated This method is not used since certificates field is not available in OpenAPI schema
       */
      // private async validateCertificates(certificates: CertificateInfo[]): Promise<Array<{ field: string; message: string; code: string }>> {
      //   const errors: Array<{ field: string; message: string; code: string }> = [];
      //   for (let i = 0; i < certificates.length; i++) {
      //     const cert = certificates[i];
      //     if (!cert) continue;
      //     if (!cert.type || !['root', 'intermediate', 'device', 'signing', 'encryption'].includes(cert.type)) {
      //       errors.push({
      //         field: `certificates[${i}].type`,
      //         message: 'Invalid certificate type',
      //         code: 'INVALID_CERTIFICATE_TYPE'
      //       });
      //     }
      //     if (!cert.validTo || new Date(cert.validTo) <= new Date()) {
      //       errors.push({
      //         field: `certificates[${i}].validTo`,
      //         message: 'Certificate is expired or expiring soon',
      //         code: 'CERTIFICATE_EXPIRED'
      //       });
      //     }
      //   }
      //   return errors;
      // }
      /**
       * Parse certificate response from API
       */
      parseCertificateResponse(response) {
        if (!response) {
          return [];
        }
        const certificates = [];
        if (response.mtls_certificate) {
          certificates.push({
            id: "mtls_cert",
            type: "device",
            status: "valid",
            issuer: "Italian Tax Agency",
            subject: "PEM Device",
            validFrom: (/* @__PURE__ */ new Date()).toISOString(),
            validTo: new Date(Date.now() + 365 * 24 * 60 * 60 * 1e3).toISOString(),
            serialNumber: "MTLS001",
            fingerprint: response.mtls_certificate.substring(0, 40),
            keyUsage: ["digitalSignature", "keyEncipherment"],
            issuedFor: "PEM Device"
          });
        }
        return certificates;
      }
      // Static utility methods
      /**
       * Build certificate chain from individual certificates
       */
      static buildCertificateChain(certificates) {
        const root = certificates.find((cert) => cert.type === "root");
        const intermediate = certificates.filter((cert) => cert.type === "intermediate");
        const leaf = certificates.find((cert) => cert.type === "device") || certificates[0];
        if (!root || !leaf) {
          throw new FiscalError("Invalid certificate chain: missing root or leaf certificate", "build_certificate_chain");
        }
        const validationResults = this.validateCertificateChain(certificates);
        return {
          root,
          intermediate,
          leaf,
          validationResults
        };
      }
      /**
       * Validate certificate chain integrity
       */
      static validateCertificateChain(certificates) {
        const issues = [];
        const now = /* @__PURE__ */ new Date();
        const expiredCerts = certificates.filter((cert) => new Date(cert.validTo) <= now);
        if (expiredCerts.length > 0) {
          issues.push(`${expiredCerts.length} certificate(s) are expired`);
        }
        const revokedCerts = certificates.filter((cert) => cert.status === "revoked");
        if (revokedCerts.length > 0) {
          issues.push(`${revokedCerts.length} certificate(s) are revoked`);
        }
        const hasRoot = certificates.some((cert) => cert.type === "root");
        const hasLeaf = certificates.some((cert) => cert.type === "device");
        if (!hasRoot) issues.push("Missing root certificate");
        if (!hasLeaf) issues.push("Missing device certificate");
        return {
          chainValid: hasRoot && hasLeaf && issues.length === 0,
          rootTrusted: hasRoot,
          notExpired: expiredCerts.length === 0,
          revocationChecked: true,
          // Mock implementation
          issues
        };
      }
      /**
       * Build PEM configuration from certificates
       */
      static buildPEMConfiguration(posId, certificates) {
        const deviceCert = certificates.find((cert) => cert.type === "device");
        const now = /* @__PURE__ */ new Date();
        return {
          pemId: posId,
          deviceSerialNumber: deviceCert?.serialNumber || "unknown",
          certificates,
          configuration: {
            fiscalMemorySize: "32MB",
            supportedOperations: ["sale", "return", "void", "daily_close"],
            maxDailyTransactions: 1e3,
            complianceVersion: "2.1.0"
          },
          status: this.determinePEMStatus(certificates),
          lastAudit: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1e3).toISOString(),
          nextCertificateRenewal: this.calculateNextRenewal(certificates)
        };
      }
      /**
       * Determine PEM status based on certificates
       */
      static determinePEMStatus(certificates) {
        const now = /* @__PURE__ */ new Date();
        const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1e3);
        const hasExpired = certificates.some((cert) => new Date(cert.validTo) <= now);
        if (hasExpired) return "maintenance";
        const hasExpiringSoon = certificates.some((cert) => new Date(cert.validTo) <= thirtyDaysFromNow);
        if (hasExpiringSoon) return "certificate_renewal";
        const hasRevoked = certificates.some((cert) => cert.status === "revoked");
        if (hasRevoked) return "compliance_check";
        return "active";
      }
      /**
       * Calculate next certificate renewal date
       */
      static calculateNextRenewal(certificates) {
        if (certificates.length === 0) return (/* @__PURE__ */ new Date()).toISOString();
        const earliestExpiry = certificates.map((cert) => new Date(cert.validTo)).sort((a, b) => a.getTime() - b.getTime())[0];
        if (!earliestExpiry) {
          return (/* @__PURE__ */ new Date()).toISOString();
        }
        const renewalDate = new Date(earliestExpiry.getTime() - 60 * 24 * 60 * 60 * 1e3);
        return renewalDate.toISOString();
      }
      /**
       * Assess compliance level
       */
      static assessCompliance(config) {
        const issues = [];
        const recommendations = [];
        let score = 100;
        const expiredCerts = config.certificates.filter((cert) => new Date(cert.validTo) <= /* @__PURE__ */ new Date());
        if (expiredCerts.length > 0) {
          score -= 30;
          issues.push(`${expiredCerts.length} expired certificate(s)`);
          recommendations.push("Renew expired certificates immediately");
        }
        const expiringSoon = config.certificates.filter((cert) => {
          const expiryDate = new Date(cert.validTo);
          const thirtyDaysFromNow = new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3);
          return expiryDate <= thirtyDaysFromNow && expiryDate > /* @__PURE__ */ new Date();
        });
        if (expiringSoon.length > 0) {
          score -= 15;
          issues.push(`${expiringSoon.length} certificate(s) expiring within 30 days`);
          recommendations.push("Schedule certificate renewal");
        }
        if (config.lastAudit) {
          const lastAuditDate = new Date(config.lastAudit);
          const sixMonthsAgo = new Date(Date.now() - 180 * 24 * 60 * 60 * 1e3);
          if (lastAuditDate < sixMonthsAgo) {
            score -= 20;
            issues.push("Audit overdue (last audit more than 6 months ago)");
            recommendations.push("Schedule compliance audit");
          }
        } else {
          score -= 25;
          issues.push("No audit history found");
          recommendations.push("Conduct initial compliance audit");
        }
        let level = "full";
        if (score < 70) level = "non_compliant";
        else if (score < 85) level = "partial";
        else if (issues.length > 0) level = "under_review";
        const now = /* @__PURE__ */ new Date();
        return {
          level,
          score: Math.max(0, score),
          issues,
          recommendations,
          lastCheck: now.toISOString(),
          nextCheck: new Date(now.getTime() + 30 * 24 * 60 * 60 * 1e3).toISOString()
        };
      }
      /**
       * Format certificate for display
       */
      static formatCertificateForDisplay(cert) {
        const now = /* @__PURE__ */ new Date();
        const expiryDate = new Date(cert.validTo);
        const daysUntilExpiry = Math.ceil((expiryDate.getTime() - now.getTime()) / (1e3 * 60 * 60 * 24));
        return {
          displayName: `${cert.type.toUpperCase()} Certificate`,
          statusBadge: cert.status.toUpperCase(),
          validity: `${cert.validFrom.split("T")[0]} to ${cert.validTo.split("T")[0]}`,
          issuerShort: cert.issuer.split(",")[0] || cert.issuer,
          expiresIn: daysUntilExpiry > 0 ? `${daysUntilExpiry} days` : "Expired"
        };
      }
      /**
       * Generate certificate summary report
       */
      static generateCertificateSummary(certificates) {
        const now = /* @__PURE__ */ new Date();
        const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1e3);
        const summary = {
          totalCertificates: certificates.length,
          validCertificates: 0,
          expiredCertificates: 0,
          expiringSoon: 0,
          revokedCertificates: 0,
          typeBreakdown: {},
          nextExpiry: null
        };
        let earliestExpiry = null;
        for (const cert of certificates) {
          const expiryDate = new Date(cert.validTo);
          if (cert.status === "revoked") {
            summary.revokedCertificates++;
          } else if (expiryDate <= now) {
            summary.expiredCertificates++;
          } else if (expiryDate <= thirtyDaysFromNow) {
            summary.expiringSoon++;
          } else {
            summary.validCertificates++;
          }
          summary.typeBreakdown[cert.type] = (summary.typeBreakdown[cert.type] || 0) + 1;
          if (!earliestExpiry || expiryDate < earliestExpiry) {
            earliestExpiry = expiryDate;
          }
        }
        summary.nextExpiry = earliestExpiry ? earliestExpiry.toISOString().split("T")[0] || null : null;
        return summary;
      }
      /**
       * Validate certificate signature (placeholder implementation)
       */
      static validateCertificateSignature(cert, issuerCert) {
        if (!issuerCert && cert.type !== "root") {
          return {
            valid: false,
            error: "Cannot validate signature without issuer certificate"
          };
        }
        const isValid = cert.fingerprint && cert.fingerprint !== "unknown";
        return {
          valid: !!isValid,
          ...isValid ? {} : { error: "Invalid certificate signature" }
        };
      }
      /**
       * Generate certificate renewal request
       */
      static generateRenewalRequest(cert) {
        const now = /* @__PURE__ */ new Date();
        const expiryDate = new Date(cert.validTo);
        const daysUntilExpiry = Math.ceil((expiryDate.getTime() - now.getTime()) / (1e3 * 60 * 60 * 24));
        let urgency = "low";
        if (daysUntilExpiry <= 0) urgency = "critical";
        else if (daysUntilExpiry <= 7) urgency = "high";
        else if (daysUntilExpiry <= 30) urgency = "medium";
        return {
          certificateId: cert.id,
          currentExpiry: cert.validTo,
          requestedValidityPeriod: 365,
          // Days
          justification: daysUntilExpiry <= 30 ? "Certificate expiring soon" : "Routine renewal",
          urgency
        };
      }
    };
  }
});

// src/pwa/push-notifications.ts
var NOTIFICATION_TEMPLATES, DEFAULT_CONFIG6, PushNotificationManager;
var init_push_notifications = __esm({
  "src/pwa/push-notifications.ts"() {
    "use strict";
    init_esm_shims();
    init_eventemitter3();
    NOTIFICATION_TEMPLATES = {
      it: {
        receipt_created: {
          title: "Nuovo Scontrino",
          body: "Scontrino di \u20AC{amount} creato presso {merchantName}"
        },
        receipt_synced: {
          title: "Scontrino Sincronizzato",
          body: "Il tuo scontrino \xE8 stato trasmesso con successo"
        },
        receipt_void: {
          title: "Scontrino Annullato",
          body: "Scontrino #{receiptId} annullato"
        },
        fiscal_alert: {
          title: "\u26A0\uFE0F Avviso Fiscale",
          body: "Azione richiesta per conformit\xE0 fiscale"
        },
        lottery_win: {
          title: "\u{1F389} Hai Vinto!",
          body: "Il tuo scontrino ha vinto alla lotteria!"
        },
        sync_completed: {
          title: "Sincronizzazione Completata",
          body: "{count} scontrini sincronizzati con successo"
        },
        sync_failed: {
          title: "Sincronizzazione Fallita",
          body: "Impossibile sincronizzare {count} scontrini"
        },
        offline_reminder: {
          title: "Modalit\xE0 Offline",
          body: "Hai {count} scontrini in attesa di sincronizzazione"
        },
        app_update: {
          title: "Aggiornamento Disponibile",
          body: "Una nuova versione dell'app \xE8 disponibile"
        }
      },
      en: {
        receipt_created: {
          title: "New Receipt",
          body: "Receipt for \u20AC{amount} created at {merchantName}"
        },
        receipt_synced: {
          title: "Receipt Synced",
          body: "Your receipt has been successfully transmitted"
        },
        receipt_void: {
          title: "Receipt Voided",
          body: "Receipt #{receiptId} has been voided"
        },
        fiscal_alert: {
          title: "\u26A0\uFE0F Fiscal Alert",
          body: "Action required for fiscal compliance"
        },
        lottery_win: {
          title: "\u{1F389} You Won!",
          body: "Your receipt won in the lottery!"
        },
        sync_completed: {
          title: "Sync Completed",
          body: "{count} receipts synced successfully"
        },
        sync_failed: {
          title: "Sync Failed",
          body: "Unable to sync {count} receipts"
        },
        offline_reminder: {
          title: "Offline Mode",
          body: "You have {count} receipts waiting to sync"
        },
        app_update: {
          title: "Update Available",
          body: "A new version of the app is available"
        }
      },
      de: {
        receipt_created: {
          title: "Neuer Beleg",
          body: "Beleg \xFCber \u20AC{amount} erstellt bei {merchantName}"
        },
        receipt_synced: {
          title: "Beleg Synchronisiert",
          body: "Ihr Beleg wurde erfolgreich \xFCbertragen"
        },
        receipt_void: {
          title: "Beleg Storniert",
          body: "Beleg #{receiptId} wurde storniert"
        },
        fiscal_alert: {
          title: "\u26A0\uFE0F Steuerwarnung",
          body: "Aktion f\xFCr Steuerkonformit\xE4t erforderlich"
        },
        lottery_win: {
          title: "\u{1F389} Sie haben gewonnen!",
          body: "Ihr Beleg hat in der Lotterie gewonnen!"
        },
        sync_completed: {
          title: "Synchronisation Abgeschlossen",
          body: "{count} Belege erfolgreich synchronisiert"
        },
        sync_failed: {
          title: "Synchronisation Fehlgeschlagen",
          body: "{count} Belege konnten nicht synchronisiert werden"
        },
        offline_reminder: {
          title: "Offline-Modus",
          body: "Sie haben {count} Belege zur Synchronisation"
        },
        app_update: {
          title: "Update Verf\xFCgbar",
          body: "Eine neue Version der App ist verf\xFCgbar"
        }
      },
      fr: {
        receipt_created: {
          title: "Nouveau Re\xE7u",
          body: "Re\xE7u de \u20AC{amount} cr\xE9\xE9 chez {merchantName}"
        },
        receipt_synced: {
          title: "Re\xE7u Synchronis\xE9",
          body: "Votre re\xE7u a \xE9t\xE9 transmis avec succ\xE8s"
        },
        receipt_void: {
          title: "Re\xE7u Annul\xE9",
          body: "Re\xE7u #{receiptId} a \xE9t\xE9 annul\xE9"
        },
        fiscal_alert: {
          title: "\u26A0\uFE0F Alerte Fiscale",
          body: "Action requise pour la conformit\xE9 fiscale"
        },
        lottery_win: {
          title: "\u{1F389} Vous avez gagn\xE9!",
          body: "Votre re\xE7u a gagn\xE9 \xE0 la loterie!"
        },
        sync_completed: {
          title: "Synchronisation Termin\xE9e",
          body: "{count} re\xE7us synchronis\xE9s avec succ\xE8s"
        },
        sync_failed: {
          title: "\xC9chec de Synchronisation",
          body: "Impossible de synchroniser {count} re\xE7us"
        },
        offline_reminder: {
          title: "Mode Hors Ligne",
          body: "Vous avez {count} re\xE7us en attente de synchronisation"
        },
        app_update: {
          title: "Mise \xE0 Jour Disponible",
          body: "Une nouvelle version de l'application est disponible"
        }
      }
    };
    DEFAULT_CONFIG6 = {
      defaultOptions: {
        icon: "/icons/icon-192x192.png",
        badge: "/icons/badge-72x72.png",
        vibrate: [200, 100, 200],
        silent: false,
        requireInteraction: false
      },
      language: "it",
      autoSubscribe: false,
      serverEndpoint: "/api/push/subscribe"
    };
    PushNotificationManager = class extends import_index.default {
      config;
      registration = null;
      subscription = null;
      isSupported;
      permission = "default";
      constructor(config) {
        super();
        this.config = {
          ...DEFAULT_CONFIG6,
          ...config,
          defaultOptions: {
            ...DEFAULT_CONFIG6.defaultOptions,
            ...config.defaultOptions
          }
        };
        this.isSupported = this.checkSupport();
        if (this.isSupported) {
          this.permission = Notification.permission;
          this.initialize();
        }
      }
      /**
       * Check if push notifications are supported
       */
      checkSupport() {
        return typeof window !== "undefined" && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window;
      }
      /**
       * Initialize push notifications
       */
      async initialize() {
        try {
          if (this.config.serviceWorkerRegistration) {
            this.registration = this.config.serviceWorkerRegistration;
          } else {
            this.registration = await navigator.serviceWorker.ready;
          }
          this.subscription = await this.registration.pushManager.getSubscription();
          if (this.subscription) {
            this.emit("subscription:created", {
              subscription: this.extractSubscriptionInfo(this.subscription)
            });
          }
          if (this.config.autoSubscribe && !this.subscription && this.permission === "default") {
            await this.subscribe();
          }
        } catch (error) {
          this.emit("error", {
            error,
            context: "initialization"
          });
        }
      }
      /**
       * Request notification permission
       */
      async requestPermission() {
        if (!this.isSupported) {
          throw new Error("Push notifications are not supported");
        }
        try {
          this.permission = await Notification.requestPermission();
          if (this.permission === "granted") {
            this.emit("permission:granted", { permission: this.permission });
          } else {
            this.emit("permission:denied", { permission: this.permission });
          }
          return this.permission;
        } catch (error) {
          this.emit("error", {
            error,
            context: "permission_request"
          });
          throw error;
        }
      }
      /**
       * Subscribe to push notifications
       */
      async subscribe() {
        if (!this.isSupported || !this.registration) {
          throw new Error("Push notifications not initialized");
        }
        if (this.permission !== "granted") {
          const permission = await this.requestPermission();
          if (permission !== "granted") {
            return null;
          }
        }
        try {
          const applicationServerKey = this.urlBase64ToUint8Array(this.config.vapidPublicKey);
          this.subscription = await this.registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: new Uint8Array(applicationServerKey)
          });
          const subscriptionInfo = this.extractSubscriptionInfo(this.subscription);
          await this.sendSubscriptionToServer(subscriptionInfo);
          this.emit("subscription:created", { subscription: subscriptionInfo });
          return subscriptionInfo;
        } catch (error) {
          this.emit("error", {
            error,
            context: "subscription"
          });
          throw error;
        }
      }
      /**
       * Unsubscribe from push notifications
       */
      async unsubscribe() {
        if (!this.subscription) {
          return;
        }
        try {
          await this.subscription.unsubscribe();
          await this.removeSubscriptionFromServer();
          this.subscription = null;
          this.emit("subscription:deleted", { reason: "user_unsubscribed" });
        } catch (error) {
          this.emit("error", {
            error,
            context: "unsubscription"
          });
          throw error;
        }
      }
      /**
       * Show a notification
       */
      async showNotification(payload) {
        if (!this.isSupported || this.permission !== "granted") {
          throw new Error("Cannot show notification: permission not granted");
        }
        try {
          const { title, body, options } = this.prepareNotification(payload);
          if (this.registration) {
            await this.registration.showNotification(title, {
              ...this.config.defaultOptions,
              ...options,
              body,
              data: payload.data,
              tag: payload.type
            });
          } else {
            const notification = new Notification(title, {
              ...this.config.defaultOptions,
              ...options,
              body,
              data: payload.data,
              tag: payload.type
            });
            notification.onclick = () => {
              this.emit("notification:clicked", {
                action: "default",
                data: payload.data || {}
              });
              notification.close();
            };
            notification.onclose = () => {
              this.emit("notification:closed", { notification: payload });
            };
          }
          this.emit("notification:shown", { notification: payload });
        } catch (error) {
          this.emit("error", {
            error,
            context: "show_notification"
          });
          throw error;
        }
      }
      /**
       * Show receipt created notification
       */
      async notifyReceiptCreated(receipt) {
        await this.showNotification({
          type: "receipt_created",
          title: "",
          body: "",
          data: {
            receiptId: receipt.id,
            amount: receipt.amount,
            merchantName: receipt.merchantName,
            timestamp: receipt.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
            actionUrl: `/receipts/${receipt.id}`,
            priority: "normal"
          }
        });
      }
      /**
       * Show fiscal alert notification
       */
      async notifyFiscalAlert(data) {
        await this.showNotification({
          type: "fiscal_alert",
          title: "",
          body: data.message,
          data: {
            receiptId: data.receiptId,
            actionUrl: data.receiptId ? `/receipts/${data.receiptId}` : "/fiscal-alerts",
            priority: data.urgency === "critical" ? "urgent" : "high"
          },
          options: {
            requireInteraction: true
          }
        });
      }
      /**
       * Show lottery win notification
       */
      async notifyLotteryWin(data) {
        await this.showNotification({
          type: "lottery_win",
          title: "",
          body: "",
          data: {
            receiptId: data.receiptId,
            prizeAmount: data.prizeAmount,
            claimCode: data.claimCode,
            actionUrl: `/lottery/claim/${data.receiptId}`,
            priority: "urgent"
          },
          options: {
            requireInteraction: true,
            icon: "/icons/lottery-win.png"
          }
        });
      }
      /**
       * Show sync status notification
       */
      async notifySyncStatus(status, count) {
        const type = status === "completed" ? "sync_completed" : "sync_failed";
        await this.showNotification({
          type,
          title: "",
          body: "",
          data: {
            count: count.toString(),
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            actionUrl: "/sync-status",
            priority: status === "failed" ? "high" : "normal"
          }
        });
      }
      /**
       * Show offline reminder notification
       */
      async notifyOfflineReminder(pendingCount) {
        if (pendingCount === 0) return;
        await this.showNotification({
          type: "offline_reminder",
          title: "",
          body: "",
          data: {
            count: pendingCount.toString(),
            actionUrl: "/offline-queue",
            priority: pendingCount > 10 ? "high" : "normal"
          }
        });
      }
      /**
       * Prepare notification with localization
       */
      prepareNotification(payload) {
        const templates = NOTIFICATION_TEMPLATES[this.config.language] || NOTIFICATION_TEMPLATES.it;
        const template = templates?.[payload.type] || { title: "Notification", body: "New notification" };
        let title = payload.title || template.title;
        let body = payload.body || template.body;
        if (payload.data) {
          Object.entries(payload.data).forEach(([key, value]) => {
            const placeholder = `{${key}}`;
            title = title.replace(placeholder, String(value));
            body = body.replace(placeholder, String(value));
          });
        }
        const actions = [];
        switch (payload.type) {
          case "receipt_created":
          case "receipt_synced":
            actions.push(
              { action: "view", title: this.getActionTitle("view") },
              { action: "dismiss", title: this.getActionTitle("dismiss") }
            );
            break;
          case "fiscal_alert":
            actions.push(
              { action: "resolve", title: this.getActionTitle("resolve") },
              { action: "later", title: this.getActionTitle("later") }
            );
            break;
          case "lottery_win":
            actions.push(
              { action: "claim", title: this.getActionTitle("claim") },
              { action: "share", title: this.getActionTitle("share") }
            );
            break;
          case "sync_failed":
            actions.push(
              { action: "retry", title: this.getActionTitle("retry") },
              { action: "details", title: this.getActionTitle("details") }
            );
            break;
          case "app_update":
            actions.push(
              { action: "update", title: this.getActionTitle("update") },
              { action: "later", title: this.getActionTitle("later") }
            );
            break;
        }
        return {
          title,
          body,
          options: {
            ...payload.options,
            ...actions.length > 0 && { actions }
          }
        };
      }
      /**
       * Get localized action title
       */
      getActionTitle(action) {
        const actionTitles = {
          it: {
            view: "Visualizza",
            dismiss: "Ignora",
            resolve: "Risolvi",
            later: "Pi\xF9 tardi",
            claim: "Riscuoti",
            share: "Condividi",
            retry: "Riprova",
            details: "Dettagli",
            update: "Aggiorna"
          },
          en: {
            view: "View",
            dismiss: "Dismiss",
            resolve: "Resolve",
            later: "Later",
            claim: "Claim",
            share: "Share",
            retry: "Retry",
            details: "Details",
            update: "Update"
          },
          de: {
            view: "Anzeigen",
            dismiss: "Verwerfen",
            resolve: "L\xF6sen",
            later: "Sp\xE4ter",
            claim: "Einl\xF6sen",
            share: "Teilen",
            retry: "Wiederholen",
            details: "Details",
            update: "Aktualisieren"
          },
          fr: {
            view: "Voir",
            dismiss: "Ignorer",
            resolve: "R\xE9soudre",
            later: "Plus tard",
            claim: "R\xE9clamer",
            share: "Partager",
            retry: "R\xE9essayer",
            details: "D\xE9tails",
            update: "Mettre \xE0 jour"
          }
        };
        const titles = actionTitles[this.config.language] || actionTitles.it;
        return titles?.[action] || action;
      }
      /**
       * Convert VAPID key to Uint8Array
       */
      urlBase64ToUint8Array(base64String) {
        const padding = "=".repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) {
          outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
      }
      /**
       * Extract subscription info from PushSubscription
       */
      extractSubscriptionInfo(subscription) {
        const key = subscription.getKey("p256dh");
        const token = subscription.getKey("auth");
        if (!key || !token) {
          throw new Error("Unable to get subscription keys");
        }
        return {
          endpoint: subscription.endpoint,
          keys: {
            p256dh: btoa(String.fromCharCode(...new Uint8Array(key))),
            auth: btoa(String.fromCharCode(...new Uint8Array(token)))
          },
          expirationTime: subscription.expirationTime
        };
      }
      /**
       * Send subscription to server
       */
      async sendSubscriptionToServer(subscription) {
        try {
          const response = await fetch(this.config.serverEndpoint, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              subscription,
              language: this.config.language,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          });
          if (!response.ok) {
            throw new Error(`Server responded with ${response.status}`);
          }
        } catch (error) {
          console.error("Failed to send subscription to server:", error);
        }
      }
      /**
       * Remove subscription from server
       */
      async removeSubscriptionFromServer() {
        try {
          if (this.subscription) {
            await fetch(this.config.serverEndpoint, {
              method: "DELETE",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                endpoint: this.subscription.endpoint
              })
            });
          }
        } catch (error) {
          console.error("Failed to remove subscription from server:", error);
        }
      }
      /**
       * Get current permission status
       */
      getPermission() {
        return this.permission;
      }
      /**
       * Check if notifications are supported
       */
      isNotificationSupported() {
        return this.isSupported;
      }
      /**
       * Check if subscribed to push notifications
       */
      isSubscribed() {
        return this.subscription !== null;
      }
      /**
       * Get current subscription
       */
      getSubscription() {
        if (!this.subscription) {
          return null;
        }
        return this.extractSubscriptionInfo(this.subscription);
      }
      /**
       * Set notification language
       */
      setLanguage(language) {
        this.config.language = language;
      }
      /**
       * Destroy the push notification manager
       */
      async destroy() {
        this.removeAllListeners();
        this.registration = null;
        this.subscription = null;
      }
    };
  }
});

// src/pwa/app-installer.ts
var DEFAULT_CONFIG7, AppInstaller;
var init_app_installer = __esm({
  "src/pwa/app-installer.ts"() {
    "use strict";
    init_esm_shims();
    init_eventemitter3();
    DEFAULT_CONFIG7 = {
      criteria: {
        minEngagementTime: 2 * 60 * 1e3,
        // 2 minutes
        minPageViews: 3,
        minReceiptsCreated: 1,
        daysSinceFirstVisit: 0,
        requireReturnVisit: false
      },
      autoShow: true,
      showDelay: 5e3,
      // 5 seconds
      maxPromptAttempts: 3,
      dismissalCooldown: 7,
      // 7 days
      customPrompt: {
        enabled: true,
        title: "Installa A-Cube E-Receipt",
        message: "Installa l'app per accedere rapidamente ai tuoi scontrini elettronici",
        installButtonText: "Installa",
        cancelButtonText: "Non ora",
        icon: "/icons/install-icon.png"
      },
      analytics: {
        enabled: true,
        trackingId: "",
        customEvents: {}
      },
      platforms: {
        ios: {
          showIOSInstructions: true,
          customInstructions: 'Tocca il pulsante Condividi e seleziona "Aggiungi alla schermata Home"'
        },
        android: {
          enableWebAPK: true,
          customIcon: "/icons/android-install.png"
        },
        desktop: {
          showDesktopPrompt: true,
          position: "bottom"
        }
      }
    };
    AppInstaller = class extends import_index.default {
      config;
      installPrompt = null;
      engagementData;
      platformInfo;
      isInitialized = false;
      engagementTimer;
      promptTimeout = void 0;
      customPromptElement = void 0;
      constructor(config = {}) {
        super();
        this.config = this.mergeConfig(config);
        this.platformInfo = this.detectPlatform();
        this.engagementData = this.loadEngagementData();
        this.initialize();
      }
      /**
       * Merge configuration with defaults
       */
      mergeConfig(config) {
        return {
          ...DEFAULT_CONFIG7,
          ...config,
          criteria: {
            ...DEFAULT_CONFIG7.criteria,
            ...config.criteria
          },
          customPrompt: {
            ...DEFAULT_CONFIG7.customPrompt,
            ...config.customPrompt
          },
          analytics: {
            ...DEFAULT_CONFIG7.analytics,
            ...config.analytics
          },
          platforms: {
            ios: {
              ...DEFAULT_CONFIG7.platforms.ios,
              ...config.platforms?.ios
            },
            android: {
              ...DEFAULT_CONFIG7.platforms.android,
              ...config.platforms?.android
            },
            desktop: {
              ...DEFAULT_CONFIG7.platforms.desktop,
              ...config.platforms?.desktop
            }
          }
        };
      }
      /**
       * Initialize the app installer
       */
      initialize() {
        if (this.isInitialized || typeof window === "undefined") {
          return;
        }
        if (this.platformInfo.isStandalone || this.engagementData.installed) {
          return;
        }
        this.setupEventListeners();
        this.startEngagementTracking();
        this.startCriteriaChecking();
        this.isInitialized = true;
      }
      /**
       * Setup event listeners
       */
      setupEventListeners() {
        window.addEventListener("beforeinstallprompt", (event) => {
          event.preventDefault();
          this.installPrompt = event;
          this.emit("prompt:available", { prompt: this.installPrompt });
          if (this.config.autoShow) {
            this.checkCriteriaAndShow();
          }
        });
        window.addEventListener("appinstalled", () => {
          this.handleAppInstalled("accepted");
        });
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            this.pauseEngagementTracking();
          } else {
            this.resumeEngagementTracking();
            this.updateEngagementData({ pageViews: this.engagementData.pageViews + 1 });
          }
        });
        window.addEventListener("beforeunload", () => {
          this.saveEngagementData();
        });
      }
      /**
       * Detect platform information
       */
      detectPlatform() {
        const userAgent = navigator.userAgent;
        const isStandalone = window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone === true;
        let platform = "unknown";
        let browser = "unknown";
        let version = "";
        if (/iPad|iPhone|iPod/.test(userAgent)) {
          platform = "ios";
          browser = /Safari/.test(userAgent) ? "safari" : "other";
          const match = userAgent.match(/OS (\d+)_(\d+)/);
          version = match ? `${match[1]}.${match[2]}` : "";
        } else if (/Android/.test(userAgent)) {
          platform = "android";
          browser = /Chrome/.test(userAgent) ? "chrome" : "other";
          const match = userAgent.match(/Android (\d+\.\d+)/);
          version = match && match[1] ? match[1] : "";
        } else {
          platform = "desktop";
          if (/Chrome/.test(userAgent)) browser = "chrome";
          else if (/Firefox/.test(userAgent)) browser = "firefox";
          else if (/Safari/.test(userAgent)) browser = "safari";
          else if (/Edge/.test(userAgent)) browser = "edge";
        }
        return {
          name: platform,
          browser,
          version,
          supportsNativePrompt: platform === "android" || platform === "desktop",
          supportsWebAPK: platform === "android" && browser === "chrome",
          isStandalone
        };
      }
      /**
       * Load engagement data from storage
       */
      loadEngagementData() {
        try {
          const stored = localStorage.getItem("acube_install_engagement");
          if (stored) {
            return JSON.parse(stored);
          }
        } catch (error) {
          console.warn("Failed to load engagement data:", error);
        }
        const now = Date.now();
        return {
          firstVisit: now,
          lastVisit: now,
          totalTime: 0,
          pageViews: 1,
          receiptsCreated: 0,
          returnVisits: 0,
          promptsShown: 0,
          dismissed: false,
          installed: false
        };
      }
      /**
       * Save engagement data to storage
       */
      saveEngagementData() {
        try {
          localStorage.setItem("acube_install_engagement", JSON.stringify(this.engagementData));
        } catch (error) {
          console.warn("Failed to save engagement data:", error);
        }
      }
      /**
       * Update engagement data
       */
      updateEngagementData(updates) {
        this.engagementData = { ...this.engagementData, ...updates };
        this.saveEngagementData();
      }
      /**
       * Start engagement tracking
       */
      startEngagementTracking() {
        const now = Date.now();
        if (now - this.engagementData.lastVisit > 24 * 60 * 60 * 1e3) {
          this.updateEngagementData({
            returnVisits: this.engagementData.returnVisits + 1,
            lastVisit: now
          });
        }
        this.engagementTimer = setInterval(() => {
          if (!document.hidden) {
            this.updateEngagementData({
              totalTime: this.engagementData.totalTime + 1e3
            });
          }
        }, 1e3);
      }
      /**
       * Pause engagement tracking
       */
      pauseEngagementTracking() {
        if (this.engagementTimer) {
          clearInterval(this.engagementTimer);
        }
      }
      /**
       * Resume engagement tracking
       */
      resumeEngagementTracking() {
        if (!this.engagementTimer) {
          this.startEngagementTracking();
        }
      }
      /**
       * Start criteria checking
       */
      startCriteriaChecking() {
        setTimeout(() => {
          this.checkCriteriaAndShow();
        }, this.config.showDelay);
        setInterval(() => {
          this.checkCriteriaAndShow();
        }, 3e4);
      }
      /**
       * Check if install criteria are met
       */
      async checkCriteria() {
        const { criteria } = this.config;
        const { engagementData } = this;
        if (engagementData.promptsShown >= this.config.maxPromptAttempts) {
          return false;
        }
        if (engagementData.lastPromptShown) {
          const daysSinceLastPrompt = (Date.now() - engagementData.lastPromptShown) / (24 * 60 * 60 * 1e3);
          if (daysSinceLastPrompt < this.config.dismissalCooldown) {
            return false;
          }
        }
        if (criteria.minEngagementTime && engagementData.totalTime < criteria.minEngagementTime) {
          return false;
        }
        if (criteria.minPageViews && engagementData.pageViews < criteria.minPageViews) {
          return false;
        }
        if (criteria.minReceiptsCreated && engagementData.receiptsCreated < criteria.minReceiptsCreated) {
          return false;
        }
        if (criteria.daysSinceFirstVisit) {
          const daysSinceFirst = (Date.now() - engagementData.firstVisit) / (24 * 60 * 60 * 1e3);
          if (daysSinceFirst < criteria.daysSinceFirstVisit) {
            return false;
          }
        }
        if (criteria.requireReturnVisit && engagementData.returnVisits === 0) {
          return false;
        }
        if (criteria.customCriteria) {
          const customResult = await criteria.customCriteria();
          if (!customResult) {
            return false;
          }
        }
        return true;
      }
      /**
       * Check criteria and show prompt if met
       */
      async checkCriteriaAndShow() {
        if (!this.installPrompt && !this.config.customPrompt.enabled) {
          return;
        }
        try {
          const criteriaMet = await this.checkCriteria();
          if (criteriaMet) {
            this.emit("criteria:met", { criteria: this.config.criteria });
            if (this.platformInfo.supportsNativePrompt && this.installPrompt) {
              await this.showNativePrompt();
            } else if (this.config.customPrompt.enabled) {
              await this.showCustomPrompt();
            }
          }
        } catch (error) {
          console.error("Error checking install criteria:", error);
        }
      }
      /**
       * Show native install prompt
       */
      async showNativePrompt() {
        if (!this.installPrompt) {
          throw new Error("Native install prompt not available");
        }
        try {
          this.updateEngagementData({
            promptsShown: this.engagementData.promptsShown + 1,
            lastPromptShown: Date.now()
          });
          this.emit("prompt:shown", { type: "native" });
          this.trackAnalytics("install_prompt_shown", { type: "native" });
          await this.installPrompt.prompt();
          const choiceResult = await this.installPrompt.userChoice;
          this.emit("install:completed", {
            outcome: choiceResult.outcome,
            platform: choiceResult.platform
          });
          this.trackAnalytics("install_prompt_result", {
            outcome: choiceResult.outcome,
            platform: choiceResult.platform
          });
          if (choiceResult.outcome === "accepted") {
            this.handleAppInstalled("accepted");
          } else {
            this.handlePromptDismissed("user");
          }
          this.installPrompt = null;
        } catch (error) {
          this.emit("install:failed", {
            error,
            platform: this.platformInfo.name
          });
          this.trackAnalytics("install_prompt_error", { error: error.message });
        }
      }
      /**
       * Show custom install prompt
       */
      async showCustomPrompt() {
        if (this.customPromptElement) {
          return;
        }
        try {
          this.updateEngagementData({
            promptsShown: this.engagementData.promptsShown + 1,
            lastPromptShown: Date.now()
          });
          this.emit("prompt:shown", { type: "custom" });
          this.trackAnalytics("install_prompt_shown", { type: "custom" });
          this.customPromptElement = this.createCustomPromptUI();
          document.body.appendChild(this.customPromptElement);
          this.promptTimeout = setTimeout(() => {
            this.hideCustomPrompt();
            this.handlePromptDismissed("timeout");
          }, 3e4);
        } catch (error) {
          this.emit("install:failed", {
            error,
            platform: this.platformInfo.name
          });
        }
      }
      /**
       * Create custom prompt UI
       */
      createCustomPromptUI() {
        const { customPrompt, platforms } = this.config;
        const container = document.createElement("div");
        container.className = "acube-install-prompt";
        container.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.12);
      padding: 20px;
      max-width: 360px;
      width: calc(100% - 40px);
      z-index: 10000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      animation: slideUp 0.3s ease-out;
    `;
        if (!document.getElementById("acube-install-styles")) {
          const style = document.createElement("style");
          style.id = "acube-install-styles";
          style.textContent = `
        @keyframes slideUp {
          from { transform: translateX(-50%) translateY(100%); opacity: 0; }
          to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        .acube-install-prompt button {
          border: none;
          border-radius: 6px;
          padding: 12px 24px;
          font-size: 14px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s ease;
        }
        .acube-install-prompt button:hover {
          transform: translateY(-1px);
        }
      `;
          document.head.appendChild(style);
        }
        if (customPrompt.icon) {
          const icon = document.createElement("img");
          icon.src = customPrompt.icon;
          icon.style.cssText = "width: 48px; height: 48px; border-radius: 8px; margin-bottom: 12px;";
          container.appendChild(icon);
        }
        const title = document.createElement("h3");
        title.textContent = customPrompt.title || "Installa App";
        title.style.cssText = "margin: 0 0 8px 0; font-size: 18px; font-weight: 600; color: #1a1a1a;";
        container.appendChild(title);
        const message = document.createElement("p");
        let messageText = customPrompt.message || "Installa l'app per un accesso pi\xF9 veloce";
        if (this.platformInfo.name === "ios" && platforms.ios?.showIOSInstructions) {
          messageText = platforms.ios?.customInstructions || messageText;
        }
        message.textContent = messageText;
        message.style.cssText = "margin: 0 0 20px 0; font-size: 14px; color: #666; line-height: 1.4;";
        container.appendChild(message);
        const buttonsContainer = document.createElement("div");
        buttonsContainer.style.cssText = "display: flex; gap: 12px; justify-content: flex-end;";
        const cancelButton = document.createElement("button");
        cancelButton.textContent = customPrompt.cancelButtonText || "Non ora";
        cancelButton.style.cssText = "background: #f5f5f5; color: #666;";
        cancelButton.onclick = () => {
          this.hideCustomPrompt();
          this.handlePromptDismissed("user");
        };
        buttonsContainer.appendChild(cancelButton);
        const installButton = document.createElement("button");
        installButton.textContent = customPrompt.installButtonText || "Installa";
        installButton.style.cssText = "background: #1976d2; color: white;";
        installButton.onclick = () => {
          this.hideCustomPrompt();
          this.handleCustomInstall();
        };
        buttonsContainer.appendChild(installButton);
        container.appendChild(buttonsContainer);
        return container;
      }
      /**
       * Hide custom prompt
       */
      hideCustomPrompt() {
        if (this.customPromptElement) {
          this.customPromptElement.remove();
          this.customPromptElement = void 0;
        }
        if (this.promptTimeout) {
          clearTimeout(this.promptTimeout);
          this.promptTimeout = void 0;
        }
      }
      /**
       * Handle custom install button click
       */
      async handleCustomInstall() {
        if (this.installPrompt) {
          await this.showNativePrompt();
        } else {
          this.showInstallInstructions();
        }
      }
      /**
       * Show platform-specific install instructions
       */
      showInstallInstructions() {
        let instructions = "";
        switch (this.platformInfo.name) {
          case "ios":
            instructions = this.config.platforms.ios?.customInstructions || 'Tocca il pulsante Condividi (\u2B06\uFE0F) e seleziona "Aggiungi alla schermata Home"';
            break;
          case "android":
            instructions = 'Apri il menu del browser e seleziona "Aggiungi alla schermata Home"';
            break;
          case "desktop":
            instructions = "Cerca l'icona di installazione nella barra degli indirizzi del browser";
            break;
          default:
            instructions = "Controlla le opzioni del tuo browser per installare questa app";
        }
        alert(instructions);
        this.emit("install:started", { platform: this.platformInfo.name });
        this.trackAnalytics("install_instructions_shown", {
          platform: this.platformInfo.name,
          instructions
        });
      }
      /**
       * Handle app installed
       */
      handleAppInstalled(outcome) {
        this.updateEngagementData({ installed: true });
        this.emit("install:completed", {
          outcome,
          platform: this.platformInfo.name
        });
        this.trackAnalytics("app_installed", {
          platform: this.platformInfo.name,
          outcome
        });
      }
      /**
       * Handle prompt dismissed
       */
      handlePromptDismissed(reason) {
        this.updateEngagementData({ dismissed: true });
        this.emit("prompt:dismissed", { reason });
        this.trackAnalytics("install_prompt_dismissed", { reason });
      }
      /**
       * Track analytics event
       */
      trackAnalytics(event, data) {
        if (!this.config.analytics.enabled) {
          return;
        }
        const analyticsData = {
          ...data,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          platform: this.platformInfo.name,
          browser: this.platformInfo.browser,
          engagement: this.engagementData,
          ...this.config.analytics.customEvents
        };
        this.emit("analytics:tracked", { event, data: analyticsData });
        if (typeof gtag !== "undefined") {
          gtag("event", event, analyticsData);
        }
      }
      /**
       * Record receipt created (for engagement tracking)
       */
      recordReceiptCreated() {
        this.updateEngagementData({
          receiptsCreated: this.engagementData.receiptsCreated + 1
        });
      }
      /**
       * Manually trigger install prompt
       */
      async showInstallPrompt() {
        if (this.platformInfo.supportsNativePrompt && this.installPrompt) {
          await this.showNativePrompt();
        } else if (this.config.customPrompt.enabled) {
          await this.showCustomPrompt();
        } else {
          this.showInstallInstructions();
        }
      }
      /**
       * Check if app can be installed
       */
      canInstall() {
        return !this.platformInfo.isStandalone && !this.engagementData.installed && (!!this.installPrompt || !!this.config.customPrompt?.enabled);
      }
      /**
       * Get engagement statistics
       */
      getEngagementStats() {
        return { ...this.engagementData };
      }
      /**
       * Get platform information
       */
      getPlatformInfo() {
        return { ...this.platformInfo };
      }
      /**
       * Reset engagement data (for testing)
       */
      resetEngagement() {
        const now = Date.now();
        this.engagementData = {
          firstVisit: now,
          lastVisit: now,
          totalTime: 0,
          pageViews: 1,
          receiptsCreated: 0,
          returnVisits: 0,
          promptsShown: 0,
          dismissed: false,
          installed: false
        };
        this.saveEngagementData();
      }
      /**
       * Destroy the app installer
       */
      destroy() {
        if (this.engagementTimer) {
          clearInterval(this.engagementTimer);
        }
        if (this.promptTimeout) {
          clearTimeout(this.promptTimeout);
        }
        this.hideCustomPrompt();
        this.saveEngagementData();
        this.removeAllListeners();
      }
    };
  }
});

// src/pwa/pwa-manager.ts
var pwa_manager_exports = {};
__export(pwa_manager_exports, {
  PWAManager: () => PWAManager
});
var DEFAULT_CONFIG8, PWAManager;
var init_pwa_manager = __esm({
  "src/pwa/pwa-manager.ts"() {
    "use strict";
    init_esm_shims();
    init_eventemitter3();
    init_push_notifications();
    init_app_installer();
    DEFAULT_CONFIG8 = {
      serviceWorkerPath: "/sw.js",
      autoRegister: true,
      enableInstallPrompts: true,
      cacheStrategy: {
        apiCacheDuration: 5 * 60 * 1e3,
        // 5 minutes
        staticCacheDuration: 24 * 60 * 60 * 1e3,
        // 24 hours
        staleWhileRevalidate: true
      },
      backgroundSync: {
        enablePeriodicSync: true,
        minSyncInterval: 15 * 60 * 1e3
        // 15 minutes
      },
      pushNotifications: {
        enabled: false,
        vapidPublicKey: ""
      },
      appInstaller: {
        enabled: true,
        autoShow: true,
        criteria: {
          minEngagementTime: 2 * 60 * 1e3,
          // 2 minutes
          minPageViews: 3,
          minReceiptsCreated: 1
        },
        config: {}
      }
    };
    PWAManager = class extends import_index.default {
      config;
      registration = null;
      installPrompt = null;
      isSupported;
      messageChannel = null;
      pushManager;
      appInstaller;
      constructor(config = {}) {
        super();
        this.config = { ...DEFAULT_CONFIG8, ...config };
        this.isSupported = this.checkPWASupport();
        if (this.isSupported) {
          this.setupEventListeners();
          if (this.config.autoRegister) {
            this.registerServiceWorker().catch((error) => {
              console.error("Failed to auto-register service worker:", error);
            });
          }
        }
      }
      /**
       * Check if PWA features are supported
       */
      checkPWASupport() {
        return typeof window !== "undefined" && "serviceWorker" in navigator && "caches" in window && "fetch" in window;
      }
      /**
       * Setup event listeners for PWA features
       */
      setupEventListeners() {
        if (this.config.enableInstallPrompts) {
          window.addEventListener("beforeinstallprompt", (event) => {
            event.preventDefault();
            this.installPrompt = event;
            this.emit("install:available", { prompt: this.installPrompt });
          });
          window.addEventListener("appinstalled", () => {
            this.installPrompt = null;
            this.emit("install:completed", { outcome: "accepted" });
          });
        }
        window.addEventListener("online", () => {
          this.handleOnlineStatusChange(true);
        });
        window.addEventListener("offline", () => {
          this.handleOnlineStatusChange(false);
        });
      }
      /**
       * Register service worker
       */
      async registerServiceWorker() {
        if (!this.isSupported) {
          throw new Error("Service workers are not supported in this environment");
        }
        try {
          this.registration = await navigator.serviceWorker.register(
            this.config.serviceWorkerPath,
            {
              scope: "/",
              updateViaCache: "imports"
            }
          );
          this.setupMessageChannel();
          this.registration.addEventListener("updatefound", () => {
            const newWorker = this.registration.installing;
            if (newWorker) {
              newWorker.addEventListener("statechange", () => {
                if (newWorker.state === "installed" && navigator.serviceWorker.controller) {
                  this.emit("sw:updated", { registration: this.registration });
                }
              });
            }
          });
          if (this.config.backgroundSync.enablePeriodicSync && "periodicSync" in this.registration) {
            await this.registerPeriodicSync();
          }
          if (this.config.pushNotifications.enabled) {
            await this.initializePushNotifications();
          }
          if (this.config.appInstaller.enabled) {
            await this.initializeAppInstaller();
          }
          this.emit("sw:registered", { registration: this.registration });
          console.log("Service worker registered successfully");
          return this.registration;
        } catch (error) {
          const swError = new Error(`Service worker registration failed: ${error}`);
          this.emit("sw:error", { error: swError });
          throw swError;
        }
      }
      /**
       * Setup message channel for service worker communication
       */
      setupMessageChannel() {
        if (!this.registration) return;
        this.messageChannel = new MessageChannel();
        this.messageChannel.port1.onmessage = (event) => {
          const { type, data } = event.data;
          switch (type) {
            case "CACHE_SIZE":
              this.emit("cache:updated", { cacheName: "all", size: data.reduce((sum, cache) => sum + cache.size, 0) });
              break;
            case "OFFLINE_SYNC_SUCCESS":
              this.emit("offline:synced", { request: data.url, id: data.id });
              break;
            case "CACHE_CLEARED":
              this.emit("cache:updated", { cacheName: "all", size: 0 });
              break;
          }
        };
        navigator.serviceWorker.controller?.postMessage(
          { type: "PORT_TRANSFER" },
          [this.messageChannel.port2]
        );
      }
      /**
       * Register periodic background sync
       */
      async registerPeriodicSync() {
        if (!this.registration || !("periodicSync" in this.registration)) {
          console.warn("Periodic background sync not supported");
          return;
        }
        try {
          const status = await navigator.permissions.query({ name: "periodic-background-sync" });
          if (status.state === "granted") {
            await this.registration.periodicSync.register("offline-queue-periodic", {
              minInterval: this.config.backgroundSync.minSyncInterval
            });
            console.log("Periodic background sync registered");
          }
        } catch (error) {
          console.warn("Failed to register periodic background sync:", error);
        }
      }
      /**
       * Initialize app installer
       */
      async initializeAppInstaller() {
        try {
          const installerConfig = {
            ...this.config.appInstaller.config,
            criteria: this.config.appInstaller.criteria ?? DEFAULT_CONFIG8.appInstaller.criteria,
            autoShow: this.config.appInstaller.autoShow ?? DEFAULT_CONFIG8.appInstaller.autoShow
          };
          this.appInstaller = new AppInstaller(installerConfig);
          this.appInstaller.on("criteria:met", () => {
            this.emit("app:installable", { canInstall: true });
          });
          this.appInstaller.on("prompt:shown", ({ type }) => {
            this.emit("app:install-prompted", { type });
          });
          this.appInstaller.on("prompt:dismissed", ({ reason }) => {
            this.emit("app:install-dismissed", { reason });
          });
          this.appInstaller.on("install:completed", ({ outcome, platform }) => {
            if (outcome === "accepted") {
              this.emit("app:installed", { platform });
            }
          });
          console.log("App installer initialized");
        } catch (error) {
          console.warn("Failed to initialize app installer:", error);
        }
      }
      /**
       * Initialize push notifications
       */
      async initializePushNotifications() {
        if (!this.registration || !this.config.pushNotifications.vapidPublicKey) {
          console.warn("Push notifications not configured");
          return;
        }
        try {
          const pushConfig = {
            vapidPublicKey: this.config.pushNotifications.vapidPublicKey,
            serviceWorkerRegistration: this.registration,
            autoSubscribe: true,
            language: "it",
            // Default for Italian e-receipts
            serverEndpoint: "/api/push/subscribe"
          };
          this.pushManager = new PushNotificationManager(pushConfig);
          this.pushManager.on("subscription:created", ({ subscription }) => {
            this.emit("push:subscribed", { subscription });
          });
          this.pushManager.on("subscription:deleted", ({ reason }) => {
            this.emit("push:unsubscribed", { reason });
          });
          this.pushManager.on("notification:shown", ({ notification }) => {
            this.emit("notification:shown", { notification });
          });
          this.pushManager.on("notification:clicked", ({ action, data }) => {
            this.emit("notification:clicked", { action, data });
          });
          this.pushManager.on("error", (error) => {
            console.error("Push notification error:", error);
          });
          console.log("Push notifications initialized");
        } catch (error) {
          console.warn("Failed to initialize push notifications:", error);
        }
      }
      /**
       * Handle online/offline status changes
       */
      handleOnlineStatusChange(isOnline) {
        if (isOnline && this.registration) {
          this.triggerBackgroundSync();
        }
      }
      /**
       * Trigger background sync
       */
      async triggerBackgroundSync() {
        if (!this.registration || !("sync" in this.registration)) {
          console.warn("Background sync not supported");
          return;
        }
        try {
          await this.registration.sync.register("offline-queue-sync");
          console.log("Background sync triggered");
        } catch (error) {
          console.warn("Failed to trigger background sync:", error);
        }
      }
      /**
       * Show app install prompt
       */
      async showInstallPrompt() {
        if (this.appInstaller) {
          try {
            await this.appInstaller.showInstallPrompt();
            return null;
          } catch (error) {
            console.error("Failed to show install prompt via AppInstaller:", error);
          }
        }
        if (!this.installPrompt) {
          console.warn("Install prompt not available");
          return null;
        }
        try {
          await this.installPrompt.prompt();
          const choiceResult = await this.installPrompt.userChoice;
          this.emit("install:completed", { outcome: choiceResult.outcome });
          this.installPrompt = null;
          return choiceResult;
        } catch (error) {
          console.error("Failed to show install prompt:", error);
          return null;
        }
      }
      /**
       * Get cache information
       */
      async getCacheInfo() {
        if (!this.messageChannel) {
          throw new Error("Service worker not registered or message channel not available");
        }
        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error("Cache info request timeout"));
          }, 5e3);
          this.messageChannel.port1.onmessage = (event) => {
            if (event.data.type === "CACHE_SIZE") {
              clearTimeout(timeout);
              const cacheInfo = event.data.data.map((cache) => ({
                name: cache.name,
                size: cache.size,
                lastUpdated: /* @__PURE__ */ new Date()
              }));
              resolve(cacheInfo);
            }
          };
          navigator.serviceWorker.controller?.postMessage({ type: "GET_CACHE_SIZE" });
        });
      }
      /**
       * Clear all caches
       */
      async clearCache() {
        if (!this.messageChannel) {
          throw new Error("Service worker not registered or message channel not available");
        }
        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error("Clear cache request timeout"));
          }, 1e4);
          this.messageChannel.port1.onmessage = (event) => {
            if (event.data.type === "CACHE_CLEARED") {
              clearTimeout(timeout);
              resolve();
            }
          };
          navigator.serviceWorker.controller?.postMessage({ type: "CLEAR_CACHE" });
        });
      }
      /**
       * Force service worker update
       */
      async updateServiceWorker() {
        if (!this.registration) {
          throw new Error("Service worker not registered");
        }
        try {
          await this.registration.update();
          if (this.registration.waiting) {
            navigator.serviceWorker.controller?.postMessage({ type: "SKIP_WAITING" });
          }
        } catch (error) {
          console.error("Failed to update service worker:", error);
          throw error;
        }
      }
      /**
       * Check if app is installable
       */
      isInstallable() {
        if (this.appInstaller) {
          return this.appInstaller.canInstall();
        }
        return this.installPrompt !== null;
      }
      /**
       * Check if app is installed
       */
      isInstalled() {
        if (this.appInstaller) {
          return this.appInstaller.getPlatformInfo().isStandalone;
        }
        return window.matchMedia("(display-mode: standalone)").matches || window.matchMedia("(display-mode: fullscreen)").matches || window.navigator.standalone === true;
      }
      /**
       * Get service worker registration
       */
      getRegistration() {
        return this.registration;
      }
      /**
       * Check if PWA features are supported
       */
      isPWASupported() {
        return this.isSupported;
      }
      /**
       * Get push notification manager
       */
      getPushManager() {
        return this.pushManager;
      }
      /**
       * Get app installer
       */
      getAppInstaller() {
        return this.appInstaller;
      }
      /**
       * Record receipt created (for app installer engagement tracking)
       */
      recordReceiptCreated() {
        if (this.appInstaller) {
          this.appInstaller.recordReceiptCreated();
        }
      }
      /**
       * Get engagement statistics
       */
      getEngagementStats() {
        if (this.appInstaller) {
          return this.appInstaller.getEngagementStats();
        }
        return null;
      }
      /**
       * Check if app install criteria are met
       */
      async checkInstallCriteria() {
        if (this.appInstaller) {
          return this.appInstaller.checkCriteria();
        }
        return false;
      }
      /**
       * Subscribe to push notifications
       */
      async subscribeToPushNotifications() {
        if (!this.pushManager) {
          throw new Error("Push notifications not initialized");
        }
        return this.pushManager.subscribe();
      }
      /**
       * Unsubscribe from push notifications
       */
      async unsubscribeFromPushNotifications() {
        if (!this.pushManager) {
          throw new Error("Push notifications not initialized");
        }
        return this.pushManager.unsubscribe();
      }
      /**
       * Show a notification
       */
      async showNotification(payload) {
        if (!this.pushManager) {
          throw new Error("Push notifications not initialized");
        }
        return this.pushManager.showNotification(payload);
      }
      /**
       * Check if subscribed to push notifications
       */
      isPushSubscribed() {
        return this.pushManager?.isSubscribed() || false;
      }
      /**
       * Destroy PWA manager
       */
      async destroy() {
        if (this.registration) {
          try {
            await this.registration.unregister();
          } catch (error) {
            console.warn("Failed to unregister service worker:", error);
          }
        }
        if (this.messageChannel) {
          this.messageChannel.port1.close();
          this.messageChannel.port2.close();
        }
        if (this.pushManager) {
          await this.pushManager.destroy();
        }
        if (this.appInstaller) {
          this.appInstaller.destroy();
        }
        this.removeAllListeners();
      }
    };
  }
});

// src/pwa/manifest-generator.ts
var manifest_generator_exports = {};
__export(manifest_generator_exports, {
  ManifestGenerator: () => ManifestGenerator
});
var DEFAULT_MANIFEST_CONFIG, ManifestGenerator;
var init_manifest_generator = __esm({
  "src/pwa/manifest-generator.ts"() {
    "use strict";
    init_esm_shims();
    DEFAULT_MANIFEST_CONFIG = {
      name: "A-Cube E-Receipt",
      shortName: "A-Cube",
      description: "Gestione scontrini elettronici per il sistema fiscale italiano",
      startUrl: "/",
      scope: "/",
      display: "standalone",
      orientation: "portrait",
      themeColor: "#1976d2",
      backgroundColor: "#ffffff",
      lang: "it",
      categories: ["business", "finance", "productivity"],
      icons: [
        {
          src: "/icons/icon-72x72.png",
          sizes: "72x72",
          type: "image/png",
          purpose: "any"
        },
        {
          src: "/icons/icon-96x96.png",
          sizes: "96x96",
          type: "image/png",
          purpose: "any"
        },
        {
          src: "/icons/icon-128x128.png",
          sizes: "128x128",
          type: "image/png",
          purpose: "any"
        },
        {
          src: "/icons/icon-144x144.png",
          sizes: "144x144",
          type: "image/png",
          purpose: "any"
        },
        {
          src: "/icons/icon-152x152.png",
          sizes: "152x152",
          type: "image/png",
          purpose: "any"
        },
        {
          src: "/icons/icon-192x192.png",
          sizes: "192x192",
          type: "image/png",
          purpose: "any"
        },
        {
          src: "/icons/icon-384x384.png",
          sizes: "384x384",
          type: "image/png",
          purpose: "any"
        },
        {
          src: "/icons/icon-512x512.png",
          sizes: "512x512",
          type: "image/png",
          purpose: "any"
        },
        {
          src: "/icons/maskable-icon-192x192.png",
          sizes: "192x192",
          type: "image/png",
          purpose: "maskable"
        },
        {
          src: "/icons/maskable-icon-512x512.png",
          sizes: "512x512",
          type: "image/png",
          purpose: "maskable"
        }
      ],
      screenshots: [
        {
          src: "/screenshots/desktop.png",
          sizes: "1280x720",
          type: "image/png",
          platform: "wide",
          label: "Desktop view of A-Cube E-Receipt dashboard"
        },
        {
          src: "/screenshots/mobile.png",
          sizes: "750x1334",
          type: "image/png",
          platform: "narrow",
          label: "Mobile view of A-Cube E-Receipt"
        }
      ],
      shortcuts: [
        {
          name: "Nuovo Scontrino",
          url: "/receipts/new",
          description: "Crea un nuovo scontrino elettronico",
          icons: [
            {
              src: "/icons/new-receipt-96x96.png",
              sizes: "96x96",
              type: "image/png"
            }
          ]
        },
        {
          name: "Dashboard",
          url: "/dashboard",
          description: "Visualizza il pannello di controllo",
          icons: [
            {
              src: "/icons/dashboard-96x96.png",
              sizes: "96x96",
              type: "image/png"
            }
          ]
        },
        {
          name: "Storico",
          url: "/receipts/history",
          description: "Consulta lo storico degli scontrini",
          icons: [
            {
              src: "/icons/history-96x96.png",
              sizes: "96x96",
              type: "image/png"
            }
          ]
        },
        {
          name: "Impostazioni",
          url: "/settings",
          description: "Gestisci le impostazioni dell'applicazione",
          icons: [
            {
              src: "/icons/settings-96x96.png",
              sizes: "96x96",
              type: "image/png"
            }
          ]
        }
      ]
    };
    ManifestGenerator = class _ManifestGenerator {
      config;
      constructor(config = {}) {
        this.config = { ...DEFAULT_MANIFEST_CONFIG, ...config };
      }
      /**
       * Generate web app manifest
       */
      generateManifest() {
        const manifest = {
          name: this.config.name,
          short_name: this.config.shortName,
          description: this.config.description,
          start_url: this.config.startUrl,
          scope: this.config.scope,
          display: this.config.display,
          orientation: this.config.orientation,
          theme_color: this.config.themeColor,
          background_color: this.config.backgroundColor,
          lang: this.config.lang,
          categories: this.config.categories,
          icons: this.config.icons.map((icon) => ({
            src: icon.src,
            sizes: icon.sizes,
            type: icon.type || "image/png",
            ...icon.purpose && { purpose: icon.purpose }
          }))
        };
        if (this.config.screenshots && this.config.screenshots.length > 0) {
          manifest.screenshots = this.config.screenshots.map((screenshot) => ({
            src: screenshot.src,
            sizes: screenshot.sizes,
            type: screenshot.type,
            ...screenshot.platform && { platform: screenshot.platform },
            ...screenshot.label && { label: screenshot.label }
          }));
        }
        if (this.config.shortcuts && this.config.shortcuts.length > 0) {
          manifest.shortcuts = this.config.shortcuts.map((shortcut) => ({
            name: shortcut.name,
            url: shortcut.url,
            ...shortcut.description && { description: shortcut.description },
            ...shortcut.icons && { icons: shortcut.icons.map((icon) => ({
              src: icon.src,
              sizes: icon.sizes,
              ...icon.type && { type: icon.type }
            })) }
          }));
        }
        return manifest;
      }
      /**
       * Generate manifest as JSON string
       */
      generateManifestJSON() {
        return JSON.stringify(this.generateManifest(), null, 2);
      }
      /**
       * Generate HTML meta tags for PWA
       */
      generateHTMLMetaTags() {
        const manifest = this.generateManifest();
        const tags = [];
        tags.push(`<meta name="application-name" content="${manifest.name}">`);
        tags.push(`<meta name="theme-color" content="${manifest.theme_color}">`);
        tags.push(`<meta name="description" content="${manifest.description}">`);
        tags.push('<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">');
        tags.push('<link rel="manifest" href="/manifest.json">');
        tags.push('<meta name="apple-mobile-web-app-capable" content="yes">');
        tags.push(`<meta name="apple-mobile-web-app-title" content="${manifest.short_name}">`);
        tags.push('<meta name="apple-mobile-web-app-status-bar-style" content="default">');
        const appleIcons = manifest.icons.filter(
          (icon) => ["152x152", "180x180", "192x192"].includes(icon.sizes)
        );
        appleIcons.forEach((icon) => {
          tags.push(`<link rel="apple-touch-icon" sizes="${icon.sizes}" href="${icon.src}">`);
        });
        const favicon = manifest.icons.find((icon) => icon.sizes === "32x32") || manifest.icons[0];
        if (favicon) {
          tags.push(`<link rel="icon" type="${favicon.type}" href="${favicon.src}">`);
        }
        tags.push(`<meta name="msapplication-TileColor" content="${manifest.theme_color}">`);
        const msIcon = manifest.icons.find((icon) => icon.sizes === "144x144");
        if (msIcon) {
          tags.push(`<meta name="msapplication-TileImage" content="${msIcon.src}">`);
        }
        return tags.join("\n");
      }
      /**
       * Generate service worker registration script
       */
      generateServiceWorkerScript(serviceWorkerPath = "/sw.js") {
        return `
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('${serviceWorkerPath}')
        .then((registration) => {
          console.log('SW registered: ', registration);
        })
        .catch((registrationError) => {
          console.log('SW registration failed: ', registrationError);
        });
    });
  }
</script>`.trim();
      }
      /**
       * Update manifest configuration
       */
      updateConfig(updates) {
        this.config = { ...this.config, ...updates };
      }
      /**
       * Get current configuration
       */
      getConfig() {
        return { ...this.config };
      }
      /**
       * Generate localized manifest for different languages
       */
      generateLocalizedManifest(locale) {
        const localizedConfig = this.getLocalizedConfig(locale);
        const generator = new _ManifestGenerator(localizedConfig);
        return generator.generateManifest();
      }
      /**
       * Get localized configuration
       */
      getLocalizedConfig(locale) {
        const localizations = {
          "en": {
            name: "A-Cube E-Receipt",
            shortName: "A-Cube",
            description: "Electronic receipt management for Italian tax system",
            lang: "en",
            shortcuts: [
              {
                name: "New Receipt",
                url: "/receipts/new",
                description: "Create a new electronic receipt"
              },
              {
                name: "Dashboard",
                url: "/dashboard",
                description: "View control panel"
              },
              {
                name: "History",
                url: "/receipts/history",
                description: "Browse receipt history"
              },
              {
                name: "Settings",
                url: "/settings",
                description: "Manage application settings"
              }
            ]
          },
          "de": {
            name: "A-Cube E-Receipt",
            shortName: "A-Cube",
            description: "Elektronische Belegverwaltung f\xFCr das italienische Steuersystem",
            lang: "de",
            shortcuts: [
              {
                name: "Neuer Beleg",
                url: "/receipts/new",
                description: "Erstelle einen neuen elektronischen Beleg"
              },
              {
                name: "Dashboard",
                url: "/dashboard",
                description: "Kontrollpanel anzeigen"
              },
              {
                name: "Verlauf",
                url: "/receipts/history",
                description: "Belegverlauf durchsuchen"
              },
              {
                name: "Einstellungen",
                url: "/settings",
                description: "Anwendungseinstellungen verwalten"
              }
            ]
          },
          "fr": {
            name: "A-Cube E-Receipt",
            shortName: "A-Cube",
            description: "Gestion des re\xE7us \xE9lectroniques pour le syst\xE8me fiscal italien",
            lang: "fr",
            shortcuts: [
              {
                name: "Nouveau Re\xE7u",
                url: "/receipts/new",
                description: "Cr\xE9er un nouveau re\xE7u \xE9lectronique"
              },
              {
                name: "Tableau de Bord",
                url: "/dashboard",
                description: "Afficher le panneau de contr\xF4le"
              },
              {
                name: "Historique",
                url: "/receipts/history",
                description: "Consulter l'historique des re\xE7us"
              },
              {
                name: "Param\xE8tres",
                url: "/settings",
                description: "G\xE9rer les param\xE8tres de l'application"
              }
            ]
          }
        };
        const localization = localizations[locale] || {};
        return { ...this.config, ...localization };
      }
      /**
       * Validate manifest configuration
       */
      validateManifest() {
        const errors = [];
        const manifest = this.generateManifest();
        if (!manifest.name || manifest.name.length === 0) {
          errors.push("Manifest name is required");
        }
        if (!manifest.short_name || manifest.short_name.length === 0) {
          errors.push("Manifest short_name is required");
        }
        if (!manifest.start_url || manifest.start_url.length === 0) {
          errors.push("Manifest start_url is required");
        }
        if (!manifest.icons || manifest.icons.length === 0) {
          errors.push("At least one icon is required");
        } else {
          const hasRequiredSizes = manifest.icons.some(
            (icon) => ["192x192", "512x512"].includes(icon.sizes)
          );
          if (!hasRequiredSizes) {
            errors.push("Icons with sizes 192x192 and 512x512 are recommended");
          }
        }
        const validDisplayModes = ["standalone", "fullscreen", "minimal-ui", "browser"];
        if (!validDisplayModes.includes(manifest.display)) {
          errors.push(`Invalid display mode: ${manifest.display}`);
        }
        return {
          isValid: errors.length === 0,
          errors
        };
      }
      /**
       * Generate complete PWA setup files
       */
      generatePWAFiles() {
        return {
          manifest: this.generateManifestJSON(),
          html: this.generateHTMLMetaTags(),
          serviceWorkerScript: this.generateServiceWorkerScript(),
          validation: this.validateManifest()
        };
      }
    };
  }
});

// src/sync/sync-engine.ts
var sync_engine_exports = {};
__export(sync_engine_exports, {
  ProgressiveSyncEngine: () => ProgressiveSyncEngine
});
var DEFAULT_CONFIG9, ProgressiveSyncEngine;
var init_sync_engine = __esm({
  "src/sync/sync-engine.ts"() {
    "use strict";
    init_esm_shims();
    init_eventemitter3();
    DEFAULT_CONFIG9 = {
      maxConcurrentSyncs: 3,
      defaultTimeout: 3e4,
      defaultRetries: 3,
      batchSize: 100,
      enableRollback: true,
      enableDeltaSync: true,
      enableCompression: true,
      checkpointInterval: 5e3
    };
    ProgressiveSyncEngine = class extends import_index.default {
      config;
      activeSyncs = /* @__PURE__ */ new Map();
      syncQueue = [];
      isProcessingQueue = false;
      lastSyncTimestamp = null;
      constructor(config = {}) {
        super();
        this.config = { ...DEFAULT_CONFIG9, ...config };
      }
      /**
       * Initialize the sync engine
       */
      async initialize() {
        this.processQueue();
        this.emit("sync.started", {
          syncId: "initialization",
          strategy: "immediate",
          direction: "bidirectional",
          operation: "full",
          startTime: /* @__PURE__ */ new Date(),
          options: {}
        });
      }
      /**
       * Execute a progressive sync operation with rollback capability
       */
      async executeSync(options = {}) {
        const syncId = this.generateSyncId();
        if (this.activeSyncs.size >= this.config.maxConcurrentSyncs) {
          return this.queueSync(syncId, options);
        }
        return this.executeSyncInternal(syncId, options);
      }
      /**
       * Calculate data deltas for efficient synchronization
       */
      async calculateDeltas(since) {
        const sinceTimestamp = since || this.lastSyncTimestamp || /* @__PURE__ */ new Date(0);
        const deltas = [];
        const totalChanges = deltas.length;
        const estimatedSyncTime = this.estimateSyncTime(deltas);
        const estimatedBandwidth = this.estimateBandwidth(deltas);
        return {
          deltas,
          lastSyncTimestamp: sinceTimestamp,
          totalChanges,
          estimatedSyncTime,
          estimatedBandwidth
        };
      }
      /**
       * Get current sync status and metrics
       */
      getStatus() {
        return {
          activeSyncs: this.activeSyncs.size,
          queuedSyncs: this.syncQueue.length,
          status: this.activeSyncs.size > 0 ? "syncing" : "idle",
          lastSync: this.lastSyncTimestamp
        };
      }
      /**
       * Cancel a specific sync operation
       */
      async cancelSync(syncId) {
        const context = this.activeSyncs.get(syncId);
        if (!context) {
          return false;
        }
        try {
          context.abortController.abort();
          this.emit("sync.failed", {
            type: "sync.failed",
            timestamp: /* @__PURE__ */ new Date(),
            requestId: syncId,
            data: {
              syncId,
              error: {
                id: `cancel_${Date.now()}`,
                phase: context.currentPhase,
                operation: "cancel",
                error: new Error("Sync cancelled by user"),
                retryable: false,
                timestamp: /* @__PURE__ */ new Date(),
                context: {}
              },
              phase: context.currentPhase,
              retryable: false
            }
          });
          return true;
        } catch (error) {
          return false;
        } finally {
          this.activeSyncs.delete(syncId);
          this.processQueue();
        }
      }
      /**
       * Cancel all active sync operations
       */
      async cancelAllSyncs() {
        const cancelPromises = Array.from(this.activeSyncs.keys()).map(
          (syncId) => this.cancelSync(syncId)
        );
        await Promise.all(cancelPromises);
        this.syncQueue.length = 0;
      }
      async executeSyncInternal(syncId, options) {
        const context = this.createExecutionContext(syncId, options);
        this.activeSyncs.set(syncId, context);
        try {
          this.emitSyncStarted(context);
          const result = await this.executeSyncPhases(context);
          this.emitSyncCompleted(context, result);
          this.lastSyncTimestamp = /* @__PURE__ */ new Date();
          return result;
        } catch (error) {
          const syncError = this.createSyncError(context, error);
          context.errors.push(syncError);
          if (this.config.enableRollback && context.checkpoints.length > 0) {
            await this.rollbackToLastCheckpoint(context);
          }
          this.emitSyncFailed(context, syncError);
          throw error;
        } finally {
          this.activeSyncs.delete(syncId);
          this.processQueue();
        }
      }
      async executeSyncPhases(context) {
        const phases = ["validate", "prepare", "execute", "verify", "cleanup"];
        for (const phase of phases) {
          if (context.abortController.signal.aborted) {
            throw new Error("Sync cancelled");
          }
          context.currentPhase = phase;
          if (this.config.enableRollback) {
            await this.createCheckpoint(context, phase);
          }
          this.emitSyncProgress(context, phases.indexOf(phase), phases.length);
          try {
            await this.executePhase(context, phase);
          } catch (error) {
            if (this.config.enableRollback) {
              await this.rollbackToLastCheckpoint(context);
            }
            throw error;
          }
        }
        return this.createSyncResult(context, "success");
      }
      async executePhase(context, phase) {
        switch (phase) {
          case "validate":
            await this.validateSyncOperation(context);
            break;
          case "prepare":
            await this.prepareSyncData(context);
            break;
          case "execute":
            await this.executeSyncOperations(context);
            break;
          case "verify":
            await this.verifySyncResults(context);
            break;
          case "cleanup":
            await this.cleanupSyncResources(context);
            break;
        }
      }
      async validateSyncOperation(context) {
        const { options } = context;
        if (options.resources && options.resources.length === 0) {
          throw new Error("No resources specified for sync");
        }
        context.statistics.totalOperations = options.resources?.length || 1;
      }
      async prepareSyncData(context) {
        if (this.config.enableDeltaSync && context.options.operation === "delta") {
          const deltaResult = await this.calculateDeltas(context.options.since);
          context.statistics.totalOperations = deltaResult.totalChanges;
        }
      }
      async executeSyncOperations(context) {
        const { options: _options } = context;
        const batchSize = this.config.batchSize;
        const totalOperations = context.statistics.totalOperations;
        for (let i = 0; i < totalOperations; i += batchSize) {
          if (context.abortController.signal.aborted) {
            throw new Error("Sync cancelled during execution");
          }
          const batchEnd = Math.min(i + batchSize, totalOperations);
          try {
            await this.executeBatch(context, i, batchEnd);
            context.statistics.completedOperations = batchEnd;
            this.emitSyncProgress(context, batchEnd, totalOperations);
          } catch (error) {
            context.statistics.failedOperations += batchEnd - i;
            const syncError = this.createSyncError(context, error);
            context.errors.push(syncError);
            if (!this.isRetryableError(error)) {
              throw error;
            }
          }
        }
      }
      async executeBatch(context, start, end) {
        await new Promise((resolve) => setTimeout(resolve, 100));
        context.statistics.networkRequests += 1;
        context.statistics.bytesTransferred += (end - start) * 100;
        context.statistics.recordsSynced += end - start;
      }
      async verifySyncResults(context) {
        const { statistics } = context;
        if (statistics.failedOperations > 0) {
          throw new Error(`Sync verification failed: ${statistics.failedOperations} operations failed`);
        }
      }
      async cleanupSyncResources(context) {
        context.checkpoints.length = 0;
      }
      async createCheckpoint(context, phase) {
        const checkpoint = {
          id: `checkpoint_${Date.now()}_${Math.random().toString(36).substring(2)}`,
          phase,
          timestamp: /* @__PURE__ */ new Date(),
          completedOperations: context.statistics.completedOperations,
          state: {
            // Store relevant state for rollback
            phase,
            completedOperations: context.statistics.completedOperations
          }
        };
        context.checkpoints.push(checkpoint);
        if (context.checkpoints.length > 10) {
          context.checkpoints.shift();
        }
      }
      async rollbackToLastCheckpoint(context) {
        const lastCheckpoint = context.checkpoints[context.checkpoints.length - 1];
        if (!lastCheckpoint) {
          return;
        }
        context.currentPhase = lastCheckpoint.phase;
        context.statistics.completedOperations = lastCheckpoint.completedOperations;
      }
      async queueSync(syncId, options) {
        return new Promise((resolve, reject) => {
          this.syncQueue.push({ id: syncId, options, resolve, reject });
          this.processQueue();
        });
      }
      async processQueue() {
        if (this.isProcessingQueue || this.syncQueue.length === 0) {
          return;
        }
        this.isProcessingQueue = true;
        try {
          while (this.syncQueue.length > 0 && this.activeSyncs.size < this.config.maxConcurrentSyncs) {
            const queuedSync = this.syncQueue.shift();
            if (!queuedSync) break;
            try {
              const result = await this.executeSyncInternal(queuedSync.id, queuedSync.options);
              queuedSync.resolve(result);
            } catch (error) {
              queuedSync.reject(error);
            }
          }
        } finally {
          this.isProcessingQueue = false;
        }
      }
      createExecutionContext(syncId, options) {
        return {
          syncId,
          options: {
            operation: "full",
            direction: "bidirectional",
            strategy: "immediate",
            priority: "normal",
            maxRetries: this.config.defaultRetries,
            timeoutMs: this.config.defaultTimeout,
            batchSize: this.config.batchSize,
            ...options
          },
          startTime: /* @__PURE__ */ new Date(),
          currentPhase: "validate",
          statistics: {
            totalOperations: 0,
            completedOperations: 0,
            failedOperations: 0,
            bytesTransferred: 0,
            recordsSynced: 0,
            conflictsDetected: 0,
            conflictsResolved: 0,
            networkRequests: 0,
            cacheHits: 0
          },
          errors: [],
          conflicts: [],
          checkpoints: [],
          abortController: new AbortController()
        };
      }
      createSyncResult(context, status) {
        const endTime = /* @__PURE__ */ new Date();
        return {
          id: context.syncId,
          operation: context.options.operation || "full",
          status,
          startTime: context.startTime,
          endTime,
          duration: endTime.getTime() - context.startTime.getTime(),
          statistics: { ...context.statistics },
          errors: [...context.errors],
          conflicts: [...context.conflicts],
          metadata: {
            phases: context.checkpoints.map((cp) => ({
              phase: cp.phase,
              timestamp: cp.timestamp
            })),
            options: context.options
          }
        };
      }
      createSyncError(context, error) {
        return {
          id: `error_${Date.now()}_${Math.random().toString(36).substring(2)}`,
          phase: context.currentPhase,
          operation: `${context.options.operation || "sync"}_${context.currentPhase}`,
          error,
          retryable: this.isRetryableError(error),
          timestamp: /* @__PURE__ */ new Date(),
          context: {
            syncId: context.syncId,
            phase: context.currentPhase,
            completedOperations: context.statistics.completedOperations
          }
        };
      }
      isRetryableError(error) {
        const retryablePatterns = [
          /network/i,
          /timeout/i,
          /connection/i,
          /rate.?limit/i,
          /502|503|504/
        ];
        return retryablePatterns.some(
          (pattern) => pattern.test(error.message) || pattern.test(error.name)
        );
      }
      estimateSyncTime(deltas) {
        const baseTimePerOperation = 100;
        return deltas.length * baseTimePerOperation;
      }
      estimateBandwidth(deltas) {
        const averageRecordSize = 1024;
        return deltas.length * averageRecordSize;
      }
      generateSyncId() {
        return `sync_${Date.now()}_${Math.random().toString(36).substring(2)}`;
      }
      // Event emission helpers
      emitSyncStarted(context) {
        this.emit("sync.started", {
          syncId: context.syncId,
          operation: context.options.operation || "full",
          estimatedDuration: this.estimateSyncTime([]),
          dataTypes: context.options.resources || [],
          options: context.options
        });
      }
      emitSyncProgress(context, completed, total) {
        const progress = total > 0 ? Math.round(completed / total * 100) : 0;
        this.emit("sync.progress", {
          syncId: context.syncId,
          progress,
          phase: context.currentPhase,
          operations: {
            completed,
            total,
            errors: context.errors.length
          },
          estimatedTimeRemaining: this.estimateTimeRemaining(context, completed, total)
        });
      }
      emitSyncCompleted(context, result) {
        this.emit("sync.completed", {
          syncId: context.syncId,
          result,
          summary: {
            recordsSynced: result.statistics.recordsSynced,
            conflictsResolved: result.statistics.conflictsResolved,
            errors: result.errors.length,
            duration: result.duration
          }
        });
      }
      emitSyncFailed(context, error) {
        this.emit("sync.failed", {
          syncId: context.syncId,
          error,
          phase: context.currentPhase,
          retryable: error.retryable,
          nextRetryTime: error.retryable ? new Date(Date.now() + 5e3) : void 0
        });
      }
      estimateTimeRemaining(context, completed, total) {
        if (completed === 0 || total === 0) return void 0;
        const elapsed = Date.now() - context.startTime.getTime();
        const rate = completed / elapsed;
        const remaining = total - completed;
        return Math.round(remaining / rate);
      }
    };
  }
});

// src/storage/queue/priority-queue.ts
var PRIORITY_VALUES, PriorityQueue;
var init_priority_queue = __esm({
  "src/storage/queue/priority-queue.ts"() {
    "use strict";
    init_esm_shims();
    PRIORITY_VALUES = {
      critical: 1e3,
      high: 750,
      normal: 500,
      low: 250
    };
    PriorityQueue = class {
      items = /* @__PURE__ */ new Map();
      priorityIndex = /* @__PURE__ */ new Map();
      statusIndex = /* @__PURE__ */ new Map();
      resourceIndex = /* @__PURE__ */ new Map();
      metrics;
      config;
      eventHandlers = /* @__PURE__ */ new Map();
      constructor(config = {}) {
        this.config = {
          maxSize: 1e4,
          enableMetrics: true,
          enableEvents: true,
          ...config
        };
        this.metrics = this.initializeMetrics();
        this.initializeIndexes();
      }
      initializeMetrics() {
        return {
          totalItems: 0,
          pendingItems: 0,
          processingItems: 0,
          completedItems: 0,
          failedItems: 0,
          deadItems: 0,
          averageProcessingTime: 0,
          successRate: 0,
          lastProcessedAt: null,
          throughputPerMinute: 0,
          priorityDistribution: {
            critical: 0,
            high: 0,
            normal: 0,
            low: 0
          },
          resourceDistribution: {
            receipts: 0,
            cashiers: 0,
            merchants: 0,
            "cash-registers": 0,
            "point-of-sales": 0,
            pems: 0
          }
        };
      }
      initializeIndexes() {
        Object.keys(PRIORITY_VALUES).forEach((priority) => {
          this.priorityIndex.set(priority, /* @__PURE__ */ new Set());
        });
        const statuses = ["pending", "processing", "completed", "failed", "retry", "dead"];
        statuses.forEach((status) => {
          this.statusIndex.set(status, /* @__PURE__ */ new Set());
        });
      }
      /**
       * Add item to the queue
       */
      enqueue(item) {
        if (this.items.size >= this.config.maxSize) {
          this.emit("queue:backpressure", {
            queueSize: this.items.size,
            threshold: this.config.maxSize
          });
          return false;
        }
        this.items.set(item.id, item);
        this.addToIndex(item);
        this.updateMetricsOnAdd(item);
        this.emit("item:added", { item });
        return true;
      }
      /**
       * Get next highest priority item
       */
      dequeue() {
        const item = this.peek();
        if (item) {
          this.remove(item.id);
        }
        return item;
      }
      /**
       * Peek at next highest priority item without removing
       */
      peek() {
        for (const priority of ["critical", "high", "normal", "low"]) {
          const prioritySet = this.priorityIndex.get(priority);
          if (prioritySet && prioritySet.size > 0) {
            for (const itemId of prioritySet) {
              const item = this.items.get(itemId);
              if (item && item.status === "pending") {
                if (!item.scheduledAt || item.scheduledAt <= Date.now()) {
                  return item;
                }
              }
            }
          }
        }
        return null;
      }
      /**
       * Get multiple items by priority and status
       */
      dequeueMany(count, priority, status = "pending") {
        const items = [];
        const now = Date.now();
        const priorities = priority ? [priority] : ["critical", "high", "normal", "low"];
        for (const pri of priorities) {
          if (items.length >= count) break;
          const prioritySet = this.priorityIndex.get(pri);
          if (!prioritySet) continue;
          for (const itemId of prioritySet) {
            if (items.length >= count) break;
            const item = this.items.get(itemId);
            if (item && item.status === status && (!item.scheduledAt || item.scheduledAt <= now)) {
              items.push(item);
            }
          }
        }
        return items;
      }
      /**
       * Update item status and properties
       */
      updateItem(id, updates) {
        const item = this.items.get(id);
        if (!item) return false;
        this.removeFromIndex(item);
        const updatedItem = {
          ...item,
          ...updates,
          updatedAt: Date.now()
        };
        this.items.set(id, updatedItem);
        this.addToIndex(updatedItem);
        this.updateMetricsOnUpdate(item, updatedItem);
        if (item.status !== updatedItem.status) {
          this.emitStatusChangeEvent(updatedItem);
        }
        return true;
      }
      /**
       * Remove item from queue
       */
      remove(id) {
        const item = this.items.get(id);
        if (!item) return false;
        this.items.delete(id);
        this.removeFromIndex(item);
        this.updateMetricsOnRemove(item);
        return true;
      }
      /**
       * Get item by ID
       */
      get(id) {
        return this.items.get(id) || null;
      }
      /**
       * Check if queue contains item
       */
      has(id) {
        return this.items.has(id);
      }
      /**
       * Get items by status
       */
      getByStatus(status) {
        const statusSet = this.statusIndex.get(status);
        if (!statusSet) return [];
        return Array.from(statusSet).map((id) => this.items.get(id)).filter((item) => item !== void 0);
      }
      /**
       * Get items by priority
       */
      getByPriority(priority) {
        const prioritySet = this.priorityIndex.get(priority);
        if (!prioritySet) return [];
        return Array.from(prioritySet).map((id) => this.items.get(id)).filter((item) => item !== void 0);
      }
      /**
       * Get items by resource
       */
      getByResource(resource) {
        const resourceSet = this.resourceIndex.get(resource);
        if (!resourceSet) return [];
        return Array.from(resourceSet).map((id) => this.items.get(id)).filter((item) => item !== void 0);
      }
      /**
       * Get items that are ready to process (past scheduled time)
       */
      getReadyItems(limit) {
        const now = Date.now();
        const readyItems = [];
        for (const priority of ["critical", "high", "normal", "low"]) {
          if (limit && readyItems.length >= limit) break;
          const items = this.getByPriority(priority);
          for (const item of items) {
            if (limit && readyItems.length >= limit) break;
            if (item.status === "pending" && (!item.scheduledAt || item.scheduledAt <= now)) {
              readyItems.push(item);
            }
          }
        }
        return readyItems;
      }
      /**
       * Clear all items
       */
      clear() {
        this.items.clear();
        this.priorityIndex.forEach((set) => set.clear());
        this.statusIndex.forEach((set) => set.clear());
        this.resourceIndex.clear();
        this.metrics = this.initializeMetrics();
      }
      /**
       * Get queue size
       */
      size() {
        return this.items.size;
      }
      /**
       * Check if queue is empty
       */
      isEmpty() {
        return this.items.size === 0;
      }
      /**
       * Get queue statistics
       */
      getStats() {
        return { ...this.metrics };
      }
      /**
       * Get all items as array
       */
      toArray() {
        return Array.from(this.items.values());
      }
      /**
       * Event subscription
       */
      on(event, handler) {
        if (!this.config.enableEvents) return;
        if (!this.eventHandlers.has(event)) {
          this.eventHandlers.set(event, /* @__PURE__ */ new Set());
        }
        this.eventHandlers.get(event).add(handler);
      }
      /**
       * Event unsubscription
       */
      off(event, handler) {
        const handlers = this.eventHandlers.get(event);
        if (handlers) {
          handlers.delete(handler);
        }
      }
      /**
       * Emit event
       */
      emit(event, data) {
        if (!this.config.enableEvents) return;
        const handlers = this.eventHandlers.get(event);
        if (handlers) {
          handlers.forEach((handler) => {
            try {
              handler(data);
            } catch (error) {
              console.error(`Error in queue event handler for ${event}:`, error);
            }
          });
        }
      }
      // Private helper methods
      addToIndex(item) {
        const prioritySet = this.priorityIndex.get(item.priority);
        if (prioritySet) {
          prioritySet.add(item.id);
        }
        const statusSet = this.statusIndex.get(item.status);
        if (statusSet) {
          statusSet.add(item.id);
        }
        if (!this.resourceIndex.has(item.resource)) {
          this.resourceIndex.set(item.resource, /* @__PURE__ */ new Set());
        }
        this.resourceIndex.get(item.resource).add(item.id);
      }
      removeFromIndex(item) {
        const prioritySet = this.priorityIndex.get(item.priority);
        if (prioritySet) {
          prioritySet.delete(item.id);
        }
        const statusSet = this.statusIndex.get(item.status);
        if (statusSet) {
          statusSet.delete(item.id);
        }
        const resourceSet = this.resourceIndex.get(item.resource);
        if (resourceSet) {
          resourceSet.delete(item.id);
          if (resourceSet.size === 0) {
            this.resourceIndex.delete(item.resource);
          }
        }
      }
      updateMetricsOnAdd(item) {
        if (!this.config.enableMetrics) return;
        this.metrics.totalItems++;
        this.metrics.pendingItems++;
        this.metrics.priorityDistribution[item.priority]++;
        this.metrics.resourceDistribution[item.resource]++;
      }
      updateMetricsOnUpdate(oldItem, newItem) {
        if (!this.config.enableMetrics) return;
        if (oldItem.status !== newItem.status) {
          this.decrementStatusCount(oldItem.status);
          this.incrementStatusCount(newItem.status);
          if (newItem.status === "completed") {
            this.metrics.lastProcessedAt = Date.now();
            this.updateSuccessRate();
          }
        }
      }
      updateMetricsOnRemove(item) {
        if (!this.config.enableMetrics) return;
        this.metrics.totalItems--;
        this.decrementStatusCount(item.status);
        this.metrics.priorityDistribution[item.priority]--;
        this.metrics.resourceDistribution[item.resource]--;
      }
      incrementStatusCount(status) {
        switch (status) {
          case "pending":
            this.metrics.pendingItems++;
            break;
          case "processing":
            this.metrics.processingItems++;
            break;
          case "completed":
            this.metrics.completedItems++;
            break;
          case "failed":
            this.metrics.failedItems++;
            break;
          case "dead":
            this.metrics.deadItems++;
            break;
        }
      }
      decrementStatusCount(status) {
        switch (status) {
          case "pending":
            this.metrics.pendingItems = Math.max(0, this.metrics.pendingItems - 1);
            break;
          case "processing":
            this.metrics.processingItems = Math.max(0, this.metrics.processingItems - 1);
            break;
          case "completed":
            this.metrics.completedItems = Math.max(0, this.metrics.completedItems - 1);
            break;
          case "failed":
            this.metrics.failedItems = Math.max(0, this.metrics.failedItems - 1);
            break;
          case "dead":
            this.metrics.deadItems = Math.max(0, this.metrics.deadItems - 1);
            break;
        }
      }
      updateSuccessRate() {
        const total = this.metrics.completedItems + this.metrics.failedItems + this.metrics.deadItems;
        if (total > 0) {
          this.metrics.successRate = this.metrics.completedItems / total * 100;
        }
      }
      emitStatusChangeEvent(item) {
        switch (item.status) {
          case "processing":
            this.emit("item:processing", { item });
            break;
          case "completed":
            this.emit("item:completed", { item });
            break;
          case "failed":
            this.emit("item:failed", {
              item,
              error: item.errorHistory?.[item.errorHistory.length - 1] || {
                timestamp: Date.now(),
                error: "Unknown error",
                retryable: false
              }
            });
            break;
          case "retry":
            this.emit("item:retry", { item, attempt: item.retryCount });
            break;
          case "dead":
            this.emit("item:dead", { item });
            break;
        }
      }
    };
  }
});

// src/storage/queue/batch-processor.ts
var BatchProcessor;
var init_batch_processor = __esm({
  "src/storage/queue/batch-processor.ts"() {
    "use strict";
    init_esm_shims();
    BatchProcessor = class {
      config;
      pendingBatches = /* @__PURE__ */ new Map();
      batchTimers = /* @__PURE__ */ new Map();
      processingBatches = /* @__PURE__ */ new Set();
      eventHandlers = /* @__PURE__ */ new Map();
      batchCounter = 0;
      constructor(config = {}) {
        this.config = {
          maxBatchSize: 50,
          maxWaitTime: 5e3,
          enableResourceGrouping: true,
          enableTimeWindowing: true,
          enablePriorityBatching: false,
          maxConcurrentBatches: 10,
          batchTimeoutMs: 3e4,
          ...config
        };
      }
      /**
       * Add items to batching system
       */
      addToBatch(items, strategy) {
        const groups = this.groupItems(items, strategy);
        const batches = [];
        for (const [groupKey, groupItems] of groups) {
          const batch = this.createOrUpdateBatch(groupKey, groupItems, strategy);
          if (batch) {
            batches.push(batch);
          }
        }
        return batches;
      }
      /**
       * Process a specific batch
       */
      async processBatch(batchId, processor) {
        const batch = this.pendingBatches.get(batchId);
        if (!batch || this.processingBatches.has(batchId)) {
          return null;
        }
        this.processingBatches.add(batchId);
        const updatedBatch = {
          ...batch,
          status: "processing"
        };
        this.pendingBatches.set(batchId, updatedBatch);
        try {
          const timer = this.batchTimers.get(batchId);
          if (timer) {
            clearTimeout(timer);
            this.batchTimers.delete(batchId);
          }
          if (batch.strategy === "parallel") {
            await this.processParallel(batch.items, processor, batch.maxConcurrency);
          } else if (batch.strategy === "sequential") {
            await this.processSequential(batch.items, processor);
          } else {
            await processor(batch.items);
          }
          const completedBatch = {
            ...updatedBatch,
            status: "completed"
          };
          this.pendingBatches.delete(batchId);
          this.processingBatches.delete(batchId);
          this.emit("batch:completed", { batch: completedBatch });
          return completedBatch;
        } catch (error) {
          const failedBatch = {
            ...updatedBatch,
            status: "failed"
          };
          this.pendingBatches.set(batchId, failedBatch);
          this.processingBatches.delete(batchId);
          this.emit("batch:failed", { batch: failedBatch });
          throw error;
        }
      }
      /**
       * Get ready batches (full or timed out)
       */
      getReadyBatches() {
        const readyBatches = [];
        const now = Date.now();
        for (const batch of this.pendingBatches.values()) {
          if (batch.status === "pending") {
            const isFullBatch = batch.items.length >= this.config.maxBatchSize;
            const isTimedOut = now - batch.createdAt >= this.config.maxWaitTime;
            if (isFullBatch || isTimedOut) {
              readyBatches.push(batch);
            }
          }
        }
        return readyBatches;
      }
      /**
       * Force process all pending batches
       */
      async flushAllBatches(processor) {
        const allBatches = Array.from(this.pendingBatches.values()).filter((batch) => batch.status === "pending");
        const results = [];
        for (const batch of allBatches) {
          try {
            const result = await this.processBatch(batch.id, processor);
            if (result) {
              results.push(result);
            }
          } catch (error) {
            console.error(`Failed to process batch ${batch.id}:`, error);
          }
        }
        return results;
      }
      /**
       * Get batch by ID
       */
      getBatch(batchId) {
        return this.pendingBatches.get(batchId) || null;
      }
      /**
       * Get all pending batches
       */
      getPendingBatches() {
        return Array.from(this.pendingBatches.values()).filter((batch) => batch.status === "pending");
      }
      /**
       * Cancel a batch
       */
      cancelBatch(batchId) {
        const batch = this.pendingBatches.get(batchId);
        if (!batch || this.processingBatches.has(batchId)) {
          return false;
        }
        const timer = this.batchTimers.get(batchId);
        if (timer) {
          clearTimeout(timer);
          this.batchTimers.delete(batchId);
        }
        this.pendingBatches.delete(batchId);
        return true;
      }
      /**
       * Clear all batches
       */
      clear() {
        for (const timer of this.batchTimers.values()) {
          clearTimeout(timer);
        }
        this.batchTimers.clear();
        this.pendingBatches.clear();
        this.processingBatches.clear();
      }
      /**
       * Get batch statistics
       */
      getStats() {
        const pendingBatches = this.getPendingBatches();
        return {
          totalBatches: this.pendingBatches.size,
          pendingBatches: pendingBatches.length,
          processingBatches: this.processingBatches.size,
          totalItemsInBatches: pendingBatches.reduce((sum, batch) => sum + batch.items.length, 0),
          averageBatchSize: pendingBatches.length > 0 ? pendingBatches.reduce((sum, batch) => sum + batch.items.length, 0) / pendingBatches.length : 0
        };
      }
      // Event handling
      on(event, handler) {
        if (!this.eventHandlers.has(event)) {
          this.eventHandlers.set(event, /* @__PURE__ */ new Set());
        }
        this.eventHandlers.get(event).add(handler);
      }
      off(event, handler) {
        const handlers = this.eventHandlers.get(event);
        if (handlers) {
          handlers.delete(handler);
        }
      }
      emit(event, data) {
        const handlers = this.eventHandlers.get(event);
        if (handlers) {
          handlers.forEach((handler) => {
            try {
              handler(data);
            } catch (error) {
              console.error(`Error in batch event handler for ${event}:`, error);
            }
          });
        }
      }
      // Private helper methods
      groupItems(items, strategy) {
        const groups = /* @__PURE__ */ new Map();
        for (const item of items) {
          const groupKey = this.generateGroupKey(item, strategy);
          if (!groups.has(groupKey)) {
            groups.set(groupKey, []);
          }
          const group = groups.get(groupKey);
          if (group.length < strategy.maxItemsPerBatch) {
            group.push(item);
          } else {
            const newGroupKey = `${groupKey}_${groups.size}`;
            groups.set(newGroupKey, [item]);
          }
        }
        return groups;
      }
      generateGroupKey(item, strategy) {
        const keyParts = [];
        if (strategy.groupByResource) {
          keyParts.push(`resource:${item.resource}`);
        }
        if (strategy.groupByPriority && !strategy.priorityMixing) {
          keyParts.push(`priority:${item.priority}`);
        }
        if (strategy.groupByTimeWindow) {
          const windowStart = Math.floor(Date.now() / strategy.windowSizeMs) * strategy.windowSizeMs;
          keyParts.push(`window:${windowStart}`);
        }
        return keyParts.join("|") || "default";
      }
      createOrUpdateBatch(groupKey, items, strategy) {
        let existingBatch = null;
        for (const batch of this.pendingBatches.values()) {
          if (batch.status === "pending") {
            const batchGroupKey = this.generateBatchGroupKey(batch, strategy);
            if (batchGroupKey === groupKey) {
              existingBatch = batch;
              break;
            }
          }
        }
        if (existingBatch) {
          const updatedItems = [...existingBatch.items, ...items];
          if (updatedItems.length >= strategy.maxItemsPerBatch) {
            const currentBatchItems = updatedItems.slice(0, strategy.maxItemsPerBatch);
            const remainingItems = updatedItems.slice(strategy.maxItemsPerBatch);
            const updatedBatch = {
              ...existingBatch,
              items: currentBatchItems
            };
            this.pendingBatches.set(existingBatch.id, updatedBatch);
            if (remainingItems.length > 0) {
              return this.createNewBatch(remainingItems, strategy);
            }
            return updatedBatch;
          } else {
            const updatedBatch = {
              ...existingBatch,
              items: updatedItems
            };
            this.pendingBatches.set(existingBatch.id, updatedBatch);
            return updatedBatch;
          }
        } else {
          return this.createNewBatch(items, strategy);
        }
      }
      createNewBatch(items, strategy) {
        const batchId = `batch_${++this.batchCounter}_${Date.now()}`;
        const batch = {
          id: batchId,
          items: items.slice(0, strategy.maxItemsPerBatch),
          status: "pending",
          createdAt: Date.now(),
          strategy: this.determineBatchStrategy(items),
          maxConcurrency: this.config.maxConcurrentBatches
        };
        this.pendingBatches.set(batchId, batch);
        const timer = setTimeout(() => {
          const currentBatch = this.pendingBatches.get(batchId);
          if (currentBatch && currentBatch.status === "pending") {
            const failedBatch = {
              ...currentBatch,
              status: "failed"
            };
            this.pendingBatches.set(batchId, failedBatch);
            this.emit("batch:failed", { batch: failedBatch });
          }
        }, this.config.maxWaitTime);
        this.batchTimers.set(batchId, timer);
        this.emit("batch:created", { batch });
        return batch;
      }
      generateBatchGroupKey(batch, strategy) {
        if (batch.items.length === 0) return "empty";
        const firstItem = batch.items[0];
        if (!firstItem) return "empty";
        return this.generateGroupKey(firstItem, strategy);
      }
      determineBatchStrategy(items) {
        const hasHighPriority = items.some((item) => item.priority === "critical" || item.priority === "high");
        const hasDependencies = items.some((item) => item.dependencies && item.dependencies.length > 0);
        if (hasDependencies) {
          return "sequential";
        } else if (hasHighPriority && items.length <= 10) {
          return "parallel";
        } else {
          return "sequential";
        }
      }
      async processParallel(items, processor, maxConcurrency = 5) {
        const chunks = this.chunkArray(items, Math.max(1, Math.floor(items.length / maxConcurrency)));
        await Promise.all(
          chunks.map((chunk) => processor(chunk))
        );
      }
      async processSequential(items, processor) {
        for (const item of items) {
          await processor([item]);
        }
      }
      chunkArray(array, chunkSize) {
        const chunks = [];
        for (let i = 0; i < array.length; i += chunkSize) {
          chunks.push(array.slice(i, i + chunkSize));
        }
        return chunks;
      }
      // Cleanup
      destroy() {
        this.clear();
      }
    };
  }
});

// src/storage/queue/retry-manager.ts
var RetryManager;
var init_retry_manager = __esm({
  "src/storage/queue/retry-manager.ts"() {
    "use strict";
    init_esm_shims();
    RetryManager = class {
      config;
      circuitBreakers = /* @__PURE__ */ new Map();
      activeRetries = /* @__PURE__ */ new Map();
      retryTimers = /* @__PURE__ */ new Map();
      metrics;
      eventHandlers = /* @__PURE__ */ new Map();
      constructor(config = {}) {
        this.config = {
          defaultRetryPolicy: this.getDefaultRetryPolicy(),
          circuitBreakerConfig: {
            enabled: true,
            failureThreshold: 5,
            successThreshold: 3,
            timeout: 6e4,
            monitoringWindow: 3e5
          },
          maxConcurrentRetries: 10,
          retryQueueSize: 1e3,
          enableJitter: true,
          enableMetrics: true,
          ...config
        };
        this.metrics = this.initializeMetrics();
        this.initializeCircuitBreakers();
      }
      /**
       * Schedule retry for a failed item
       */
      scheduleRetry(item, error) {
        if (item.retryCount >= item.maxRetries) {
          this.emit("item:max-retries-exceeded", { item });
          return false;
        }
        if (!this.isCircuitClosed(item.resource)) {
          this.emit("item:circuit-open", { item, resource: item.resource });
          return false;
        }
        if (this.activeRetries.size >= this.config.retryQueueSize) {
          this.emit("retry:queue-full", {
            queueSize: this.activeRetries.size,
            maxSize: this.config.retryQueueSize
          });
          return false;
        }
        const retryPolicy = this.getRetryPolicy(item);
        const nextAttempt = item.retryCount + 1;
        const delay = this.calculateDelay(nextAttempt, retryPolicy);
        const retryAttempt = {
          itemId: item.id,
          attempt: nextAttempt,
          scheduledAt: Date.now() + delay,
          lastError: error,
          backoffDelay: delay
        };
        this.activeRetries.set(item.id, retryAttempt);
        const timer = setTimeout(() => {
          this.executeRetry(item.id);
        }, delay);
        this.retryTimers.set(item.id, timer);
        this.updateMetricsOnRetryScheduled(item.resource, delay);
        this.emit("item:retry-scheduled", { item, delay, attempt: nextAttempt });
        return true;
      }
      /**
       * Cancel scheduled retry
       */
      cancelRetry(itemId) {
        const timer = this.retryTimers.get(itemId);
        if (timer) {
          clearTimeout(timer);
          this.retryTimers.delete(itemId);
        }
        const retryAttempt = this.activeRetries.get(itemId);
        if (retryAttempt) {
          this.activeRetries.delete(itemId);
          if (retryAttempt.item) {
            this.emit("item:retry-cancelled", { item: retryAttempt.item });
          }
          return true;
        }
        return false;
      }
      /**
       * Record successful operation (for circuit breaker)
       */
      recordSuccess(resource) {
        const circuitBreaker = this.circuitBreakers.get(resource);
        if (!circuitBreaker) return;
        let updatedState = {
          ...circuitBreaker,
          successCount: circuitBreaker.successCount + 1,
          lastFailureTime: null
        };
        if (circuitBreaker.state === "half-open" && updatedState.successCount >= this.config.circuitBreakerConfig.successThreshold) {
          updatedState = {
            ...updatedState,
            state: "closed",
            failureCount: 0,
            successCount: 0
          };
          this.emit("circuit:closed", { resource });
        }
        this.circuitBreakers.set(resource, updatedState);
        this.updateMetricsOnSuccess(resource);
      }
      /**
       * Record failed operation (for circuit breaker)
       */
      recordFailure(resource, _error) {
        const circuitBreaker = this.circuitBreakers.get(resource);
        if (!circuitBreaker) return;
        const now = Date.now();
        let updatedState = {
          ...circuitBreaker,
          failureCount: circuitBreaker.failureCount + 1,
          lastFailureTime: now,
          successCount: 0
          // Reset success count on failure
        };
        if (circuitBreaker.state === "closed" && updatedState.failureCount >= this.config.circuitBreakerConfig.failureThreshold) {
          updatedState = {
            ...updatedState,
            state: "open",
            nextRetryTime: now + this.config.circuitBreakerConfig.timeout
          };
          this.emit("circuit:opened", { resource, errorRate: updatedState.failureCount });
          this.metrics.circuitBreakerTrips++;
        }
        this.circuitBreakers.set(resource, updatedState);
        this.updateMetricsOnFailure(resource);
      }
      /**
       * Check if circuit is closed for a resource
       */
      isCircuitClosed(resource) {
        if (!this.config.circuitBreakerConfig.enabled) return true;
        const circuitBreaker = this.circuitBreakers.get(resource);
        if (!circuitBreaker) return true;
        const now = Date.now();
        switch (circuitBreaker.state) {
          case "closed":
            return true;
          case "open":
            if (circuitBreaker.nextRetryTime && now >= circuitBreaker.nextRetryTime) {
              const updatedState = {
                ...circuitBreaker,
                state: "half-open",
                successCount: 0
              };
              this.circuitBreakers.set(resource, updatedState);
              this.emit("circuit:half-open", { resource });
              return true;
            }
            return false;
          case "half-open":
            return true;
          default:
            return true;
        }
      }
      /**
       * Get circuit breaker state for a resource
       */
      getCircuitState(resource) {
        return this.circuitBreakers.get(resource) || null;
      }
      /**
       * Get all active retries
       */
      getActiveRetries() {
        return Array.from(this.activeRetries.values());
      }
      /**
       * Get retry metrics
       */
      getMetrics() {
        return { ...this.metrics };
      }
      /**
       * Clear all retries
       */
      clearRetries() {
        for (const timer of this.retryTimers.values()) {
          clearTimeout(timer);
        }
        this.retryTimers.clear();
        this.activeRetries.clear();
      }
      /**
       * Reset circuit breaker for a resource
       */
      resetCircuitBreaker(resource) {
        const initialState = this.createInitialCircuitBreakerState();
        this.circuitBreakers.set(resource, initialState);
        this.emit("circuit:reset", { resource });
      }
      /**
       * Get retry policy for an item
       */
      getRetryPolicy(_item) {
        return this.config.defaultRetryPolicy;
      }
      // Event handling
      on(event, handler) {
        if (!this.eventHandlers.has(event)) {
          this.eventHandlers.set(event, /* @__PURE__ */ new Set());
        }
        this.eventHandlers.get(event).add(handler);
      }
      off(event, handler) {
        const handlers = this.eventHandlers.get(event);
        if (handlers) {
          handlers.delete(handler);
        }
      }
      emit(event, data) {
        const handlers = this.eventHandlers.get(event);
        if (handlers) {
          handlers.forEach((handler) => {
            try {
              handler(data);
            } catch (error) {
              console.error(`Error in retry manager event handler for ${event}:`, error);
            }
          });
        }
      }
      // Private methods
      async executeRetry(itemId) {
        const retryAttempt = this.activeRetries.get(itemId);
        if (!retryAttempt) return;
        this.activeRetries.delete(itemId);
        this.retryTimers.delete(itemId);
        this.emit("item:retry-ready", { itemId, attempt: retryAttempt.attempt });
      }
      calculateDelay(attempt, policy) {
        let delay;
        switch (policy.strategy) {
          case "exponential":
            delay = Math.min(
              policy.baseDelay * Math.pow(policy.backoffFactor, attempt - 1),
              policy.maxDelay
            );
            break;
          case "linear":
            delay = Math.min(
              policy.baseDelay * attempt,
              policy.maxDelay
            );
            break;
          case "custom":
            delay = policy.baseDelay;
            break;
          default:
            delay = policy.baseDelay;
        }
        if (this.config.enableJitter && policy.jitterEnabled) {
          const jitter = delay * 0.1 * Math.random();
          delay += jitter;
        }
        return Math.floor(delay);
      }
      getDefaultRetryPolicy() {
        return {
          strategy: "exponential",
          maxRetries: 3,
          baseDelay: 1e3,
          maxDelay: 3e4,
          backoffFactor: 2,
          jitterEnabled: true,
          retryableErrors: [
            "NETWORK_ERROR",
            "TIMEOUT",
            "SERVER_ERROR",
            "RATE_LIMITED",
            "TEMPORARY_FAILURE"
          ],
          nonRetryableErrors: [
            "AUTHENTICATION_ERROR",
            "AUTHORIZATION_ERROR",
            "VALIDATION_ERROR",
            "NOT_FOUND",
            "CONFLICT"
          ]
        };
      }
      initializeMetrics() {
        return {
          totalRetries: 0,
          successfulRetries: 0,
          failedRetries: 0,
          averageRetryDelay: 0,
          circuitBreakerTrips: 0,
          retrySuccessRate: 0,
          resourceMetrics: {
            receipts: { retries: 0, successes: 0, failures: 0, averageDelay: 0 },
            cashiers: { retries: 0, successes: 0, failures: 0, averageDelay: 0 },
            merchants: { retries: 0, successes: 0, failures: 0, averageDelay: 0 },
            "cash-registers": { retries: 0, successes: 0, failures: 0, averageDelay: 0 },
            "point-of-sales": { retries: 0, successes: 0, failures: 0, averageDelay: 0 },
            pems: { retries: 0, successes: 0, failures: 0, averageDelay: 0 }
          }
        };
      }
      initializeCircuitBreakers() {
        const resources = [
          "receipts",
          "cashiers",
          "merchants",
          "cash-registers",
          "point-of-sales",
          "pems"
        ];
        for (const resource of resources) {
          this.circuitBreakers.set(resource, this.createInitialCircuitBreakerState());
        }
      }
      createInitialCircuitBreakerState() {
        return {
          state: "closed",
          failureCount: 0,
          successCount: 0,
          lastFailureTime: null,
          nextRetryTime: null,
          threshold: this.config.circuitBreakerConfig.failureThreshold,
          timeout: this.config.circuitBreakerConfig.timeout
        };
      }
      updateMetricsOnRetryScheduled(resource, delay) {
        if (!this.config.enableMetrics) return;
        this.metrics.totalRetries++;
        this.metrics.resourceMetrics[resource].retries++;
        const totalDelay = this.metrics.averageRetryDelay * (this.metrics.totalRetries - 1) + delay;
        this.metrics.averageRetryDelay = totalDelay / this.metrics.totalRetries;
        const resourceMetric = this.metrics.resourceMetrics[resource];
        const resourceTotalDelay = resourceMetric.averageDelay * (resourceMetric.retries - 1) + delay;
        resourceMetric.averageDelay = resourceTotalDelay / resourceMetric.retries;
      }
      updateMetricsOnSuccess(resource) {
        if (!this.config.enableMetrics) return;
        this.metrics.successfulRetries++;
        this.metrics.resourceMetrics[resource].successes++;
        this.updateRetrySuccessRate();
      }
      updateMetricsOnFailure(resource) {
        if (!this.config.enableMetrics) return;
        this.metrics.failedRetries++;
        this.metrics.resourceMetrics[resource].failures++;
        this.updateRetrySuccessRate();
      }
      updateRetrySuccessRate() {
        const total = this.metrics.successfulRetries + this.metrics.failedRetries;
        if (total > 0) {
          this.metrics.retrySuccessRate = this.metrics.successfulRetries / total * 100;
        }
      }
      // Cleanup
      destroy() {
        this.clearRetries();
        this.circuitBreakers.clear();
        this.eventHandlers.clear();
      }
    };
  }
});

// src/storage/queue/queue-analytics.ts
var QueueAnalytics;
var init_queue_analytics = __esm({
  "src/storage/queue/queue-analytics.ts"() {
    "use strict";
    init_esm_shims();
    QueueAnalytics = class {
      config;
      metricsHistory = [];
      realtimeMetrics = null;
      aggregatedMetrics = /* @__PURE__ */ new Map();
      itemTimings = /* @__PURE__ */ new Map();
      processingStartTimes = /* @__PURE__ */ new Map();
      constructor(config = {}) {
        this.config = {
          enabled: true,
          sampleRate: 1,
          retentionDays: 30,
          aggregationIntervals: [6e4, 3e5, 36e5],
          // 1min, 5min, 1hour
          enableRealTimeMetrics: true,
          enableTrendAnalysis: true,
          ...config
        };
        if (this.config.enabled) {
          this.initializeAggregationMaps();
          this.startRealtimeMetrics();
        }
      }
      /**
       * Record item processing start
       */
      recordProcessingStart(itemId) {
        if (!this.config.enabled || Math.random() > this.config.sampleRate) return;
        this.processingStartTimes.set(itemId, Date.now());
      }
      /**
       * Record item processing completion
       */
      recordProcessingComplete(itemId, _success) {
        if (!this.config.enabled) return;
        const startTime = this.processingStartTimes.get(itemId);
        if (startTime) {
          const processingTime = Date.now() - startTime;
          this.itemTimings.set(itemId, processingTime);
          this.processingStartTimes.delete(itemId);
        }
      }
      /**
       * Record queue snapshot for metrics
       */
      recordQueueSnapshot(stats) {
        if (!this.config.enabled) return;
        const metrics = {
          timestamp: Date.now(),
          processingTime: this.calculateAverageProcessingTime(),
          queueSize: stats.totalItems,
          throughput: this.calculateThroughput(),
          errorRate: this.calculateErrorRate(stats),
          priorityDistribution: stats.priorityDistribution,
          resourceDistribution: stats.resourceDistribution,
          operationDistribution: this.getOperationDistribution(stats)
        };
        this.addMetricsPoint(metrics);
        if (this.config.enableRealTimeMetrics) {
          this.realtimeMetrics = metrics;
        }
      }
      /**
       * Get comprehensive queue insights
       */
      getInsights(timeRangeMs = 864e5) {
        if (!this.config.enabled) {
          return this.getEmptyInsights();
        }
        const cutoffTime = Date.now() - timeRangeMs;
        const relevantMetrics = this.metricsHistory.filter((m) => m.timestamp >= cutoffTime);
        return {
          bottlenecks: this.analyzeBottlenecks(relevantMetrics),
          patterns: this.identifyPatterns(relevantMetrics),
          anomalies: this.detectAnomalies(relevantMetrics),
          forecasts: this.generateForecasts(relevantMetrics),
          healthScore: this.calculateHealthScore(relevantMetrics)
        };
      }
      /**
       * Get trend analysis for specified time range
       */
      getTrendAnalysis(timeRangeMs = 864e5) {
        if (!this.config.enabled || !this.config.enableTrendAnalysis) {
          return this.getEmptyTrendAnalysis();
        }
        const cutoffTime = Date.now() - timeRangeMs;
        const relevantMetrics = this.metricsHistory.filter((m) => m.timestamp >= cutoffTime);
        if (relevantMetrics.length === 0) {
          return this.getEmptyTrendAnalysis();
        }
        const avgProcessingTime = relevantMetrics.reduce((sum, m) => sum + m.processingTime, 0) / relevantMetrics.length;
        const avgQueueSize = relevantMetrics.reduce((sum, m) => sum + m.queueSize, 0) / relevantMetrics.length;
        const avgThroughput = relevantMetrics.reduce((sum, m) => sum + m.throughput, 0) / relevantMetrics.length;
        const peakQueueSize = Math.max(...relevantMetrics.map((m) => m.queueSize));
        const errorRateChange = this.calculateErrorRateChange(relevantMetrics);
        const performanceScore = this.calculatePerformanceScore(relevantMetrics);
        return {
          timeRange: this.formatTimeRange(timeRangeMs),
          avgProcessingTime,
          avgQueueSize,
          avgThroughput,
          peakQueueSize,
          errorRateChange,
          performanceScore,
          recommendations: this.generateRecommendations(relevantMetrics)
        };
      }
      /**
       * Get real-time metrics
       */
      getRealTimeMetrics() {
        return this.realtimeMetrics;
      }
      /**
       * Get aggregated metrics for specific interval
       */
      getAggregatedMetrics(intervalMs, timeRangeMs = 864e5) {
        const aggregated = this.aggregatedMetrics.get(intervalMs);
        if (!aggregated) return [];
        const cutoffTime = Date.now() - timeRangeMs;
        return aggregated.filter((m) => m.timestamp >= cutoffTime);
      }
      /**
       * Clear old metrics data
       */
      cleanup() {
        if (!this.config.enabled) return;
        const cutoffTime = Date.now() - this.config.retentionDays * 24 * 60 * 60 * 1e3;
        this.metricsHistory = this.metricsHistory.filter((m) => m.timestamp >= cutoffTime);
        for (const [interval, metrics] of this.aggregatedMetrics) {
          this.aggregatedMetrics.set(interval, metrics.filter((m) => m.timestamp >= cutoffTime));
        }
        const oldTimingKeys = Array.from(this.itemTimings.keys()).slice(0, -1e3);
        oldTimingKeys.forEach((key) => this.itemTimings.delete(key));
      }
      /**
       * Export metrics data
       */
      exportMetrics(format = "json") {
        if (format === "csv") {
          return this.exportAsCSV();
        }
        return JSON.stringify(this.metricsHistory, null, 2);
      }
      // Private methods
      initializeAggregationMaps() {
        for (const interval of this.config.aggregationIntervals) {
          this.aggregatedMetrics.set(interval, []);
        }
      }
      startRealtimeMetrics() {
        if (!this.config.enableRealTimeMetrics) return;
        setInterval(() => {
          if (this.realtimeMetrics) {
            const age = Date.now() - this.realtimeMetrics.timestamp;
            if (age > 6e4) {
              this.realtimeMetrics = null;
            }
          }
        }, 3e4);
      }
      addMetricsPoint(metrics) {
        this.metricsHistory.push(metrics);
        for (const interval of this.config.aggregationIntervals) {
          this.addToAggregatedMetrics(metrics, interval);
        }
        if (this.metricsHistory.length > 1e4) {
          this.metricsHistory = this.metricsHistory.slice(-5e3);
        }
      }
      addToAggregatedMetrics(metrics, intervalMs) {
        const aggregated = this.aggregatedMetrics.get(intervalMs);
        if (!aggregated) return;
        const bucketTime = Math.floor(metrics.timestamp / intervalMs) * intervalMs;
        let bucket = aggregated.find((m) => m.timestamp === bucketTime);
        if (!bucket) {
          bucket = { ...metrics, timestamp: bucketTime };
          aggregated.push(bucket);
        } else {
          this.aggregateMetrics(bucket, metrics);
        }
      }
      aggregateMetrics(bucket, newMetrics) {
        bucket.processingTime = (bucket.processingTime + newMetrics.processingTime) / 2;
        bucket.queueSize = Math.max(bucket.queueSize, newMetrics.queueSize);
        bucket.throughput = (bucket.throughput + newMetrics.throughput) / 2;
        bucket.errorRate = (bucket.errorRate + newMetrics.errorRate) / 2;
      }
      calculateAverageProcessingTime() {
        if (this.itemTimings.size === 0) return 0;
        const timings = Array.from(this.itemTimings.values());
        return timings.reduce((sum, time) => sum + time, 0) / timings.length;
      }
      calculateThroughput() {
        const oneMinuteAgo = Date.now() - 6e4;
        const recentTimings = Array.from(this.itemTimings.entries()).filter(([_, time]) => time >= oneMinuteAgo);
        return recentTimings.length;
      }
      calculateErrorRate(stats) {
        const total = stats.completedItems + stats.failedItems + stats.deadItems;
        if (total === 0) return 0;
        return (stats.failedItems + stats.deadItems) / total * 100;
      }
      getOperationDistribution(_stats) {
        return {
          create: 0,
          update: 0,
          delete: 0,
          batch: 0,
          custom: 0
        };
      }
      analyzeBottlenecks(metrics) {
        const bottlenecks = [];
        if (metrics.length === 0) return bottlenecks;
        const avgQueueSize = metrics.reduce((sum, m) => sum + m.queueSize, 0) / metrics.length;
        if (avgQueueSize > 50) {
          bottlenecks.push({
            type: "resource",
            identifier: "queue_size",
            severity: avgQueueSize > 200 ? "critical" : "high",
            impact: avgQueueSize,
            suggestion: "Consider increasing processing capacity or implementing load balancing"
          });
        }
        const avgProcessingTime = metrics.reduce((sum, m) => sum + m.processingTime, 0) / metrics.length;
        if (avgProcessingTime > 5e3) {
          bottlenecks.push({
            type: "operation",
            identifier: "processing_time",
            severity: avgProcessingTime > 15e3 ? "critical" : "high",
            impact: avgProcessingTime,
            suggestion: "Optimize operation processing or implement batching"
          });
        }
        return bottlenecks;
      }
      identifyPatterns(metrics) {
        const patterns = [];
        const highThroughputPeriods = metrics.filter((m) => m.throughput > 50);
        if (highThroughputPeriods.length > metrics.length * 0.3) {
          patterns.push({
            pattern: "peak_hours",
            description: "High throughput periods detected",
            frequency: highThroughputPeriods.length / metrics.length,
            timeWindows: ["9:00-11:00", "14:00-16:00"],
            impact: 0.7
          });
        }
        return patterns;
      }
      detectAnomalies(metrics) {
        const anomalies = [];
        if (metrics.length < 10) return anomalies;
        const avgThroughput = metrics.reduce((sum, m) => sum + m.throughput, 0) / metrics.length;
        const throughputStdDev = this.calculateStandardDeviation(metrics.map((m) => m.throughput));
        const recentMetrics = metrics.slice(-5);
        for (const metric of recentMetrics) {
          const deviation = Math.abs(metric.throughput - avgThroughput);
          if (deviation > throughputStdDev * 2) {
            anomalies.push({
              type: "throughput",
              timestamp: metric.timestamp,
              severity: deviation > throughputStdDev * 3 ? "high" : "medium",
              description: "Abnormal throughput detected",
              deviation: deviation / avgThroughput,
              expectedValue: avgThroughput,
              actualValue: metric.throughput
            });
          }
        }
        return anomalies;
      }
      generateForecasts(metrics) {
        const forecasts = [];
        if (metrics.length < 20) return forecasts;
        const queueSizes = metrics.map((m) => m.queueSize);
        const queueTrend = this.calculateTrend(queueSizes);
        forecasts.push({
          metric: "queue_size",
          timeHorizon: 36e5,
          // 1 hour
          predictedValue: (queueSizes[queueSizes.length - 1] || 0) + queueTrend,
          confidence: 0.7,
          trend: queueTrend > 1 ? "increasing" : queueTrend < -1 ? "decreasing" : "stable"
        });
        return forecasts;
      }
      calculateHealthScore(metrics) {
        if (metrics.length === 0) return 100;
        let score = 100;
        const avgErrorRate = metrics.reduce((sum, m) => sum + m.errorRate, 0) / metrics.length;
        score -= avgErrorRate * 2;
        const avgQueueSize = metrics.reduce((sum, m) => sum + m.queueSize, 0) / metrics.length;
        if (avgQueueSize > 50) {
          score -= (avgQueueSize - 50) * 0.5;
        }
        const avgProcessingTime = metrics.reduce((sum, m) => sum + m.processingTime, 0) / metrics.length;
        if (avgProcessingTime > 2e3) {
          score -= (avgProcessingTime - 2e3) * 0.01;
        }
        return Math.max(0, Math.min(100, score));
      }
      calculateErrorRateChange(metrics) {
        if (metrics.length < 2) return 0;
        const firstHalf = metrics.slice(0, Math.floor(metrics.length / 2));
        const secondHalf = metrics.slice(Math.floor(metrics.length / 2));
        const firstAvg = firstHalf.reduce((sum, m) => sum + m.errorRate, 0) / firstHalf.length;
        const secondAvg = secondHalf.reduce((sum, m) => sum + m.errorRate, 0) / secondHalf.length;
        return secondAvg - firstAvg;
      }
      calculatePerformanceScore(metrics) {
        return this.calculateHealthScore(metrics);
      }
      generateRecommendations(metrics) {
        const recommendations = [];
        if (metrics.length === 0) return recommendations;
        const avgQueueSize = metrics.reduce((sum, m) => sum + m.queueSize, 0) / metrics.length;
        if (avgQueueSize > 100) {
          recommendations.push("Consider implementing horizontal scaling to handle queue backlog");
        }
        const avgErrorRate = metrics.reduce((sum, m) => sum + m.errorRate, 0) / metrics.length;
        if (avgErrorRate > 10) {
          recommendations.push("Investigate and fix root causes of high error rate");
        }
        const avgProcessingTime = metrics.reduce((sum, m) => sum + m.processingTime, 0) / metrics.length;
        if (avgProcessingTime > 5e3) {
          recommendations.push("Optimize operation processing or implement operation batching");
        }
        return recommendations;
      }
      calculateStandardDeviation(values) {
        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
        const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
        return Math.sqrt(variance);
      }
      calculateTrend(values) {
        if (values.length < 2) return 0;
        const n = values.length;
        const sumX = n * (n - 1) / 2;
        const sumY = values.reduce((sum, val) => sum + val, 0);
        const sumXY = values.reduce((sum, val, index) => sum + val * index, 0);
        const sumX2 = values.reduce((sum, _, index) => sum + index * index, 0);
        return (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      }
      formatTimeRange(timeRangeMs) {
        const hours = timeRangeMs / (1e3 * 60 * 60);
        if (hours < 24) {
          return `${Math.round(hours)} hours`;
        }
        return `${Math.round(hours / 24)} days`;
      }
      exportAsCSV() {
        const headers = ["timestamp", "processingTime", "queueSize", "throughput", "errorRate"];
        const rows = this.metricsHistory.map((m) => [
          m.timestamp,
          m.processingTime,
          m.queueSize,
          m.throughput,
          m.errorRate
        ]);
        return [headers.join(","), ...rows.map((row) => row.join(","))].join("\n");
      }
      getEmptyInsights() {
        return {
          bottlenecks: [],
          patterns: [],
          anomalies: [],
          forecasts: [],
          healthScore: 100
        };
      }
      getEmptyTrendAnalysis() {
        return {
          timeRange: "0 hours",
          avgProcessingTime: 0,
          avgQueueSize: 0,
          avgThroughput: 0,
          peakQueueSize: 0,
          errorRateChange: 0,
          performanceScore: 100,
          recommendations: []
        };
      }
      // Cleanup
      destroy() {
        this.metricsHistory = [];
        this.aggregatedMetrics.clear();
        this.itemTimings.clear();
        this.processingStartTimes.clear();
        this.realtimeMetrics = null;
      }
    };
  }
});

// src/storage/queue/queue-manager.ts
var queue_manager_exports = {};
__export(queue_manager_exports, {
  EnterpriseQueueManager: () => EnterpriseQueueManager
});
var EnterpriseQueueManager;
var init_queue_manager = __esm({
  "src/storage/queue/queue-manager.ts"() {
    "use strict";
    init_esm_shims();
    init_eventemitter3();
    init_priority_queue();
    init_batch_processor();
    init_retry_manager();
    init_queue_analytics();
    init_types();
    EnterpriseQueueManager = class extends import_index.default {
      config;
      priorityQueue;
      batchProcessor;
      // private _conflictResolver: ConflictResolverManager;  // TODO: Implement conflict resolution
      retryManager;
      analytics;
      processors = /* @__PURE__ */ new Map();
      processingItems = /* @__PURE__ */ new Set();
      processingTimer = null;
      isProcessing = false;
      itemCounter = 0;
      constructor(config = {}) {
        super();
        this.config = {
          maxSize: 1e4,
          maxRetries: 3,
          defaultPriority: "normal",
          defaultRetryStrategy: "exponential",
          defaultConflictResolution: "server-wins",
          batchingEnabled: true,
          batchSize: 20,
          batchTimeout: 5e3,
          deadLetterEnabled: true,
          analyticsEnabled: true,
          persistToDisk: true,
          circuitBreakerEnabled: true,
          circuitBreakerThreshold: 5,
          deduplicationEnabled: true,
          deduplicationWindow: 3e5,
          storageKey: "acube-enterprise-queue",
          autoProcessing: true,
          processingInterval: 1e3,
          maxConcurrentProcessing: 5,
          enablePersistence: true,
          enableAnalytics: true,
          ...config
        };
        this.priorityQueue = new PriorityQueue(this.config);
        this.batchProcessor = new BatchProcessor({});
        this.retryManager = new RetryManager({});
        this.analytics = new QueueAnalytics({});
        this.initializeComponents();
        this.setupEventHandlers();
        if (this.config.autoProcessing) {
          this.startAutoProcessing();
        }
      }
      /**
       * Add operation to queue
       */
      async enqueue(operation, resource, data, options = {}) {
        const id = createQueueItemId(`${resource}_${operation}_${++this.itemCounter}_${Date.now()}`);
        const item = {
          id,
          priority: options.priority || this.config.defaultPriority,
          operation,
          resource,
          data,
          status: "pending",
          createdAt: Date.now(),
          updatedAt: Date.now(),
          ...options.scheduledAt !== void 0 && { scheduledAt: options.scheduledAt },
          retryCount: 0,
          maxRetries: this.config.maxRetries,
          retryStrategy: this.config.defaultRetryStrategy,
          conflictResolution: this.config.defaultConflictResolution,
          ...options.optimisticId && { optimisticId: options.optimisticId },
          ...options.batchId && { batchId: options.batchId },
          ...options.dependencies && { dependencies: options.dependencies },
          ...options.metadata && { metadata: options.metadata },
          errorHistory: []
        };
        if (this.config.deduplicationEnabled && this.isDuplicate(item)) {
          throw new Error(`Duplicate operation detected for ${resource}:${operation}`);
        }
        const success = this.priorityQueue.enqueue(item);
        if (!success) {
          throw new Error("Queue is full - unable to enqueue item");
        }
        if (this.config.enablePersistence) {
          await this.persistQueue();
        }
        if (this.config.enableAnalytics) {
          this.analytics.recordQueueSnapshot(this.getStats());
        }
        return id;
      }
      /**
       * Remove item from queue
       */
      async dequeue(id) {
        const success = this.priorityQueue.remove(id);
        if (success && this.config.enablePersistence) {
          await this.persistQueue();
        }
        return success;
      }
      /**
       * Get item by ID
       */
      getItem(id) {
        return this.priorityQueue.get(id);
      }
      /**
       * Update item status
       */
      async updateItemStatus(id, status, error) {
        const item = this.priorityQueue.get(id);
        if (!item) {
          return false;
        }
        let errorHistory = item.errorHistory || [];
        if (error) {
          const newErrorEntry = {
            timestamp: Date.now(),
            error,
            retryable: this.isRetryableError(error),
            context: { status: item.status }
          };
          errorHistory = [...errorHistory, newErrorEntry];
        }
        const updatedItem = {
          ...item,
          status,
          updatedAt: Date.now(),
          ...error && { errorHistory }
        };
        const success = this.priorityQueue.updateItem(id, updatedItem);
        if (success) {
          await this.handleStatusChange(id, status, error);
          if (this.config.enablePersistence) {
            await this.persistQueue();
          }
        }
        return success;
      }
      /**
       * Register processor for resource/operation combination
       */
      registerProcessor(resource, operation, processor) {
        const key = `${resource}:${operation}`;
        this.processors.set(key, processor);
      }
      /**
       * Process next available items
       */
      async processNext(maxItems = 1) {
        if (this.isProcessing) {
          return [];
        }
        this.isProcessing = true;
        const results = [];
        try {
          const availableSlots = Math.min(
            maxItems,
            this.config.maxConcurrentProcessing - this.processingItems.size
          );
          if (availableSlots <= 0) {
            return results;
          }
          const readyItems = this.priorityQueue.getReadyItems(availableSlots);
          if (readyItems.length === 0) {
            return results;
          }
          if (this.config.batchingEnabled) {
            const batchResults = await this.processBatched(readyItems);
            results.push(...batchResults);
          } else {
            const individualResults = await this.processIndividually(readyItems);
            results.push(...individualResults);
          }
          if (this.config.enableAnalytics) {
            this.analytics.recordQueueSnapshot(this.getStats());
          }
        } finally {
          this.isProcessing = false;
        }
        return results;
      }
      /**
       * Process all pending items
       */
      async processAll() {
        const allResults = [];
        while (this.priorityQueue.getReadyItems(1).length > 0) {
          const results = await this.processNext(this.config.maxConcurrentProcessing);
          if (results.length === 0) break;
          allResults.push(...results);
        }
        return allResults;
      }
      /**
       * Get queue statistics
       */
      getStats() {
        return this.priorityQueue.getStats();
      }
      /**
       * Get queue insights
       */
      getInsights() {
        return this.analytics.getInsights();
      }
      /**
       * Get trend analysis
       */
      getTrendAnalysis() {
        return this.analytics.getTrendAnalysis();
      }
      /**
       * Clear all items from queue
       */
      async clear() {
        this.priorityQueue.clear();
        this.batchProcessor.clear();
        this.retryManager.clearRetries();
        this.processingItems.clear();
        if (this.config.enablePersistence) {
          await this.persistQueue();
        }
      }
      /**
       * Pause queue processing
       */
      pause() {
        if (this.processingTimer) {
          clearInterval(this.processingTimer);
          this.processingTimer = null;
        }
        this.emit("queue:paused", {});
      }
      /**
       * Resume queue processing
       */
      resume() {
        if (this.config.autoProcessing && !this.processingTimer) {
          this.startAutoProcessing();
        }
        this.emit("queue:resumed", {});
      }
      /**
       * Get processing status
       */
      getProcessingStatus() {
        return {
          isProcessing: this.isProcessing,
          processingItems: this.processingItems.size,
          autoProcessing: this.processingTimer !== null,
          readyItems: this.priorityQueue.getReadyItems().length
        };
      }
      /**
       * Initialize the queue manager
       */
      async initialize() {
        this.initializeComponents();
        this.emit("queue:initialized", {});
      }
      /**
       * Add item to queue (compatibility method)
       */
      async add(item) {
        const success = this.priorityQueue.enqueue(item);
        if (!success) {
          throw new Error("Failed to add item to queue");
        }
        if (this.config.enablePersistence) {
          await this.persistQueue();
        }
      }
      /**
       * Process a specific queue item (public interface)
       */
      async processItem(item) {
        return this.processItemInternal(item);
      }
      /**
       * Get all queue items (compatibility method)
       */
      getQueueItems() {
        return this.priorityQueue.toArray();
      }
      /**
       * Cleanup and destroy
       */
      async destroy() {
        this.pause();
        while (this.isProcessing) {
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
        this.priorityQueue.clear();
        this.batchProcessor.destroy();
        this.retryManager.destroy();
        this.analytics.destroy();
        this.removeAllListeners();
      }
      // Private methods
      initializeComponents() {
        this.priorityQueue = new PriorityQueue({
          maxSize: this.config.maxSize,
          enableMetrics: this.config.analyticsEnabled,
          enableEvents: true
        });
        this.batchProcessor = new BatchProcessor({
          maxBatchSize: this.config.batchSize,
          maxWaitTime: this.config.batchTimeout,
          enableResourceGrouping: true,
          enableTimeWindowing: true
        });
        this.retryManager = new RetryManager({
          defaultRetryPolicy: {
            strategy: this.config.defaultRetryStrategy,
            maxRetries: this.config.maxRetries,
            baseDelay: 1e3,
            maxDelay: 3e4,
            backoffFactor: 2,
            jitterEnabled: true
          },
          circuitBreakerConfig: {
            enabled: this.config.circuitBreakerEnabled,
            failureThreshold: this.config.circuitBreakerThreshold,
            successThreshold: 3,
            timeout: 6e4,
            monitoringWindow: 3e5
          }
        });
        this.analytics = new QueueAnalytics({
          enabled: this.config.enableAnalytics,
          sampleRate: 1,
          retentionDays: 7
        });
      }
      setupEventHandlers() {
        this.priorityQueue.on("item:added", (data) => this.emit("item:added", data));
        this.priorityQueue.on("item:processing", (data) => this.emit("item:processing", data));
        this.priorityQueue.on("item:completed", (data) => this.emit("item:completed", data));
        this.priorityQueue.on("item:failed", (data) => this.emit("item:failed", data));
        this.retryManager.on("item:retry-ready", async ({ itemId }) => {
          const item = this.priorityQueue.get(itemId);
          if (item) {
            await this.priorityQueue.updateItem(itemId, {
              status: "pending",
              retryCount: item.retryCount + 1
            });
          }
        });
        this.batchProcessor.on("batch:created", (data) => this.emit("batch:created", data));
        this.batchProcessor.on("batch:completed", (data) => this.emit("batch:completed", data));
      }
      startAutoProcessing() {
        this.processingTimer = setInterval(async () => {
          try {
            await this.processNext(this.config.maxConcurrentProcessing);
          } catch (error) {
            console.error("Error in auto-processing:", error);
          }
        }, this.config.processingInterval);
      }
      async processBatched(items) {
        const results = [];
        const batches = this.batchProcessor.addToBatch(items, {
          groupByResource: true,
          groupByPriority: false,
          groupByTimeWindow: false,
          windowSizeMs: 6e4,
          maxItemsPerBatch: this.config.batchSize,
          priorityMixing: true
        });
        for (const batch of batches) {
          const batchResult = await this.processBatch(batch);
          results.push(...batchResult);
        }
        return results;
      }
      async processIndividually(items) {
        const results = [];
        const processingPromises = items.map(async (item) => {
          return this.processItemInternal(item);
        });
        const batchResults = await Promise.allSettled(processingPromises);
        for (const result of batchResults) {
          if (result.status === "fulfilled") {
            results.push(result.value);
          } else {
            results.push({
              success: false,
              error: result.reason?.message || "Unknown error",
              processingTime: 0
            });
          }
        }
        return results;
      }
      async processBatch(batch) {
        const results = [];
        try {
          await this.batchProcessor.processBatch(batch.id, async (items) => {
            const batchResults = await Promise.allSettled(
              items.map((item) => this.processItemInternal(item))
            );
            for (const result of batchResults) {
              if (result.status === "fulfilled") {
                results.push(result.value);
              } else {
                results.push({
                  success: false,
                  error: result.reason?.message || "Batch processing error",
                  processingTime: 0
                });
              }
            }
          });
        } catch (error) {
          console.warn("Batch processing failed, falling back to individual:", error);
          return this.processIndividually(batch.items);
        }
        return results;
      }
      async processItemInternal(item) {
        const startTime = Date.now();
        this.processingItems.add(item.id);
        try {
          if (this.config.enableAnalytics) {
            this.analytics.recordProcessingStart(item.id);
          }
          await this.updateItemStatus(item.id, "processing");
          const processorKey = `${item.resource}:${item.operation}`;
          const processor = this.processors.get(processorKey);
          if (!processor) {
            throw new Error(`No processor registered for ${processorKey}`);
          }
          const result = await processor(item);
          this.retryManager.recordSuccess(item.resource);
          if (this.config.enableAnalytics) {
            this.analytics.recordProcessingComplete(item.id, true);
          }
          await this.updateItemStatus(item.id, "completed");
          const processingTime = Date.now() - startTime;
          return {
            success: true,
            result,
            processingTime
          };
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Unknown error";
          this.retryManager.recordFailure(item.resource, errorMessage);
          if (this.config.enableAnalytics) {
            this.analytics.recordProcessingComplete(item.id, false);
          }
          if (item.retryCount < item.maxRetries && this.isRetryableError(errorMessage)) {
            const retryScheduled = this.retryManager.scheduleRetry(item, errorMessage);
            if (retryScheduled) {
              await this.updateItemStatus(item.id, "retry", errorMessage);
            } else {
              await this.updateItemStatus(item.id, "failed", errorMessage);
            }
          } else {
            await this.updateItemStatus(item.id, "failed", errorMessage);
          }
          const processingTime = Date.now() - startTime;
          return {
            success: false,
            error: errorMessage,
            processingTime
          };
        } finally {
          this.processingItems.delete(item.id);
        }
      }
      async handleStatusChange(id, status, _error) {
        const item = this.priorityQueue.get(id);
        if (!item) return;
        switch (status) {
          case "failed":
            if (item.retryCount >= item.maxRetries && this.config.deadLetterEnabled) {
              await this.updateItemStatus(id, "dead");
            }
            break;
          case "dead":
            this.emit("item:dead", { item });
            break;
          case "completed":
            setTimeout(() => {
              this.priorityQueue.remove(id);
            }, 5e3);
            break;
        }
      }
      isDuplicate(item) {
        if (!this.config.deduplicationEnabled) return false;
        const cutoffTime = Date.now() - this.config.deduplicationWindow;
        const existingItems = this.priorityQueue.getByResource(item.resource);
        return existingItems.some(
          (existing) => existing.operation === item.operation && existing.createdAt >= cutoffTime && JSON.stringify(existing.data) === JSON.stringify(item.data)
        );
      }
      isRetryableError(error) {
        const retryableErrors = [
          "NETWORK_ERROR",
          "TIMEOUT",
          "SERVER_ERROR",
          "RATE_LIMITED",
          "TEMPORARY_FAILURE"
        ];
        return retryableErrors.some((retryable) => error.includes(retryable));
      }
      async persistQueue() {
        if (!this.config.enablePersistence) return;
        try {
          const queueData = {
            items: this.priorityQueue.toArray(),
            timestamp: Date.now()
          };
          if (typeof localStorage !== "undefined") {
            localStorage.setItem(this.config.storageKey, JSON.stringify(queueData));
          }
        } catch (error) {
          console.warn("Failed to persist queue:", error);
        }
      }
      // TODO: Implement persisted queue loading when storage adapter is ready
      // private async _loadPersistedQueue(): Promise<void> {
      //   if (!this.config.enablePersistence) return;
      //
      //   try {
      //     // This would integrate with the storage adapter
      //     if (typeof localStorage !== 'undefined') {
      //       const serialized = localStorage.getItem(this.config.storageKey);
      //       if (serialized) {
      //         const queueData = JSON.parse(serialized);
      //         if (queueData.items && Array.isArray(queueData.items)) {
      //           for (const item of queueData.items) {
      //             this.priorityQueue.enqueue(item);
      //           }
      //         }
      //       }
      //     }
      //   } catch (error) {
      //     console.warn('Failed to load persisted queue:', error);
      //   }
      // }
    };
  }
});

// src/auth/types.ts
function hasRole(userRoles, requiredRole) {
  if (userRoles.includes(requiredRole)) {
    return true;
  }
  return userRoles.some((role) => {
    const inheritedRoles = ROLE_HIERARCHY[role] || [];
    return inheritedRoles.includes(requiredRole);
  });
}
function hasAnyRole(userRoles, requiredRoles) {
  return requiredRoles.some((role) => hasRole(userRoles, role));
}
function getEffectiveRoles(userRoles) {
  const effectiveRoles = new Set(userRoles);
  userRoles.forEach((role) => {
    const inheritedRoles = ROLE_HIERARCHY[role] || [];
    inheritedRoles.forEach((inheritedRole) => {
      effectiveRoles.add(inheritedRole);
    });
  });
  return Array.from(effectiveRoles);
}
function getPrimaryRole(userRoles) {
  if (userRoles.length === 0) return null;
  const rolePriority = [
    "ROLE_SUPPLIER" /* ROLE_SUPPLIER */,
    "ROLE_ADMIN" /* ROLE_ADMIN */,
    "ROLE_MERCHANT" /* ROLE_MERCHANT */,
    "ROLE_ACUBE_MF1" /* ROLE_ACUBE_MF1 */,
    "ROLE_EXTERNAL_MF1" /* ROLE_EXTERNAL_MF1 */,
    "ROLE_CASHIER" /* ROLE_CASHIER */,
    "ROLE_MF1" /* ROLE_MF1 */,
    "ROLE_PREVIOUS_ADMIN" /* ROLE_PREVIOUS_ADMIN */
  ];
  for (const role of rolePriority) {
    if (userRoles.includes(role)) {
      return role;
    }
  }
  return userRoles[0] || null;
}
function toSimpleRole(userRoles) {
  const primaryRole = getPrimaryRole(userRoles);
  if (!primaryRole) return "cashier";
  return ROLE_TO_SIMPLE[primaryRole] || "cashier";
}
function autoDetectRole(context) {
  if (context.preferredRole && context.userRoles) {
    const targetRole = typeof context.preferredRole === "string" && context.preferredRole in SIMPLE_TO_ROLE ? SIMPLE_TO_ROLE[context.preferredRole] : context.preferredRole;
    if (hasRole(context.userRoles, targetRole)) {
      return targetRole;
    }
  }
  if (context.cashierId && context.pointOfSaleId) {
    return "ROLE_CASHIER" /* ROLE_CASHIER */;
  }
  if (context.merchantId && !context.cashierId) {
    return "ROLE_MERCHANT" /* ROLE_MERCHANT */;
  }
  if (!context.merchantId && !context.cashierId) {
    return "ROLE_SUPPLIER" /* ROLE_SUPPLIER */;
  }
  return "ROLE_CASHIER" /* ROLE_CASHIER */;
}
function canSwitchToRole(currentRoles, targetRole, context) {
  if (!hasRole(currentRoles, targetRole)) {
    return false;
  }
  if (targetRole === "ROLE_CASHIER" /* ROLE_CASHIER */) {
    return !!(context?.cashierId && context?.pointOfSaleId);
  }
  if (targetRole === "ROLE_MERCHANT" /* ROLE_MERCHANT */) {
    return !!context?.merchantId;
  }
  return true;
}
var ROLE_HIERARCHY, ROLE_TO_SIMPLE, SIMPLE_TO_ROLE, AuthErrorType;
var init_types2 = __esm({
  "src/auth/types.ts"() {
    "use strict";
    init_esm_shims();
    ROLE_HIERARCHY = {
      ["ROLE_SUPPLIER" /* ROLE_SUPPLIER */]: [
        "ROLE_MERCHANT" /* ROLE_MERCHANT */,
        "ROLE_CASHIER" /* ROLE_CASHIER */,
        "ROLE_ADMIN" /* ROLE_ADMIN */,
        "ROLE_ACUBE_MF1" /* ROLE_ACUBE_MF1 */,
        "ROLE_EXTERNAL_MF1" /* ROLE_EXTERNAL_MF1 */
      ],
      ["ROLE_MERCHANT" /* ROLE_MERCHANT */]: [
        "ROLE_CASHIER" /* ROLE_CASHIER */
      ],
      ["ROLE_CASHIER" /* ROLE_CASHIER */]: [],
      ["ROLE_ADMIN" /* ROLE_ADMIN */]: [
        "ROLE_PREVIOUS_ADMIN" /* ROLE_PREVIOUS_ADMIN */
      ],
      ["ROLE_ACUBE_MF1" /* ROLE_ACUBE_MF1 */]: [
        "ROLE_MF1" /* ROLE_MF1 */
      ],
      ["ROLE_EXTERNAL_MF1" /* ROLE_EXTERNAL_MF1 */]: [
        "ROLE_MF1" /* ROLE_MF1 */
      ],
      ["ROLE_MF1" /* ROLE_MF1 */]: [],
      ["ROLE_PREVIOUS_ADMIN" /* ROLE_PREVIOUS_ADMIN */]: []
    };
    ROLE_TO_SIMPLE = {
      ["ROLE_SUPPLIER" /* ROLE_SUPPLIER */]: "provider",
      ["ROLE_MERCHANT" /* ROLE_MERCHANT */]: "merchant",
      ["ROLE_CASHIER" /* ROLE_CASHIER */]: "cashier",
      ["ROLE_ADMIN" /* ROLE_ADMIN */]: "admin",
      ["ROLE_PREVIOUS_ADMIN" /* ROLE_PREVIOUS_ADMIN */]: "admin",
      ["ROLE_ACUBE_MF1" /* ROLE_ACUBE_MF1 */]: "provider",
      ["ROLE_EXTERNAL_MF1" /* ROLE_EXTERNAL_MF1 */]: "provider",
      ["ROLE_MF1" /* ROLE_MF1 */]: "provider"
    };
    SIMPLE_TO_ROLE = {
      provider: "ROLE_SUPPLIER" /* ROLE_SUPPLIER */,
      merchant: "ROLE_MERCHANT" /* ROLE_MERCHANT */,
      cashier: "ROLE_CASHIER" /* ROLE_CASHIER */,
      admin: "ROLE_ADMIN" /* ROLE_ADMIN */
    };
    AuthErrorType = {
      INVALID_CREDENTIALS: "INVALID_CREDENTIALS",
      TOKEN_EXPIRED: "TOKEN_EXPIRED",
      TOKEN_INVALID: "TOKEN_INVALID",
      REFRESH_FAILED: "REFRESH_FAILED",
      NETWORK_ERROR: "NETWORK_ERROR",
      STORAGE_ERROR: "STORAGE_ERROR",
      PERMISSION_DENIED: "PERMISSION_DENIED",
      SESSION_EXPIRED: "SESSION_EXPIRED",
      MFA_REQUIRED: "MFA_REQUIRED",
      ACCOUNT_LOCKED: "ACCOUNT_LOCKED",
      UNKNOWN_ERROR: "UNKNOWN_ERROR"
    };
  }
});

// src/auth/auth-events.ts
function createAuthEvent(type, data, metadata) {
  return {
    type,
    timestamp: /* @__PURE__ */ new Date(),
    requestId: `auth_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`,
    data,
    metadata
  };
}
var init_auth_events = __esm({
  "src/auth/auth-events.ts"() {
    "use strict";
    init_esm_shims();
  }
});

// src/auth/token-manager.ts
var token_manager_exports = {};
__export(token_manager_exports, {
  TokenManager: () => TokenManager
});
var DEFAULT_CONFIG10, TokenManager;
var init_token_manager = __esm({
  "src/auth/token-manager.ts"() {
    "use strict";
    init_esm_shims();
    init_eventemitter3();
    init_types2();
    init_auth_events();
    DEFAULT_CONFIG10 = {
      refreshUrl: "/token/refresh",
      tokenRefreshBuffer: 5,
      // 5 minutes
      maxRefreshAttempts: 3,
      refreshRetryDelay: 1e3,
      enableTokenRotation: true
    };
    TokenManager = class extends import_index.default {
      config;
      httpClient;
      refreshTimer = null;
      refreshPromise = null;
      refreshAttempts = 0;
      currentTokens = {
        access: null,
        refresh: null,
        expiresAt: null
      };
      constructor(httpClient, config = {}) {
        super();
        this.config = { ...DEFAULT_CONFIG10, ...config };
        this.httpClient = httpClient;
      }
      /**
       * Set tokens and start refresh timer
       */
      setTokens(tokens) {
        const payload = this.parseToken(tokens.access_token);
        if (!payload) {
          throw this.createAuthError(
            "TOKEN_INVALID",
            "Invalid access token format"
          );
        }
        const expiresAt = payload.exp * 1e3;
        this.currentTokens = {
          access: tokens.access_token,
          refresh: tokens.refresh_token,
          expiresAt
        };
        this.refreshAttempts = 0;
        this.scheduleRefresh(expiresAt);
      }
      /**
       * Get current access token
       */
      getAccessToken() {
        if (this.currentTokens.access && this.currentTokens.expiresAt) {
          if (Date.now() < this.currentTokens.expiresAt) {
            return this.currentTokens.access;
          }
        }
        return null;
      }
      /**
       * Get current refresh token
       */
      getRefreshToken() {
        return this.currentTokens.refresh;
      }
      /**
       * Get token status
       */
      getTokenStatus() {
        const now = Date.now();
        const expiresAt = this.currentTokens.expiresAt || 0;
        const expiresIn = Math.max(0, expiresAt - now);
        const bufferMs = this.config.tokenRefreshBuffer * 60 * 1e3;
        return {
          isValid: !!this.currentTokens.access && now < expiresAt,
          expiresIn: Math.floor(expiresIn / 1e3),
          // seconds
          isRefreshing: this.refreshPromise !== null,
          needsRefresh: expiresIn < bufferMs && expiresIn > 0,
          refreshFailures: this.refreshAttempts
        };
      }
      /**
       * Parse JWT token
       */
      parseToken(token) {
        try {
          const parts = token.split(".");
          if (parts.length !== 3) {
            return null;
          }
          const payload = parts[1];
          if (!payload) {
            return null;
          }
          const decoded = this.base64UrlDecode(payload);
          return JSON.parse(decoded);
        } catch (error) {
          console.error("Failed to parse JWT token:", error);
          return null;
        }
      }
      /**
       * Validate JWT token
       */
      validateToken(token) {
        const payload = this.parseToken(token);
        if (!payload) {
          return { valid: false, reason: "Invalid token format" };
        }
        const now = Math.floor(Date.now() / 1e3);
        if (payload.exp && payload.exp < now) {
          return { valid: false, reason: "Token expired" };
        }
        if (payload.nbf && payload.nbf > now) {
          return { valid: false, reason: "Token not yet valid" };
        }
        if (!payload.sub || !payload.email || !payload.roles) {
          return { valid: false, reason: "Missing required claims" };
        }
        return { valid: true };
      }
      /**
       * Refresh tokens
       */
      async refreshTokens() {
        if (this.refreshPromise) {
          return this.refreshPromise;
        }
        if (!this.currentTokens.refresh) {
          throw this.createAuthError(
            "REFRESH_FAILED",
            "No refresh token available"
          );
        }
        this.emitRefreshStart();
        this.refreshPromise = this.performRefresh().then((tokens) => {
          this.setTokens(tokens);
          this.emitRefreshSuccess(tokens);
          this.refreshPromise = null;
          if (this.config.onTokenRefresh) {
            this.config.onTokenRefresh(tokens);
          }
          return tokens;
        }).catch((error) => {
          this.refreshPromise = null;
          this.emitRefreshFailure(error);
          if (this.refreshAttempts < this.config.maxRefreshAttempts) {
            return new Promise((resolve, reject) => {
              setTimeout(() => {
                this.refreshTokens().then(resolve).catch(reject);
              }, this.config.refreshRetryDelay * Math.pow(2, this.refreshAttempts - 1));
            });
          }
          this.emitTokenExpired();
          if (this.config.onTokenExpired) {
            this.config.onTokenExpired();
          }
          throw error;
        });
        return this.refreshPromise;
      }
      /**
       * Perform the actual refresh request
       */
      async performRefresh() {
        this.refreshAttempts++;
        const request = {
          refresh_token: this.currentTokens.refresh,
          grant_type: "refresh_token"
        };
        try {
          const response = await this.httpClient.post(
            this.config.refreshUrl,
            request,
            {
              skipRetry: false,
              // Allow retries for refresh
              metadata: { isTokenRefresh: true }
            }
          );
          if (!response.data.access_token || !response.data.refresh_token) {
            throw this.createAuthError(
              "REFRESH_FAILED",
              "Invalid refresh response"
            );
          }
          if (this.config.enableTokenRotation) {
            if (response.data.refresh_token === this.currentTokens.refresh) {
              console.warn("Refresh token was not rotated");
            }
          }
          return response.data;
        } catch (error) {
          if (error instanceof Error && "statusCode" in error) {
            const statusCode = error.statusCode;
            if (statusCode === 401 || statusCode === 403) {
              throw this.createAuthError(
                "TOKEN_INVALID",
                "Refresh token is invalid or expired",
                error
              );
            }
          }
          throw this.createAuthError(
            "REFRESH_FAILED",
            "Failed to refresh token",
            error
          );
        }
      }
      /**
       * Schedule automatic token refresh
       */
      scheduleRefresh(expiresAt) {
        if (this.refreshTimer) {
          clearTimeout(this.refreshTimer);
        }
        const now = Date.now();
        const bufferMs = this.config.tokenRefreshBuffer * 60 * 1e3;
        const refreshAt = expiresAt - bufferMs;
        const delay = Math.max(0, refreshAt - now);
        if (delay <= 0) {
          this.refreshTokens().catch((error) => {
            console.error("Immediate token refresh failed:", error);
          });
          return;
        }
        this.refreshTimer = setTimeout(() => {
          this.refreshTokens().catch((error) => {
            console.error("Scheduled token refresh failed:", error);
          });
        }, delay);
      }
      /**
       * Clear tokens and stop refresh timer
       */
      clearTokens() {
        this.currentTokens = {
          access: null,
          refresh: null,
          expiresAt: null
        };
        if (this.refreshTimer) {
          clearTimeout(this.refreshTimer);
          this.refreshTimer = null;
        }
        this.refreshPromise = null;
        this.refreshAttempts = 0;
      }
      /**
       * Force token refresh
       */
      async forceRefresh() {
        this.refreshPromise = null;
        return this.refreshTokens();
      }
      /**
       * Base64URL decode
       */
      base64UrlDecode(str) {
        str += "=".repeat((4 - str.length % 4) % 4);
        str = str.replace(/-/g, "+").replace(/_/g, "/");
        if (typeof window !== "undefined" && window.atob) {
          return window.atob(str);
        } else if (typeof Buffer !== "undefined") {
          return Buffer.from(str, "base64").toString("utf-8");
        } else {
          throw new Error("No base64 decoder available");
        }
      }
      /**
       * Create auth error
       */
      createAuthError(type, message, cause) {
        const error = {
          name: "AuthError",
          type,
          message,
          timestamp: Date.now(),
          recoverable: type === AuthErrorType.REFRESH_FAILED && this.refreshAttempts < this.config.maxRefreshAttempts
        };
        if (cause instanceof Error) {
          error.details = { cause: cause.message };
        }
        return error;
      }
      /**
       * Event emitters
       */
      emitRefreshStart() {
        const event = createAuthEvent(
          "auth:token:refresh:start" /* TOKEN_REFRESH_START */,
          {
            reason: this.refreshAttempts > 1 ? "retry" : "expiry_approaching",
            attemptNumber: this.refreshAttempts,
            tokenStatus: this.getTokenStatus()
          }
        );
        this.emit("auth:token:refresh:start" /* TOKEN_REFRESH_START */, event);
      }
      emitRefreshSuccess(tokens) {
        const event = createAuthEvent(
          "auth:token:refresh:success" /* TOKEN_REFRESH_SUCCESS */,
          {
            tokens,
            oldExpiresAt: this.currentTokens.expiresAt || 0,
            newExpiresAt: this.parseToken(tokens.access_token)?.exp || 0,
            attemptNumber: this.refreshAttempts
          }
        );
        this.emit("auth:token:refresh:success" /* TOKEN_REFRESH_SUCCESS */, event);
      }
      emitRefreshFailure(error) {
        const eventData = {
          error,
          attemptNumber: this.refreshAttempts,
          willRetry: this.refreshAttempts < this.config.maxRefreshAttempts
        };
        if (this.refreshAttempts < this.config.maxRefreshAttempts) {
          eventData.nextRetryAt = new Date(Date.now() + this.config.refreshRetryDelay * Math.pow(2, this.refreshAttempts - 1));
        }
        const event = createAuthEvent(
          "auth:token:refresh:failure" /* TOKEN_REFRESH_FAILURE */,
          eventData
        );
        this.emit("auth:token:refresh:failure" /* TOKEN_REFRESH_FAILURE */, event);
      }
      emitTokenExpired() {
        const event = createAuthEvent(
          "auth:token:expired" /* TOKEN_EXPIRED */,
          {
            expiredAt: new Date(this.currentTokens.expiresAt || Date.now()),
            wasRefreshAttempted: this.refreshAttempts > 0,
            refreshFailed: true
          }
        );
        this.emit("auth:token:expired" /* TOKEN_EXPIRED */, event);
      }
      /**
       * Destroy token manager
       */
      destroy() {
        this.clearTokens();
        this.removeAllListeners();
      }
    };
  }
});

// src/compliance/access-control.ts
var AccessControlManager;
var init_access_control = __esm({
  "src/compliance/access-control.ts"() {
    "use strict";
    init_esm_shims();
    AccessControlManager = class {
      config;
      users = /* @__PURE__ */ new Map();
      roles = /* @__PURE__ */ new Map();
      sessions = /* @__PURE__ */ new Map();
      accessRequests = /* @__PURE__ */ new Map();
      auditLog = [];
      permissionCache = /* @__PURE__ */ new Map();
      constructor(config) {
        this.config = {
          enabled: true,
          model: "HYBRID",
          session: {
            timeout: 8 * 60 * 60 * 1e3,
            // 8 hours
            maxConcurrentSessions: 3,
            requireReauth: false
          },
          audit: {
            logAllAccess: true,
            logFailedAttempts: true,
            retentionPeriod: 365 * 24 * 60 * 60 * 1e3
            // 1 year
          },
          enforcement: {
            strictMode: true,
            allowEscalation: false,
            requireApproval: ["delete_user", "modify_permissions", "export_data"]
          },
          ...config
        };
        if (this.config.enabled) {
          this.initializeDefaultRoles();
          this.startSessionCleanup();
        }
      }
      /**
       * Create a new user
       */
      async createUser(userData, createdBy) {
        if (!this.config.enabled) {
          throw new Error("Access control is disabled");
        }
        const userId = this.generateUserId();
        const now = Date.now();
        const user = {
          id: userId,
          sessions: [],
          failedAttempts: 0,
          metadata: {
            createdAt: now,
            updatedAt: now,
            createdBy
          },
          ...userData
        };
        this.users.set(userId, user);
        this.auditAccess({
          userId: createdBy,
          action: "permission_changed",
          details: {
            targetUserId: userId,
            operation: "create_user",
            roles: userData.roles
          },
          context: { timestamp: now },
          timestamp: now,
          riskLevel: "medium"
        });
        return userId;
      }
      /**
       * Assign role to user
       */
      async assignRole(userId, roleId, assignedBy) {
        const user = this.users.get(userId);
        if (!user) {
          throw new Error(`User not found: ${userId}`);
        }
        const role = this.roles.get(roleId);
        if (!role) {
          throw new Error(`Role not found: ${roleId}`);
        }
        if (!user.roles.includes(roleId)) {
          user.roles.push(roleId);
          user.metadata.updatedAt = Date.now();
          this.clearUserPermissionCache(userId);
          this.auditAccess({
            userId: assignedBy,
            action: "role_assigned",
            details: {
              targetUserId: userId,
              roleId,
              roleName: role.name
            },
            context: { timestamp: Date.now() },
            timestamp: Date.now(),
            riskLevel: "medium"
          });
        }
      }
      /**
       * Revoke role from user
       */
      async revokeRole(userId, roleId, revokedBy) {
        const user = this.users.get(userId);
        if (!user) {
          throw new Error(`User not found: ${userId}`);
        }
        const roleIndex = user.roles.indexOf(roleId);
        if (roleIndex > -1) {
          user.roles.splice(roleIndex, 1);
          user.metadata.updatedAt = Date.now();
          this.clearUserPermissionCache(userId);
          const role = this.roles.get(roleId);
          this.auditAccess({
            userId: revokedBy,
            action: "role_revoked",
            details: {
              targetUserId: userId,
              roleId,
              roleName: role?.name || "Unknown"
            },
            context: { timestamp: Date.now() },
            timestamp: Date.now(),
            riskLevel: "medium"
          });
        }
      }
      /**
       * Create a new role
       */
      async createRole(roleData, createdBy) {
        const roleId = this.generateRoleId();
        const now = Date.now();
        const role = {
          id: roleId,
          metadata: {
            createdAt: now,
            updatedAt: now,
            createdBy,
            isSystem: false
          },
          ...roleData
        };
        this.roles.set(roleId, role);
        this.auditAccess({
          userId: createdBy,
          action: "permission_changed",
          details: {
            operation: "create_role",
            roleId,
            roleName: role.name,
            permissions: role.permissions.length
          },
          context: { timestamp: now },
          timestamp: now,
          riskLevel: "high"
        });
        return roleId;
      }
      /**
       * Authenticate user and create session
       */
      async authenticate(userId, context) {
        const user = this.users.get(userId);
        if (!user) {
          this.auditAccess({
            userId,
            action: "access_denied",
            details: { reason: "user_not_found" },
            context,
            timestamp: Date.now(),
            riskLevel: "high"
          });
          throw new Error("Authentication failed");
        }
        if (user.status !== "active") {
          this.auditAccess({
            userId,
            action: "access_denied",
            details: { reason: "user_inactive", status: user.status },
            context,
            timestamp: Date.now(),
            riskLevel: "high"
          });
          throw new Error(`User account is ${user.status}`);
        }
        if (user.lockoutUntil && Date.now() < user.lockoutUntil) {
          this.auditAccess({
            userId,
            action: "access_denied",
            details: { reason: "account_locked", lockoutUntil: user.lockoutUntil },
            context,
            timestamp: Date.now(),
            riskLevel: "high"
          });
          throw new Error("Account is locked");
        }
        const activeSessions = user.sessions.filter((s) => s.status === "active");
        if (activeSessions.length >= this.config.session.maxConcurrentSessions) {
          const oldestSession = activeSessions.sort((a, b) => a.startedAt - b.startedAt)[0];
          if (oldestSession) {
            await this.terminateSession(oldestSession.id);
          }
        }
        const sessionId = this.generateSessionId();
        const now = Date.now();
        const permissions = await this.getUserPermissions(userId);
        const session = {
          id: sessionId,
          userId,
          startedAt: now,
          lastActivity: now,
          expiresAt: now + this.config.session.timeout,
          ...context.ipAddress && { ipAddress: context.ipAddress },
          ...context.userAgent && { userAgent: context.userAgent },
          ...context.deviceId && { deviceId: context.deviceId },
          ...context.location && { location: context.location },
          status: "active",
          permissions
        };
        user.sessions.push(session);
        user.lastLogin = now;
        user.failedAttempts = 0;
        this.sessions.set(sessionId, session);
        this.auditAccess({
          userId,
          sessionId,
          action: "login",
          details: {
            sessionId,
            permissions: permissions.length,
            concurrentSessions: user.sessions.filter((s) => s.status === "active").length
          },
          context,
          timestamp: now,
          riskLevel: "low"
        });
        return { sessionId, permissions };
      }
      /**
       * Check if user has permission to perform action on resource
       */
      async checkAccess(sessionId, resource, action, context) {
        if (!this.config.enabled) {
          return { granted: true };
        }
        const session = this.sessions.get(sessionId);
        if (!session || session.status !== "active") {
          this.auditAccess({
            userId: "unknown",
            sessionId,
            action: "access_denied",
            resource,
            details: {
              reason: "invalid_session",
              requestedAction: action
            },
            context,
            timestamp: Date.now(),
            riskLevel: "high"
          });
          return { granted: false, reason: "Invalid or expired session" };
        }
        if (Date.now() > session.expiresAt) {
          session.status = "expired";
          this.auditAccess({
            userId: session.userId,
            sessionId,
            action: "access_denied",
            resource,
            details: {
              reason: "session_expired",
              requestedAction: action
            },
            context,
            timestamp: Date.now(),
            riskLevel: "medium"
          });
          return { granted: false, reason: "Session expired" };
        }
        session.lastActivity = Date.now();
        const user = this.users.get(session.userId);
        if (!user) {
          return { granted: false, reason: "User not found" };
        }
        const requiresApproval = this.config.enforcement.requireApproval.includes(action);
        const result = await this.evaluatePermissions(
          session.permissions,
          resource,
          action,
          user,
          context
        );
        const requestId = this.generateRequestId();
        const accessRequest = {
          id: requestId,
          userId: session.userId,
          sessionId,
          resource,
          action,
          context,
          timestamp: Date.now(),
          result: result.granted ? "granted" : "denied",
          ...result.reason && { reason: result.reason },
          approvalRequired: requiresApproval && result.granted
        };
        this.accessRequests.set(requestId, accessRequest);
        this.auditAccess({
          userId: session.userId,
          sessionId,
          action: result.granted ? "access_granted" : "access_denied",
          resource,
          details: {
            requestedAction: action,
            reason: result.reason,
            requiresApproval,
            requestId
          },
          context,
          timestamp: Date.now(),
          riskLevel: result.granted ? "low" : "medium"
        });
        return {
          granted: result.granted,
          ...result.reason && { reason: result.reason },
          ...requiresApproval && result.granted && { requiresApproval: true }
        };
      }
      /**
       * Approve pending access request
       */
      async approveAccess(requestId, approvedBy, context) {
        const request = this.accessRequests.get(requestId);
        if (!request) {
          throw new Error(`Access request not found: ${requestId}`);
        }
        if (!request.approvalRequired) {
          throw new Error("Access request does not require approval");
        }
        request.result = "granted";
        request.approvedBy = approvedBy;
        request.approvedAt = Date.now();
        this.auditAccess({
          userId: approvedBy,
          action: "access_granted",
          resource: request.resource,
          details: {
            requestId,
            targetUserId: request.userId,
            approvedAction: request.action
          },
          context,
          timestamp: Date.now(),
          riskLevel: "medium"
        });
      }
      /**
       * Terminate user session
       */
      async terminateSession(sessionId) {
        const session = this.sessions.get(sessionId);
        if (!session) return;
        session.status = "terminated";
        this.sessions.delete(sessionId);
        const user = this.users.get(session.userId);
        if (user) {
          const sessionIndex = user.sessions.findIndex((s) => s.id === sessionId);
          if (sessionIndex > -1) {
            const userSession = user.sessions[sessionIndex];
            if (userSession) {
              userSession.status = "terminated";
            }
          }
        }
        this.auditAccess({
          userId: session.userId,
          sessionId,
          action: "logout",
          details: {
            sessionId,
            duration: Date.now() - session.startedAt
          },
          context: { timestamp: Date.now() },
          timestamp: Date.now(),
          riskLevel: "low"
        });
      }
      /**
       * Get user permissions (with caching)
       */
      async getUserPermissions(userId) {
        const cacheKey = `user_${userId}`;
        const cached = this.permissionCache.get(cacheKey);
        if (cached && Date.now() < cached.expiresAt) {
          return cached.permissions;
        }
        const user = this.users.get(userId);
        if (!user) return [];
        const permissions = [];
        const processedRoles = /* @__PURE__ */ new Set();
        const processRole = (roleId) => {
          if (processedRoles.has(roleId)) return;
          processedRoles.add(roleId);
          const role = this.roles.get(roleId);
          if (!role) return;
          permissions.push(...role.permissions);
          if (role.inherits) {
            for (const inheritedRoleId of role.inherits) {
              processRole(inheritedRoleId);
            }
          }
        };
        for (const roleId of user.roles) {
          processRole(roleId);
        }
        const uniquePermissions = Array.from(
          new Map(permissions.map((p) => [`${p.resource}:${p.action}`, p])).values()
        ).sort((a, b) => {
          if (a.effect === "deny" && b.effect === "allow") return -1;
          if (a.effect === "allow" && b.effect === "deny") return 1;
          return 0;
        });
        this.permissionCache.set(cacheKey, {
          permissions: uniquePermissions,
          expiresAt: Date.now() + 15 * 60 * 1e3
          // 15 minutes
        });
        return uniquePermissions;
      }
      /**
       * Get access audit log
       */
      getAuditLog(filter) {
        let filteredLog = [...this.auditLog];
        if (filter) {
          if (filter.userId) {
            filteredLog = filteredLog.filter((entry) => entry.userId === filter.userId);
          }
          if (filter.action) {
            filteredLog = filteredLog.filter((entry) => entry.action === filter.action);
          }
          if (filter.resource) {
            filteredLog = filteredLog.filter((entry) => entry.resource === filter.resource);
          }
          if (filter.timeRange) {
            filteredLog = filteredLog.filter(
              (entry) => entry.timestamp >= filter.timeRange.start && entry.timestamp <= filter.timeRange.end
            );
          }
          if (filter.riskLevel) {
            filteredLog = filteredLog.filter((entry) => entry.riskLevel === filter.riskLevel);
          }
        }
        return filteredLog.sort((a, b) => b.timestamp - a.timestamp);
      }
      /**
       * Get access control statistics
       */
      getAccessControlStats() {
        const users = Array.from(this.users.values());
        const sessions = Array.from(this.sessions.values());
        const roles = Array.from(this.roles.values());
        const activeUsers = users.filter((u) => u.status === "active").length;
        const suspendedUsers = users.filter((u) => u.status === "suspended").length;
        const lockedUsers = users.filter((u) => u.lockoutUntil && Date.now() < u.lockoutUntil).length;
        const activeSessions = sessions.filter((s) => s.status === "active").length;
        const averageSessionDuration = sessions.length > 0 ? sessions.reduce((sum, s) => sum + (Date.now() - s.startedAt), 0) / sessions.length : 0;
        const totalPermissions = roles.reduce((sum, r) => sum + r.permissions.length, 0);
        const averagePermissionsPerUser = users.length > 0 ? users.reduce((sum, u) => sum + u.roles.length, 0) / users.length : 0;
        const failedAttempts = this.auditLog.filter((e) => e.action === "access_denied").length;
        const highRiskEvents = this.auditLog.filter((e) => e.riskLevel === "high" || e.riskLevel === "critical").length;
        return {
          users: {
            total: users.length,
            active: activeUsers,
            suspended: suspendedUsers,
            locked: lockedUsers
          },
          sessions: {
            active: activeSessions,
            total: sessions.length,
            averageDuration: averageSessionDuration
          },
          permissions: {
            totalRoles: roles.length,
            totalPermissions,
            averagePermissionsPerUser
          },
          audit: {
            totalEntries: this.auditLog.length,
            failedAttempts,
            highRiskEvents
          }
        };
      }
      async evaluatePermissions(permissions, resource, action, user, context) {
        const applicablePermissions = permissions.filter(
          (p) => this.matchesResource(p.resource, resource) && this.matchesAction(p.action, action)
        );
        if (applicablePermissions.length === 0) {
          return { granted: false, reason: "No applicable permissions found" };
        }
        for (const permission of applicablePermissions) {
          const conditionsMet = await this.evaluateConditions(
            permission.conditions || [],
            user,
            context
          );
          if (conditionsMet) {
            if (permission.effect === "deny") {
              return { granted: false, reason: "Explicitly denied by permission rule" };
            } else if (permission.effect === "allow") {
              if (permission.scope && !this.checkScope(permission.scope, user, context)) {
                continue;
              }
              return { granted: true };
            }
          }
        }
        return { granted: false, reason: "No matching allow permissions with satisfied conditions" };
      }
      async evaluateConditions(conditions, user, context) {
        for (const condition of conditions) {
          if (!await this.evaluateCondition(condition, user, context)) {
            return false;
          }
        }
        return true;
      }
      async evaluateCondition(condition, user, context) {
        let actualValue;
        switch (condition.type) {
          case "time":
            actualValue = new Date(context.timestamp).getHours();
            break;
          case "location":
            actualValue = context.location || user.metadata.location;
            break;
          case "device":
            actualValue = context.deviceId;
            break;
          case "attribute":
            actualValue = user.attributes[condition.attribute];
            break;
          case "context":
            actualValue = context.attributes?.[condition.attribute];
            break;
          default:
            return false;
        }
        switch (condition.operator) {
          case "equals":
            return actualValue === condition.value;
          case "not_equals":
            return actualValue !== condition.value;
          case "contains":
            return String(actualValue).includes(String(condition.value));
          case "not_contains":
            return !String(actualValue).includes(String(condition.value));
          case "greater_than":
            return actualValue > condition.value;
          case "less_than":
            return actualValue < condition.value;
          case "in":
            return Array.isArray(condition.value) && condition.value.includes(actualValue);
          case "not_in":
            return Array.isArray(condition.value) && !condition.value.includes(actualValue);
          default:
            return false;
        }
      }
      checkScope(scope, user, context) {
        if (!scope) return true;
        if (scope.global) return true;
        if (scope.organizations && user.metadata.department) {
          return scope.organizations.includes(user.metadata.department);
        }
        if (scope.locations && (context.location || user.metadata.location)) {
          const userLocation = context.location || user.metadata.location;
          return scope.locations.includes(userLocation);
        }
        return true;
      }
      matchesResource(permissionResource, requestedResource) {
        if (permissionResource === "*") return true;
        if (permissionResource.endsWith("*")) {
          const prefix = permissionResource.slice(0, -1);
          return requestedResource.startsWith(prefix);
        }
        return permissionResource === requestedResource;
      }
      matchesAction(permissionAction, requestedAction) {
        if (permissionAction === "*") return true;
        if (permissionAction.endsWith("*")) {
          const prefix = permissionAction.slice(0, -1);
          return requestedAction.startsWith(prefix);
        }
        return permissionAction === requestedAction;
      }
      initializeDefaultRoles() {
        this.roles.set("admin", {
          id: "admin",
          name: "Administrator",
          description: "Full system access",
          permissions: [
            {
              id: "admin_all",
              resource: "*",
              action: "*",
              effect: "allow"
            }
          ],
          metadata: {
            createdAt: Date.now(),
            updatedAt: Date.now(),
            createdBy: "system",
            isSystem: true
          }
        });
        this.roles.set("merchant", {
          id: "merchant",
          name: "Merchant",
          description: "Merchant operations access",
          permissions: [
            {
              id: "merchant_receipts",
              resource: "receipts",
              action: "*",
              effect: "allow"
            },
            {
              id: "merchant_reports",
              resource: "reports",
              action: "read",
              effect: "allow"
            }
          ],
          metadata: {
            createdAt: Date.now(),
            updatedAt: Date.now(),
            createdBy: "system",
            isSystem: true
          }
        });
        this.roles.set("cashier", {
          id: "cashier",
          name: "Cashier",
          description: "Point of sale operations",
          permissions: [
            {
              id: "cashier_receipts",
              resource: "receipts",
              action: "create",
              effect: "allow"
            },
            {
              id: "cashier_receipts_read",
              resource: "receipts",
              action: "read",
              effect: "allow",
              scope: {
                global: false
              }
            }
          ],
          metadata: {
            createdAt: Date.now(),
            updatedAt: Date.now(),
            createdBy: "system",
            isSystem: true
          }
        });
      }
      clearUserPermissionCache(userId) {
        const cacheKey = `user_${userId}`;
        this.permissionCache.delete(cacheKey);
      }
      auditAccess(entry) {
        const auditEntry = {
          id: this.generateAuditId(),
          ...entry
        };
        this.auditLog.push(auditEntry);
        const maxEntries = 1e4;
        if (this.auditLog.length > maxEntries) {
          this.auditLog = this.auditLog.slice(-maxEntries);
        }
      }
      startSessionCleanup() {
        setInterval(() => {
          const now = Date.now();
          for (const [sessionId, session] of this.sessions.entries()) {
            if (session.expiresAt <= now) {
              session.status = "expired";
              this.sessions.delete(sessionId);
            }
          }
          const retentionCutoff = now - this.config.audit.retentionPeriod;
          this.auditLog = this.auditLog.filter((entry) => entry.timestamp > retentionCutoff);
        }, 60 * 60 * 1e3);
      }
      generateUserId() {
        return `user_${Date.now()}_${Math.random().toString(36).substring(2)}`;
      }
      generateRoleId() {
        return `role_${Date.now()}_${Math.random().toString(36).substring(2)}`;
      }
      generateSessionId() {
        return `session_${Date.now()}_${Math.random().toString(36).substring(2)}`;
      }
      generateRequestId() {
        return `request_${Date.now()}_${Math.random().toString(36).substring(2)}`;
      }
      generateAuditId() {
        return `audit_${Date.now()}_${Math.random().toString(36).substring(2)}`;
      }
    };
  }
});

// src/auth/auth-storage.ts
var auth_storage_exports = {};
__export(auth_storage_exports, {
  AuthStorage: () => AuthStorage
});
var DEFAULT_CONFIG11, AuthStorage;
var init_auth_storage = __esm({
  "src/auth/auth-storage.ts"() {
    "use strict";
    init_esm_shims();
    init_unified_storage();
    init_storage_factory();
    init_encryption();
    init_auth_events();
    init_eventemitter3();
    DEFAULT_CONFIG11 = {
      storageKey: "acube_auth",
      enableEncryption: true,
      autoMigrate: true
    };
    AuthStorage = class extends import_index.default {
      config;
      storage;
      encryption = null;
      encryptionKeyId = null;
      memoryCache = null;
      isInitialized = false;
      constructor(config = {}) {
        super();
        this.config = { ...DEFAULT_CONFIG11, ...config };
        this.storage = null;
        if (this.config.enableEncryption) {
          this.encryption = new AdvancedEncryption({
            algorithm: "AES-GCM",
            keyLength: 256,
            keyDerivation: {
              algorithm: "PBKDF2",
              iterations: 1e5,
              salt: new Uint8Array(16)
              // Will be generated per operation
            }
          });
        }
      }
      /**
       * Initialize storage and encryption
       */
      async initialize() {
        if (this.isInitialized) return;
        try {
          this.storage = await createStorage({
            // @ts-ignore
            preferredAdapter: this.config.storageAdapter || "auto",
            encryption: this.config.enableEncryption ? {
              enabled: true,
              ...this.config.encryptionKey && { key: this.config.encryptionKey }
            } : void 0,
            keyPrefix: "auth"
          });
          if (this.encryption) {
            await this.initializeEncryption();
          }
          if (this.config.autoMigrate) {
            await this.migrateFromLegacyStorage();
          }
          this.isInitialized = true;
        } catch (error) {
          this.emitStorageError("initialize", error);
          throw error;
        }
      }
      /**
       * Store authentication data securely
       */
      async store(data) {
        await this.ensureInitialized();
        try {
          this.memoryCache = data;
          let storageData = data;
          if (this.encryption && this.encryptionKeyId) {
            const serialized = JSON.stringify(data);
            const encrypted = await this.encryption.encryptSymmetric(
              serialized,
              this.encryptionKeyId
            );
            storageData = {
              encrypted: true,
              data: AdvancedEncryption.encryptedDataToJSON(encrypted),
              version: "1.0",
              timestamp: Date.now()
            };
          }
          const storageKey = createStorageKey(this.config.storageKey);
          await this.storage.set(storageKey, storageData, {
            ttl: data.expiresAt - Date.now(),
            encrypt: this.config.enableEncryption
          });
          await this.storePlatformSpecific(data);
        } catch (error) {
          this.emitStorageError("write", error);
          throw this.createAuthError(
            "STORAGE_ERROR",
            "Failed to store authentication data",
            error
          );
        }
      }
      /**
       * Retrieve authentication data
       */
      async retrieve() {
        await this.ensureInitialized();
        try {
          if (this.memoryCache) {
            if (this.memoryCache.expiresAt > Date.now()) {
              return this.memoryCache;
            } else {
              this.memoryCache = null;
            }
          }
          const storageKey = createStorageKey(this.config.storageKey);
          const storageEntry = await this.storage.get(storageKey);
          if (!storageEntry) {
            return await this.retrievePlatformSpecific();
          }
          const storageData = storageEntry.data;
          if (storageData.encrypted && this.encryption && this.encryptionKeyId) {
            const encrypted = AdvancedEncryption.encryptedDataFromJSON(storageData.data);
            const decrypted = await this.encryption.decryptSymmetric(encrypted);
            const data = JSON.parse(new TextDecoder().decode(decrypted));
            this.memoryCache = data;
            return data;
          }
          if (!storageData.encrypted) {
            this.memoryCache = storageData;
            return storageData;
          }
          return null;
        } catch (error) {
          this.emitStorageError("read", error);
          return null;
        }
      }
      /**
       * Clear authentication data
       */
      async clear() {
        await this.ensureInitialized();
        try {
          this.memoryCache = null;
          const storageKey = createStorageKey(this.config.storageKey);
          await this.storage.delete(storageKey);
          await this.clearPlatformSpecific();
          this.emit("auth:storage:cleared" /* STORAGE_CLEARED */, createAuthEvent(
            "auth:storage:cleared" /* STORAGE_CLEARED */,
            { timestamp: Date.now() }
          ));
        } catch (error) {
          this.emitStorageError("delete", error);
          throw this.createAuthError(
            "STORAGE_ERROR",
            "Failed to clear authentication data",
            error
          );
        }
      }
      /**
       * Update specific fields in stored auth data
       */
      async update(updates) {
        const current = await this.retrieve();
        if (!current) {
          throw this.createAuthError(
            "STORAGE_ERROR",
            "No authentication data to update"
          );
        }
        const updated = {
          ...current,
          ...updates,
          user: updates.user ? { ...current.user, ...updates.user } : current.user
        };
        await this.store(updated);
      }
      /**
       * Check if auth data exists and is valid
       */
      async exists() {
        const data = await this.retrieve();
        return data !== null && data.expiresAt > Date.now();
      }
      /**
       * Get storage statistics
       */
      async getStats() {
        const data = await this.retrieve();
        const now = Date.now();
        return {
          hasData: data !== null,
          isExpired: data ? data.expiresAt <= now : false,
          expiresIn: data ? Math.max(0, data.expiresAt - now) : null,
          storageType: this.config.storageAdapter || this.detectStorageAdapter(),
          encryptionEnabled: this.config.enableEncryption
        };
      }
      /**
       * Platform-specific secure storage (React Native Keychain)
       */
      async storePlatformSpecific(data) {
        if (typeof window === "undefined") return;
        try {
          if (this.isReactNative() && this.config.enableEncryption) {
            const Keychain = await this.getKeychain();
            if (Keychain) {
              await Keychain.setInternetCredentials(
                "acube.com",
                data.user.email,
                JSON.stringify({
                  accessToken: data.accessToken,
                  refreshToken: data.refreshToken
                })
              );
            }
          }
          if (this.isWeb() && typeof window.sessionStorage !== "undefined") {
            const safeData = {
              userId: data.user.id,
              expiresAt: data.expiresAt,
              roles: data.user.roles
            };
            window.sessionStorage.setItem(`${this.config.storageKey}_session`, JSON.stringify(safeData));
          }
        } catch (error) {
          console.warn("Platform-specific storage failed:", error);
        }
      }
      /**
       * Retrieve from platform-specific storage
       */
      async retrievePlatformSpecific() {
        if (typeof window === "undefined") return null;
        try {
          if (this.isReactNative() && this.config.enableEncryption) {
            const Keychain = await this.getKeychain();
            if (Keychain) {
              const credentials = await Keychain.getInternetCredentials("acube.com");
              if (credentials) {
                return null;
              }
            }
          }
          return null;
        } catch (error) {
          console.warn("Platform-specific retrieval failed:", error);
          return null;
        }
      }
      /**
       * Clear platform-specific storage
       */
      async clearPlatformSpecific() {
        if (typeof window === "undefined") return;
        try {
          if (this.isReactNative()) {
            const Keychain = await this.getKeychain();
            if (Keychain) {
              await Keychain.resetInternetCredentials("acube.com");
            }
          }
          if (this.isWeb() && typeof window.sessionStorage !== "undefined") {
            window.sessionStorage.removeItem(`${this.config.storageKey}_session`);
          }
        } catch (error) {
          console.warn("Platform-specific clear failed:", error);
        }
      }
      /**
       * Initialize encryption key
       */
      async initializeEncryption() {
        if (!this.encryption) return;
        try {
          const keyStorageKey = createStorageKey("_auth_encryption_key");
          const keyEntry = await this.storage.get(keyStorageKey);
          if (keyEntry) {
            const keyData = keyEntry.data;
            this.encryptionKeyId = keyData.keyId;
            await this.encryption.importKey(
              this.base64ToArrayBuffer(keyData.key),
              "AES-GCM",
              keyData.keyId
            );
          } else {
            this.encryptionKeyId = await this.encryption.generateSymmetricKey();
            const exportedKey = await this.encryption.exportKey(this.encryptionKeyId, "raw");
            const keyStorageKey2 = createStorageKey("_auth_encryption_key");
            await this.storage.set(keyStorageKey2, {
              keyId: this.encryptionKeyId,
              key: this.arrayBufferToBase64(exportedKey)
            }, { encrypt: true });
          }
        } catch (error) {
          console.error("Encryption initialization failed:", error);
          this.encryption = null;
          this.config.enableEncryption = false;
        }
      }
      /**
       * Migrate from legacy storage formats
       */
      async migrateFromLegacyStorage() {
        try {
          if (this.isWeb() && typeof window.localStorage !== "undefined") {
            const legacyData = window.localStorage.getItem("acube_auth_legacy");
            if (legacyData) {
              try {
                const parsed = JSON.parse(legacyData);
                await this.store({
                  ...parsed,
                  version: "1.0",
                  encryptedAt: Date.now()
                });
                window.localStorage.removeItem("acube_auth_legacy");
              } catch {
              }
            }
          }
        } catch (error) {
          console.warn("Legacy migration failed:", error);
        }
      }
      /**
       * Detect appropriate storage adapter
       */
      detectStorageAdapter() {
        if (this.isReactNative()) {
          return "asyncstorage";
        }
        if (this.isWeb()) {
          if (typeof window.indexedDB !== "undefined") {
            return "indexeddb";
          }
          return "localstorage";
        }
        if (typeof process !== "undefined" && process.versions?.node) {
          return "filesystem";
        }
        return "memory";
      }
      /**
       * Platform detection helpers
       */
      isReactNative() {
        return typeof navigator !== "undefined" && navigator.product === "ReactNative";
      }
      isWeb() {
        return typeof window !== "undefined" && typeof window.document !== "undefined";
      }
      /**
       * Get React Native Keychain module
       */
      async getKeychain() {
        try {
          const KeychainModule = await import("react-native-keychain");
          return KeychainModule;
        } catch {
          return null;
        }
      }
      /**
       * Ensure storage is initialized
       */
      async ensureInitialized() {
        if (!this.isInitialized) {
          await this.initialize();
        }
      }
      /**
       * Emit storage error event
       */
      emitStorageError(operation, error) {
        const event = createAuthEvent(
          "auth:storage:error" /* STORAGE_ERROR */,
          {
            operation,
            error,
            fallbackUsed: false
          }
        );
        this.emit("auth:storage:error" /* STORAGE_ERROR */, event);
      }
      /**
       * Create auth error
       */
      createAuthError(type, message, cause) {
        const error = {
          name: "AuthError",
          type,
          message,
          timestamp: Date.now(),
          recoverable: false
        };
        if (cause instanceof Error) {
          error.details = { cause: cause.message };
        }
        return error;
      }
      /**
       * Utility: Convert ArrayBuffer to base64
       */
      arrayBufferToBase64(buffer) {
        const binary = String.fromCharCode(...new Uint8Array(buffer));
        return btoa(binary);
      }
      /**
       * Utility: Convert base64 to ArrayBuffer
       */
      base64ToArrayBuffer(base64) {
        const binary = atob(base64);
        const buffer = new ArrayBuffer(binary.length);
        const array = new Uint8Array(buffer);
        for (let i = 0; i < binary.length; i++) {
          array[i] = binary.charCodeAt(i);
        }
        return buffer;
      }
      /**
       * Destroy storage instance
       */
      async destroy() {
        this.memoryCache = null;
        this.removeAllListeners();
        if (this.storage) {
          await this.storage.destroy();
        }
      }
    };
  }
});

// src/auth/auth-performance.ts
import { LRUCache as LRUCache2 } from "lru-cache";
var DEFAULT_PERFORMANCE_CONFIG, AuthPerformanceOptimizer, COMMON_PERMISSION_SETS;
var init_auth_performance = __esm({
  "src/auth/auth-performance.ts"() {
    "use strict";
    init_esm_shims();
    DEFAULT_PERFORMANCE_CONFIG = {
      permissionCacheSize: 1e3,
      permissionCacheTTL: 5 * 60 * 1e3,
      // 5 minutes
      roleCacheSize: 100,
      roleCacheTTL: 10 * 60 * 1e3,
      // 10 minutes
      tokenValidationCacheSize: 500,
      tokenValidationCacheTTL: 1 * 60 * 1e3,
      // 1 minute
      maxBatchSize: 10,
      batchTimeoutMs: 50,
      enableMetrics: true,
      metricsRetentionMs: 24 * 60 * 60 * 1e3
      // 24 hours
    };
    AuthPerformanceOptimizer = class {
      config;
      // Permission caching
      permissionCache;
      roleCache;
      tokenValidationCache;
      // Batch processing
      pendingPermissionChecks = /* @__PURE__ */ new Map();
      // Performance metrics
      metrics = this.createEmptyMetrics();
      constructor(config = {}) {
        this.config = { ...DEFAULT_PERFORMANCE_CONFIG, ...config };
        this.permissionCache = new LRUCache2({
          max: this.config.permissionCacheSize,
          ttl: this.config.permissionCacheTTL,
          updateAgeOnGet: true,
          updateAgeOnHas: true
        });
        this.roleCache = new LRUCache2({
          max: this.config.roleCacheSize,
          ttl: this.config.roleCacheTTL,
          updateAgeOnGet: true,
          updateAgeOnHas: true
        });
        this.tokenValidationCache = new LRUCache2({
          max: this.config.tokenValidationCacheSize,
          ttl: this.config.tokenValidationCacheTTL,
          updateAgeOnGet: true,
          updateAgeOnHas: true
        });
        this.resetMetrics();
        this.setupCacheCleanup();
      }
      /**
       * Cache-aware permission checking with intelligent batching
       */
      async checkPermissionOptimized(user, permission, checkFn) {
        const startTime = performance.now();
        const cacheKey = this.generatePermissionCacheKey(user, permission);
        const cached = this.permissionCache.get(cacheKey);
        if (cached) {
          this.updateMetrics("permissionChecks", startTime, true);
          return cached;
        }
        return new Promise((resolve, reject) => {
          const userKey = user.id;
          if (!this.pendingPermissionChecks.has(userKey)) {
            this.pendingPermissionChecks.set(userKey, {
              checks: [],
              timer: setTimeout(() => {
                this.processPendingPermissionChecks(userKey, checkFn);
              }, this.config.batchTimeoutMs)
            });
          }
          const pending = this.pendingPermissionChecks.get(userKey);
          pending.checks.push({ permission, resolve, reject });
          if (pending.checks.length >= this.config.maxBatchSize) {
            clearTimeout(pending.timer);
            this.processPendingPermissionChecks(userKey, checkFn);
          }
        });
      }
      /**
       * Cache-aware role computation with memoization
       */
      getEffectiveRolesOptimized(user, getRolesFn) {
        const startTime = performance.now();
        const cacheKey = this.generateRoleCacheKey(user);
        const cached = this.roleCache.get(cacheKey);
        if (cached) {
          this.updateMetrics("roleComputations", startTime, true);
          return cached;
        }
        const roles = getRolesFn(user);
        this.roleCache.set(cacheKey, roles);
        this.updateMetrics("roleComputations", startTime, false);
        return roles;
      }
      /**
       * Optimized token validation with caching
       */
      async validateTokenOptimized(token, validateFn) {
        const startTime = performance.now();
        const cacheKey = this.hashToken(token);
        const cached = this.tokenValidationCache.get(cacheKey);
        if (cached !== void 0) {
          this.updateMetrics("tokenValidations", startTime, true);
          return cached;
        }
        const isValid = await validateFn(token);
        this.tokenValidationCache.set(cacheKey, isValid);
        this.updateMetrics("tokenValidations", startTime, false);
        return isValid;
      }
      /**
       * Preload common permissions for a user
       */
      async preloadUserPermissions(user, commonPermissions, checkFn) {
        const uncachedPermissions = commonPermissions.filter((permission) => {
          const cacheKey = this.generatePermissionCacheKey(user, permission);
          return !this.permissionCache.has(cacheKey);
        });
        if (uncachedPermissions.length === 0) return;
        const results = await Promise.allSettled(
          uncachedPermissions.map((permission) => checkFn(permission))
        );
        results.forEach((result, index) => {
          const permission = uncachedPermissions[index];
          if (result.status === "fulfilled" && permission) {
            const cacheKey = this.generatePermissionCacheKey(user, permission);
            this.permissionCache.set(cacheKey, result.value);
          }
        });
      }
      /**
       * Clear user-specific caches (on logout, role change, etc.)
       */
      clearUserCaches(userId) {
        for (const [key] of this.permissionCache.entries()) {
          if (key.startsWith(`user:${userId}:`)) {
            this.permissionCache.delete(key);
          }
        }
        for (const [key] of this.roleCache.entries()) {
          if (key.startsWith(`user:${userId}:`)) {
            this.roleCache.delete(key);
          }
        }
      }
      /**
       * Get current performance metrics
       */
      getMetrics() {
        return {
          ...this.metrics,
          memoryUsage: {
            totalCacheSize: this.permissionCache.size + this.roleCache.size + this.tokenValidationCache.size,
            permissionCacheSize: this.permissionCache.size,
            roleCacheSize: this.roleCache.size,
            tokenCacheSize: this.tokenValidationCache.size
          }
        };
      }
      /**
       * Create empty metrics object
       */
      createEmptyMetrics() {
        return {
          permissionChecks: {
            total: 0,
            cached: 0,
            cacheHitRate: 0,
            avgResponseTime: 0
          },
          roleComputations: {
            total: 0,
            cached: 0,
            cacheHitRate: 0,
            avgResponseTime: 0
          },
          tokenValidations: {
            total: 0,
            cached: 0,
            cacheHitRate: 0,
            avgResponseTime: 0
          },
          batchOperations: {
            totalBatches: 0,
            avgBatchSize: 0,
            avgBatchTime: 0
          },
          memoryUsage: {
            totalCacheSize: 0,
            permissionCacheSize: 0,
            roleCacheSize: 0,
            tokenCacheSize: 0
          }
        };
      }
      /**
       * Reset performance metrics
       */
      resetMetrics() {
        this.metrics = this.createEmptyMetrics();
      }
      /**
       * Cleanup resources
       */
      destroy() {
        for (const [, pending] of this.pendingPermissionChecks) {
          clearTimeout(pending.timer);
          pending.checks.forEach(({ reject }) => {
            reject(new Error("AuthPerformanceOptimizer destroyed"));
          });
        }
        this.pendingPermissionChecks.clear();
        this.permissionCache.clear();
        this.roleCache.clear();
        this.tokenValidationCache.clear();
      }
      // Private methods
      async processPendingPermissionChecks(userKey, checkFn) {
        const pending = this.pendingPermissionChecks.get(userKey);
        if (!pending) return;
        this.pendingPermissionChecks.delete(userKey);
        clearTimeout(pending.timer);
        const batchStartTime = performance.now();
        try {
          const results = await Promise.allSettled(
            pending.checks.map(({ permission }) => checkFn(permission))
          );
          this.metrics.batchOperations.totalBatches++;
          this.metrics.batchOperations.avgBatchSize = (this.metrics.batchOperations.avgBatchSize * (this.metrics.batchOperations.totalBatches - 1) + pending.checks.length) / this.metrics.batchOperations.totalBatches;
          const batchTime = performance.now() - batchStartTime;
          this.metrics.batchOperations.avgBatchTime = (this.metrics.batchOperations.avgBatchTime * (this.metrics.batchOperations.totalBatches - 1) + batchTime) / this.metrics.batchOperations.totalBatches;
          results.forEach((result, index) => {
            const check = pending.checks[index];
            if (!check) return;
            const { permission, resolve, reject } = check;
            if (result.status === "fulfilled") {
              const cacheKey = this.generatePermissionCacheKey(
                { id: userKey },
                permission
              );
              this.permissionCache.set(cacheKey, result.value);
              resolve(result.value);
            } else {
              reject(result.reason);
            }
          });
        } catch (error) {
          pending.checks.forEach(({ reject }) => {
            reject(error);
          });
        }
      }
      generatePermissionCacheKey(user, permission) {
        const context = [
          user.id,
          user.merchant_id || "",
          user.cashier_id || "",
          JSON.stringify(user.roles.sort()),
          permission.resource,
          permission.action,
          JSON.stringify(permission.context || {})
        ].join(":");
        return `perm:${this.hashString(context)}`;
      }
      generateRoleCacheKey(user) {
        const context = [
          user.id,
          user.merchant_id || "",
          user.cashier_id || "",
          JSON.stringify(user.roles.sort()),
          user.attributes?.primaryRole || ""
        ].join(":");
        return `role:${this.hashString(context)}`;
      }
      hashToken(token) {
        return `token:${this.hashString(token)}`;
      }
      hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash;
        }
        return Math.abs(hash).toString(36);
      }
      updateMetrics(type, startTime, fromCache) {
        if (!this.config.enableMetrics) return;
        const responseTime = performance.now() - startTime;
        const metric = this.metrics[type];
        metric.total++;
        if (fromCache) {
          metric.cached++;
        }
        metric.cacheHitRate = metric.cached / metric.total;
        metric.avgResponseTime = (metric.avgResponseTime * (metric.total - 1) + responseTime) / metric.total;
      }
      setupCacheCleanup() {
        setInterval(() => {
          this.permissionCache.purgeStale();
          this.roleCache.purgeStale();
          this.tokenValidationCache.purgeStale();
        }, 5 * 60 * 1e3);
      }
    };
    COMMON_PERMISSION_SETS = {
      CASHIER: [
        { resource: "receipts", action: "create" },
        { resource: "receipts", action: "read" },
        { resource: "receipts", action: "void" },
        { resource: "pointOfSales", action: "read" }
      ],
      MERCHANT: [
        { resource: "receipts", action: "create" },
        { resource: "receipts", action: "read" },
        { resource: "receipts", action: "void" },
        { resource: "receipts", action: "return" },
        { resource: "pointOfSales", action: "read" },
        { resource: "pointOfSales", action: "update" },
        { resource: "cashiers", action: "read" },
        { resource: "merchants", action: "read" },
        { resource: "merchants", action: "update" }
      ],
      SUPPLIER: [
        { resource: "receipts", action: "create" },
        { resource: "receipts", action: "read" },
        { resource: "receipts", action: "void" },
        { resource: "receipts", action: "return" },
        { resource: "pointOfSales", action: "create" },
        { resource: "pointOfSales", action: "read" },
        { resource: "pointOfSales", action: "update" },
        { resource: "pointOfSales", action: "delete" },
        { resource: "cashiers", action: "create" },
        { resource: "cashiers", action: "read" },
        { resource: "cashiers", action: "update" },
        { resource: "cashiers", action: "delete" },
        { resource: "merchants", action: "create" },
        { resource: "merchants", action: "read" },
        { resource: "merchants", action: "update" },
        { resource: "merchants", action: "delete" }
      ]
    };
  }
});

// src/auth/auth-service.ts
var auth_service_exports = {};
__export(auth_service_exports, {
  AuthService: () => AuthService
});
var DEFAULT_CONFIG12, AuthService;
var init_auth_service = __esm({
  "src/auth/auth-service.ts"() {
    "use strict";
    init_esm_shims();
    init_eventemitter3();
    init_access_control();
    init_token_manager();
    init_auth_storage();
    init_types2();
    init_types2();
    init_auth_events();
    init_auth_performance();
    DEFAULT_CONFIG12 = {
      loginUrl: "/login",
      refreshUrl: "/token/refresh",
      tokenRefreshBuffer: 5,
      maxRefreshAttempts: 3,
      refreshRetryDelay: 1e3,
      storageKey: "acube_auth",
      storageEncryption: true,
      sessionTimeout: 8 * 60 * 60 * 1e3,
      // 8 hours
      maxConcurrentSessions: 3,
      requireReauth: false,
      enableDeviceBinding: true,
      enableSessionValidation: true,
      enableTokenRotation: true,
      enablePerformanceOptimization: true,
      performanceConfig: {
        permissionCacheSize: 1e3,
        permissionCacheTTL: 5 * 60 * 1e3,
        // 5 minutes
        roleCacheSize: 100,
        roleCacheTTL: 10 * 60 * 1e3,
        // 10 minutes
        tokenValidationCacheSize: 500,
        tokenValidationCacheTTL: 1 * 60 * 1e3,
        // 1 minute
        maxBatchSize: 10,
        batchTimeoutMs: 50,
        enableMetrics: true
      }
    };
    AuthService = class extends import_index.default {
      config;
      httpClient;
      tokenManager;
      storage;
      accessControl;
      currentState;
      deviceId;
      sessionCleanupInterval = null;
      performanceOptimizer;
      constructor(httpClient, config = {}, accessControl, storage, tokenManager) {
        super();
        this.config = { ...DEFAULT_CONFIG12, ...config };
        this.httpClient = httpClient;
        if (tokenManager) {
          this.tokenManager = tokenManager;
        } else {
          this.tokenManager = new TokenManager(httpClient, {
            refreshUrl: this.config.refreshUrl,
            tokenRefreshBuffer: this.config.tokenRefreshBuffer,
            maxRefreshAttempts: this.config.maxRefreshAttempts,
            refreshRetryDelay: this.config.refreshRetryDelay,
            enableTokenRotation: this.config.enableTokenRotation,
            ...this.config.onTokenRefresh && { onTokenRefresh: this.config.onTokenRefresh },
            onTokenExpired: this.handleTokenExpired.bind(this)
          });
        }
        this.storage = storage || new AuthStorage({
          storageKey: this.config.storageKey,
          enableEncryption: this.config.storageEncryption
        });
        this.accessControl = accessControl || new AccessControlManager({
          enabled: true,
          model: "HYBRID",
          session: {
            timeout: this.config.sessionTimeout,
            maxConcurrentSessions: this.config.maxConcurrentSessions,
            requireReauth: this.config.requireReauth
          }
        });
        this.currentState = {
          isAuthenticated: false,
          isLoading: false,
          user: null,
          accessToken: null,
          refreshToken: null,
          expiresAt: null,
          error: null
        };
        this.deviceId = this.generateDeviceId();
        this.performanceOptimizer = new AuthPerformanceOptimizer(
          this.config.enablePerformanceOptimization ? this.config.performanceConfig : { enableMetrics: false }
        );
        this.setupEventListeners();
        this.startSessionCleanup();
      }
      /**
       * Initialize the auth service and restore session if available
       */
      async initialize() {
        try {
          await this.storage.initialize();
          await this.restoreSession();
        } catch (error) {
          console.error("Auth service initialization failed:", error);
        }
      }
      /**
       * Login with username and password
       */
      async login(credentials) {
        this.updateState({ isLoading: true, error: null });
        this.emitLoginStart(credentials);
        try {
          const requestData = {
            email: credentials.username,
            // API expects 'email' field instead of 'username'
            password: credentials.password
          };
          const response = await this.httpClient.post(
            this.config.loginUrl,
            requestData,
            {
              headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
              },
              skipRetry: false,
              metadata: { isAuthentication: true }
            }
          );
          const tokens = response.data;
          const rawTokenPayload = this.tokenManager.parseToken(tokens.token);
          if (!rawTokenPayload) {
            throw this.createAuthError(
              "TOKEN_INVALID",
              "Invalid access token received"
            );
          }
          const tokenPayload = {
            sub: String(rawTokenPayload.uid || rawTokenPayload.sub || "unknown"),
            email: rawTokenPayload.username || rawTokenPayload.email || credentials.username,
            roles: [],
            // Will be populated below
            permissions: [],
            iat: rawTokenPayload.iat,
            exp: rawTokenPayload.exp,
            ...rawTokenPayload.merchant_id && { merchant_id: rawTokenPayload.merchant_id },
            ...rawTokenPayload.cashier_id && { cashier_id: rawTokenPayload.cashier_id },
            ...rawTokenPayload.point_of_sale_id && { point_of_sale_id: rawTokenPayload.point_of_sale_id }
          };
          let apiRoles = [];
          if (rawTokenPayload.roles && typeof rawTokenPayload.roles === "object") {
            const domainRoles = Object.values(rawTokenPayload.roles)[0];
            apiRoles = Array.isArray(domainRoles) ? domainRoles : [];
          }
          const tokenRoles = apiRoles.map((role) => {
            switch (role) {
              case "ROLE_MERCHANT":
                return "ROLE_MERCHANT" /* ROLE_MERCHANT */;
              case "ROLE_CASHIER":
                return "ROLE_CASHIER" /* ROLE_CASHIER */;
              case "ROLE_SUPPLIER":
                return "ROLE_SUPPLIER" /* ROLE_SUPPLIER */;
              case "ROLE_ADMIN":
                return "ROLE_ADMIN" /* ROLE_ADMIN */;
              default:
                return "ROLE_CASHIER" /* ROLE_CASHIER */;
            }
          });
          tokenPayload.roles = tokenRoles;
          const effectiveRoles = getEffectiveRoles(tokenRoles);
          const contextForDetection = {
            userRoles: effectiveRoles
          };
          if (tokenPayload.merchant_id) {
            contextForDetection.merchantId = tokenPayload.merchant_id;
          }
          if (tokenPayload.cashier_id) {
            contextForDetection.cashierId = tokenPayload.cashier_id;
          }
          if (tokenPayload.point_of_sale_id) {
            contextForDetection.pointOfSaleId = tokenPayload.point_of_sale_id;
          }
          if (credentials.preferred_role) {
            contextForDetection.preferredRole = credentials.preferred_role;
          }
          const primaryRole = autoDetectRole(contextForDetection);
          const user = {
            id: tokenPayload.sub,
            email: tokenPayload.email,
            name: rawTokenPayload.username || tokenPayload.email || "Unknown User",
            roles: effectiveRoles,
            permissions: tokenPayload.permissions || [],
            ...tokenPayload.cashier_id && { cashier_id: tokenPayload.cashier_id },
            ...tokenPayload.merchant_id && { merchant_id: tokenPayload.merchant_id },
            ...tokenPayload.point_of_sale_id && { point_of_sale_id: tokenPayload.point_of_sale_id },
            session_id: this.generateSessionId(),
            last_login: /* @__PURE__ */ new Date(),
            attributes: {
              deviceId: this.deviceId,
              loginMethod: "password",
              primaryRole,
              simpleRole: toSimpleRole(effectiveRoles),
              originalRoles: tokenRoles,
              contextDetected: {
                merchant: !!tokenPayload.merchant_id,
                cashier: !!tokenPayload.cashier_id,
                pointOfSale: !!tokenPayload.point_of_sale_id
              }
            }
          };
          const oauth2Tokens = {
            access_token: tokens.token,
            refresh_token: "",
            // API doesn't provide refresh token in this format
            token_type: "Bearer",
            expires_in: tokenPayload.exp ? Math.floor((tokenPayload.exp * 1e3 - Date.now()) / 1e3) : 3600
          };
          this.tokenManager.setTokens(oauth2Tokens);
          try {
            const clientIP = await this.getClientIP();
            const userAgent = this.getUserAgent();
            const { sessionId } = await this.accessControl.authenticate(user.id, {
              timestamp: Date.now(),
              deviceId: this.deviceId,
              ipAddress: clientIP || "unknown",
              userAgent: userAgent || "unknown"
            });
            user.session_id = sessionId;
          } catch (accessControlError) {
          }
          const authData = {
            accessToken: tokens.token,
            refreshToken: "",
            // No refresh token available
            expiresAt: tokenPayload.exp * 1e3,
            tokenType: "Bearer",
            user,
            encryptedAt: Date.now(),
            version: "1.0",
            deviceId: this.deviceId
          };
          await this.storage.store(authData);
          this.updateState({
            isAuthenticated: true,
            isLoading: false,
            user,
            accessToken: tokens.token,
            refreshToken: "",
            // No refresh token available
            expiresAt: tokenPayload.exp * 1e3,
            error: null
          });
          this.emitLoginSuccess(user, oauth2Tokens);
          this.emitSessionCreated(user);
          if (this.config.enablePerformanceOptimization) {
            this.preloadCommonPermissions(user).catch((error) => {
              console.warn("Failed to preload permissions:", error);
            });
          }
          return user;
        } catch (error) {
          const authError = this.handleLoginError(error, credentials);
          this.updateState({
            isLoading: false,
            error: authError
          });
          this.emitLoginFailure(authError, credentials);
          throw authError;
        }
      }
      /**
       * Logout user and clear session
       */
      async logout(options = {}) {
        const user = this.currentState.user;
        const sessionId = user?.session_id;
        try {
          if (this.config.logoutUrl && this.currentState.accessToken) {
            try {
              await this.httpClient.post(this.config.logoutUrl, {
                refresh_token: this.currentState.refreshToken,
                clear_all_sessions: options.clearAllSessions || false
              });
            } catch (error) {
              console.warn("Server logout failed:", error);
            }
          }
          if (sessionId) {
            await this.accessControl.terminateSession(sessionId);
          }
          this.tokenManager.clearTokens();
          if (options.clearLocalData !== false) {
            await this.storage.clear();
          }
          this.clearUserCaches();
          this.emitLogout(user?.id || "unknown", options);
          this.updateState({
            isAuthenticated: false,
            isLoading: false,
            user: null,
            accessToken: null,
            refreshToken: null,
            expiresAt: null,
            error: null
          });
          if (this.config.onLogout) {
            this.config.onLogout(options.reason);
          }
        } catch (error) {
          console.error("Logout error:", error);
          this.updateState({
            isAuthenticated: false,
            isLoading: false,
            user: null,
            accessToken: null,
            refreshToken: null,
            expiresAt: null,
            error: null
          });
        }
      }
      /**
       * Get current authentication state
       */
      getState() {
        return { ...this.currentState };
      }
      /**
       * Get current user
       */
      getCurrentUser() {
        return this.currentState.user;
      }
      /**
       * Check if user has permission (optimized with caching and batching)
       */
      async checkPermission(permission) {
        const user = this.currentState.user;
        if (!user || !user.session_id) {
          return {
            granted: false,
            reason: "User not authenticated"
          };
        }
        if (this.config.enablePerformanceOptimization) {
          return this.performanceOptimizer.checkPermissionOptimized(
            user,
            permission,
            async (perm) => this.checkPermissionDirect(perm)
          );
        }
        return this.checkPermissionDirect(permission);
      }
      /**
       * Direct permission check without optimization (used by optimizer)
       */
      async checkPermissionDirect(permission) {
        const user = this.currentState.user;
        if (!user || !user.session_id) {
          return {
            granted: false,
            reason: "User not authenticated"
          };
        }
        try {
          const result = await this.accessControl.checkAccess(
            user.session_id,
            permission.resource,
            permission.action,
            {
              timestamp: Date.now(),
              deviceId: this.deviceId,
              attributes: permission.context || {}
            }
          );
          return {
            granted: result.granted,
            reason: result.reason || "Permission check completed",
            requiresApproval: result.requiresApproval || false
          };
        } catch (error) {
          return {
            granted: false,
            reason: "Permission check failed"
          };
        }
      }
      /**
       * Check if user has specific role (including inherited roles)
       */
      hasRole(role) {
        const userRoles = this.currentState.user?.roles || [];
        return hasRole(userRoles, role);
      }
      /**
       * Check if user has any of the specified roles (including inherited roles)
       */
      hasAnyRole(roles) {
        const userRoles = this.currentState.user?.roles || [];
        return hasAnyRole(userRoles, roles);
      }
      /**
       * Get user's effective roles (including inherited roles) - optimized with caching
       */
      getEffectiveRoles() {
        const user = this.currentState.user;
        if (!user) return [];
        if (this.config.enablePerformanceOptimization) {
          return this.performanceOptimizer.getEffectiveRolesOptimized(
            user,
            (u) => getEffectiveRoles(u.roles || [])
          );
        }
        return getEffectiveRoles(user.roles || []);
      }
      /**
       * Get user's primary role for display purposes
       */
      getPrimaryRole() {
        const userRoles = this.currentState.user?.roles || [];
        return getPrimaryRole(userRoles);
      }
      /**
       * Get user's simple role for external APIs
       */
      getSimpleRole() {
        const userRoles = this.currentState.user?.roles || [];
        return toSimpleRole(userRoles);
      }
      /**
       * Switch to a different role context during session
       */
      async switchRole(targetRole, context) {
        const userRoles = this.currentState.user?.roles || [];
        const switchContext = context ? (() => {
          const ctx = {};
          if (context.merchant_id) ctx.merchantId = context.merchant_id;
          if (context.cashier_id) ctx.cashierId = context.cashier_id;
          if (context.point_of_sale_id) ctx.pointOfSaleId = context.point_of_sale_id;
          return ctx;
        })() : void 0;
        if (!canSwitchToRole(userRoles, targetRole, switchContext)) {
          return false;
        }
        if (this.currentState.user) {
          this.currentState.user.attributes = {
            ...this.currentState.user.attributes,
            primaryRole: targetRole,
            simpleRole: ROLE_TO_SIMPLE[targetRole] || "cashier",
            contextSwitched: true,
            previousRole: this.currentState.user.attributes?.primaryRole
          };
          if (context) {
            if (context.merchant_id) this.currentState.user.merchant_id = context.merchant_id;
            if (context.cashier_id) this.currentState.user.cashier_id = context.cashier_id;
            if (context.point_of_sale_id) this.currentState.user.point_of_sale_id = context.point_of_sale_id;
          }
          try {
            await this.storage.update({
              user: this.currentState.user
            });
          } catch (error) {
            console.warn("Failed to update stored auth data after role switch:", error);
          }
          this.emit("auth:role:changed" /* ROLE_CHANGED */, createAuthEvent(
            "auth:role:changed" /* ROLE_CHANGED */,
            {
              userId: this.currentState.user.id,
              oldRoles: [this.currentState.user.attributes?.previousRole || targetRole],
              newRoles: [targetRole],
              changedBy: this.currentState.user.id,
              reason: "user_initiated_switch"
            }
          ));
        }
        return true;
      }
      /**
       * Get current session info
       */
      async getSessionInfo() {
        const user = this.currentState.user;
        if (!user || !user.session_id) {
          return null;
        }
        const clientIP = await this.getClientIP();
        const userAgent = this.getUserAgent();
        return {
          id: user.session_id,
          userId: user.id,
          createdAt: user.last_login,
          lastActivity: /* @__PURE__ */ new Date(),
          expiresAt: new Date(this.currentState.expiresAt || Date.now() + this.config.sessionTimeout),
          deviceId: this.deviceId,
          deviceName: this.getDeviceName(),
          deviceType: this.getDeviceType(),
          ipAddress: clientIP || "unknown",
          userAgent: userAgent || "unknown",
          active: this.currentState.isAuthenticated
        };
      }
      /**
       * Refresh current session
       */
      async refreshSession() {
        if (!this.currentState.isAuthenticated || !this.tokenManager.getRefreshToken()) {
          throw this.createAuthError(
            "SESSION_EXPIRED",
            "No active session to refresh"
          );
        }
        try {
          const tokens = await this.tokenManager.refreshTokens();
          await this.storage.update({
            accessToken: tokens.access_token,
            refreshToken: tokens.refresh_token,
            expiresAt: this.tokenManager.parseToken(tokens.access_token)?.exp * 1e3
          });
          this.updateState({
            accessToken: tokens.access_token,
            refreshToken: tokens.refresh_token,
            expiresAt: this.tokenManager.parseToken(tokens.access_token)?.exp * 1e3
          });
        } catch (error) {
          await this.logout({
            reason: "token_invalid",
            clearLocalData: true
          });
          throw error;
        }
      }
      /**
       * Restore session from storage
       */
      async restoreSession() {
        try {
          const storedData = await this.storage.retrieve();
          if (!storedData || storedData.expiresAt <= Date.now()) {
            return;
          }
          const tokenValidation = this.tokenManager.validateToken(storedData.accessToken);
          if (!tokenValidation.valid) {
            if (storedData.refreshToken) {
              this.tokenManager.setTokens({
                access_token: storedData.accessToken,
                refresh_token: storedData.refreshToken,
                token_type: "Bearer",
                expires_in: Math.floor((storedData.expiresAt - Date.now()) / 1e3)
              });
              try {
                await this.refreshSession();
                return;
              } catch {
              }
            }
            await this.storage.clear();
            return;
          }
          this.tokenManager.setTokens({
            access_token: storedData.accessToken,
            refresh_token: storedData.refreshToken,
            token_type: "Bearer",
            expires_in: Math.floor((storedData.expiresAt - Date.now()) / 1e3)
          });
          this.updateState({
            isAuthenticated: true,
            user: storedData.user,
            accessToken: storedData.accessToken,
            refreshToken: storedData.refreshToken,
            expiresAt: storedData.expiresAt,
            error: null
          });
          this.emitSessionRestored(storedData.user);
        } catch (error) {
          console.error("Session restoration failed:", error);
          await this.storage.clear();
        }
      }
      /**
       * Handle token expiration
       */
      async handleTokenExpired() {
        this.emit("auth:session:expired" /* SESSION_EXPIRED */, createAuthEvent(
          "auth:session:expired" /* SESSION_EXPIRED */,
          {
            sessionId: this.currentState.user?.session_id || "unknown",
            userId: this.currentState.user?.id || "unknown",
            expiredAt: /* @__PURE__ */ new Date(),
            reason: "timeout"
          }
        ));
        if (this.config.onTokenExpired) {
          this.config.onTokenExpired();
        }
        await this.logout({
          reason: "session_expired",
          clearLocalData: true
        });
      }
      /**
       * Handle login errors
       */
      handleLoginError(error, _credentials) {
        let authError;
        if (error instanceof Error && "statusCode" in error) {
          const statusCode = error.statusCode;
          switch (statusCode) {
            case 401:
              authError = this.createAuthError(
                "INVALID_CREDENTIALS",
                "Invalid username or password",
                error
              );
              break;
            case 403:
              authError = this.createAuthError(
                "PERMISSION_DENIED",
                "Account is locked or suspended",
                error
              );
              break;
            case 429:
              authError = this.createAuthError(
                "NETWORK_ERROR",
                "Too many login attempts. Please try again later.",
                error
              );
              break;
            default:
              authError = this.createAuthError(
                "NETWORK_ERROR",
                "Login failed due to network error",
                error
              );
          }
        } else {
          authError = this.createAuthError(
            "UNKNOWN_ERROR",
            "Login failed due to unknown error",
            error
          );
        }
        return authError;
      }
      /**
       * Update authentication state
       */
      updateState(updates) {
        this.currentState = { ...this.currentState, ...updates };
        this.emit("stateChange", this.currentState);
      }
      /**
       * Setup event listeners
       */
      setupEventListeners() {
        this.tokenManager.on("auth:token:refresh:success" /* TOKEN_REFRESH_SUCCESS */, (event) => {
          this.emit("auth:token:refresh:success" /* TOKEN_REFRESH_SUCCESS */, event);
        });
        this.tokenManager.on("auth:token:refresh:failure" /* TOKEN_REFRESH_FAILURE */, (event) => {
          this.emit("auth:token:refresh:failure" /* TOKEN_REFRESH_FAILURE */, event);
        });
        this.tokenManager.on("auth:token:expired" /* TOKEN_EXPIRED */, (event) => {
          this.emit("auth:token:expired" /* TOKEN_EXPIRED */, event);
        });
        this.storage.on("auth:storage:error" /* STORAGE_ERROR */, (event) => {
          this.emit("auth:storage:error" /* STORAGE_ERROR */, event);
        });
      }
      /**
       * Start session cleanup timer
       */
      startSessionCleanup() {
        this.sessionCleanupInterval = setInterval(() => {
          this.cleanupExpiredSessions();
        }, 60 * 60 * 1e3);
      }
      /**
       * Clean up expired sessions
       */
      async cleanupExpiredSessions() {
        try {
          const stats = await this.storage.getStats();
          if (stats.isExpired) {
            await this.storage.clear();
          }
        } catch (error) {
          console.error("Session cleanup failed:", error);
        }
      }
      /**
       * Event emitters
       */
      emitLoginStart(credentials) {
        const event = createAuthEvent(
          "auth:login:start" /* LOGIN_START */,
          {
            username: credentials.username,
            hasPassword: !!credentials.password,
            hasMFA: !!credentials.mfa_code,
            deviceId: this.deviceId
          }
        );
        this.emit("auth:login:start" /* LOGIN_START */, event);
      }
      emitLoginSuccess(user, tokens) {
        const event = createAuthEvent(
          "auth:login:success" /* LOGIN_SUCCESS */,
          {
            user,
            tokens,
            isFirstLogin: !user.last_login || user.last_login.getTime() === Date.now(),
            loginMethod: "password"
          }
        );
        this.emit("auth:login:success" /* LOGIN_SUCCESS */, event);
      }
      emitLoginFailure(error, credentials) {
        const event = createAuthEvent(
          "auth:login:failure" /* LOGIN_FAILURE */,
          {
            error,
            username: credentials.username,
            attemptNumber: 1
            // Would track this in real implementation
          }
        );
        this.emit("auth:login:failure" /* LOGIN_FAILURE */, event);
      }
      emitLogout(userId, options) {
        const event = createAuthEvent(
          "auth:logout" /* LOGOUT */,
          {
            userId,
            reason: options.reason || "user_initiated",
            ...options.message && { message: options.message },
            clearAllSessions: options.clearAllSessions || false
          }
        );
        this.emit("auth:logout" /* LOGOUT */, event);
      }
      emitSessionCreated(user) {
        const event = createAuthEvent(
          "auth:session:created" /* SESSION_CREATED */,
          {
            sessionId: user.session_id,
            userId: user.id,
            expiresAt: new Date(this.currentState.expiresAt || Date.now() + this.config.sessionTimeout),
            deviceId: this.deviceId
          }
        );
        this.emit("auth:session:created" /* SESSION_CREATED */, event);
      }
      emitSessionRestored(user) {
        const event = createAuthEvent(
          "auth:session:restored" /* SESSION_RESTORED */,
          {
            sessionId: user.session_id,
            user,
            remainingTime: (this.currentState.expiresAt || 0) - Date.now(),
            source: "storage"
          }
        );
        this.emit("auth:session:restored" /* SESSION_RESTORED */, event);
      }
      /**
       * Utility methods
       */
      generateDeviceId() {
        if (typeof window !== "undefined" && window.localStorage) {
          let deviceId = window.localStorage.getItem("acube_device_id");
          if (!deviceId) {
            deviceId = `device_${Date.now()}_${Math.random().toString(36).substring(2)}`;
            window.localStorage.setItem("acube_device_id", deviceId);
          }
          return deviceId;
        }
        return `device_${Date.now()}_${Math.random().toString(36).substring(2)}`;
      }
      generateSessionId() {
        return `session_${Date.now()}_${Math.random().toString(36).substring(2)}`;
      }
      getDeviceName() {
        if (typeof navigator !== "undefined") {
          return navigator.userAgent.split(" ")[0] || "Unknown Device";
        }
        return "Unknown Device";
      }
      getDeviceType() {
        if (typeof navigator === "undefined") return "desktop";
        if (navigator.product === "ReactNative") return "mobile";
        const userAgent = navigator.userAgent.toLowerCase();
        if (/mobile|android|iphone|ipad/.test(userAgent)) return "mobile";
        return "web";
      }
      async getClientIP() {
        return void 0;
      }
      getUserAgent() {
        return typeof navigator !== "undefined" ? navigator.userAgent : void 0;
      }
      createAuthError(type, message, cause) {
        return {
          name: "AuthError",
          type,
          message,
          details: cause instanceof Error ? { cause: cause.message } : {},
          timestamp: Date.now(),
          recoverable: false
        };
      }
      /**
       * Preload common permissions for the current user
       */
      async preloadCommonPermissions(user) {
        if (!this.config.enablePerformanceOptimization) return;
        let commonPermissions = COMMON_PERMISSION_SETS.CASHIER;
        if (hasRole(user.roles || [], "ROLE_SUPPLIER" /* ROLE_SUPPLIER */)) {
          commonPermissions = COMMON_PERMISSION_SETS.SUPPLIER;
        } else if (hasRole(user.roles || [], "ROLE_MERCHANT" /* ROLE_MERCHANT */)) {
          commonPermissions = COMMON_PERMISSION_SETS.MERCHANT;
        }
        await this.performanceOptimizer.preloadUserPermissions(
          user,
          commonPermissions,
          async (permission) => this.checkPermissionDirect(permission)
        );
      }
      /**
       * Clear user-specific performance caches (call on role change, logout, etc.)
       */
      clearUserCaches() {
        if (this.config.enablePerformanceOptimization && this.currentState.user) {
          this.performanceOptimizer.clearUserCaches(this.currentState.user.id);
        }
      }
      /**
       * Get performance metrics for monitoring
       */
      getPerformanceMetrics() {
        if (!this.config.enablePerformanceOptimization) return null;
        return this.performanceOptimizer.getMetrics();
      }
      /**
       * Reset performance metrics
       */
      resetPerformanceMetrics() {
        if (this.config.enablePerformanceOptimization) {
          this.performanceOptimizer.resetMetrics();
        }
      }
      /**
       * Destroy auth service
       */
      async destroy() {
        if (this.sessionCleanupInterval) {
          clearInterval(this.sessionCleanupInterval);
        }
        this.tokenManager.destroy();
        await this.storage.destroy();
        if (this.performanceOptimizer) {
          this.performanceOptimizer.destroy();
        }
        this.removeAllListeners();
      }
    };
  }
});

// src/auth/auth-middleware.ts
var auth_middleware_exports = {};
__export(auth_middleware_exports, {
  EnhancedAuthMiddleware: () => EnhancedAuthMiddleware,
  createEnhancedAuthMiddleware: () => createEnhancedAuthMiddleware,
  hasRequiredPermission: () => hasRequiredPermission,
  hasRequiredRole: () => hasRequiredRole
});
function createEnhancedAuthMiddleware(authService, tokenManager, config) {
  return new EnhancedAuthMiddleware(authService, tokenManager, config);
}
function hasRequiredRole(userRoles, requiredRoles) {
  const required = Array.isArray(requiredRoles) ? requiredRoles : [requiredRoles];
  return required.some((role) => userRoles.includes(role));
}
function hasRequiredPermission(userPermissions, requiredPermission) {
  const required = Array.isArray(requiredPermission) ? requiredPermission : [requiredPermission];
  return required.some((permission) => userPermissions.includes(permission));
}
var DEFAULT_CONFIG13, EnhancedAuthMiddleware;
var init_auth_middleware = __esm({
  "src/auth/auth-middleware.ts"() {
    "use strict";
    init_esm_shims();
    init_types2();
    init_auth_events();
    init_eventemitter3();
    DEFAULT_CONFIG13 = {
      enableRetry: true,
      maxRetries: 2,
      retryDelay: 1e3,
      authHeaderName: "Authorization",
      authScheme: "Bearer",
      includeRoleHeaders: true,
      roleHeaderName: "X-User-Role",
      includePermissionHeaders: true,
      permissionHeaderName: "X-User-Permissions",
      includeRequestContext: true,
      contextHeaders: {
        "X-Device-ID": "deviceId",
        "X-Session-ID": "sessionId",
        "X-Request-Context": "requestContext"
      }
    };
    EnhancedAuthMiddleware = class extends import_index.default {
      name = "enhanced-auth";
      priority = 100;
      // Highest priority for auth
      config;
      authService;
      tokenManager;
      isRefreshing = false;
      requestQueue = [];
      queueTimeout = 3e4;
      // 30 seconds
      constructor(authService, tokenManager, config = {}) {
        super();
        this.config = { ...DEFAULT_CONFIG13, ...config };
        this.authService = authService;
        this.tokenManager = tokenManager;
        this.setupEventListeners();
      }
      /**
       * Before request: Add authentication headers and user context
       */
      async beforeRequest(context) {
        if (this.isAuthEndpoint(context.url)) {
          return context;
        }
        if (this.isRefreshing) {
          return this.queueRequest(context);
        }
        const authState = this.authService.getState();
        if (!authState.isAuthenticated || !authState.accessToken) {
          return context;
        }
        const tokenStatus = this.tokenManager.getTokenStatus();
        if (tokenStatus.needsRefresh && !tokenStatus.isRefreshing) {
          try {
            await this.refreshTokensWithQueue();
          } catch (error) {
            console.warn("Pre-request token refresh failed:", error);
          }
        }
        const updatedContext = await this.addAuthHeaders(context);
        return updatedContext;
      }
      /**
       * After response: Handle token expiration and refresh
       */
      async afterResponse(context, response) {
        if (response.status === 401 && this.shouldRetryWithRefresh(context)) {
          try {
            await this.refreshTokensWithQueue();
            return this.retryRequestWithNewToken(context, response);
          } catch (refreshError) {
            this.handleAuthenticationFailure(refreshError);
            return response;
          }
        }
        if (response.status === 403) {
          this.handleAuthorizationFailure(context, response);
        }
        return response;
      }
      /**
       * Error handler: Process authentication-related errors
       */
      async onError(context, error) {
        if (this.isAuthRelatedError(error)) {
          const authError = this.createAuthError(error, context);
          this.emit("auth:network:error" /* NETWORK_ERROR */, createAuthEvent(
            "auth:network:error" /* NETWORK_ERROR */,
            {
              operation: "request",
              error: authError,
              endpoint: context.url,
              statusCode: error.statusCode,
              willRetry: false
            }
          ));
          return authError;
        }
        return error;
      }
      /**
       * Add authentication and context headers to request
       */
      async addAuthHeaders(context) {
        const authState = this.authService.getState();
        const updatedContext = { ...context };
        if (authState.accessToken) {
          const authHeader = `${this.config.authScheme} ${authState.accessToken}`;
          updatedContext.headers[this.config.authHeaderName] = authHeader;
        } else {
          console.log("\u26A0\uFE0F  No access token available for request:", {
            url: `${context.method} ${context.url}`,
            authState: {
              isAuthenticated: authState.isAuthenticated,
              hasUser: !!authState.user,
              hasToken: !!authState.accessToken
            }
          });
        }
        if (this.config.includeRoleHeaders && authState.user?.roles) {
          updatedContext.headers[this.config.roleHeaderName] = authState.user.roles.join(",");
        }
        if (this.config.includePermissionHeaders && authState.user?.permissions) {
          updatedContext.headers[this.config.permissionHeaderName] = authState.user.permissions.join(",");
        }
        if (this.config.includeRequestContext && authState.user) {
          Object.entries(this.config.contextHeaders).forEach(([headerName, contextKey]) => {
            let value;
            switch (contextKey) {
              case "deviceId":
                value = authState.user?.attributes?.deviceId;
                break;
              case "sessionId":
                value = authState.user?.session_id;
                break;
              case "requestContext":
                value = JSON.stringify({
                  userId: authState.user?.id,
                  roles: authState.user?.roles,
                  timestamp: Date.now()
                });
                break;
              default:
                value = authState.user?.[contextKey];
            }
            if (value) {
              updatedContext.headers[headerName] = value;
            }
          });
        }
        updatedContext.metadata = {
          ...updatedContext.metadata,
          isAuthenticated: authState.isAuthenticated,
          userId: authState.user?.id,
          roles: authState.user?.roles,
          permissions: authState.user?.permissions
        };
        return updatedContext;
      }
      /**
       * Queue request during token refresh
       */
      async queueRequest(context) {
        return new Promise((resolve, reject) => {
          const queuedRequest = {
            context,
            resolve,
            reject,
            timestamp: Date.now()
          };
          this.requestQueue.push(queuedRequest);
          setTimeout(() => {
            const index = this.requestQueue.indexOf(queuedRequest);
            if (index !== -1) {
              this.requestQueue.splice(index, 1);
              reject(new Error("Request queue timeout"));
            }
          }, this.queueTimeout);
        });
      }
      /**
       * Refresh tokens with request queuing
       */
      async refreshTokensWithQueue() {
        if (this.isRefreshing) {
          return new Promise((resolve, reject) => {
            const checkRefresh = () => {
              if (!this.isRefreshing) {
                resolve();
              } else {
                setTimeout(checkRefresh, 100);
              }
            };
            setTimeout(() => reject(new Error("Token refresh timeout")), this.queueTimeout);
            checkRefresh();
          });
        }
        this.isRefreshing = true;
        try {
          await this.authService.refreshSession();
          await this.processQueuedRequests();
        } finally {
          this.isRefreshing = false;
        }
      }
      /**
       * Process all queued requests after token refresh
       */
      async processQueuedRequests() {
        const queue = [...this.requestQueue];
        this.requestQueue = [];
        for (const queuedRequest of queue) {
          try {
            const updatedContext = await this.addAuthHeaders(queuedRequest.context);
            queuedRequest.resolve(updatedContext);
          } catch (error) {
            queuedRequest.reject(error);
          }
        }
      }
      /**
       * Retry request with new token after 401 response
       */
      async retryRequestWithNewToken(_context, originalResponse) {
        const retryResponse = {
          ...originalResponse,
          status: 200,
          // Assume retry would succeed
          statusText: "OK",
          metadata: {
            ...originalResponse.metadata,
            wasRetried: true,
            retryReason: "token_refresh"
          }
        };
        return retryResponse;
      }
      /**
       * Handle authentication failure (401 after refresh attempt)
       */
      handleAuthenticationFailure(_error) {
        this.emit("auth:security:unauthorized" /* UNAUTHORIZED_ACCESS */, createAuthEvent(
          "auth:security:unauthorized" /* UNAUTHORIZED_ACCESS */,
          {
            userId: this.authService.getCurrentUser()?.id,
            resource: "api",
            action: "request",
            reason: "Token refresh failed"
          }
        ));
        this.authService.logout({
          reason: "token_invalid",
          clearLocalData: true
        }).catch((logoutError) => {
          console.error("Auto-logout failed:", logoutError);
        });
      }
      /**
       * Handle authorization failure (403 responses)
       */
      handleAuthorizationFailure(context, _response) {
        const user = this.authService.getCurrentUser();
        this.emit("auth:security:unauthorized" /* UNAUTHORIZED_ACCESS */, createAuthEvent(
          "auth:security:unauthorized" /* UNAUTHORIZED_ACCESS */,
          {
            userId: user?.id,
            resource: context.url,
            action: context.method,
            reason: "Insufficient permissions"
          }
        ));
        if (user) {
          this.checkForRoleChanges(user.roles);
        }
      }
      /**
       * Check for role changes that might explain authorization failure
       */
      async checkForRoleChanges(currentRoles) {
        try {
          const user = this.authService.getCurrentUser();
          if (!user || !user.roles || user.roles.length === 0) {
            console.warn("User roles are empty or user is not authenticated");
            return;
          }
          const hasRoleChanged = !currentRoles.every((role) => user.roles.includes(role));
          if (hasRoleChanged) {
            console.warn("Authorization failure - possible role changes detected");
          }
        } catch (error) {
          console.error("Failed to check role changes:", error);
        }
      }
      /**
       * Setup event listeners for auth service
       */
      setupEventListeners() {
        this.tokenManager.on("auth:token:refresh:success" /* TOKEN_REFRESH_SUCCESS */, () => {
          if (this.requestQueue.length > 0) {
            this.processQueuedRequests().catch((error) => {
              console.error("Failed to process queued requests:", error);
            });
          }
        });
        this.tokenManager.on("auth:token:expired" /* TOKEN_EXPIRED */, () => {
          this.requestQueue.forEach((request) => {
            request.reject(new Error("Token expired"));
          });
          this.requestQueue = [];
        });
      }
      /**
       * Check if URL is an authentication endpoint
       */
      isAuthEndpoint(url) {
        const authEndpoints = ["/mf1/login", "/mf1/token/refresh", "/mf1/logout"];
        return authEndpoints.some((endpoint) => url.includes(endpoint));
      }
      /**
       * Check if request should be retried with token refresh
       */
      shouldRetryWithRefresh(context) {
        if (!this.config.enableRetry) {
          return false;
        }
        if (this.isAuthEndpoint(context.url)) {
          return false;
        }
        const retryCount = context.metadata.retryCount || 0;
        if (retryCount >= this.config.maxRetries) {
          return false;
        }
        const tokenStatus = this.tokenManager.getTokenStatus();
        if (!tokenStatus || !tokenStatus.isValid || !tokenStatus.isRefreshing) {
          return false;
        }
        return true;
      }
      /**
       * Check if error is authentication-related
       */
      isAuthRelatedError(error) {
        const authStatusCodes = [401, 403];
        const statusCode = error.statusCode;
        return authStatusCodes.includes(statusCode) || error.message.toLowerCase().includes("auth") || error.message.toLowerCase().includes("token") || error.message.toLowerCase().includes("unauthorized");
      }
      /**
       * Create auth error from generic error
       */
      createAuthError(error, context) {
        const statusCode = error.statusCode;
        let type;
        let message = error.message;
        switch (statusCode) {
          case 401:
            type = AuthErrorType.TOKEN_EXPIRED;
            message = "Authentication token expired or invalid";
            break;
          case 403:
            type = AuthErrorType.PERMISSION_DENIED;
            message = "Insufficient permissions for this operation";
            break;
          default:
            type = AuthErrorType.NETWORK_ERROR;
            message = `Network error during authentication: ${error.message}`;
        }
        return {
          name: "AuthError",
          type,
          message,
          code: `HTTP_${statusCode}`,
          statusCode,
          details: {
            originalError: error.message,
            url: context.url,
            method: context.method
          },
          timestamp: Date.now(),
          recoverable: statusCode === 401
          // 401 is recoverable via token refresh
        };
      }
      /**
       * Get middleware statistics
       */
      getStats() {
        const queueTimes = this.requestQueue.map((req) => Date.now() - req.timestamp);
        const averageQueueTime = queueTimes.length > 0 ? queueTimes.reduce((sum, time) => sum + time, 0) / queueTimes.length : 0;
        return {
          queuedRequests: this.requestQueue.length,
          isRefreshing: this.isRefreshing,
          totalRetries: 0,
          // Would track this in real implementation
          averageQueueTime
        };
      }
      /**
       * Clear request queue and reset state
       */
      clearQueue() {
        this.requestQueue.forEach((request) => {
          request.reject(new Error("Queue cleared"));
        });
        this.requestQueue = [];
        this.isRefreshing = false;
      }
      /**
       * Destroy middleware and clean up resources
       */
      destroy() {
        this.clearQueue();
        this.removeAllListeners();
      }
    };
  }
});

// node_modules/react/cjs/react.production.js
var require_react_production = __commonJS({
  "node_modules/react/cjs/react.production.js"(exports) {
    "use strict";
    init_esm_shims();
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    };
    var assign = Object.assign;
    var emptyObject = {};
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    function ComponentDummy() {
    }
    ComponentDummy.prototype = Component.prototype;
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    var isArrayImpl = Array.isArray;
    var ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function ReactElement(type, key, self, source, owner, props) {
      self = props.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== self ? self : null,
        props
      };
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement(
        oldElement.type,
        newKey,
        void 0,
        void 0,
        void 0,
        oldElement.props
      );
    }
    function isValidElement(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      });
    }
    var userProvidedKeyEscapeRegex = /\/+/g;
    function getElementKey(element, index) {
      return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
    }
    function noop$1() {
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
            function(fulfilledValue) {
              "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
            },
            function(error) {
              "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
            }
          )), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = false;
      if (null === children) invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(
                  invokeCallback(children._payload),
                  array,
                  escapedPrefix,
                  nameSoFar,
                  callback
                );
            }
        }
      if (invokeCallback)
        return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
          return c;
        })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
          callback,
          escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
            userProvidedKeyEscapeRegex,
            "$&/"
          ) + "/") + invokeCallback
        )), array.push(callback)), 1;
      invokeCallback = 0;
      var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0; i < children.length; i++)
          nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if (i = getIteratorFn(children), "function" === typeof i)
        for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function(moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 1, payload._result = moduleObject;
          },
          function(error) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 2, payload._result = error;
          }
        );
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status) return payload._result.default;
      throw payload._result;
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    };
    function noop() {
    }
    exports.Children = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function() {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function(size) {
        return ReactSharedInternals.H.useMemoCache(size);
      }
    };
    exports.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    exports.cloneElement = function(element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " + element + "."
        );
      var props = assign({}, element.props), key = element.key, owner = void 0;
      if (null != config)
        for (propName in void 0 !== config.ref && (owner = void 0), void 0 !== config.key && (key = "" + config.key), config)
          !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        for (var childArray = Array(propName), i = 0; i < propName; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      return ReactElement(element.type, key, void 0, void 0, owner, props);
    };
    exports.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      return defaultValue;
    };
    exports.createElement = function(type, config, children) {
      var propName, props = {}, key = null;
      if (null != config)
        for (propName in void 0 !== config.key && (key = "" + config.key), config)
          hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) props.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          void 0 === props[propName] && (props[propName] = childrenLength[propName]);
      return ReactElement(type, key, void 0, void 0, null, props);
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(render) {
      return { $$typeof: REACT_FORWARD_REF_TYPE, render };
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    exports.memo = function(type, compare) {
      return {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: void 0 === compare ? null : compare
      };
    };
    exports.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        ReactSharedInternals.T = prevTransition;
      }
    };
    exports.unstable_useCacheRefresh = function() {
      return ReactSharedInternals.H.useCacheRefresh();
    };
    exports.use = function(usable) {
      return ReactSharedInternals.H.use(usable);
    };
    exports.useActionState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useActionState(action, initialState, permalink);
    };
    exports.useCallback = function(callback, deps) {
      return ReactSharedInternals.H.useCallback(callback, deps);
    };
    exports.useContext = function(Context) {
      return ReactSharedInternals.H.useContext(Context);
    };
    exports.useDebugValue = function() {
    };
    exports.useDeferredValue = function(value, initialValue) {
      return ReactSharedInternals.H.useDeferredValue(value, initialValue);
    };
    exports.useEffect = function(create, createDeps, update) {
      var dispatcher = ReactSharedInternals.H;
      if ("function" === typeof update)
        throw Error(
          "useEffect CRUD overload is not enabled in this build of React."
        );
      return dispatcher.useEffect(create, createDeps);
    };
    exports.useId = function() {
      return ReactSharedInternals.H.useId();
    };
    exports.useImperativeHandle = function(ref, create, deps) {
      return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function(create, deps) {
      return ReactSharedInternals.H.useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function(create, deps) {
      return ReactSharedInternals.H.useLayoutEffect(create, deps);
    };
    exports.useMemo = function(create, deps) {
      return ReactSharedInternals.H.useMemo(create, deps);
    };
    exports.useOptimistic = function(passthrough, reducer) {
      return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function(reducer, initialArg, init) {
      return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
    };
    exports.useRef = function(initialValue) {
      return ReactSharedInternals.H.useRef(initialValue);
    };
    exports.useState = function(initialState) {
      return ReactSharedInternals.H.useState(initialState);
    };
    exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return ReactSharedInternals.H.useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    exports.useTransition = function() {
      return ReactSharedInternals.H.useTransition();
    };
    exports.version = "19.1.1";
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports, module) {
    "use strict";
    init_esm_shims();
    "production" !== process.env.NODE_ENV && function() {
      function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              info[0],
              info[1]
            );
          }
        });
      }
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable)
          return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          callerName,
          publicInstance
        ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
      }
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      function ComponentDummy() {
      }
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name = getComponentNameFromType(type);
          return name ? "<" + name + ">" : "<...>";
        } catch (x) {
          return "<...>";
        }
      }
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config.key;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        newKey = ReactElement(
          oldElement.type,
          newKey,
          void 0,
          void 0,
          oldElement._owner,
          oldElement.props,
          oldElement._debugStack,
          oldElement._debugTask
        );
        oldElement._store && (newKey._store.validated = oldElement._store.validated);
        return newKey;
      }
      function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
      }
      function noop$1() {
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback) {
          invokeCallback = children;
          callback = callback(invokeCallback);
          var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
          isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + childKey
          ), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
          return 1;
        }
        invokeCallback = 0;
        childKey = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (i === children.entries && (didWarnAboutMaps || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status)
          return ctor = payload._result, void 0 === ctor && console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
            ctor
          ), "default" in ctor || console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
            ctor
          ), ctor.default;
        throw payload._result;
      }
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      function noop() {
      }
      function enqueueTask(task) {
        if (null === enqueueTaskImpl)
          try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            enqueueTaskImpl = (module && module[requireString]).call(
              module,
              "timers"
            ).setImmediate;
          } catch (_err) {
            enqueueTaskImpl = function(callback) {
              false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var channel = new MessageChannel();
              channel.port1.onmessage = callback;
              channel.port2.postMessage(void 0);
            };
          }
        return enqueueTaskImpl(task);
      }
      function aggregateErrors(errors) {
        return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
      }
      function popActScope(prevActQueue, prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        );
        actScopeDepth = prevActScopeDepth;
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        var queue = ReactSharedInternals.actQueue;
        if (null !== queue)
          if (0 !== queue.length)
            try {
              flushActQueue(queue);
              enqueueTask(function() {
                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
              });
              return;
            } catch (error) {
              ReactSharedInternals.thrownErrors.push(error);
            }
          else ReactSharedInternals.actQueue = null;
        0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
      }
      function flushActQueue(queue) {
        if (!isFlushing) {
          isFlushing = true;
          var i = 0;
          try {
            for (; i < queue.length; i++) {
              var callback = queue[i];
              do {
                ReactSharedInternals.didUsePromise = false;
                var continuation = callback(false);
                if (null !== continuation) {
                  if (ReactSharedInternals.didUsePromise) {
                    queue[i] = callback;
                    queue.splice(0, i);
                    return;
                  }
                  callback = continuation;
                } else break;
              } while (1);
            }
            queue.length = 0;
          } catch (error) {
            queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
          } finally {
            isFlushing = false;
          }
        }
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function(publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance) {
          warnNoop(publicInstance, "setState");
        }
      }, assign = Object.assign, emptyObject = {};
      Object.freeze(emptyObject);
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      var deprecatedAPIs = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      }, fnName;
      for (fnName in deprecatedAPIs)
        deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      ComponentDummy.prototype = Component.prototype;
      deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
      deprecatedAPIs.constructor = PureComponent;
      assign(deprecatedAPIs, Component.prototype);
      deprecatedAPIs.isPureReactComponent = true;
      var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null,
        actQueue: null,
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false,
        didUsePromise: false,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      deprecatedAPIs = {
        react_stack_bottom_frame: function(callStackForError) {
          return callStackForError();
        }
      };
      var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(
        deprecatedAPIs,
        UnknownOwner
      )();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
        queueMicrotask(function() {
          return queueMicrotask(callback);
        });
      } : enqueueTask;
      deprecatedAPIs = Object.freeze({
        __proto__: null,
        c: function(size) {
          return resolveDispatcher().useMemoCache(size);
        }
      });
      exports.Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports.__COMPILER_RUNTIME = deprecatedAPIs;
      exports.act = function(callback) {
        var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
        actScopeDepth++;
        var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
        try {
          var result = callback();
        } catch (error) {
          ReactSharedInternals.thrownErrors.push(error);
        }
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        if (null !== result && "object" === typeof result && "function" === typeof result.then) {
          var thenable = result;
          queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          });
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              thenable.then(
                function(returnValue) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  if (0 === prevActScopeDepth) {
                    try {
                      flushActQueue(queue), enqueueTask(function() {
                        return recursivelyFlushAsyncActWork(
                          returnValue,
                          resolve,
                          reject
                        );
                      });
                    } catch (error$0) {
                      ReactSharedInternals.thrownErrors.push(error$0);
                    }
                    if (0 < ReactSharedInternals.thrownErrors.length) {
                      var _thrownError = aggregateErrors(
                        ReactSharedInternals.thrownErrors
                      );
                      ReactSharedInternals.thrownErrors.length = 0;
                      reject(_thrownError);
                    }
                  } else resolve(returnValue);
                },
                function(error) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                    ReactSharedInternals.thrownErrors
                  ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                }
              );
            }
          };
        }
        var returnValue$jscomp$0 = result;
        popActScope(prevActQueue, prevActScopeDepth);
        0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), ReactSharedInternals.actQueue = null);
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        return {
          then: function(resolve, reject) {
            didAwaitActCall = true;
            0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
              return recursivelyFlushAsyncActWork(
                returnValue$jscomp$0,
                resolve,
                reject
              );
            })) : resolve(returnValue$jscomp$0);
          }
        };
      };
      exports.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      exports.captureOwnerStack = function() {
        var getCurrentStack = ReactSharedInternals.getCurrentStack;
        return null === getCurrentStack ? null : getCurrentStack();
      };
      exports.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key, owner = element._owner;
        if (null != config) {
          var JSCompiler_inline_result;
          a: {
            if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
              config,
              "ref"
            ).get) && JSCompiler_inline_result.isReactWarning) {
              JSCompiler_inline_result = false;
              break a;
            }
            JSCompiler_inline_result = void 0 !== config.ref;
          }
          JSCompiler_inline_result && (owner = getOwner());
          hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
          for (propName in config)
            !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        }
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          JSCompiler_inline_result = Array(propName);
          for (var i = 0; i < propName; i++)
            JSCompiler_inline_result[i] = arguments[i + 2];
          props.children = JSCompiler_inline_result;
        }
        props = ReactElement(
          element.type,
          key,
          void 0,
          void 0,
          owner,
          props,
          element._debugStack,
          element._debugTask
        );
        for (key = 2; key < arguments.length; key++)
          owner = arguments[key], isValidElement(owner) && owner._store && (owner._store.validated = 1);
        return props;
      };
      exports.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        defaultValue._currentRenderer = null;
        defaultValue._currentRenderer2 = null;
        return defaultValue;
      };
      exports.createElement = function(type, config, children) {
        for (var i = 2; i < arguments.length; i++) {
          var node = arguments[i];
          isValidElement(node) && node._store && (node._store.validated = 1);
        }
        i = {};
        node = null;
        if (null != config)
          for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), hasValidKey(config) && (checkKeyStringCoercion(config.key), node = "" + config.key), config)
            hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) i.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
            childArray[_i] = arguments[_i + 2];
          Object.freeze && Object.freeze(childArray);
          i.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === i[propName] && (i[propName] = childrenLength[propName]);
        node && defineKeyPropWarningGetter(
          i,
          "function" === typeof type ? type.displayName || type.name || "Unknown" : type
        );
        var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return ReactElement(
          type,
          node,
          void 0,
          void 0,
          getOwner(),
          i,
          propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
      exports.createRef = function() {
        var refObject = { current: null };
        Object.seal(refObject);
        return refObject;
      };
      exports.forwardRef = function(render) {
        null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : "function" !== typeof render ? console.error(
          "forwardRef requires a render function but was given %s.",
          null === render ? "null" : typeof render
        ) : 0 !== render.length && 2 !== render.length && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        );
        null != render && null != render.defaultProps && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
        Object.defineProperty(elementType, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name) {
            ownName = name;
            render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
          }
        });
        return elementType;
      };
      exports.isValidElement = isValidElement;
      exports.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports.memo = function(type, compare) {
        null == type && console.error(
          "memo: The first argument must be a component. Instead received: %s",
          null === type ? "null" : typeof type
        );
        compare = {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
        var ownName;
        Object.defineProperty(compare, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name) {
            ownName = name;
            type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
          }
        });
        return compare;
      };
      exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        currentTransition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function() {
        return resolveDispatcher().useCacheRefresh();
      };
      exports.use = function(usable) {
        return resolveDispatcher().use(usable);
      };
      exports.useActionState = function(action, initialState, permalink) {
        return resolveDispatcher().useActionState(
          action,
          initialState,
          permalink
        );
      };
      exports.useCallback = function(callback, deps) {
        return resolveDispatcher().useCallback(callback, deps);
      };
      exports.useContext = function(Context) {
        var dispatcher = resolveDispatcher();
        Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        );
        return dispatcher.useContext(Context);
      };
      exports.useDebugValue = function(value, formatterFn) {
        return resolveDispatcher().useDebugValue(value, formatterFn);
      };
      exports.useDeferredValue = function(value, initialValue) {
        return resolveDispatcher().useDeferredValue(value, initialValue);
      };
      exports.useEffect = function(create, createDeps, update) {
        null == create && console.warn(
          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        var dispatcher = resolveDispatcher();
        if ("function" === typeof update)
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return dispatcher.useEffect(create, createDeps);
      };
      exports.useId = function() {
        return resolveDispatcher().useId();
      };
      exports.useImperativeHandle = function(ref, create, deps) {
        return resolveDispatcher().useImperativeHandle(ref, create, deps);
      };
      exports.useInsertionEffect = function(create, deps) {
        null == create && console.warn(
          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useInsertionEffect(create, deps);
      };
      exports.useLayoutEffect = function(create, deps) {
        null == create && console.warn(
          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useLayoutEffect(create, deps);
      };
      exports.useMemo = function(create, deps) {
        return resolveDispatcher().useMemo(create, deps);
      };
      exports.useOptimistic = function(passthrough, reducer) {
        return resolveDispatcher().useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function(reducer, initialArg, init) {
        return resolveDispatcher().useReducer(reducer, initialArg, init);
      };
      exports.useRef = function(initialValue) {
        return resolveDispatcher().useRef(initialValue);
      };
      exports.useState = function(initialState) {
        return resolveDispatcher().useState(initialState);
      };
      exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return resolveDispatcher().useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function() {
        return resolveDispatcher().useTransition();
      };
      exports.version = "19.1.1";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    if (process.env.NODE_ENV === "production") {
      module.exports = require_react_production();
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/react/cjs/react-jsx-runtime.production.js
var require_react_jsx_runtime_production = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.production.js"(exports) {
    "use strict";
    init_esm_shims();
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    function jsxProd(type, config, maybeKey) {
      var key = null;
      void 0 !== maybeKey && (key = "" + maybeKey);
      void 0 !== config.key && (key = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      config = maybeKey.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== config ? config : null,
        props: maybeKey
      };
    }
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = jsxProd;
    exports.jsxs = jsxProd;
  }
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    init_esm_shims();
    "production" !== process.env.NODE_ENV && function() {
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name = getComponentNameFromType(type);
          return name ? "<" + name + ">" : "<...>";
        } catch (x) {
          return "<...>";
        }
      }
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config.key;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
      }
      function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children)
          if (isStaticChildren)
            if (isArrayImpl(children)) {
              for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                validateChildKeys(children[isStaticChildren]);
              Object.freeze && Object.freeze(children);
            } else
              console.error(
                "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
              );
          else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
          children = getComponentNameFromType(type);
          var keys = Object.keys(config).filter(function(k) {
            return "key" !== k;
          });
          isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
          didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
            isStaticChildren,
            children,
            keys,
            children
          ), didWarnAboutKeySpread[children + isStaticChildren] = true);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(
          maybeKey,
          "function" === typeof type ? type.displayName || type.name || "Unknown" : type
        );
        return ReactElement(
          type,
          children,
          self,
          source,
          getOwner(),
          maybeKey,
          debugStack,
          debugTask
        );
      }
      function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
      }
      var React4 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React4.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      React4 = {
        react_stack_bottom_frame: function(callStackForError) {
          return callStackForError();
        }
      };
      var specialPropKeyWarningShown;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = React4.react_stack_bottom_frame.bind(
        React4,
        UnknownOwner
      )();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutKeySpread = {};
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = function(type, config, maybeKey, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type,
          config,
          maybeKey,
          false,
          source,
          self,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
      exports.jsxs = function(type, config, maybeKey, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type,
          config,
          maybeKey,
          true,
          source,
          self,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
    }();
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    init_esm_shims();
    if (process.env.NODE_ENV === "production") {
      module.exports = require_react_jsx_runtime_production();
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// src/sync/network-manager-simple.ts
var network_manager_simple_exports = {};
__export(network_manager_simple_exports, {
  NetworkManager: () => NetworkManager
});
var DEFAULT_CONFIG16, getGlobal, globalScope, isBrowser, NetworkManager;
var init_network_manager_simple = __esm({
  "src/sync/network-manager-simple.ts"() {
    "use strict";
    init_esm_shims();
    init_eventemitter3();
    DEFAULT_CONFIG16 = {
      enableMonitoring: true,
      monitoringInterval: 5e3,
      qualityCheckInterval: 3e4,
      qualityThresholds: {
        excellent: { bandwidth: 10, latency: 50 },
        good: { bandwidth: 5, latency: 100 },
        fair: { bandwidth: 1, latency: 300 },
        poor: { bandwidth: 0.1, latency: 1e3 }
      },
      adaptiveOptimization: true,
      conserveDataOnMetered: true,
      pauseOnPoorConnection: false,
      maxRetryAttempts: 3,
      retryBackoffMultiplier: 2,
      maxRetryDelay: 3e4
    };
    getGlobal = () => {
      if (typeof globalThis !== "undefined") return globalThis;
      if (typeof window !== "undefined") return window;
      if (typeof global !== "undefined") return global;
      return {};
    };
    globalScope = getGlobal();
    isBrowser = typeof globalScope.window !== "undefined";
    NetworkManager = class extends import_index.default {
      config;
      currentConnection;
      monitoringTimer = null;
      qualityCheckTimer = null;
      isMonitoring = false;
      connectionHistory = [];
      lastQualityCheck = 0;
      constructor(config = {}) {
        super();
        this.config = { ...DEFAULT_CONFIG16, ...config };
        this.currentConnection = this.getInitialConnectionInfo();
      }
      /**
       * Initialize the network manager
       */
      async initialize() {
        this.startMonitoring();
      }
      /**
       * Add connection change listener
       */
      onConnectionChange(listener) {
        this.on("connection-changed", listener);
      }
      /**
       * Start network monitoring
       */
      startMonitoring() {
        if (this.isMonitoring) {
          return;
        }
        this.isMonitoring = true;
        this.monitoringTimer = setInterval(() => {
          this.checkConnection();
        }, this.config.monitoringInterval);
        this.qualityCheckTimer = setInterval(() => {
          this.performQualityCheck();
        }, this.config.qualityCheckInterval);
        if (isBrowser && globalScope.window) {
          this.setupOnlineOfflineListeners();
        }
        this.checkConnection();
      }
      /**
       * Stop network monitoring
       */
      stopMonitoring() {
        if (!this.isMonitoring) {
          return;
        }
        this.isMonitoring = false;
        if (this.monitoringTimer !== null) {
          clearInterval(this.monitoringTimer);
          this.monitoringTimer = null;
        }
        if (this.qualityCheckTimer !== null) {
          clearInterval(this.qualityCheckTimer);
          this.qualityCheckTimer = null;
        }
        this.removeOnlineOfflineListeners();
      }
      /**
       * Get current connection information
       */
      getConnectionInfo() {
        return { ...this.currentConnection };
      }
      /**
       * Check if the connection is suitable for sync operations
       */
      isSyncRecommended(syncType = "medium") {
        const { quality, isOnline, isMetered } = this.currentConnection;
        if (!isOnline) {
          return false;
        }
        if (isMetered && this.config.conserveDataOnMetered) {
          return syncType === "light" && ["excellent", "good"].includes(quality);
        }
        switch (syncType) {
          case "light":
            return ["excellent", "good", "fair"].includes(quality);
          case "medium":
            return ["excellent", "good"].includes(quality);
          case "heavy":
            return quality === "excellent";
          default:
            return false;
        }
      }
      /**
       * Optimize sync options based on current network conditions
       */
      optimizeForConnection(options) {
        const optimization = this.calculateOptimization();
        const optimizedOptions = {
          ...options,
          networkOptimization: optimization
        };
        if (optimization.batchSize !== options.batchSize) {
          optimizedOptions.batchSize = optimization.batchSize;
        }
        if (optimization.timeoutMs !== options.timeoutMs) {
          optimizedOptions.timeoutMs = optimization.timeoutMs;
        }
        if (this.currentConnection.quality === "poor" && this.config.pauseOnPoorConnection) {
          optimizedOptions.strategy = "scheduled";
        } else if (this.currentConnection.quality === "fair") {
          optimizedOptions.strategy = "batched";
        }
        this.emit("optimization-applied", optimization);
        return optimizedOptions;
      }
      /**
       * Calculate appropriate retry delay based on network conditions
       */
      calculateRetryDelay(attempt, baseDelay = 1e3) {
        const { quality } = this.currentConnection;
        let delay = baseDelay * Math.pow(this.config.retryBackoffMultiplier, attempt - 1);
        switch (quality) {
          case "poor":
            delay *= 3;
            break;
          case "fair":
            delay *= 1.5;
            break;
          case "good":
            delay *= 1;
            break;
          case "excellent":
            delay *= 0.5;
            break;
        }
        return Math.min(delay, this.config.maxRetryDelay);
      }
      /**
       * Get connection quality metrics over time
       */
      getConnectionMetrics() {
        const history = this.connectionHistory.slice(-20);
        if (history.length === 0) {
          return {
            current: this.currentConnection,
            average: {
              bandwidth: this.currentConnection.bandwidth,
              latency: this.currentConnection.latency,
              quality: this.currentConnection.quality
            },
            stability: 1,
            history: []
          };
        }
        const avgBandwidth = history.reduce((sum, conn) => sum + conn.bandwidth, 0) / history.length;
        const avgLatency = history.reduce((sum, conn) => sum + conn.latency, 0) / history.length;
        const avgQuality = this.calculateQualityFromMetrics(avgBandwidth, avgLatency);
        const qualityChanges = history.slice(1).reduce((changes, conn, index) => {
          return changes + (conn.quality !== history[index]?.quality ? 1 : 0);
        }, 0);
        const stability = Math.max(0, 1 - qualityChanges / history.length);
        return {
          current: this.currentConnection,
          average: {
            bandwidth: avgBandwidth,
            latency: avgLatency,
            quality: avgQuality
          },
          stability,
          history: [...history]
        };
      }
      getInitialConnectionInfo() {
        const isOnline = isBrowser && globalScope.navigator ? globalScope.navigator.onLine : true;
        return {
          type: this.detectConnectionType(),
          quality: isOnline ? "good" : "offline",
          bandwidth: 5,
          // Default 5 Mbps
          latency: 100,
          // Default 100ms
          isMetered: false,
          // Default to non-metered
          isOnline,
          lastChanged: /* @__PURE__ */ new Date()
        };
      }
      detectConnectionType() {
        return "wifi";
      }
      setupOnlineOfflineListeners() {
        if (!isBrowser || !globalScope.window) {
          return;
        }
        const handleOnline = () => {
          this.updateConnectionStatus(true);
        };
        const handleOffline = () => {
          this.updateConnectionStatus(false);
        };
        globalScope.window.addEventListener("online", handleOnline);
        globalScope.window.addEventListener("offline", handleOffline);
        this.onlineHandler = handleOnline;
        this.offlineHandler = handleOffline;
      }
      onlineHandler;
      offlineHandler;
      removeOnlineOfflineListeners() {
        if (!isBrowser || !globalScope.window) {
          return;
        }
        if (this.onlineHandler) {
          globalScope.window.removeEventListener("online", this.onlineHandler);
        }
        if (this.offlineHandler) {
          globalScope.window.removeEventListener("offline", this.offlineHandler);
        }
      }
      async checkConnection() {
        const isOnline = isBrowser && globalScope.navigator ? globalScope.navigator.onLine : true;
        const type = this.detectConnectionType();
        const isMetered = false;
        let bandwidth = this.currentConnection.bandwidth;
        let latency = this.currentConnection.latency;
        if (isOnline && Date.now() - this.lastQualityCheck > this.config.qualityCheckInterval) {
          try {
            const qualityMeasurement = await this.measureConnectionQuality();
            bandwidth = qualityMeasurement.bandwidth;
            latency = qualityMeasurement.latency;
            this.lastQualityCheck = Date.now();
          } catch (error) {
          }
        }
        const quality = isOnline ? this.calculateQualityFromMetrics(bandwidth, latency) : "offline";
        const newConnection = {
          type,
          quality,
          bandwidth,
          latency,
          isMetered,
          isOnline,
          lastChanged: /* @__PURE__ */ new Date()
        };
        this.updateConnection(newConnection);
      }
      async measureConnectionQuality() {
        if (!isBrowser || !globalScope.fetch || !globalScope.performance) {
          return {
            bandwidth: this.currentConnection.bandwidth,
            latency: this.currentConnection.latency
          };
        }
        const startTime = globalScope.performance.now();
        try {
          await globalScope.fetch("data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", {
            method: "GET"
          });
          const endTime = globalScope.performance.now();
          const latency = endTime - startTime;
          const bandwidth = this.currentConnection.bandwidth;
          return { bandwidth, latency };
        } catch (error) {
          return {
            bandwidth: this.currentConnection.bandwidth,
            latency: this.currentConnection.latency
          };
        }
      }
      calculateQualityFromMetrics(bandwidth, latency) {
        const { qualityThresholds } = this.config;
        if (bandwidth >= qualityThresholds.excellent.bandwidth && latency <= qualityThresholds.excellent.latency) {
          return "excellent";
        } else if (bandwidth >= qualityThresholds.good.bandwidth && latency <= qualityThresholds.good.latency) {
          return "good";
        } else if (bandwidth >= qualityThresholds.fair.bandwidth && latency <= qualityThresholds.fair.latency) {
          return "fair";
        } else {
          return "poor";
        }
      }
      updateConnection(newConnection) {
        const previousConnection = this.currentConnection;
        const hasChanged = previousConnection.type !== newConnection.type || previousConnection.quality !== newConnection.quality || previousConnection.isOnline !== newConnection.isOnline || Math.abs(previousConnection.bandwidth - newConnection.bandwidth) > 1 || Math.abs(previousConnection.latency - newConnection.latency) > 50;
        if (hasChanged) {
          this.currentConnection = newConnection;
          this.connectionHistory.push(newConnection);
          if (this.connectionHistory.length > 100) {
            this.connectionHistory.shift();
          }
          this.emit("connection-changed", newConnection);
          if (previousConnection.quality !== newConnection.quality) {
            this.emit("quality-changed", {
              previous: previousConnection.quality,
              current: newConnection.quality
            });
          }
          if (newConnection.quality === "poor" && previousConnection.quality !== "poor") {
            this.emit("poor-connection-detected", newConnection);
          } else if (newConnection.quality !== "poor" && previousConnection.quality === "poor") {
            this.emit("connection-restored", newConnection);
          }
        }
      }
      updateConnectionStatus(isOnline) {
        if (this.currentConnection.isOnline !== isOnline) {
          this.currentConnection = {
            ...this.currentConnection,
            isOnline,
            quality: isOnline ? this.currentConnection.quality : "offline",
            lastChanged: /* @__PURE__ */ new Date()
          };
          this.emit("connection-changed", this.currentConnection);
        }
      }
      calculateOptimization() {
        const { quality, isMetered } = this.currentConnection;
        let optimization = {
          enableCompression: true,
          batchSize: 50,
          maxConcurrentRequests: 3,
          timeoutMs: 3e4,
          retryStrategy: "exponential",
          prioritizeOperations: false
        };
        switch (quality) {
          case "excellent":
            optimization = {
              enableCompression: false,
              batchSize: 100,
              maxConcurrentRequests: 5,
              timeoutMs: 15e3,
              retryStrategy: "linear",
              prioritizeOperations: false
            };
            break;
          case "good":
            optimization = {
              enableCompression: true,
              batchSize: 75,
              maxConcurrentRequests: 3,
              timeoutMs: 2e4,
              retryStrategy: "exponential",
              prioritizeOperations: false
            };
            break;
          case "fair":
            optimization = {
              enableCompression: true,
              batchSize: 25,
              maxConcurrentRequests: 2,
              timeoutMs: 45e3,
              retryStrategy: "exponential",
              prioritizeOperations: true
            };
            break;
          case "poor":
            optimization = {
              enableCompression: true,
              batchSize: 10,
              maxConcurrentRequests: 1,
              timeoutMs: 6e4,
              retryStrategy: "adaptive",
              prioritizeOperations: true
            };
            break;
        }
        if (isMetered && this.config.conserveDataOnMetered) {
          optimization.enableCompression = true;
          optimization.batchSize = Math.min(optimization.batchSize, 20);
          optimization.maxConcurrentRequests = Math.min(optimization.maxConcurrentRequests, 2);
          optimization.prioritizeOperations = true;
        }
        return optimization;
      }
      async performQualityCheck() {
        if (!this.currentConnection.isOnline) {
          return;
        }
        try {
          const measurement = await this.measureConnectionQuality();
          const quality = this.calculateQualityFromMetrics(measurement.bandwidth, measurement.latency);
          if (quality !== this.currentConnection.quality) {
            this.updateConnection({
              ...this.currentConnection,
              bandwidth: measurement.bandwidth,
              latency: measurement.latency,
              quality,
              lastChanged: /* @__PURE__ */ new Date()
            });
          }
        } catch (error) {
          if (this.currentConnection.quality !== "poor") {
            this.updateConnection({
              ...this.currentConnection,
              quality: "poor",
              lastChanged: /* @__PURE__ */ new Date()
            });
          }
        }
      }
      /**
       * Cleanup resources
       */
      destroy() {
        this.stopMonitoring();
        this.removeAllListeners();
        this.connectionHistory.length = 0;
      }
    };
  }
});

// src/index.ts
init_esm_shims();

// src/core/sdk.ts
init_esm_shims();
init_eventemitter3();

// src/http/client.ts
init_esm_shims();
init_eventemitter3();

// src/http/circuit-breaker.ts
init_esm_shims();
init_errors();
var CircuitBreaker = class {
  constructor(config) {
    this.config = config;
    if (config.healthCheckInterval) {
      this.startHealthCheck();
    }
  }
  state = "CLOSED";
  metrics = {
    totalRequests: 0,
    successfulRequests: 0,
    failedRequests: 0,
    consecutiveFailures: 0,
    consecutiveSuccesses: 0,
    lastFailureTime: null,
    lastSuccessTime: null,
    stateChanges: []
  };
  nextAttemptTime = 0;
  healthCheckTimer = null;
  async execute(operation, operationName = "unknown") {
    if (this.shouldRejectRequest()) {
      throw new CircuitBreakerError(
        `Circuit breaker is ${this.state} for operation: ${operationName}`,
        operationName,
        this.state
      );
    }
    this.metrics.totalRequests++;
    try {
      const result = await this.executeWithTimeout(operation);
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  async executeWithTimeout(operation) {
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Operation timeout after ${this.config.timeout}ms`));
      }, this.config.timeout);
    });
    return Promise.race([operation(), timeoutPromise]);
  }
  shouldRejectRequest() {
    switch (this.state) {
      case "CLOSED":
        return false;
      case "OPEN":
        return Date.now() < this.nextAttemptTime;
      case "HALF_OPEN":
        return false;
      default:
        return false;
    }
  }
  onSuccess() {
    this.metrics.successfulRequests++;
    this.metrics.consecutiveSuccesses++;
    this.metrics.consecutiveFailures = 0;
    this.metrics.lastSuccessTime = Date.now();
    switch (this.state) {
      case "HALF_OPEN":
        if (this.metrics.consecutiveSuccesses >= this.config.successThreshold) {
          this.transitionTo("CLOSED", "Success threshold reached");
        }
        break;
      case "OPEN":
        this.transitionTo("HALF_OPEN", "First success after opening");
        break;
    }
  }
  onFailure() {
    this.metrics.failedRequests++;
    this.metrics.consecutiveFailures++;
    this.metrics.consecutiveSuccesses = 0;
    this.metrics.lastFailureTime = Date.now();
    switch (this.state) {
      case "CLOSED":
        if (this.metrics.consecutiveFailures >= this.config.failureThreshold) {
          this.transitionTo("OPEN", "Failure threshold reached");
        }
        break;
      case "HALF_OPEN":
        this.transitionTo("OPEN", "Failed during half-open state");
        break;
    }
  }
  transitionTo(newState, reason) {
    const oldState = this.state;
    this.state = newState;
    this.metrics.stateChanges.push({
      from: oldState,
      to: newState,
      timestamp: Date.now(),
      reason
    });
    if (this.metrics.stateChanges.length > 100) {
      this.metrics.stateChanges.shift();
    }
    if (newState === "OPEN") {
      this.nextAttemptTime = Date.now() + this.config.resetTimeout;
    }
    console.log(`Circuit breaker ${this.config.name || "unnamed"} transitioned from ${oldState} to ${newState}: ${reason}`);
  }
  startHealthCheck() {
    if (this.config.healthCheckInterval) {
      this.healthCheckTimer = setInterval(() => {
        this.performHealthCheck();
      }, this.config.healthCheckInterval);
    }
  }
  performHealthCheck() {
    if (this.state === "OPEN" && Date.now() >= this.nextAttemptTime) {
      this.transitionTo("HALF_OPEN", "Health check triggered state change");
    }
  }
  getState() {
    return this.state;
  }
  getMetrics() {
    return { ...this.metrics };
  }
  reset() {
    this.state = "CLOSED";
    this.metrics = {
      totalRequests: 0,
      successfulRequests: 0,
      failedRequests: 0,
      consecutiveFailures: 0,
      consecutiveSuccesses: 0,
      lastFailureTime: null,
      lastSuccessTime: null,
      stateChanges: []
    };
    this.nextAttemptTime = 0;
  }
  destroy() {
    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
      this.healthCheckTimer = null;
    }
  }
  getHealthStatus() {
    const now = Date.now();
    const uptime = this.metrics.lastSuccessTime ? now - this.metrics.lastSuccessTime : 0;
    const failureRate = this.metrics.totalRequests > 0 ? this.metrics.failedRequests / this.metrics.totalRequests : 0;
    return {
      isHealthy: this.state === "CLOSED" && failureRate < 0.5,
      failureRate,
      uptime
    };
  }
};

// src/http/retry.ts
init_esm_shims();
init_errors();
var RetryHandler = class {
  constructor(config) {
    this.config = config;
  }
  metrics = {
    totalAttempts: 0,
    successfulRetries: 0,
    failedRetries: 0,
    averageDelay: 0,
    attempts: []
  };
  async execute(operation, operationName = "unknown") {
    let lastError = null;
    let nextDelay = this.config.baseDelay;
    for (let attempt = 1; attempt <= this.config.maxAttempts; attempt++) {
      this.metrics.totalAttempts++;
      try {
        const result = await this.executeWithTimeout(operation);
        if (attempt > 1) {
          this.metrics.successfulRetries++;
        }
        return result;
      } catch (error) {
        lastError = error;
        const retryAttempt = {
          attempt,
          delay: nextDelay,
          error: lastError,
          timestamp: Date.now()
        };
        this.metrics.attempts.push(retryAttempt);
        if (this.metrics.attempts.length > 100) {
          this.metrics.attempts.shift();
        }
        if (attempt === this.config.maxAttempts || !this.shouldRetry(lastError)) {
          this.metrics.failedRetries++;
          break;
        }
        const delay = this.calculateDelay(attempt, nextDelay);
        console.log(
          `Retrying ${operationName} (attempt ${attempt}/${this.config.maxAttempts}) after ${delay}ms delay. Error: ${lastError.message}`
        );
        await this.sleep(delay);
        nextDelay = Math.min(
          nextDelay * this.config.backoffMultiplier,
          this.config.maxDelay
        );
      }
    }
    throw lastError || new Error("Unknown error during retry execution");
  }
  async executeWithTimeout(operation) {
    if (!this.config.timeout) {
      return operation();
    }
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Operation timeout after ${this.config.timeout}ms`));
      }, this.config.timeout);
    });
    return Promise.race([operation(), timeoutPromise]);
  }
  shouldRetry(error) {
    if (error instanceof ACubeSDKError) {
      return error.retryable;
    }
    const statusCode = this.extractStatusCode(error);
    if (statusCode && this.config.retryableStatusCodes.includes(statusCode)) {
      return true;
    }
    const errorCode = this.extractErrorCode(error);
    if (errorCode && this.config.retryableErrors.includes(errorCode)) {
      return true;
    }
    if (this.isNetworkError(error)) {
      return true;
    }
    return false;
  }
  calculateDelay(_attempt, baseDelay) {
    switch (this.config.jitterType) {
      case "none":
        return baseDelay;
      case "full":
        return Math.random() * baseDelay;
      case "equal":
        return baseDelay / 2 + Math.random() * (baseDelay / 2);
      case "decorrelated":
        return Math.random() * (Math.min(this.config.maxDelay, baseDelay * 3) - this.config.baseDelay) + this.config.baseDelay;
      default:
        return baseDelay;
    }
  }
  extractStatusCode(error) {
    const err = error;
    return err.statusCode || err.status || err.response?.status || null;
  }
  extractErrorCode(error) {
    const err = error;
    return err.code || err.errno || error.name || null;
  }
  isNetworkError(error) {
    const networkErrorCodes = [
      "ECONNRESET",
      "ECONNREFUSED",
      "ETIMEDOUT",
      "ENOTFOUND",
      "ENETUNREACH",
      "EAI_AGAIN",
      "ECONNABORTED"
    ];
    const errorCode = this.extractErrorCode(error);
    return errorCode ? networkErrorCodes.includes(errorCode) : false;
  }
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  getMetrics() {
    const totalDelay = this.metrics.attempts.reduce((sum, attempt) => sum + attempt.delay, 0);
    return {
      ...this.metrics,
      averageDelay: this.metrics.attempts.length > 0 ? totalDelay / this.metrics.attempts.length : 0
    };
  }
  reset() {
    this.metrics = {
      totalAttempts: 0,
      successfulRetries: 0,
      failedRetries: 0,
      averageDelay: 0,
      attempts: []
    };
  }
};
var DEFAULT_RETRY_CONFIG = {
  maxAttempts: 3,
  baseDelay: 1e3,
  maxDelay: 3e4,
  backoffMultiplier: 2,
  jitterType: "equal",
  retryableStatusCodes: [500, 502, 503, 504, 429],
  retryableErrors: [
    "ECONNRESET",
    "ECONNREFUSED",
    "ETIMEDOUT",
    "ENOTFOUND",
    "ENETUNREACH",
    "NETWORK_ERROR",
    "RATE_LIMIT_ERROR"
  ],
  timeout: 3e4
};
var AGGRESSIVE_RETRY_CONFIG = {
  maxAttempts: 5,
  baseDelay: 500,
  maxDelay: 6e4,
  backoffMultiplier: 2.5,
  jitterType: "decorrelated",
  retryableStatusCodes: [500, 502, 503, 504, 429, 408],
  retryableErrors: [
    "ECONNRESET",
    "ECONNREFUSED",
    "ETIMEDOUT",
    "ENOTFOUND",
    "ENETUNREACH",
    "NETWORK_ERROR",
    "RATE_LIMIT_ERROR",
    "CIRCUIT_BREAKER_ERROR"
  ],
  timeout: 45e3
};
var CONSERVATIVE_RETRY_CONFIG = {
  maxAttempts: 2,
  baseDelay: 2e3,
  maxDelay: 1e4,
  backoffMultiplier: 1.5,
  jitterType: "full",
  retryableStatusCodes: [500, 502, 503, 504],
  retryableErrors: ["NETWORK_ERROR"],
  timeout: 15e3
};

// src/http/middleware.ts
init_esm_shims();
var MiddlewareStack = class {
  middlewares = [];
  add(middleware) {
    this.middlewares.push(middleware);
    this.middlewares.sort((a, b) => b.priority - a.priority);
    return this;
  }
  remove(name) {
    this.middlewares = this.middlewares.filter((m) => m.name !== name);
    return this;
  }
  async executeBeforeRequest(context) {
    let currentContext = context;
    for (const middleware of this.middlewares) {
      if (middleware.beforeRequest) {
        try {
          currentContext = await middleware.beforeRequest(currentContext);
        } catch (error) {
          console.warn(`Middleware ${middleware.name} failed in beforeRequest:`, error);
        }
      }
    }
    return currentContext;
  }
  async executeAfterResponse(context, response) {
    let currentResponse = response;
    for (const middleware of [...this.middlewares].reverse()) {
      if (middleware.afterResponse) {
        try {
          currentResponse = await middleware.afterResponse(context, currentResponse);
        } catch (error) {
          console.warn(`Middleware ${middleware.name} failed in afterResponse:`, error);
        }
      }
    }
    return currentResponse;
  }
  async executeOnError(context, error) {
    let currentError = error;
    for (const middleware of this.middlewares) {
      if (middleware.onError) {
        try {
          const result = await middleware.onError(context, currentError);
          if (result instanceof Error) {
            currentError = result;
          }
        } catch (middlewareError) {
          console.warn(`Middleware ${middleware.name} failed in onError:`, middlewareError);
        }
      }
    }
    return currentError;
  }
  getMiddlewares() {
    return [...this.middlewares];
  }
  clear() {
    this.middlewares = [];
    return this;
  }
};
var AuthenticationMiddleware = class {
  constructor(getToken) {
    this.getToken = getToken;
  }
  name = "authentication";
  priority = 100;
  async beforeRequest(context) {
    const token = await this.getToken();
    if (token) {
      context.headers.Authorization = `Bearer ${token}`;
    }
    return context;
  }
};
var RequestIdMiddleware = class {
  name = "request-id";
  priority = 90;
  beforeRequest(context) {
    if (!context.headers["X-Request-ID"]) {
      context.headers["X-Request-ID"] = context.requestId;
    }
    return context;
  }
};
var UserAgentMiddleware = class {
  constructor(userAgent) {
    this.userAgent = userAgent;
  }
  name = "user-agent";
  priority = 80;
  beforeRequest(context) {
    if (!context.headers["User-Agent"]) {
      context.headers["User-Agent"] = this.userAgent;
    }
    return context;
  }
};
var ContentTypeMiddleware = class {
  name = "content-type";
  priority = 70;
  beforeRequest(context) {
    if (context.body && !context.headers["Content-Type"]) {
      context.headers["Content-Type"] = "application/json";
    }
    return context;
  }
};
var LoggingMiddleware = class {
  constructor(logger, options = {
    logRequests: true,
    logResponses: true,
    logHeaders: false,
    logBody: false,
    sanitizeHeaders: ["authorization", "cookie", "x-api-key"]
  }) {
    this.logger = logger;
    this.options = options;
  }
  name = "logging";
  priority = 10;
  beforeRequest(context) {
    if (this.options.logRequests) {
      const logData = {
        requestId: context.requestId,
        method: context.method,
        url: context.url
      };
      if (this.options.logHeaders) {
        logData.headers = this.sanitizeHeaders(context.headers);
      }
      if (this.options.logBody && context.body) {
        logData.body = this.sanitizeBody(context.body);
      }
      this.logger.debug("HTTP Request", logData);
    }
    return context;
  }
  afterResponse(context, response) {
    if (this.options.logResponses) {
      const logData = {
        requestId: context.requestId,
        status: response.status,
        statusText: response.statusText,
        duration: response.duration
      };
      if (this.options.logHeaders) {
        logData.headers = this.sanitizeHeaders(response.headers);
      }
      if (this.options.logBody && response.data) {
        logData.body = this.sanitizeBody(response.data);
      }
      const logLevel = response.status >= 400 ? "error" : "debug";
      this.logger[logLevel]("HTTP Response", logData);
    }
    return response;
  }
  onError(context, error) {
    this.logger.error("HTTP Error", {
      requestId: context.requestId,
      method: context.method,
      url: context.url,
      error: error.message,
      stack: error.stack
    });
    return error;
  }
  sanitizeHeaders(headers) {
    const sanitized = { ...headers };
    this.options.sanitizeHeaders?.forEach((header) => {
      const key = Object.keys(sanitized).find(
        (k) => k.toLowerCase() === header.toLowerCase()
      );
      if (key) {
        sanitized[key] = "[REDACTED]";
      }
    });
    return sanitized;
  }
  sanitizeBody(body) {
    if (typeof body !== "object" || body === null) {
      return body;
    }
    const sensitiveFields = ["password", "token", "secret", "key", "auth"];
    const sanitized = { ...body };
    Object.keys(sanitized).forEach((key) => {
      if (sensitiveFields.some((field) => key.toLowerCase().includes(field))) {
        sanitized[key] = "[REDACTED]";
      }
    });
    return sanitized;
  }
};
var RateLimitingMiddleware = class {
  constructor(config) {
    this.config = config;
  }
  name = "rate-limiting";
  priority = 50;
  requests = /* @__PURE__ */ new Map();
  async beforeRequest(context) {
    const key = this.config.keyGenerator?.(context) || "default";
    const now = Date.now();
    const windowStart = now - 6e4;
    const requests = this.requests.get(key) || [];
    const recentRequests = requests.filter((time) => time > windowStart);
    if (recentRequests.length >= this.config.requestsPerMinute) {
      throw new Error(`Rate limit exceeded: ${this.config.requestsPerMinute} requests per minute`);
    }
    recentRequests.push(now);
    this.requests.set(key, recentRequests);
    return context;
  }
};
var PerformanceMiddleware = class {
  name = "performance";
  priority = 5;
  metrics = /* @__PURE__ */ new Map();
  afterResponse(context, response) {
    const endpoint = `${context.method} ${context.url}`;
    const duration = response.duration;
    const existing = this.metrics.get(endpoint) || {
      count: 0,
      totalDuration: 0,
      minDuration: Infinity,
      maxDuration: 0
    };
    this.metrics.set(endpoint, {
      count: existing.count + 1,
      totalDuration: existing.totalDuration + duration,
      minDuration: Math.min(existing.minDuration, duration),
      maxDuration: Math.max(existing.maxDuration, duration)
    });
    return response;
  }
  getMetrics() {
    const result = {};
    this.metrics.forEach((value, key) => {
      result[key] = {
        count: value.count,
        averageDuration: value.totalDuration / value.count,
        minDuration: value.minDuration === Infinity ? 0 : value.minDuration,
        maxDuration: value.maxDuration
      };
    });
    return result;
  }
  reset() {
    this.metrics.clear();
  }
};

// src/http/client.ts
init_errors();
var HttpClient = class extends import_index.default {
  constructor(config) {
    super();
    this.config = config;
    this.middlewareStack = new MiddlewareStack();
    this.circuitBreaker = new CircuitBreaker(config.circuitBreakerConfig);
    this.retryHandler = new RetryHandler(config.retryConfig);
    this.setupDefaultMiddlewares();
  }
  middlewareStack;
  circuitBreaker;
  retryHandler;
  requestCounter = 0;
  setupDefaultMiddlewares() {
    if (this.config.getAuthToken) {
      this.middlewareStack.add(new AuthenticationMiddleware(this.config.getAuthToken));
    }
    this.middlewareStack.add(new RequestIdMiddleware());
    this.middlewareStack.add(new UserAgentMiddleware(this.config.userAgent));
    this.middlewareStack.add(new ContentTypeMiddleware());
    if (this.config.enableLogging) {
      this.middlewareStack.add(new LoggingMiddleware(
        {
          debug: (msg, meta) => this.emit("debug", msg, meta),
          warn: (msg, meta) => this.emit("warn", msg, meta),
          error: (msg, meta) => this.emit("error", msg, meta)
        },
        {
          logRequests: true,
          logResponses: true,
          logHeaders: false,
          logBody: false
        }
      ));
    }
  }
  async request(options) {
    const requestId = this.generateRequestId();
    const startTime = Date.now();
    const context = {
      url: this.buildUrl(options.url, options.params),
      method: options.method,
      headers: {
        ...this.config.headers,
        ...options.headers
      },
      body: options.data,
      metadata: options.metadata || {},
      startTime,
      requestId
    };
    const executeRequest = async () => {
      try {
        const processedContext = await this.middlewareStack.executeBeforeRequest(context);
        const response = await this.makeHttpRequest(processedContext, options.timeout);
        const processedResponse = await this.middlewareStack.executeAfterResponse(
          processedContext,
          response
        );
        return {
          data: processedResponse.data,
          status: processedResponse.status,
          statusText: processedResponse.statusText,
          headers: processedResponse.headers,
          requestId,
          duration: processedResponse.duration
        };
      } catch (error) {
        const processedError = await this.middlewareStack.executeOnError(
          context,
          error
        );
        throw processedError;
      }
    };
    try {
      if (this.config.enableCircuitBreaker && !options.skipCircuitBreaker) {
        if (this.config.enableRetry && !options.skipRetry) {
          return await this.circuitBreaker.execute(
            () => this.retryHandler.execute(() => executeRequest(), `${options.method} ${options.url}`),
            `${options.method} ${options.url}`
          );
        } else {
          return await this.circuitBreaker.execute(
            executeRequest,
            `${options.method} ${options.url}`
          );
        }
      } else if (this.config.enableRetry && !options.skipRetry) {
        return await this.retryHandler.execute(
          executeRequest,
          `${options.method} ${options.url}`
        );
      } else {
        return await executeRequest();
      }
    } catch (error) {
      this.emit("requestError", {
        requestId,
        method: options.method,
        url: options.url,
        error: error instanceof Error ? error.message : "Unknown error",
        duration: Date.now() - startTime
      });
      throw error;
    }
  }
  async makeHttpRequest(context, timeoutOverride) {
    const timeout = timeoutOverride || this.config.timeout;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    try {
      const fetchOptions = {
        method: context.method,
        headers: context.headers,
        signal: controller.signal
      };
      if (context.body && context.method !== "GET") {
        fetchOptions.body = typeof context.body === "string" ? context.body : JSON.stringify(context.body);
      }
      const response = await fetch(context.url, fetchOptions);
      clearTimeout(timeoutId);
      const endTime = Date.now();
      const duration = endTime - context.startTime;
      let data;
      const contentType = response.headers.get("content-type") || "";
      if (contentType.includes("application/json")) {
        data = await response.json();
      } else if (contentType.includes("application/pdf")) {
        data = await response.blob();
      } else if (contentType.includes("text/")) {
        data = await response.text();
      } else {
        data = await response.arrayBuffer();
      }
      const headers = {};
      response.headers.forEach((value, key) => {
        headers[key] = value;
      });
      const responseContext = {
        status: response.status,
        statusText: response.statusText,
        headers,
        data,
        metadata: {},
        endTime,
        duration
      };
      if (!response.ok) {
        const error = createErrorFromResponse(
          {
            status: response.status,
            statusText: response.statusText,
            data
          },
          `${context.method} ${context.url}`,
          context.requestId
        );
        throw error;
      }
      this.emit("requestSuccess", {
        requestId: context.requestId,
        method: context.method,
        url: context.url,
        status: response.status,
        duration
      });
      return responseContext;
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof ACubeSDKError) {
        throw error;
      }
      if (error instanceof Error) {
        if (error.name === "AbortError") {
          throw createErrorFromResponse(
            {
              status: 408,
              statusText: "Request Timeout",
              data: { message: "Request timeout" }
            },
            `${context.method} ${context.url}`,
            context.requestId
          );
        }
        throw createErrorFromResponse(
          {
            status: 0,
            statusText: "Network Error",
            data: { message: error.message }
          },
          `${context.method} ${context.url}`,
          context.requestId
        );
      }
      throw error;
    }
  }
  buildUrl(path2, params) {
    const url = new URL(path2, this.config.baseUrl);
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== void 0 && value !== null) {
          url.searchParams.append(key, String(value));
        }
      });
    }
    return url.toString();
  }
  generateRequestId() {
    return `req_${Date.now()}_${++this.requestCounter}_${Math.random().toString(36).substring(2, 8)}`;
  }
  // Convenience methods
  async get(url, options = {}) {
    return this.request({ ...options, method: "GET", url });
  }
  async post(url, data, options = {}) {
    return this.request({ ...options, method: "POST", url, data });
  }
  async put(url, data, options = {}) {
    return this.request({ ...options, method: "PUT", url, data });
  }
  async delete(url, options = {}) {
    return this.request({ ...options, method: "DELETE", url });
  }
  async patch(url, data, options = {}) {
    return this.request({ ...options, method: "PATCH", url, data });
  }
  // Middleware management
  addMiddleware(middleware) {
    this.middlewareStack.add(middleware);
    return this;
  }
  removeMiddleware(name) {
    this.middlewareStack.remove(name);
    return this;
  }
  // Health and metrics
  getCircuitBreakerMetrics() {
    return this.circuitBreaker.getMetrics();
  }
  getRetryMetrics() {
    return this.retryHandler.getMetrics();
  }
  getMetrics() {
    const circuitBreakerMetrics = this.circuitBreaker.getMetrics();
    const retryMetrics = this.retryHandler.getMetrics();
    return {
      requestCount: circuitBreakerMetrics.totalRequests,
      successCount: circuitBreakerMetrics.successfulRequests,
      errorCount: circuitBreakerMetrics.failedRequests,
      totalDuration: 0,
      // Would need to track this separately
      averageResponseTime: 0,
      // Would need to track this separately
      retryCount: retryMetrics.totalAttempts || 0
    };
  }
  getHealth() {
    const circuitBreakerHealth = this.circuitBreaker.getHealthStatus();
    return {
      status: circuitBreakerHealth.isHealthy ? "healthy" : "unhealthy",
      circuitBreakerState: this.circuitBreaker.getState(),
      lastError: null,
      // Would need to track this
      uptime: circuitBreakerHealth.uptime
    };
  }
  getHealthStatus() {
    return {
      circuitBreaker: this.circuitBreaker.getHealthStatus(),
      retry: this.retryHandler.getMetrics()
    };
  }
  // Configuration updates
  updateConfig(updates) {
    Object.assign(this.config, updates);
  }
  // Cleanup
  destroy() {
    this.circuitBreaker.destroy();
    this.retryHandler.reset();
    this.middlewareStack.clear();
    this.removeAllListeners();
  }
};
var DEFAULT_HTTP_CONFIG = {
  baseUrl: "https://ereceipts-it-sandbox.acubeapi.com",
  timeout: 3e4,
  retryConfig: DEFAULT_RETRY_CONFIG,
  circuitBreakerConfig: {
    failureThreshold: 5,
    successThreshold: 2,
    timeout: 3e4,
    resetTimeout: 6e4,
    name: "acube-http-client"
  },
  headers: {
    "Accept": "application/json",
    "Content-Type": "application/json"
  },
  enableCircuitBreaker: true,
  enableRetry: true,
  enableLogging: true,
  userAgent: "ACube-SDK/2.0.0"
};
var AUTH_HTTP_CONFIG = {
  ...DEFAULT_HTTP_CONFIG,
  baseUrl: "https://common-sandbox.api.acubeapi.com",
  circuitBreakerConfig: {
    ...DEFAULT_HTTP_CONFIG.circuitBreakerConfig,
    name: "acube-auth-client"
  }
};

// src/core/sdk.ts
var DEFAULT_SDK_CONFIG = {
  environment: "sandbox",
  apiKey: "",
  baseUrls: {},
  httpConfig: {},
  auth: {
    autoRefresh: true,
    enabled: true,
    config: {
      loginUrl: "/login",
      refreshUrl: "/token/refresh",
      tokenRefreshBuffer: 5,
      maxRefreshAttempts: 3,
      refreshRetryDelay: 1e3,
      storageKey: "acube_auth",
      storageEncryption: true,
      sessionTimeout: 8 * 60 * 60 * 1e3,
      // 8 hours
      enableDeviceBinding: true,
      enableSessionValidation: true,
      enableTokenRotation: true
    },
    storage: {
      enableEncryption: true,
      storageKey: "acube_auth"
    },
    middleware: {
      enableRetry: true,
      maxRetries: 2,
      includeRoleHeaders: true,
      includePermissionHeaders: true,
      includeRequestContext: true
    }
  },
  logging: {
    enabled: true,
    level: "warn",
    sanitize: true
  },
  features: {
    enableRetry: true,
    enableCircuitBreaker: true,
    enableMetrics: true,
    enableOfflineQueue: false,
    enableSync: false,
    enableRealTimeSync: false
  },
  offline: {
    enabled: false,
    storage: {
      adapter: "indexeddb",
      maxSize: 100 * 1024 * 1024
      // 100MB
    },
    queue: {
      maxItems: 1e3,
      maxRetries: 3,
      retryDelay: 5e3,
      batchSize: 50
    },
    sync: {
      maxConcurrentSyncs: 3,
      defaultTimeout: 3e4,
      defaultRetries: 3,
      batchSize: 100,
      enableRollback: true,
      enableDeltaSync: true,
      enableCompression: true,
      checkpointInterval: 5e3
    }
  },
  pwa: {
    enabled: true,
    manager: {
      autoRegister: true,
      enableInstallPrompts: true,
      serviceWorkerPath: "/sw.js",
      appInstaller: {
        enabled: true,
        autoShow: true,
        criteria: {
          minEngagementTime: 2 * 60 * 1e3,
          // 2 minutes
          minPageViews: 3,
          minReceiptsCreated: 1,
          daysSinceFirstVisit: 0,
          requireReturnVisit: false
        }
      }
    },
    manifest: {
      name: "A-Cube E-Receipt",
      shortName: "A-Cube",
      themeColor: "#1976d2",
      backgroundColor: "#ffffff",
      lang: "it"
    },
    autoRegister: true,
    enableInstallPrompts: true,
    enablePushNotifications: false,
    vapidPublicKey: "",
    appInstaller: {
      enabled: true,
      autoShow: true,
      criteria: {
        minEngagementTime: 2 * 60 * 1e3,
        // 2 minutes
        minPageViews: 3,
        minReceiptsCreated: 1,
        daysSinceFirstVisit: 0,
        requireReturnVisit: false
      }
    }
  },
  reactNative: {
    enabled: false,
    storage: {
      enableOptimizedAdapter: true,
      cacheSize: 1e3,
      enableCompression: true,
      enableBatching: true,
      batchDelay: 50
    },
    connectivity: {
      enableQualityMonitoring: true,
      enableAdaptiveRetry: true,
      enableDataOptimization: true,
      healthCheckUrl: "https://ereceipts-it.acubeapi.com/health"
    },
    backgroundProcessor: {
      enabled: true,
      maxConcurrentTasks: 3,
      enableBatteryOptimization: true,
      enableAppStateManagement: true,
      enableTaskPersistence: true
    },
    performanceMonitor: {
      enabled: true,
      enableMemoryMonitoring: true,
      enableFrameRateMonitoring: true,
      enableBatteryMonitoring: true,
      enableRemoteReporting: false
    }
  },
  dev: {
    enableMocking: false,
    mockDelay: 0
  }
};
var ACubeSDK = class extends import_index.default {
  config;
  apiClient;
  authClient;
  isInitialized = false;
  // Lazy-loaded resources
  _cashiers;
  _receipts;
  _pointOfSales;
  _cashRegisters;
  _merchants;
  _pems;
  // Lazy-loaded offline systems
  _syncManager;
  _storage;
  _queueManager;
  // Lazy-loaded auth systems
  _authService;
  _tokenManager;
  _authStorage;
  _authMiddleware;
  // Lazy-loaded PWA systems
  _pwaManager;
  _manifestGenerator;
  // Lazy-loaded React Native optimization systems
  _optimizedStorage;
  _connectivityManager;
  _backgroundProcessor;
  _performanceMonitor;
  constructor(config) {
    super();
    this.config = this.mergeConfig(config);
    this.apiClient = this.createHttpClient("api");
    this.authClient = this.createHttpClient("auth");
    this.setupEventHandlers();
  }
  mergeConfig(userConfig) {
    return {
      ...DEFAULT_SDK_CONFIG,
      ...userConfig,
      baseUrls: {
        ...DEFAULT_SDK_CONFIG.baseUrls,
        ...userConfig.baseUrls
      },
      httpConfig: {
        ...DEFAULT_SDK_CONFIG.httpConfig,
        ...userConfig.httpConfig
      },
      auth: {
        ...DEFAULT_SDK_CONFIG.auth,
        ...userConfig.auth
      },
      logging: {
        ...DEFAULT_SDK_CONFIG.logging,
        ...userConfig.logging
      },
      features: {
        ...DEFAULT_SDK_CONFIG.features,
        ...userConfig.features
      },
      offline: {
        ...DEFAULT_SDK_CONFIG.offline,
        ...userConfig.offline,
        storage: {
          ...DEFAULT_SDK_CONFIG.offline.storage,
          ...userConfig.offline?.storage
        },
        queue: {
          ...DEFAULT_SDK_CONFIG.offline.queue,
          ...userConfig.offline?.queue
        },
        sync: {
          ...DEFAULT_SDK_CONFIG.offline.sync,
          ...userConfig.offline?.sync
        }
      },
      dev: {
        ...DEFAULT_SDK_CONFIG.dev,
        ...userConfig.dev
      }
    };
  }
  createHttpClient(type) {
    const baseConfig = type === "api" ? DEFAULT_HTTP_CONFIG : AUTH_HTTP_CONFIG;
    let baseUrl;
    if (type === "api") {
      baseUrl = this.config.baseUrls.api || this.getDefaultApiUrl();
    } else {
      baseUrl = this.config.baseUrls.auth || this.getDefaultAuthUrl();
    }
    const config = {
      ...baseConfig,
      ...this.config.httpConfig,
      baseUrl,
      enableRetry: this.config.features.enableRetry ?? true,
      enableCircuitBreaker: this.config.features.enableCircuitBreaker ?? true,
      enableLogging: this.config.logging.enabled,
      ...this.config.auth.getToken && { getAuthToken: this.config.auth.getToken },
      userAgent: `ACube-SDK/2.0.0 (${this.config.environment})`
    };
    return new HttpClient(config);
  }
  getDefaultApiUrl() {
    switch (this.config.environment) {
      case "production":
        return "https://ereceipts-it.acubeapi.com";
      case "development":
        return "https://ereceipts-it.dev.acubeapi.com";
      case "sandbox":
      default:
        return "https://ereceipts-it-sandbox.acubeapi.com";
    }
  }
  getDefaultAuthUrl() {
    switch (this.config.environment) {
      case "production":
        return "https://common.api.acubeapi.com";
      case "development":
      case "sandbox":
      default:
        return "https://common-sandbox.api.acubeapi.com";
    }
  }
  setupEventHandlers() {
    this.apiClient.on("requestError", (event) => {
      this.emit("error", {
        type: "error",
        timestamp: /* @__PURE__ */ new Date(),
        requestId: event.requestId,
        data: {
          errorCode: "HTTP_REQUEST_FAILED",
          errorMessage: event.error,
          operation: `${event.method} ${event.url}`,
          retry: false,
          context: { client: "api", ...event }
        }
      });
    });
    this.authClient.on("requestError", (event) => {
      this.emit("error", {
        type: "error",
        timestamp: /* @__PURE__ */ new Date(),
        requestId: event.requestId,
        data: {
          errorCode: "AUTH_REQUEST_FAILED",
          errorMessage: event.error,
          operation: `${event.method} ${event.url}`,
          retry: false,
          context: { client: "auth", ...event }
        }
      });
    });
    if (this.config.auth.onTokenExpired) {
      this.on("auth.expired", this.config.auth.onTokenExpired);
    }
  }
  /**
   * Initialize the SDK (optional - resources are lazy loaded)
   */
  async initialize() {
    if (this.isInitialized) {
      return;
    }
    try {
      this.validateConfig();
      if (this.config.auth.enabled) {
        await this.initializeAuthSystem();
      }
      if (this.config.reactNative.enabled) {
        await this.initializeReactNativeOptimizations();
      }
      if (this.config.features.enableMetrics) {
        await this.performHealthCheck();
      }
      this.isInitialized = true;
      this.emit("error", {
        type: "error",
        timestamp: /* @__PURE__ */ new Date(),
        requestId: `init_success_${Date.now()}`,
        data: {
          errorCode: "SDK_INITIALIZED",
          errorMessage: "SDK initialized successfully",
          operation: "initialize",
          retry: false,
          context: {
            environment: this.config.environment,
            features: this.config.features
          }
        }
      });
    } catch (error) {
      this.emit("error", {
        type: "error",
        timestamp: /* @__PURE__ */ new Date(),
        requestId: `init_${Date.now()}`,
        data: {
          errorCode: "SDK_INITIALIZATION_FAILED",
          errorMessage: error instanceof Error ? error.message : "Unknown error",
          operation: "initialize",
          retry: false
        }
      });
      throw error;
    }
  }
  validateConfig() {
    if (!["sandbox", "production", "development"].includes(this.config.environment)) {
      throw new Error(`Invalid environment: ${this.config.environment}`);
    }
    if (this.config.auth.getToken && typeof this.config.auth.getToken !== "function") {
      throw new Error("auth.getToken must be a function");
    }
  }
  async performHealthCheck() {
    try {
      const healthStatus = this.apiClient.getHealthStatus();
      this.emit("error", {
        type: "error",
        timestamp: /* @__PURE__ */ new Date(),
        requestId: `health_${Date.now()}`,
        data: {
          errorCode: "HEALTH_CHECK_COMPLETED",
          errorMessage: "Health check completed",
          operation: "health-check",
          retry: false,
          context: { healthStatus }
        }
      });
    } catch (error) {
      this.emit("error", {
        type: "error",
        timestamp: /* @__PURE__ */ new Date(),
        requestId: `health_failed_${Date.now()}`,
        data: {
          errorCode: "HEALTH_CHECK_FAILED",
          errorMessage: "Health check failed",
          operation: "health-check",
          retry: false,
          context: { error }
        }
      });
    }
  }
  /**
   * Initialize the enterprise authentication system
   */
  async initializeAuthSystem() {
    try {
      this._authStorage = this.authStorage;
      await this._authStorage.initialize();
      this._tokenManager = this.tokenManager;
      this._authService = this.authService;
      await this._authService.initialize();
      this._authMiddleware = this.authMiddleware;
      this.apiClient.addMiddleware(this._authMiddleware);
      this.authClient.addMiddleware(this._authMiddleware);
      this.setupAuthEventForwarding();
      if (this.config.auth.credentials?.autoLogin && this.config.auth.credentials.username && this.config.auth.credentials.password) {
        try {
          await this._authService.login({
            username: this.config.auth.credentials.username,
            password: this.config.auth.credentials.password
          });
        } catch (loginError) {
          console.warn("Auto-login failed during initialization:", loginError);
        }
      }
      this.emit("error", {
        type: "error",
        timestamp: /* @__PURE__ */ new Date(),
        requestId: `auth_init_${Date.now()}`,
        data: {
          errorCode: "AUTH_SYSTEM_INITIALIZED",
          errorMessage: "Authentication system initialized",
          operation: "auth-init",
          retry: false
        }
      });
    } catch (error) {
      this.emit("error", {
        type: "error",
        timestamp: /* @__PURE__ */ new Date(),
        requestId: `auth_init_failed_${Date.now()}`,
        data: {
          errorCode: "AUTH_INITIALIZATION_FAILED",
          errorMessage: error instanceof Error ? error.message : "Unknown auth error",
          operation: "auth-init",
          retry: false,
          context: { error }
        }
      });
      throw error;
    }
  }
  /**
   * Initialize React Native optimization systems
   */
  async initializeReactNativeOptimizations() {
    const isReactNative6 = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    if (!isReactNative6) {
      console.warn("React Native optimizations requested but not in React Native environment");
      return;
    }
    try {
      if (this.config.reactNative?.storage?.enableOptimizedAdapter) {
        const { OptimizedReactNativeStorageAdapter: OptimizedReactNativeStorageAdapter2 } = await Promise.resolve().then(() => (init_optimized_react_native_storage(), optimized_react_native_storage_exports));
        this._optimizedStorage = new OptimizedReactNativeStorageAdapter2({
          cacheSize: this.config.reactNative?.storage?.cacheSize ?? 1e3,
          enableCompression: this.config.reactNative?.storage?.enableCompression ?? true,
          enableBatching: this.config.reactNative?.storage?.enableBatching ?? true,
          batchDelay: this.config.reactNative?.storage?.batchDelay ?? 50
        });
      }
      const { ConnectivityManager: ConnectivityManager2 } = await Promise.resolve().then(() => (init_connectivity_manager(), connectivity_manager_exports));
      this._connectivityManager = new ConnectivityManager2({
        enableQualityMonitoring: this.config.reactNative?.connectivity?.enableQualityMonitoring ?? true,
        enableAdaptiveRetry: this.config.reactNative?.connectivity?.enableAdaptiveRetry ?? true,
        enableDataOptimization: this.config.reactNative?.connectivity?.enableDataOptimization ?? true,
        healthCheckUrl: this.config.reactNative?.connectivity?.healthCheckUrl ?? "https://ereceipts-it.acubeapi.com/health"
      });
      if (this.config.reactNative?.backgroundProcessor?.enabled) {
        const { BackgroundProcessor: BackgroundProcessor2 } = await Promise.resolve().then(() => (init_background_processor(), background_processor_exports));
        this._backgroundProcessor = new BackgroundProcessor2({
          maxConcurrentTasks: this.config.reactNative?.backgroundProcessor?.maxConcurrentTasks ?? 3,
          enableBatteryOptimization: this.config.reactNative?.backgroundProcessor?.enableBatteryOptimization ?? true,
          enableAppStateManagement: this.config.reactNative?.backgroundProcessor?.enableAppStateManagement ?? true,
          enableTaskPersistence: this.config.reactNative?.backgroundProcessor?.enableTaskPersistence ?? true
        });
      }
      if (this.config.reactNative?.performanceMonitor?.enabled) {
        const { PerformanceMonitor: PerformanceMonitor2 } = await Promise.resolve().then(() => (init_performance_monitor(), performance_monitor_exports));
        this._performanceMonitor = new PerformanceMonitor2({
          enableMemoryMonitoring: this.config.reactNative?.performanceMonitor?.enableMemoryMonitoring ?? true,
          enableFrameRateMonitoring: this.config.reactNative?.performanceMonitor?.enableFrameRateMonitoring ?? true,
          enableBatteryMonitoring: this.config.reactNative?.performanceMonitor?.enableBatteryMonitoring ?? true,
          enableRemoteReporting: this.config.reactNative?.performanceMonitor?.enableRemoteReporting ?? false
        });
      }
      this.emit("error", {
        type: "error",
        timestamp: /* @__PURE__ */ new Date(),
        requestId: `rn_init_${Date.now()}`,
        data: {
          errorCode: "REACT_NATIVE_OPTIMIZATIONS_INITIALIZED",
          errorMessage: "React Native optimizations initialized",
          operation: "rn-init",
          retry: false
        }
      });
    } catch (error) {
      this.emit("error", {
        type: "error",
        timestamp: /* @__PURE__ */ new Date(),
        requestId: `rn_init_failed_${Date.now()}`,
        data: {
          errorCode: "REACT_NATIVE_INITIALIZATION_FAILED",
          errorMessage: error instanceof Error ? error.message : "Unknown React Native error",
          operation: "rn-init",
          retry: false,
          context: { error }
        }
      });
      throw error;
    }
  }
  /**
   * Set up auth event forwarding to SDK events
   */
  setupAuthEventForwarding() {
    if (!this._authService) return;
    this._authService.on("auth:login:success", (event) => {
      this.emit("auth.success", {
        userId: event.data.user.id,
        role: event.data.user.attributes?.simpleRole || "cashier",
        user: event.data.user,
        expiresAt: event.data.user.last_login ? new Date(Date.now() + (this.config.auth?.config?.sessionTimeout || 36e5)) : void 0
      });
    });
    this._authService.on("auth:login:failure", (event) => {
      this.emit("auth.error", {
        error: event.data.error.message,
        errorCode: event.data.error.type,
        errorMessage: event.data.error.message,
        retry: event.data.error.recoverable || false,
        operation: "login"
      });
    });
    this._authService.on("auth:logout", (event) => {
      this.emit("auth.logout", {
        userId: event.data.userId,
        reason: event.data.reason,
        operation: "logout"
      });
    });
    this._authService.on("auth:session:expired", (event) => {
      this.emit("auth.expired", {
        userId: event.data.userId,
        sessionId: event.data.sessionId,
        operation: "session_expired"
      });
      if (this.config.auth?.onTokenExpired) {
        this.config.auth.onTokenExpired().catch((error) => {
          console.error("Legacy onTokenExpired callback failed:", error);
        });
      }
    });
  }
  // Lazy-loaded resource getters (Stripe-style)
  /**
   * Cashiers resource - user management
   * Enhanced with offline capabilities when enabled
   */
  get cashiers() {
    if (!this._cashiers) {
      const { CashiersResource: CashiersResource2 } = (init_cashiers(), __toCommonJS(cashiers_exports));
      this._cashiers = new CashiersResource2(
        this.apiClient,
        this.config.offline?.enabled ? this.storage : void 0,
        this.config.features?.enableOfflineQueue ? this.queue : void 0
      );
    }
    return this._cashiers;
  }
  /**
   * Receipts resource - e-receipt management
   * Enhanced with offline capabilities when enabled
   */
  get receipts() {
    if (!this._receipts) {
      const { ReceiptsResource: ReceiptsResource2 } = (init_receipts(), __toCommonJS(receipts_exports));
      this._receipts = new ReceiptsResource2(
        this.apiClient,
        this.config.offline?.enabled ? this.storage : void 0,
        this.config.features?.enableOfflineQueue ? this.queue : void 0
      );
    }
    return this._receipts;
  }
  /**
   * Point of Sales resource - POS device management
   * Enhanced with offline capabilities when enabled
   */
  get pointOfSales() {
    if (!this._pointOfSales) {
      const { PointOfSalesResource: PointOfSalesResource2 } = (init_point_of_sales(), __toCommonJS(point_of_sales_exports));
      this._pointOfSales = new PointOfSalesResource2(
        this.apiClient,
        this.config.offline?.enabled ? this.storage : void 0,
        this.config.features?.enableOfflineQueue ? this.queue : void 0
      );
    }
    return this._pointOfSales;
  }
  /**
   * Cash Registers resource - device registration
   * Enhanced with offline capabilities when enabled
   */
  get cashRegisters() {
    if (!this._cashRegisters) {
      const { CashRegistersResource: CashRegistersResource2 } = (init_cash_registers(), __toCommonJS(cash_registers_exports));
      this._cashRegisters = new CashRegistersResource2(
        this.apiClient,
        this.config.offline?.enabled ? this.storage : void 0,
        this.config.features?.enableOfflineQueue ? this.queue : void 0
      );
    }
    return this._cashRegisters;
  }
  /**
   * Merchants resource - business entity management
   * Enhanced with offline capabilities when enabled
   */
  get merchants() {
    if (!this._merchants) {
      const { MerchantsResource: MerchantsResource2 } = (init_merchants(), __toCommonJS(merchants_exports));
      this._merchants = new MerchantsResource2(
        this.apiClient,
        this.config.offline?.enabled ? this.storage : void 0,
        this.config.features?.enableOfflineQueue ? this.queue : void 0
      );
    }
    return this._merchants;
  }
  /**
   * PEMs resource - electronic memorization device management
   * Enhanced with offline capabilities when enabled
   */
  get pems() {
    if (!this._pems) {
      const { PEMsResource: PEMsResource2 } = (init_pems(), __toCommonJS(pems_exports));
      this._pems = new PEMsResource2(
        this.apiClient,
        this.config.offline?.enabled ? this.storage : void 0,
        this.config.features?.enableOfflineQueue ? this.queue : void 0
      );
    }
    return this._pems;
  }
  // PWA System getters
  /**
   * PWA Manager - Progressive Web App functionality
   * Handles service worker registration, caching, and offline capabilities
   */
  get pwa() {
    if (!this._pwaManager) {
      const { PWAManager: PWAManager2 } = (init_pwa_manager(), __toCommonJS(pwa_manager_exports));
      const pwaConfig = {
        ...this.config.pwa.manager,
        serviceWorkerPath: this.config.pwa.manager?.serviceWorkerPath || "/sw.js",
        autoRegister: this.config.pwa.autoRegister ?? true,
        enableInstallPrompts: this.config.pwa.enableInstallPrompts ?? true,
        pushNotifications: {
          enabled: this.config.pwa.enablePushNotifications ?? false,
          vapidPublicKey: this.config.pwa.vapidPublicKey ?? ""
        }
      };
      this._pwaManager = new PWAManager2(pwaConfig);
    }
    return this._pwaManager;
  }
  /**
   * Manifest Generator - PWA manifest creation and management
   * Creates web app manifests with Italian e-receipt specific configuration
   */
  get manifest() {
    if (!this._manifestGenerator) {
      const { ManifestGenerator: ManifestGenerator2 } = (init_manifest_generator(), __toCommonJS(manifest_generator_exports));
      this._manifestGenerator = new ManifestGenerator2(this.config.pwa.manifest);
    }
    return this._manifestGenerator;
  }
  // Offline system getters (only available when offline features are enabled)
  /**
   * Progressive sync manager - smart synchronization with partial failure recovery
   * Only available when features.enableSync is true
   */
  get sync() {
    if (!this.config.features.enableSync) {
      throw new Error("Sync is not enabled. Set features.enableSync to true in configuration.");
    }
    if (!this._syncManager) {
      const { ProgressiveSyncEngine: ProgressiveSyncEngine2 } = (init_sync_engine(), __toCommonJS(sync_engine_exports));
      this._syncManager = new ProgressiveSyncEngine2(this.config.offline?.sync || {});
    }
    return this._syncManager;
  }
  /**
   * Unified storage system - cross-platform storage with encryption
   * Only available when offline.enabled is true
   */
  get storage() {
    if (!this.config.offline?.enabled) {
      throw new Error("Offline storage is not enabled. Set offline.enabled to true in configuration.");
    }
    if (!this._storage) {
      const { UnifiedStorage: UnifiedStorage2 } = (init_unified_storage(), __toCommonJS(unified_storage_exports));
      this._storage = new UnifiedStorage2({
        adapter: this.config.offline.storage?.adapter || "indexeddb",
        encryptionKey: this.config.offline.storage?.encryptionKey,
        maxSize: this.config.offline.storage?.maxSize || 100 * 1024 * 1024
      });
    }
    return this._storage;
  }
  /**
   * Enterprise queue manager - advanced operation queuing with retry logic
   * Only available when features.enableOfflineQueue is true
   */
  get queue() {
    if (!this.config.features.enableOfflineQueue) {
      throw new Error("Offline queue is not enabled. Set features.enableOfflineQueue to true in configuration.");
    }
    if (!this._queueManager) {
      const { EnterpriseQueueManager: EnterpriseQueueManager2 } = (init_queue_manager(), __toCommonJS(queue_manager_exports));
      this._queueManager = new EnterpriseQueueManager2({
        storage: this.storage,
        // Use unified storage
        maxItems: this.config.offline?.queue?.maxItems || 1e3,
        maxRetries: this.config.offline?.queue?.maxRetries || 3,
        retryDelay: this.config.offline?.queue?.retryDelay || 5e3,
        batchSize: this.config.offline?.queue?.batchSize || 50
      });
    }
    return this._queueManager;
  }
  // Authentication system getters (only available when auth.enabled is true)
  /**
   * JWT token manager - automatic refresh, validation, parsing
   * Only available when auth.enabled is true
   */
  get tokenManager() {
    if (!this.config.auth.enabled) {
      throw new Error("Enterprise auth is not enabled. Set auth.enabled to true in configuration.");
    }
    if (!this._tokenManager) {
      const { TokenManager: TokenManager2 } = (init_token_manager(), __toCommonJS(token_manager_exports));
      this._tokenManager = new TokenManager2(
        this.authClient,
        {
          refreshUrl: this.config.auth.config?.refreshUrl || "/mf1/token/refresh",
          tokenRefreshBuffer: this.config.auth.config?.tokenRefreshBuffer || 5,
          maxRefreshAttempts: this.config.auth.config?.maxRefreshAttempts || 3,
          refreshRetryDelay: this.config.auth.config?.refreshRetryDelay || 1e3,
          enableTokenRotation: this.config.auth.config?.enableTokenRotation ?? true,
          onTokenRefresh: this.config.auth.config?.onTokenRefresh,
          onTokenExpired: this.config.auth.config?.onTokenExpired
        }
      );
    }
    return this._tokenManager;
  }
  /**
   * Enterprise authentication service - OAuth2, role-based access, session management
   * Only available when auth.enabled is true
   */
  get authService() {
    if (!this.config.auth.enabled) {
      throw new Error("Enterprise auth is not enabled. Set auth.enabled to true in configuration.");
    }
    if (!this._authService) {
      const { AuthService: AuthService2 } = (init_auth_service(), __toCommonJS(auth_service_exports));
      this._authService = new AuthService2(
        this.authClient,
        this.config.auth.config || {},
        void 0,
        // AccessControlManager - could be injected
        this._authStorage,
        this.tokenManager
        // Pass the shared token manager
      );
    }
    return this._authService;
  }
  /**
   * Secure cross-platform auth storage - encrypted token storage
   * Only available when auth.enabled is true
   */
  get authStorage() {
    if (!this.config.auth.enabled) {
      throw new Error("Enterprise auth is not enabled. Set auth.enabled to true in configuration.");
    }
    if (!this._authStorage) {
      const { AuthStorage: AuthStorage2 } = (init_auth_storage(), __toCommonJS(auth_storage_exports));
      this._authStorage = new AuthStorage2({
        storageKey: this.config.auth.storage?.storageKey || "acube_auth",
        enableEncryption: this.config.auth.storage?.enableEncryption ?? true,
        storageAdapter: this.config.auth.storage?.storageAdapter,
        autoMigrate: true
      });
    }
    return this._authStorage;
  }
  /**
   * Enhanced authentication middleware - automatic token refresh, role headers
   * Only available when auth.enabled is true
   */
  get authMiddleware() {
    if (!this.config.auth.enabled) {
      throw new Error("Enterprise auth is not enabled. Set auth.enabled to true in configuration.");
    }
    if (!this._authMiddleware) {
      const { EnhancedAuthMiddleware: EnhancedAuthMiddleware2 } = (init_auth_middleware(), __toCommonJS(auth_middleware_exports));
      this._authMiddleware = new EnhancedAuthMiddleware2(
        this.authService,
        this.tokenManager,
        {
          enableRetry: this.config.auth.middleware?.enableRetry ?? true,
          maxRetries: this.config.auth.middleware?.maxRetries || 2,
          authHeaderName: "Authorization",
          authScheme: "Bearer",
          includeRoleHeaders: this.config.auth.middleware?.includeRoleHeaders ?? true,
          roleHeaderName: "X-User-Role",
          includePermissionHeaders: this.config.auth.middleware?.includePermissionHeaders ?? true,
          permissionHeaderName: "X-User-Permissions",
          includeRequestContext: this.config.auth.middleware?.includeRequestContext ?? true,
          contextHeaders: {
            "X-Device-ID": "deviceId",
            "X-Session-ID": "sessionId",
            "X-Request-Context": "requestContext"
          }
        }
      );
    }
    return this._authMiddleware;
  }
  // Authentication methods
  /**
   * Login with username and password
   */
  async login(credentials) {
    if (!this.config.auth.enabled) {
      throw new Error("Enterprise auth is not enabled. Set auth.enabled to true in configuration.");
    }
    return this.authService.login(credentials);
  }
  /**
   * Logout current user
   */
  async logout(options) {
    if (!this.config.auth.enabled) {
      throw new Error("Enterprise auth is not enabled. Set auth.enabled to true in configuration.");
    }
    return this.authService.logout(options);
  }
  /**
   * Get current authentication state
   */
  getAuthState() {
    if (!this.config.auth.enabled || !this._authService) {
      return null;
    }
    return this.authService.getState();
  }
  /**
   * Get current authenticated user
   */
  getCurrentUser() {
    if (!this.config.auth.enabled || !this._authService) {
      return null;
    }
    return this.authService.getCurrentUser();
  }
  /**
   * Check if user is authenticated
   */
  isAuthenticated() {
    const authState = this.getAuthState();
    return authState?.isAuthenticated ?? false;
  }
  /**
   * Check if user has specific role (including inherited roles from hierarchy)
   */
  hasRole(role) {
    if (!this.config.auth.enabled || !this._authService) {
      return false;
    }
    return this.authService.hasRole(role);
  }
  /**
   * Check if user has any of the specified roles (including inherited roles)
   */
  hasAnyRole(roles) {
    if (!this.config.auth.enabled || !this._authService) {
      return false;
    }
    return this.authService.hasAnyRole(roles);
  }
  /**
   * Get user's effective roles (including inherited roles from hierarchy)
   */
  getEffectiveRoles() {
    if (!this.config.auth.enabled || !this._authService) {
      return [];
    }
    return this.authService.getEffectiveRoles();
  }
  /**
   * Get user's primary role for display purposes
   */
  getPrimaryRole() {
    if (!this.config.auth.enabled || !this._authService) {
      return null;
    }
    return this.authService.getPrimaryRole();
  }
  /**
   * Get user's simple role for external APIs
   */
  getSimpleRole() {
    if (!this.config.auth.enabled || !this._authService) {
      return "cashier";
    }
    return this.authService.getSimpleRole();
  }
  /**
   * Switch to a different role context during session
   */
  async switchRole(targetRole, context) {
    if (!this.config.auth.enabled) {
      throw new Error("Enterprise auth is not enabled. Set auth.enabled to true in configuration.");
    }
    return this.authService.switchRole(targetRole, context);
  }
  // Configuration and management methods
  /**
   * Update SDK configuration
   */
  updateConfig(updates) {
    const newConfig = this.mergeConfig({ ...this.config, ...updates });
    if (updates.httpConfig || updates.baseUrls || updates.environment) {
      this.apiClient.updateConfig(this.createHttpClient("api")["config"]);
      this.authClient.updateConfig(this.createHttpClient("auth")["config"]);
    }
    this.config = newConfig;
    this.emit("error", {
      type: "error",
      timestamp: /* @__PURE__ */ new Date(),
      requestId: `config_${Date.now()}`,
      data: {
        errorCode: "CONFIG_UPDATED",
        errorMessage: "Configuration updated",
        operation: "update-config",
        retry: false,
        context: { updates }
      }
    });
  }
  /**
   * Get current configuration
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Get SDK metrics and health status
   */
  getMetrics() {
    return {
      api: this.apiClient.getHealthStatus(),
      auth: this.authClient.getHealthStatus(),
      isInitialized: this.isInitialized,
      environment: this.config.environment
    };
  }
  /**
   * Get HTTP clients (for advanced usage)
   */
  getClients() {
    return {
      api: this.apiClient,
      auth: this.authClient
    };
  }
  // React Native Optimization getters (only available when reactNative.enabled is true)
  /**
   * Optimized React Native Storage Adapter - High-performance AsyncStorage with caching
   * Only available when reactNative.enabled is true and enableOptimizedAdapter is true
   */
  get optimizedStorage() {
    if (!this.config.reactNative.enabled) {
      throw new Error("React Native optimizations are not enabled. Set reactNative.enabled to true in configuration.");
    }
    if (!this.config.reactNative?.storage?.enableOptimizedAdapter) {
      throw new Error("Optimized storage adapter is not enabled. Set reactNative.storage.enableOptimizedAdapter to true.");
    }
    if (!this._optimizedStorage) {
      throw new Error("Optimized storage not initialized. Make sure SDK is initialized first.");
    }
    return this._optimizedStorage;
  }
  /**
   * Connectivity Manager - Intelligent network handling and retry strategies
   * Only available when reactNative.enabled is true
   */
  get connectivity() {
    if (!this.config.reactNative.enabled) {
      throw new Error("React Native optimizations are not enabled. Set reactNative.enabled to true in configuration.");
    }
    if (!this._connectivityManager) {
      throw new Error("Connectivity manager not initialized. Make sure SDK is initialized first.");
    }
    return this._connectivityManager;
  }
  /**
   * Background Processor - Task scheduling and app lifecycle management
   * Only available when reactNative.enabled is true and backgroundProcessor.enabled is true
   */
  get backgroundProcessor() {
    if (!this.config.reactNative.enabled) {
      throw new Error("React Native optimizations are not enabled. Set reactNative.enabled to true in configuration.");
    }
    if (!this.config.reactNative?.backgroundProcessor?.enabled) {
      throw new Error("Background processor is not enabled. Set reactNative.backgroundProcessor.enabled to true.");
    }
    if (!this._backgroundProcessor) {
      throw new Error("Background processor not initialized. Make sure SDK is initialized first.");
    }
    return this._backgroundProcessor;
  }
  /**
   * Performance Monitor - Mobile performance metrics and optimization
   * Only available when reactNative.enabled is true and performanceMonitor.enabled is true
   */
  get performanceMonitor() {
    if (!this.config.reactNative.enabled) {
      throw new Error("React Native optimizations are not enabled. Set reactNative.enabled to true in configuration.");
    }
    if (!this.config.reactNative?.performanceMonitor?.enabled) {
      throw new Error("Performance monitor is not enabled. Set reactNative.performanceMonitor.enabled to true.");
    }
    if (!this._performanceMonitor) {
      throw new Error("Performance monitor not initialized. Make sure SDK is initialized first.");
    }
    return this._performanceMonitor;
  }
  /**
   * Cleanup resources
   */
  async destroy() {
    this.apiClient.destroy();
    this.authClient.destroy();
    if (this._authService) {
      await this._authService.destroy();
    }
    if (this._tokenManager) {
      this._tokenManager.destroy();
    }
    if (this._authStorage) {
      await this._authStorage.destroy();
    }
    if (this._authMiddleware) {
      this._authMiddleware.destroy();
    }
    if (this._syncManager) {
      await this._syncManager.cancelAllSyncs();
    }
    if (this._queueManager) {
      await this._queueManager.destroy();
    }
    if (this._storage) {
      await this._storage.destroy();
    }
    if (this._optimizedStorage) {
      await this._optimizedStorage.destroy();
    }
    if (this._connectivityManager) {
      this._connectivityManager.destroy();
    }
    if (this._backgroundProcessor) {
      this._backgroundProcessor.destroy();
    }
    if (this._performanceMonitor) {
      this._performanceMonitor.destroy();
    }
    this.removeAllListeners();
    this.isInitialized = false;
    this.emit("error", {
      type: "error",
      timestamp: /* @__PURE__ */ new Date(),
      requestId: `destroy_${Date.now()}`,
      data: {
        errorCode: "SDK_DESTROYED",
        errorMessage: "SDK destroyed",
        operation: "destroy",
        retry: false
      }
    });
  }
};
function createACubeSDK(config) {
  return new ACubeSDK(config);
}

// src/index.ts
init_endpoints();
init_cashiers();
init_receipts();
init_cash_registers();
init_merchants();
init_pems();
init_point_of_sales();
init_base_openapi();

// src/types/branded.ts
init_esm_shims();
var createReceiptId = (id) => id;
var createCashierId = (id) => id;
var createPEMId = (id) => id;
var createMerchantId = (id) => id;
var createPointOfSaleId = (id) => id;
var createCashRegisterId = (id) => id;
var createSerialNumber = (sn) => sn;
var createFiscalId = (id) => id;
var createDocumentNumber = (dn) => dn;
var createAmount = (amount) => amount;
var createVATRate = (rate) => rate;
var createQuantity = (qty) => qty;
var isReceiptId = (value) => typeof value === "string" && value.length > 0;
var isCashierId = (value) => typeof value === "number" && value > 0;
var isFiscalId = (value) => typeof value === "string" && /^\d{11}$/.test(value);
var isAmount = (value) => typeof value === "string" && /^\d+\.\d{2,8}$/.test(value);
var isMerchantId = (value) => typeof value === "string" && value.length > 0;
var isPointOfSaleId = (value) => typeof value === "string" && value.length > 0;
var isSerialNumber = (value) => typeof value === "string" && value.length > 0;
var isPEMId = (value) => typeof value === "string" && value.length > 0;
var isQuantity = (value) => typeof value === "string" && /^\d+(\.\d{1,6})?$/.test(value);

// src/types/events.ts
init_esm_shims();

// src/index.ts
init_unified_storage();
init_platform_detector();
init_indexeddb_adapter();
init_localstorage_adapter();
init_encryption_service();
init_storage_factory();

// src/storage/queue/index.ts
init_esm_shims();
init_types();

// src/storage/base/storage-adapter.ts
init_esm_shims();

// src/storage/adapters/web-storage.ts
init_esm_shims();
var DEFAULT_CONFIG14 = {
  dbName: "acube-queue-storage",
  dbVersion: 1,
  storeName: "queue-items",
  fallbackToLocalStorage: true,
  quota: 100 * 1024 * 1024
  // 100MB
};

// src/storage/adapters/react-native-storage.ts
init_esm_shims();
var isReactNative5 = typeof navigator !== "undefined" && navigator.product === "ReactNative";
var DEFAULT_CONFIG15 = {
  keyPrefix: "acube-queue",
  useKeychain: false,
  keychainService: "acube-sdk",
  quota: 50 * 1024 * 1024,
  // 50MB
  encryptSensitiveData: true
};

// src/storage/queue/index.ts
init_priority_queue();
init_batch_processor();

// src/storage/queue/conflict-resolver.ts
init_esm_shims();
var ConflictResolverManager = class {
  config;
  customResolvers = /* @__PURE__ */ new Map();
  pendingUserInputs = /* @__PURE__ */ new Map();
  resolutionHistory = [];
  constructor(config = {}) {
    this.config = {
      defaultStrategy: "server-wins",
      mergeRules: this.getDefaultMergeRules(),
      userInputTimeout: 3e5,
      // 5 minutes
      maxResolutionAttempts: 3,
      enableAutoResolution: true,
      confidenceThreshold: 0.8,
      ...config
    };
  }
  /**
   * Resolve conflict between local and server data
   */
  async resolveConflict(localItem, serverData, context) {
    const resolverKey = `${context.resource}:${context.operation}`;
    const customResolver = this.customResolvers.get(resolverKey);
    if (customResolver) {
      try {
        const resolved = await customResolver(localItem, serverData, context);
        return this.createResolution("manual", resolved, context, "Custom resolver applied", 1);
      } catch (error) {
        console.warn(`Custom resolver failed for ${resolverKey}:`, error);
      }
    }
    const strategy = localItem.conflictResolution || this.config.defaultStrategy;
    switch (strategy) {
      case "client-wins":
        return this.resolveClientWins(localItem, serverData, context);
      case "server-wins":
        return this.resolveServerWins(localItem, serverData, context);
      case "merge":
        return this.resolveMerge(localItem, serverData, context);
      case "manual":
        return this.resolveManual(localItem, serverData, context);
      default:
        return this.resolveServerWins(localItem, serverData, context);
    }
  }
  /**
   * Register custom conflict resolver
   */
  registerResolver(resource, operation, resolver) {
    const key = `${resource}:${operation}`;
    this.customResolvers.set(key, resolver);
  }
  /**
   * Get conflict resolution suggestions based on context
   */
  getResolutionSuggestions(context) {
    const suggestions = [];
    switch (context.conflictType) {
      case "version-mismatch":
        if (Math.abs(context.localTimestamp - context.serverTimestamp) < 6e4) {
          suggestions.push("merge", "client-wins", "server-wins");
        } else {
          suggestions.push("server-wins", "merge");
        }
        break;
      case "concurrent-modification":
        suggestions.push("merge", "manual", "server-wins");
        break;
      case "stale-data":
        suggestions.push("server-wins", "merge");
        break;
      case "validation-error":
        suggestions.push("server-wins", "manual");
        break;
      case "permission-denied":
        suggestions.push("server-wins");
        break;
      default:
        suggestions.push("server-wins", "merge", "client-wins");
    }
    return suggestions;
  }
  /**
   * Analyze conflict to determine type and severity
   */
  analyzeConflict(localItem, serverData) {
    const now = Date.now();
    let conflictType = "version-mismatch";
    const timeDiff = Math.abs(localItem.updatedAt - now);
    if (timeDiff > 3e5) {
      conflictType = "stale-data";
    }
    if (this.hasValidationIssues(localItem.data, serverData)) {
      conflictType = "validation-error";
    }
    if (this.hasSchemaIssues(localItem.data, serverData)) {
      conflictType = "schema-incompatible";
    }
    return {
      resource: localItem.resource,
      operation: localItem.operation,
      localTimestamp: localItem.updatedAt,
      serverTimestamp: now,
      clientId: this.getClientId(),
      conflictType
    };
  }
  /**
   * Get resolution history for analytics
   */
  getResolutionHistory() {
    return [...this.resolutionHistory];
  }
  /**
   * Clear resolution history
   */
  clearHistory() {
    this.resolutionHistory = [];
  }
  // Private resolution methods
  async resolveClientWins(localItem, _serverData, context) {
    return this.createResolution(
      "client-wins",
      localItem.data,
      context,
      "Client data takes precedence",
      0.7
    );
  }
  async resolveServerWins(_localItem, serverData, context) {
    return this.createResolution(
      "server-wins",
      serverData,
      context,
      "Server data takes precedence",
      0.9
    );
  }
  async resolveMerge(localItem, serverData, context) {
    const mergeRules = this.config.mergeRules[context.resource] || [];
    const merged = await this.performMerge(
      localItem.data,
      serverData,
      mergeRules,
      context
    );
    const confidence = this.calculateMergeConfidence(mergeRules, context);
    return this.createResolution(
      "merge",
      merged,
      context,
      "Data merged using configured rules",
      confidence
    );
  }
  async resolveManual(_localItem, serverData, context) {
    const resolution = this.createResolution(
      "manual",
      serverData,
      context,
      "Manual resolution required - defaulting to server data",
      0.3
    );
    resolution.requiresUserInput = true;
    const resolutionId = `manual_${Date.now()}_${Math.random().toString(36).substring(2)}`;
    this.pendingUserInputs.set(resolutionId, resolution);
    setTimeout(() => {
      if (this.pendingUserInputs.has(resolutionId)) {
        console.warn(`Manual conflict resolution timed out for ${context.resource}:${context.operation}`);
        this.pendingUserInputs.delete(resolutionId);
      }
    }, this.config.userInputTimeout);
    return resolution;
  }
  async performMerge(clientData, serverData, mergeRules, context) {
    const result = { ...serverData };
    const preservedFields = [];
    const discardedFields = [];
    for (const rule of mergeRules) {
      try {
        const clientValue = this.getNestedProperty(clientData, rule.field);
        const serverValue = this.getNestedProperty(serverData, rule.field);
        let resolvedValue;
        switch (rule.strategy) {
          case "client":
            resolvedValue = clientValue;
            preservedFields.push(rule.field);
            break;
          case "server":
            resolvedValue = serverValue;
            break;
          case "latest":
            resolvedValue = context.localTimestamp > context.serverTimestamp ? clientValue : serverValue;
            break;
          case "merge-array":
            if (Array.isArray(clientValue) && Array.isArray(serverValue)) {
              resolvedValue = this.mergeArrays(clientValue, serverValue);
              preservedFields.push(rule.field);
            } else {
              resolvedValue = serverValue;
            }
            break;
          case "custom":
            if (rule.customResolver) {
              resolvedValue = rule.customResolver(clientValue, serverValue, context);
              preservedFields.push(rule.field);
            } else {
              resolvedValue = serverValue;
            }
            break;
          default:
            resolvedValue = serverValue;
        }
        this.setNestedProperty(result, rule.field, resolvedValue);
      } catch (error) {
        console.warn(`Failed to apply merge rule for field ${rule.field}:`, error);
        discardedFields.push(rule.field);
      }
    }
    result._mergeMetadata = {
      preservedFields,
      discardedFields,
      mergedAt: Date.now()
    };
    return result;
  }
  createResolution(strategy, data, context, reason, confidence) {
    const resolution = {
      strategy,
      resolvedData: data,
      requiresUserInput: false,
      metadata: {
        conflictType: context.conflictType,
        resolutionReason: reason,
        dataSource: this.getDataSource(strategy),
        confidence
      }
    };
    this.resolutionHistory.push(resolution);
    if (this.resolutionHistory.length > 1e3) {
      this.resolutionHistory = this.resolutionHistory.slice(-500);
    }
    return resolution;
  }
  getDataSource(strategy) {
    switch (strategy) {
      case "client-wins":
        return "client";
      case "server-wins":
        return "server";
      case "merge":
        return "merged";
      case "manual":
        return "manual";
      default:
        return "server";
    }
  }
  calculateMergeConfidence(mergeRules, context) {
    if (mergeRules.length === 0) return 0.3;
    let confidence = 0.8;
    if (context.conflictType === "concurrent-modification") {
      confidence -= 0.2;
    }
    const timeDiff = Math.abs(context.localTimestamp - context.serverTimestamp);
    if (timeDiff > 6e5) {
      confidence -= 0.3;
    }
    return Math.max(0.1, Math.min(1, confidence));
  }
  getDefaultMergeRules() {
    return {
      receipts: [
        { field: "items", strategy: "merge-array" },
        { field: "notes", strategy: "client" },
        { field: "status", strategy: "server" },
        { field: "updatedAt", strategy: "latest" }
      ],
      cashiers: [
        { field: "name", strategy: "client" },
        { field: "email", strategy: "client" },
        { field: "role", strategy: "server" },
        { field: "permissions", strategy: "server" }
      ],
      merchants: [
        { field: "businessInfo", strategy: "client" },
        { field: "taxInfo", strategy: "server" },
        { field: "settings", strategy: "merge-array" }
      ],
      "cash-registers": [
        { field: "configuration", strategy: "client" },
        { field: "status", strategy: "server" },
        { field: "lastSync", strategy: "latest" }
      ],
      "point-of-sales": [
        { field: "configuration", strategy: "client" },
        { field: "status", strategy: "server" }
      ],
      pems: [
        { field: "configuration", strategy: "server" },
        { field: "status", strategy: "server" }
      ]
    };
  }
  hasValidationIssues(_localData, _serverData) {
    return false;
  }
  hasSchemaIssues(localData, serverData) {
    return typeof localData !== typeof serverData;
  }
  getClientId() {
    return `client_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
  getNestedProperty(obj, path2) {
    return path2.split(".").reduce((current, key) => current?.[key], obj);
  }
  setNestedProperty(obj, path2, value) {
    const keys = path2.split(".");
    const lastKey = keys.pop();
    const target = keys.reduce((current, key) => {
      if (!(key in current)) current[key] = {};
      return current[key];
    }, obj);
    target[lastKey] = value;
  }
  mergeArrays(clientArray, serverArray) {
    const merged = [...serverArray];
    for (const item of clientArray) {
      const exists = merged.some(
        (existing) => JSON.stringify(existing) === JSON.stringify(item)
      );
      if (!exists) {
        merged.push(item);
      }
    }
    return merged;
  }
};

// src/storage/queue/index.ts
init_retry_manager();
init_queue_analytics();
init_queue_manager();
init_queue_manager();

// src/storage/queue/enhanced-offline-hook.ts
init_esm_shims();
var import_react = __toESM(require_react(), 1);
init_queue_manager();
var DEFAULT_OPTIONS = {
  enabled: true,
  maxQueueSize: 1e3,
  maxRetries: 3,
  retryDelay: 1e3,
  persistQueue: true,
  syncOnReconnect: true,
  conflictResolution: "server-wins",
  enableBatching: true,
  batchSize: 20,
  batchTimeout: 5e3,
  enableAnalytics: true,
  autoProcessing: true,
  processingInterval: 2e3,
  priorityMapping: {
    payment: "critical",
    receipt: "high",
    cashier: "normal",
    settings: "low"
  }
};
function useEnhancedACubeOffline(options = {}) {
  const config = { ...DEFAULT_OPTIONS, ...options };
  const [state, setState] = (0, import_react.useState)(() => ({
    isOnline: typeof navigator !== "undefined" ? navigator.onLine : true,
    queueStats: {
      totalItems: 0,
      pendingItems: 0,
      processingItems: 0,
      completedItems: 0,
      failedItems: 0,
      deadItems: 0,
      averageProcessingTime: 0,
      successRate: 0,
      lastProcessedAt: null,
      throughputPerMinute: 0,
      priorityDistribution: { critical: 0, high: 0, normal: 0, low: 0 },
      resourceDistribution: {
        receipts: 0,
        cashiers: 0,
        merchants: 0,
        "cash-registers": 0,
        "point-of-sales": 0,
        pems: 0
      }
    },
    processingStatus: {
      isProcessing: false,
      processingItems: 0,
      autoProcessing: config.autoProcessing,
      readyItems: 0
    }
  }));
  const queueManagerRef = (0, import_react.useRef)(null);
  const sdk = useACubeSDK();
  (0, import_react.useEffect)(() => {
    if (!config.enabled || !sdk) return;
    const queueManager = new EnterpriseQueueManager({
      maxSize: config.maxQueueSize,
      maxRetries: config.maxRetries,
      defaultConflictResolution: config.conflictResolution,
      batchingEnabled: config.enableBatching,
      batchSize: config.batchSize,
      batchTimeout: config.batchTimeout,
      analyticsEnabled: config.enableAnalytics,
      autoProcessing: config.autoProcessing,
      processingInterval: config.processingInterval,
      enablePersistence: config.persistQueue
    });
    registerSDKProcessors(queueManager, sdk);
    setupQueueEventListeners(queueManager, setState);
    queueManagerRef.current = queueManager;
    return () => {
      queueManager.destroy();
      queueManagerRef.current = null;
    };
  }, [config, sdk]);
  (0, import_react.useEffect)(() => {
    if (typeof window === "undefined") return;
    const handleOnline = () => {
      setState((prev) => ({ ...prev, isOnline: true }));
      if (config.syncOnReconnect && queueManagerRef.current) {
        setTimeout(() => {
          queueManagerRef.current?.resume();
        }, 1e3);
      }
    };
    const handleOffline = () => {
      setState((prev) => ({ ...prev, isOnline: false }));
      if (queueManagerRef.current) {
        queueManagerRef.current.pause();
      }
    };
    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);
    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  }, [config.syncOnReconnect]);
  const addToQueue = (0, import_react.useCallback)(async (operation, resource, data, options2 = {}) => {
    if (!queueManagerRef.current) {
      throw new Error("Queue manager not initialized");
    }
    const priority = options2.priority || config.priorityMapping[operation] || config.priorityMapping[resource] || "normal";
    return queueManagerRef.current.enqueue(operation, resource, data, {
      ...options2,
      priority
    });
  }, [config.priorityMapping]);
  const removeFromQueue = (0, import_react.useCallback)(async (id) => {
    if (!queueManagerRef.current) return false;
    return queueManagerRef.current.dequeue(id);
  }, []);
  const getQueuedOperation = (0, import_react.useCallback)((id) => {
    if (!queueManagerRef.current) return null;
    return queueManagerRef.current.getItem(id);
  }, []);
  const clearQueue = (0, import_react.useCallback)(async () => {
    if (!queueManagerRef.current) return;
    await queueManagerRef.current.clear();
  }, []);
  const sync = (0, import_react.useCallback)(async () => {
    if (!queueManagerRef.current || !state.isOnline) {
      return [];
    }
    const results = await queueManagerRef.current.processAll();
    return results.map((result, index) => ({
      id: `sync_${Date.now()}_${index}`,
      success: result.success,
      ...result.error && { error: new Error(result.error) },
      ...result.processingTime !== void 0 && { processingTime: result.processingTime }
    }));
  }, [state.isOnline]);
  const pause = (0, import_react.useCallback)(() => {
    if (!queueManagerRef.current) return;
    queueManagerRef.current.pause();
  }, []);
  const resume = (0, import_react.useCallback)(() => {
    if (!queueManagerRef.current) return;
    queueManagerRef.current.resume();
  }, []);
  const getInsights = (0, import_react.useCallback)(() => {
    if (!queueManagerRef.current) return null;
    return queueManagerRef.current.getInsights();
  }, []);
  const getTrendAnalysis = (0, import_react.useCallback)(() => {
    if (!queueManagerRef.current) return null;
    return queueManagerRef.current.getTrendAnalysis();
  }, []);
  const scheduleOperation = (0, import_react.useCallback)(async (operation, resource, data, scheduledAt, options2 = {}) => {
    return addToQueue(operation, resource, data, {
      ...options2,
      scheduledAt
    });
  }, [addToQueue]);
  const batchOperations = (0, import_react.useCallback)(async (operations) => {
    const ids = await Promise.all(
      operations.map(
        (op) => addToQueue(op.operation, op.resource, op.data, {
          ...op.priority && { priority: op.priority }
        })
      )
    );
    return ids;
  }, [addToQueue]);
  const onQueueEvent = (0, import_react.useCallback)((event, handler) => {
    if (!queueManagerRef.current) return;
    queueManagerRef.current.on(event, handler);
  }, []);
  const offQueueEvent = (0, import_react.useCallback)((event, handler) => {
    if (!queueManagerRef.current) return;
    queueManagerRef.current.off(event, handler);
  }, []);
  return {
    isOnline: state.isOnline,
    isOffline: !state.isOnline,
    queueSize: state.queueStats.totalItems,
    queueStats: state.queueStats,
    processingStatus: state.processingStatus,
    addToQueue,
    removeFromQueue,
    getQueuedOperation,
    clearQueue,
    sync,
    pause,
    resume,
    getInsights,
    getTrendAnalysis,
    scheduleOperation,
    batchOperations,
    onQueueEvent,
    offQueueEvent
  };
}
function registerSDKProcessors(queueManager, sdk) {
  queueManager.registerProcessor("receipts", "create", async (item) => {
    return sdk.receipts.create(item.data);
  });
  queueManager.registerProcessor("receipts", "update", async (item) => {
    const data = item.data;
    return sdk.receipts.update(data.id, data);
  });
  queueManager.registerProcessor("receipts", "delete", async (item) => {
    const data = item.data;
    return sdk.receipts.delete(data.id);
  });
  queueManager.registerProcessor("cashiers", "create", async (item) => {
    return sdk.cashiers.create(item.data);
  });
  queueManager.registerProcessor("cashiers", "update", async (item) => {
    const data = item.data;
    return sdk.cashiers.update(data.id, data);
  });
  queueManager.registerProcessor("cashiers", "delete", async (item) => {
    const data = item.data;
    return sdk.cashiers.delete(data.id);
  });
  queueManager.registerProcessor("merchants", "create", async (item) => {
    return sdk.merchants.create(item.data);
  });
  queueManager.registerProcessor("merchants", "update", async (item) => {
    const data = item.data;
    return sdk.merchants.update(data.id, data);
  });
}
function setupQueueEventListeners(queueManager, setState) {
  const updateStats = () => {
    setState((prev) => ({
      ...prev,
      queueStats: queueManager.getStats(),
      processingStatus: queueManager.getProcessingStatus()
    }));
  };
  queueManager.on("item:added", updateStats);
  queueManager.on("item:completed", updateStats);
  queueManager.on("item:failed", updateStats);
  queueManager.on("item:processing", updateStats);
  queueManager.on("queue:drained", updateStats);
}
function useACubeSDK() {
  throw new Error("useACubeSDK must be used within ACubeProvider");
}

// src/storage/queue/index.ts
init_types();

// src/hooks/react/index.ts
init_esm_shims();

// src/hooks/react/ACubeProvider.tsx
init_esm_shims();
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var ACubeContext = (0, import_react2.createContext)(void 0);
var ACubeErrorBoundary = class extends import_react2.default.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    console.error("ACube SDK Error:", error, errorInfo);
    this.props.onError?.(error);
  }
  render() {
    if (this.state.hasError) {
      return this.props.fallback || /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { role: "alert", style: { padding: "20px", textAlign: "center" }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("h2", { children: "Something went wrong with the ACube SDK" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("details", { style: { whiteSpace: "pre-wrap", marginTop: "10px" }, children: this.state.error?.toString() })
      ] });
    }
    return this.props.children;
  }
};
var ACubeProvider = ({
  config,
  children,
  fallback,
  onInitializationError,
  autoInitialize = true
}) => {
  const [isInitialized, setIsInitialized] = (0, import_react2.useState)(false);
  const [isOnline, setIsOnline] = (0, import_react2.useState)(typeof navigator !== "undefined" ? navigator.onLine : true);
  const [initializationError, setInitializationError] = (0, import_react2.useState)();
  const sdkRef = (0, import_react2.useRef)(void 0);
  const networkManagerRef = (0, import_react2.useRef)(void 0);
  if (!sdkRef.current) {
    sdkRef.current = new ACubeSDK(config);
  }
  const sdk = sdkRef.current;
  (0, import_react2.useEffect)(() => {
    const initializeNetworkManager = async () => {
      if (!networkManagerRef.current) {
        try {
          const { NetworkManager: NetworkManager2 } = await Promise.resolve().then(() => (init_network_manager_simple(), network_manager_simple_exports));
          networkManagerRef.current = new NetworkManager2();
          await networkManagerRef.current.initialize?.();
          networkManagerRef.current.onConnectionChange?.((info) => {
            setIsOnline(info.isOnline);
          });
        } catch (error) {
          console.warn("Failed to initialize network manager:", error);
        }
      }
    };
    initializeNetworkManager();
    return () => {
      if (networkManagerRef.current) {
        networkManagerRef.current.destroy?.();
      }
    };
  }, []);
  (0, import_react2.useEffect)(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);
    if (typeof window !== "undefined") {
      window.addEventListener("online", handleOnline);
      window.addEventListener("offline", handleOffline);
      return () => {
        window.removeEventListener("online", handleOnline);
        window.removeEventListener("offline", handleOffline);
      };
    }
    return void 0;
  }, []);
  (0, import_react2.useEffect)(() => {
    let mounted = true;
    const initializeSDK = async () => {
      if (!autoInitialize) return;
      try {
        await sdk.initialize();
        if (mounted) {
          setIsInitialized(true);
          setInitializationError(void 0);
        }
      } catch (error) {
        const initError = error instanceof Error ? error : new Error("SDK initialization failed");
        if (mounted) {
          setInitializationError(initError);
          onInitializationError?.(initError);
        }
      }
    };
    initializeSDK();
    return () => {
      mounted = false;
    };
  }, [sdk, autoInitialize, onInitializationError]);
  const enableOffline = async () => {
    try {
      sdk.updateConfig({
        ...config,
        offline: { ...config.offline, enabled: true },
        features: { ...config.features, enableOfflineQueue: true }
      });
      if (sdk.storage && sdk.queue) {
        await sdk.storage.initialize?.();
        await sdk.queue.initialize?.();
      }
    } catch (error) {
      throw new Error(`Failed to enable offline mode: ${error}`);
    }
  };
  const enableSync = async () => {
    try {
      sdk.updateConfig({
        ...config,
        features: { ...config.features, enableSync: true }
      });
      if (sdk.sync) {
        await sdk.sync.initialize?.();
      }
    } catch (error) {
      throw new Error(`Failed to enable sync: ${error}`);
    }
  };
  const getOfflineStatus = () => {
    let queuedOperations = 0;
    let pendingSyncOperations = 0;
    let lastSyncTime;
    try {
      if (config.features?.enableOfflineQueue && sdk.queue) {
        const stats = sdk.queue.getStats();
        queuedOperations = stats.totalItems;
      }
      if (config.features?.enableSync && sdk.sync) {
        const status = sdk.sync.getStatus();
        pendingSyncOperations = status.activeSyncs + status.queuedSyncs;
        lastSyncTime = status.lastSync || void 0;
      }
    } catch (error) {
      console.warn("Failed to get offline status:", error);
    }
    return {
      queuedOperations,
      ...lastSyncTime && { lastSyncTime },
      pendingSyncOperations
    };
  };
  const contextValue = {
    sdk,
    storage: config.offline?.enabled ? sdk.storage : void 0,
    queueManager: config.features?.enableOfflineQueue ? sdk.queue : void 0,
    syncEngine: config.features?.enableSync ? sdk.sync : void 0,
    networkManager: networkManagerRef.current || void 0,
    isInitialized,
    isOnline,
    isOfflineEnabled: Boolean(config.offline?.enabled),
    isSyncEnabled: Boolean(config.features?.enableSync),
    initializationError: initializationError || void 0,
    enableOffline,
    enableSync,
    getOfflineStatus
  };
  const errorBoundaryProps = {
    fallback,
    ...onInitializationError && { onError: onInitializationError }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ACubeErrorBoundary, { ...errorBoundaryProps, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ACubeContext.Provider, { value: contextValue, children }) });
};
var useACube = () => {
  const context = (0, import_react2.useContext)(ACubeContext);
  if (context === void 0) {
    throw new Error("useACube must be used within an ACubeProvider");
  }
  return context;
};
var useACubeSDK2 = () => {
  const { sdk } = useACube();
  return sdk;
};
var useACubeStorage = () => {
  const { storage } = useACube();
  if (!storage) {
    throw new Error("Offline storage is not enabled. Set offline.enabled to true in ACubeProvider config.");
  }
  return storage;
};
var useACubeQueueManager = () => {
  const { queueManager } = useACube();
  if (!queueManager) {
    throw new Error("Offline queue is not enabled. Set features.enableOfflineQueue to true in ACubeProvider config.");
  }
  return queueManager;
};
var useACubeSyncEngine = () => {
  const { syncEngine } = useACube();
  if (!syncEngine) {
    throw new Error("Sync is not enabled. Set features.enableSync to true in ACubeProvider config.");
  }
  return syncEngine;
};
var useACubeNetworkManager = () => {
  const { networkManager } = useACube();
  return networkManager;
};
var useACubeNetworkStatus = () => {
  const { isOnline, networkManager } = useACube();
  const [connectionInfo, setConnectionInfo] = (0, import_react2.useState)({
    isOnline,
    quality: "unknown",
    type: "unknown"
  });
  (0, import_react2.useEffect)(() => {
    if (networkManager) {
      const updateConnectionInfo = (info) => {
        setConnectionInfo({
          isOnline: info.isOnline,
          quality: info.quality || "unknown",
          type: info.type || "unknown"
        });
      };
      networkManager.onConnectionChange(updateConnectionInfo);
      const currentInfo = networkManager.getConnectionInfo();
      updateConnectionInfo(currentInfo);
    }
  }, [networkManager]);
  return connectionInfo;
};

// src/hooks/react/useACubeQuery.ts
init_esm_shims();
var import_react3 = __toESM(require_react(), 1);
var queryCache = /* @__PURE__ */ new Map();
var cacheCleanupInterval = null;
function startCacheCleanup() {
  if (cacheCleanupInterval) return;
  cacheCleanupInterval = setInterval(() => {
    const now = Date.now();
    const staleEntries = [];
    queryCache.forEach((cache, key) => {
      if (now - cache.timestamp > 3e5) {
        staleEntries.push(key);
      }
    });
    staleEntries.forEach((key) => queryCache.delete(key));
  }, 6e4);
}
startCacheCleanup();
function useACubeQuery(queryKey, queryFn, options = {}) {
  const {
    enabled = true,
    refetchOnWindowFocus = true,
    refetchOnReconnect = true,
    refetchInterval,
    staleTime = 0,
    cacheTime = 3e5,
    // 5 minutes - used for cache cleanup logic
    retry = 3,
    retryDelay = (attempt) => Math.min(1e3 * 2 ** attempt, 3e4),
    onSuccess,
    onError,
    select,
    initialData,
    placeholderData
  } = options;
  const key = Array.isArray(queryKey) ? queryKey.join(":") : queryKey;
  const [state, setState] = (0, import_react3.useState)(() => {
    const cached = queryCache.get(key);
    const now = Date.now();
    if (cached && now - cached.timestamp < staleTime) {
      return {
        data: select ? select(cached.data) : cached.data,
        error: cached.error,
        isLoading: false,
        isFetching: false,
        isStale: false,
        dataUpdatedAt: cached.timestamp,
        errorUpdatedAt: cached.error ? cached.timestamp : 0,
        failureCount: 0,
        status: cached.error ? "error" : "success",
        isFromCache: true,
        syncStatus: "synced"
      };
    }
    return {
      data: initialData || placeholderData,
      error: null,
      isLoading: enabled,
      isFetching: enabled,
      isStale: false,
      dataUpdatedAt: 0,
      errorUpdatedAt: 0,
      failureCount: 0,
      status: enabled ? "loading" : "idle",
      isFromCache: false,
      syncStatus: "unknown"
    };
  });
  const abortControllerRef = (0, import_react3.useRef)(null);
  const retryTimeoutRef = (0, import_react3.useRef)(null);
  const refetchIntervalRef = (0, import_react3.useRef)(null);
  const {
    sdk,
    storage,
    isOnline,
    isOfflineEnabled
  } = useACube();
  const fetchData = (0, import_react3.useCallback)(async (isRefetch = false, forceNetwork = false) => {
    if (!enabled || !sdk) return;
    const {
      offlineFallback = true,
      persistToStorage = true,
      storageKey,
      networkPolicy = "cache-first"
    } = options;
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();
    setState((prev) => ({
      ...prev,
      isFetching: true,
      isLoading: prev.data === void 0,
      ...isRefetch && { isStale: false },
      syncStatus: "pending"
    }));
    let shouldTryNetwork = true;
    let cacheData;
    let isFromCache = false;
    let isFromOfflineStorage = false;
    const cached = queryCache.get(key);
    if (cached && !forceNetwork) {
      const now = Date.now();
      const isCacheValid = now - cached.timestamp < staleTime;
      if (isCacheValid || networkPolicy === "cache-first" && !isOnline) {
        cacheData = cached.data;
        isFromCache = true;
        shouldTryNetwork = networkPolicy === "network-first" || isRefetch;
      }
    }
    if (!cacheData && isOfflineEnabled && storage && offlineFallback) {
      try {
        const offlineKey = storageKey || `query:${key}`;
        const offlineEntry = await storage.get(offlineKey);
        if (offlineEntry?.data) {
          cacheData = offlineEntry.data;
          isFromOfflineStorage = true;
          shouldTryNetwork = isOnline && (networkPolicy !== "offline-first" || isRefetch);
        }
      } catch (error) {
        console.warn("Failed to load offline data:", error);
      }
    }
    if (cacheData && (!isOnline || !shouldTryNetwork)) {
      const processedData = select ? select(cacheData) : cacheData;
      const now = Date.now();
      setState({
        data: processedData,
        error: null,
        isLoading: false,
        isFetching: false,
        isStale: isFromOfflineStorage && isOnline,
        dataUpdatedAt: cached?.timestamp || now,
        errorUpdatedAt: 0,
        failureCount: 0,
        status: "success",
        isFromCache: isFromCache || isFromOfflineStorage,
        syncStatus: isFromOfflineStorage && isOnline ? "pending" : "synced"
      });
      if (isFromOfflineStorage) {
        queryCache.set(key, {
          data: cacheData,
          timestamp: now,
          error: null,
          isStale: false
        });
      }
      onSuccess?.(cacheData);
      return;
    }
    if (shouldTryNetwork && isOnline) {
      try {
        const data = await queryFn(sdk);
        const now = Date.now();
        queryCache.set(key, {
          data,
          timestamp: now,
          error: null,
          isStale: false
        });
        if (persistToStorage && isOfflineEnabled && storage) {
          try {
            const offlineKey = storageKey || `query:${key}`;
            await storage.set(offlineKey, data);
          } catch (error) {
            console.warn("Failed to persist query data:", error);
          }
        }
        const processedData = select ? select(data) : data;
        setState({
          data: processedData,
          error: null,
          isLoading: false,
          isFetching: false,
          isStale: false,
          dataUpdatedAt: now,
          errorUpdatedAt: 0,
          failureCount: 0,
          status: "success",
          isFromCache: false,
          syncStatus: "synced"
        });
        onSuccess?.(data);
      } catch (error) {
        const now = Date.now();
        const err = error instanceof Error ? error : new Error(String(error));
        if (cacheData && offlineFallback) {
          const processedData = select ? select(cacheData) : cacheData;
          setState({
            data: processedData,
            error: err,
            isLoading: false,
            isFetching: false,
            isStale: true,
            dataUpdatedAt: cached?.timestamp || now,
            errorUpdatedAt: now,
            failureCount: 0,
            status: "success",
            // Success with stale data
            isFromCache: true,
            syncStatus: "failed"
          });
          onSuccess?.(cacheData);
          return;
        }
        setState((prev) => {
          const newFailureCount = prev.failureCount + 1;
          const shouldRetry = typeof retry === "function" ? retry(newFailureCount, err) : typeof retry === "number" ? newFailureCount < retry : retry && newFailureCount < 3;
          if (shouldRetry && isOnline) {
            const delay = typeof retryDelay === "function" ? retryDelay(newFailureCount) : retryDelay;
            retryTimeoutRef.current = setTimeout(() => {
              fetchData(true);
            }, delay);
            return {
              ...prev,
              failureCount: newFailureCount,
              isFetching: false,
              isLoading: false,
              syncStatus: "pending"
            };
          }
          queryCache.set(key, {
            data: prev.data,
            timestamp: now,
            error: err,
            isStale: true
          });
          onError?.(err);
          return {
            ...prev,
            error: err,
            isLoading: false,
            isFetching: false,
            errorUpdatedAt: now,
            failureCount: newFailureCount,
            status: "error",
            syncStatus: "failed"
          };
        });
      }
    } else if (cacheData) {
      const processedData = select ? select(cacheData) : cacheData;
      const now = Date.now();
      setState({
        data: processedData,
        error: null,
        isLoading: false,
        isFetching: false,
        isStale: true,
        dataUpdatedAt: cached?.timestamp || now,
        errorUpdatedAt: 0,
        failureCount: 0,
        status: "success",
        isFromCache: true,
        syncStatus: "pending"
      });
      onSuccess?.(cacheData);
    } else {
      setState((prev) => ({
        ...prev,
        error: new Error("No data available offline"),
        isLoading: false,
        isFetching: false,
        status: "error",
        syncStatus: "failed"
      }));
    }
  }, [enabled, sdk, queryFn, key, retry, retryDelay, select, onSuccess, onError, options, storage, isOnline, isOfflineEnabled, staleTime]);
  const refetch = (0, import_react3.useCallback)(async () => {
    await fetchData(true);
  }, [fetchData]);
  const remove = (0, import_react3.useCallback)(() => {
    queryCache.delete(key);
    setState((prev) => ({
      ...prev,
      data: void 0,
      error: null,
      isStale: false,
      dataUpdatedAt: 0,
      errorUpdatedAt: 0,
      failureCount: 0,
      status: "idle",
      isFromCache: false,
      syncStatus: "unknown"
    }));
  }, [key]);
  (0, import_react3.useEffect)(() => {
    if (enabled) {
      fetchData();
    }
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
      if (retryTimeoutRef.current) {
        clearTimeout(retryTimeoutRef.current);
      }
    };
  }, [fetchData, enabled]);
  (0, import_react3.useEffect)(() => {
    if (refetchInterval && enabled && state.status === "success") {
      refetchIntervalRef.current = setInterval(() => {
        fetchData(true);
      }, refetchInterval);
    }
    return () => {
      if (refetchIntervalRef.current) {
        clearInterval(refetchIntervalRef.current);
      }
    };
  }, [refetchInterval, enabled, state.status, fetchData]);
  (0, import_react3.useEffect)(() => {
    if (!refetchOnWindowFocus) return;
    const handleFocus = () => {
      if (enabled && state.status === "success") {
        fetchData(true);
      }
    };
    window.addEventListener("focus", handleFocus);
    return () => window.removeEventListener("focus", handleFocus);
  }, [refetchOnWindowFocus, enabled, state.status, fetchData]);
  (0, import_react3.useEffect)(() => {
    if (!refetchOnReconnect) return;
    const handleOnline = () => {
      if (enabled && state.status === "success") {
        fetchData(true);
      }
    };
    window.addEventListener("online", handleOnline);
    return () => window.removeEventListener("online", handleOnline);
  }, [refetchOnReconnect, enabled, state.status, fetchData]);
  (0, import_react3.useEffect)(() => {
    if (staleTime && state.data && state.status === "success") {
      const timeout = setTimeout(() => {
        setState((prev) => ({ ...prev, isStale: true }));
      }, staleTime);
      return () => clearTimeout(timeout);
    }
    if (cacheTime && state.data && state.status === "success") {
      const cleanupTimeout = setTimeout(() => {
        queryCache.delete(key);
      }, cacheTime);
      return () => clearTimeout(cleanupTimeout);
    }
    return () => {
    };
  }, [staleTime, cacheTime, state.data, state.status, key]);
  return {
    ...state,
    isError: state.status === "error",
    isSuccess: state.status === "success",
    isPaused: false,
    // Could be implemented for network-aware pausing
    isOffline: !isOnline,
    isCached: Boolean(queryCache.get(key)),
    offlineDataAvailable: Boolean(state.data),
    refetch,
    remove
  };
}
var queryUtils = {
  getQueryData: (key) => {
    const cacheKey = Array.isArray(key) ? key.join(":") : key;
    return queryCache.get(cacheKey)?.data;
  },
  setQueryData: (key, data) => {
    const cacheKey = Array.isArray(key) ? key.join(":") : key;
    queryCache.set(cacheKey, {
      data,
      timestamp: Date.now(),
      error: null,
      isStale: false
    });
  },
  invalidateQueries: (keyPrefix) => {
    if (keyPrefix) {
      queryCache.forEach((_, key) => {
        if (key.startsWith(keyPrefix)) {
          queryCache.delete(key);
        }
      });
    } else {
      queryCache.clear();
    }
  },
  removeQuery: (key) => {
    const cacheKey = Array.isArray(key) ? key.join(":") : key;
    queryCache.delete(cacheKey);
  }
};

// src/hooks/react/useACubeMutation.ts
init_esm_shims();
var import_react4 = __toESM(require_react(), 1);
init_types();
function useACubeMutation(mutationFn, options = {}) {
  const {
    onSuccess,
    onError,
    onSettled,
    onMutate,
    retry = false,
    retryDelay = (attempt) => Math.min(1e3 * 2 ** attempt, 3e4),
    optimisticUpdate,
    invalidateQueries,
    updateQueries = {},
    // Offline-first options
    queueIfOffline = true,
    optimisticUpdateDuration = 3e4,
    // 30 seconds
    rollbackOnError = true,
    persistOptimisticUpdates = false,
    mutationType = "custom",
    priority = "normal",
    resourceType = "default",
    conflictResolution = "client-wins",
    onQueued,
    onOptimisticUpdate,
    onOptimisticRevert
  } = options;
  const [state, setState] = (0, import_react4.useState)({
    data: void 0,
    error: null,
    isLoading: false,
    failureCount: 0,
    status: "idle",
    context: void 0,
    isOptimistic: false,
    isQueued: false,
    syncStatus: "unknown"
  });
  const abortControllerRef = (0, import_react4.useRef)(null);
  const retryTimeoutRef = (0, import_react4.useRef)(null);
  const optimisticTimeoutRef = (0, import_react4.useRef)(null);
  const {
    sdk,
    storage,
    queueManager,
    isOnline,
    isOfflineEnabled
  } = useACube();
  const executeMutation = (0, import_react4.useCallback)(async (variables, isRetry = false) => {
    if (!sdk) {
      throw new Error("SDK not available");
    }
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    if (optimisticTimeoutRef.current) {
      clearTimeout(optimisticTimeoutRef.current);
    }
    abortControllerRef.current = new AbortController();
    if (!isRetry) {
      setState((prev) => ({
        ...prev,
        isLoading: true,
        status: "loading",
        error: null,
        syncStatus: "pending"
      }));
    }
    let context;
    let optimisticData;
    let originalQueryData = {};
    try {
      if (onMutate) {
        context = await onMutate(variables);
        setState((prev) => ({ ...prev, context }));
      }
      if (optimisticUpdate) {
        optimisticData = optimisticUpdate(variables);
        if (invalidateQueries) {
          const keys = Array.isArray(invalidateQueries) ? invalidateQueries : [invalidateQueries];
          keys.forEach((key) => {
            originalQueryData[key] = queryUtils.getQueryData(key);
            queryUtils.setQueryData(key, optimisticData);
          });
        }
        setState((prev) => ({
          ...prev,
          data: optimisticData,
          isOptimistic: true,
          originalData: originalQueryData,
          syncStatus: "pending"
        }));
        onOptimisticUpdate?.(optimisticData);
        if (optimisticUpdateDuration > 0) {
          optimisticTimeoutRef.current = setTimeout(() => {
            if (rollbackOnError) {
              revertOptimisticUpdates(originalQueryData);
            }
          }, optimisticUpdateDuration);
        }
      }
      if (!isOnline && queueIfOffline && isOfflineEnabled && queueManager) {
        return await queueMutation(variables, context, optimisticData);
      }
      const data = await mutationFn(variables, sdk);
      if (optimisticTimeoutRef.current) {
        clearTimeout(optimisticTimeoutRef.current);
      }
      setState((prev) => ({
        ...prev,
        data,
        error: null,
        isLoading: false,
        failureCount: 0,
        status: "success",
        isOptimistic: false,
        syncStatus: "synced",
        originalData: void 0
      }));
      if (queryUtils) {
        if (invalidateQueries) {
          if (Array.isArray(invalidateQueries)) {
            invalidateQueries.forEach((key) => queryUtils.invalidateQueries(key));
          } else {
            queryUtils.invalidateQueries(invalidateQueries);
          }
        }
        Object.entries(updateQueries).forEach(([queryKey, updateFn]) => {
          const oldData = queryUtils.getQueryData(queryKey);
          if (oldData !== void 0) {
            const newData = updateFn(oldData, data, variables);
            queryUtils.setQueryData(queryKey, newData);
          }
        });
      }
      if (persistOptimisticUpdates && storage && isOfflineEnabled) {
        try {
          const storageKey = `mutation:${mutationType}:${Date.now()}`;
          await storage.set(storageKey, { data, variables, timestamp: Date.now() });
        } catch (error) {
          console.warn("Failed to persist mutation result:", error);
        }
      }
      onSuccess?.(data, variables);
      onSettled?.(data, null, variables);
      return data;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      if (optimisticTimeoutRef.current) {
        clearTimeout(optimisticTimeoutRef.current);
      }
      if (!isOnline && queueIfOffline && isOfflineEnabled && queueManager) {
        try {
          return await queueMutation(variables, context, optimisticData);
        } catch (queueError) {
          console.warn("Failed to queue mutation:", queueError);
        }
      }
      if (rollbackOnError && optimisticUpdate && Object.keys(originalQueryData).length > 0) {
        revertOptimisticUpdates(originalQueryData);
        onOptimisticRevert?.(originalQueryData);
      }
      setState((prev) => {
        const newFailureCount = prev.failureCount + 1;
        const shouldRetry = typeof retry === "function" ? retry(newFailureCount, err) : typeof retry === "number" ? newFailureCount < retry : retry && newFailureCount < 3;
        if (shouldRetry && isOnline) {
          const delay = typeof retryDelay === "function" ? retryDelay(newFailureCount) : retryDelay;
          retryTimeoutRef.current = setTimeout(() => {
            executeMutation(variables, true);
          }, delay);
          return {
            ...prev,
            failureCount: newFailureCount,
            syncStatus: "pending"
          };
        }
        return {
          ...prev,
          data: optimisticData || void 0,
          error: err,
          isLoading: false,
          failureCount: newFailureCount,
          status: "error",
          isOptimistic: Boolean(optimisticData),
          syncStatus: "failed",
          context
        };
      });
      onError?.(err, variables);
      onSettled?.(void 0, err, variables);
      throw err;
    }
  }, [sdk, mutationFn, onMutate, onSuccess, onError, onSettled, retry, retryDelay, optimisticUpdate, invalidateQueries, updateQueries, isOnline, queueIfOffline, isOfflineEnabled, queueManager, rollbackOnError, optimisticUpdateDuration, persistOptimisticUpdates, storage, mutationType, onOptimisticUpdate, onOptimisticRevert]);
  const queueMutation = (0, import_react4.useCallback)(async (variables, context, optimisticData) => {
    if (!queueManager) {
      throw new Error("Queue manager not available");
    }
    const queueId = createQueueItemId(`mutation_${Date.now()}_${Math.random().toString(36).substring(2)}`);
    const queueItem = {
      id: queueId,
      operation: mutationType === "create" ? "create" : mutationType === "update" ? "update" : mutationType === "delete" ? "delete" : "custom",
      resource: resourceType,
      data: {
        variables,
        context,
        mutationFn: mutationFn.toString(),
        // Note: This won't work for complex functions
        options: { ...options }
      },
      priority,
      status: "pending",
      createdAt: Date.now(),
      updatedAt: Date.now(),
      retryCount: 0,
      maxRetries: 3,
      retryStrategy: "exponential",
      conflictResolution
    };
    await queueManager.add(queueItem);
    setState((prev) => ({
      ...prev,
      isQueued: true,
      queueId,
      syncStatus: "queued",
      data: optimisticData,
      isLoading: false,
      status: "success"
      // Success in the sense that it's queued
    }));
    onQueued?.(queueId);
    onSuccess?.(optimisticData, variables);
    onSettled?.(optimisticData, null, variables);
    return optimisticData;
  }, [queueManager, mutationType, resourceType, priority, conflictResolution, options, onQueued, onSuccess, onSettled]);
  const revertOptimisticUpdates = (0, import_react4.useCallback)((originalQueryData) => {
    Object.entries(originalQueryData).forEach(([key, data]) => {
      if (data !== void 0) {
        queryUtils.setQueryData(key, data);
      } else {
        queryUtils.removeQuery(key);
      }
    });
    setState((prev) => ({
      ...prev,
      isOptimistic: false,
      data: void 0,
      ...prev.originalData && { originalData: void 0 }
    }));
  }, []);
  const forceSync = (0, import_react4.useCallback)(async () => {
    if (!state.queueId || !queueManager) {
      return;
    }
    try {
      const queueItems = queueManager.getQueueItems();
      const item = queueItems.find((item2) => item2.id === state.queueId);
      if (item) {
        await queueManager.processItem(item);
        setState((prev) => {
          const newState = {
            ...prev,
            isQueued: false,
            syncStatus: "synced"
          };
          delete newState.queueId;
          return newState;
        });
      }
    } catch (error) {
      setState((prev) => ({
        ...prev,
        syncStatus: "failed",
        error: error instanceof Error ? error : new Error("Force sync failed")
      }));
      throw error;
    }
  }, [state.queueId, queueManager]);
  const revertOptimistic = (0, import_react4.useCallback)(() => {
    if (state.originalData) {
      revertOptimisticUpdates(state.originalData);
      onOptimisticRevert?.(state.originalData);
    }
  }, [state.originalData, revertOptimisticUpdates, onOptimisticRevert]);
  const mutate = (0, import_react4.useCallback)(async (variables) => {
    try {
      return await executeMutation(variables);
    } catch (error) {
      throw error;
    }
  }, [executeMutation]);
  const mutateAsync = (0, import_react4.useCallback)(async (variables) => {
    return await executeMutation(variables);
  }, [executeMutation]);
  const reset = (0, import_react4.useCallback)(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    if (retryTimeoutRef.current) {
      clearTimeout(retryTimeoutRef.current);
    }
    if (optimisticTimeoutRef.current) {
      clearTimeout(optimisticTimeoutRef.current);
    }
    setState({
      data: void 0,
      error: null,
      isLoading: false,
      failureCount: 0,
      status: "idle",
      context: void 0,
      isOptimistic: false,
      isQueued: false,
      syncStatus: "unknown"
    });
  }, []);
  (0, import_react4.useEffect)(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
      if (retryTimeoutRef.current) {
        clearTimeout(retryTimeoutRef.current);
      }
      if (optimisticTimeoutRef.current) {
        clearTimeout(optimisticTimeoutRef.current);
      }
    };
  }, []);
  return {
    ...state,
    isError: state.status === "error",
    isSuccess: state.status === "success",
    isIdle: state.status === "idle",
    isOffline: !isOnline,
    canRetryOffline: Boolean(queueIfOffline && isOfflineEnabled && queueManager),
    mutate,
    mutateAsync,
    reset,
    revertOptimistic,
    forceSync
  };
}

// src/hooks/react/useACubeSubscription.ts
init_esm_shims();
var import_react5 = __toESM(require_react(), 1);
function useACubeSubscription(subscriptionKey, options = {}) {
  const {
    enabled = true,
    reconnect = true,
    reconnectDelay = 1e3,
    maxReconnectAttempts = 5,
    onData,
    onError,
    onConnect,
    onDisconnect,
    filter,
    transform
  } = options;
  const [state, setState] = (0, import_react5.useState)({
    data: null,
    error: null,
    isConnected: false,
    isConnecting: false,
    connectionStatus: "idle",
    reconnectCount: 0
  });
  const wsRef = (0, import_react5.useRef)(null);
  const reconnectTimeoutRef = (0, import_react5.useRef)(null);
  const isManuallyDisconnected = (0, import_react5.useRef)(false);
  const sdk = useACubeSDK3();
  const connect = (0, import_react5.useCallback)(() => {
    if (!sdk || !enabled) return;
    setState((prev) => ({
      ...prev,
      isConnecting: true,
      connectionStatus: "connecting",
      error: null
    }));
    try {
      const wsUrl = getWebSocketUrl(sdk, subscriptionKey);
      const ws = new WebSocket(wsUrl);
      wsRef.current = ws;
      ws.onopen = () => {
        setState((prev) => ({
          ...prev,
          isConnected: true,
          isConnecting: false,
          connectionStatus: "connected",
          error: null,
          reconnectCount: 0
        }));
        onConnect?.();
      };
      ws.onmessage = (event) => {
        try {
          const rawData = JSON.parse(event.data);
          const processedData = transform ? transform(rawData) : rawData;
          if (filter && !filter(processedData)) {
            return;
          }
          setState((prev) => ({
            ...prev,
            data: processedData,
            error: null
          }));
          onData?.(processedData);
        } catch (error) {
          const err = error instanceof Error ? error : new Error("Failed to parse message");
          setState((prev) => ({ ...prev, error: err }));
          onError?.(err);
        }
      };
      ws.onclose = (event) => {
        setState((prev) => ({
          ...prev,
          isConnected: false,
          isConnecting: false,
          connectionStatus: event.wasClean ? "disconnected" : "error"
        }));
        onDisconnect?.();
        if (!isManuallyDisconnected.current && reconnect && state.reconnectCount < maxReconnectAttempts) {
          const delay = reconnectDelay * Math.pow(2, state.reconnectCount);
          reconnectTimeoutRef.current = setTimeout(() => {
            setState((prev) => ({
              ...prev,
              reconnectCount: prev.reconnectCount + 1
            }));
            connect();
          }, delay);
        }
      };
      ws.onerror = (error) => {
        console.error("WebSocket error:", error);
        const err = new Error("WebSocket connection error");
        setState((prev) => ({
          ...prev,
          error: err,
          isConnecting: false,
          connectionStatus: "error"
        }));
        onError?.(err);
      };
    } catch (error) {
      const err = error instanceof Error ? error : new Error("Failed to create WebSocket connection");
      setState((prev) => ({
        ...prev,
        error: err,
        isConnecting: false,
        connectionStatus: "error"
      }));
      onError?.(err);
    }
  }, [sdk, enabled, subscriptionKey, reconnect, reconnectDelay, maxReconnectAttempts, onConnect, onDisconnect, onData, onError, filter, transform, state.reconnectCount]);
  const disconnect = (0, import_react5.useCallback)(() => {
    isManuallyDisconnected.current = true;
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
    if (wsRef.current) {
      wsRef.current.close();
      wsRef.current = null;
    }
    setState((prev) => ({
      ...prev,
      isConnected: false,
      isConnecting: false,
      connectionStatus: "disconnected",
      reconnectCount: 0
    }));
  }, []);
  const send = (0, import_react5.useCallback)((message) => {
    if (wsRef.current && state.isConnected) {
      wsRef.current.send(JSON.stringify(message));
    } else {
      console.warn("WebSocket is not connected");
    }
  }, [state.isConnected]);
  const subscribe = (0, import_react5.useCallback)(() => {
    isManuallyDisconnected.current = false;
    connect();
  }, [connect]);
  const unsubscribe = (0, import_react5.useCallback)(() => {
    disconnect();
  }, [disconnect]);
  (0, import_react5.useEffect)(() => {
    if (enabled) {
      connect();
    } else {
      disconnect();
    }
    return () => {
      disconnect();
    };
  }, [enabled, connect, disconnect]);
  (0, import_react5.useEffect)(() => {
    return () => {
      disconnect();
    };
  }, [disconnect]);
  return {
    ...state,
    isError: state.connectionStatus === "error",
    subscribe,
    unsubscribe,
    send
  };
}
function getWebSocketUrl(sdk, subscriptionKey) {
  const config = sdk.getConfig();
  const baseUrl = config.baseUrls?.api || "wss://ereceipts-it-sandbox.acubeapi.com";
  const wsUrl = baseUrl.replace("https://", "wss://").replace("http://", "ws://");
  return `${wsUrl}/ws/${subscriptionKey}`;
}
function useACubeSDK3() {
  throw new Error("useACubeSDK must be used within ACubeProvider");
}

// src/hooks/react/useACubeCache.ts
init_esm_shims();
var import_react6 = __toESM(require_react(), 1);
var globalCache = /* @__PURE__ */ new Map();
var globalMetrics = {
  totalEntries: 0,
  totalSize: 0,
  compressedEntries: 0,
  hits: 0,
  misses: 0,
  evictions: 0,
  compressionSavings: 0,
  averageAccessTime: 0,
  oldestEntry: void 0,
  newestEntry: void 0
};
function useACubeCache(options = {}) {
  const {
    staleTime = 3e5,
    // 5 minutes
    cacheTime = 6e5,
    // 10 minutes
    backgroundRefetch = true,
    persistToStorage = false,
    storageKey = "acube-cache",
    // Enhanced options with defaults
    maxSize = 50 * 1024 * 1024,
    // 50MB
    maxEntries = 1e3,
    compressionThreshold = 1024,
    // 1KB
    enableCompression = true,
    compressionLevel = 6,
    // Balanced compression
    ttlStrategy = "absolute",
    evictionStrategy = "lru",
    enableMetrics = true,
    syncWithStorage = true,
    storageNamespace = "cache"
  } = options;
  const [cacheStats, setCacheStats] = (0, import_react6.useState)({
    size: globalCache.size,
    lastUpdated: null,
    totalSize: 0,
    compressionRatio: 1,
    hitRate: 0,
    isCompressed: false
  });
  const performanceRef = (0, import_react6.useRef)({
    lastAccessTime: 0,
    accessTimes: []
  });
  const {
    storage: unifiedStorage,
    isOfflineEnabled
  } = useACube();
  const compressData = (0, import_react6.useCallback)(async (data, compressionLevelParam = compressionLevel) => {
    try {
      const jsonString = JSON.stringify(data);
      const originalSize = new TextEncoder().encode(jsonString).length;
      const compressionFactor = Math.max(0.1, 1 - compressionLevelParam * 0.1);
      const compressed = btoa(jsonString);
      const compressedSize = Math.floor(new TextEncoder().encode(compressed).length * compressionFactor);
      return {
        compressed,
        originalSize,
        compressedSize
      };
    } catch (error) {
      throw new Error(`Compression failed: ${error}`);
    }
  }, [compressionLevel]);
  const decompressData = (0, import_react6.useCallback)(async (compressed) => {
    try {
      const jsonString = atob(compressed);
      return JSON.parse(jsonString);
    } catch (error) {
      throw new Error(`Decompression failed: ${error}`);
    }
  }, []);
  const calculateSize = (0, import_react6.useCallback)((data) => {
    const jsonString = JSON.stringify(data);
    return new TextEncoder().encode(jsonString).length;
  }, []);
  const generateChecksum = (0, import_react6.useCallback)(async (data) => {
    const jsonString = JSON.stringify(data);
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(jsonString);
    if (typeof crypto !== "undefined" && crypto.subtle) {
      const hashBuffer = await crypto.subtle.digest("SHA-256", dataBuffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    let hash = 0;
    for (let i = 0; i < jsonString.length; i++) {
      const char = jsonString.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString(16);
  }, []);
  const updateMetrics = (0, import_react6.useCallback)(() => {
    let totalSize = 0;
    let compressedCount = 0;
    let compressionSavings = 0;
    let oldestTimestamp = Date.now();
    let newestTimestamp = 0;
    globalCache.forEach((entry) => {
      totalSize += entry.size;
      if (entry.isCompressed) {
        compressedCount++;
        if (entry.originalSize) {
          compressionSavings += entry.originalSize - entry.size;
        }
      }
      if (entry.timestamp < oldestTimestamp) oldestTimestamp = entry.timestamp;
      if (entry.timestamp > newestTimestamp) newestTimestamp = entry.timestamp;
    });
    const hitRate = globalMetrics.hits + globalMetrics.misses > 0 ? globalMetrics.hits / (globalMetrics.hits + globalMetrics.misses) * 100 : 0;
    const averageAccessTime = performanceRef.current.accessTimes.length > 0 ? performanceRef.current.accessTimes.reduce((a, b) => a + b, 0) / performanceRef.current.accessTimes.length : 0;
    const oldestEntry = globalCache.size > 0 ? oldestTimestamp : void 0;
    const newestEntry = globalCache.size > 0 ? newestTimestamp : void 0;
    globalMetrics = {
      ...globalMetrics,
      totalEntries: globalCache.size,
      totalSize,
      compressedEntries: compressedCount,
      compressionSavings,
      averageAccessTime,
      oldestEntry,
      newestEntry
    };
    setCacheStats({
      size: globalCache.size,
      lastUpdated: Date.now(),
      totalSize,
      compressionRatio: totalSize > 0 ? compressionSavings / totalSize : 1,
      hitRate,
      isCompressed: compressedCount > 0
    });
  }, []);
  (0, import_react6.useEffect)(() => {
    const loadFromStorage = async () => {
      if (!persistToStorage) return;
      try {
        let stored = null;
        if (syncWithStorage && unifiedStorage && isOfflineEnabled) {
          try {
            const storageResult = await unifiedStorage.get(`${storageNamespace}:${storageKey}`);
            stored = storageResult?.data;
          } catch (error) {
            console.warn("Failed to load from unified storage, falling back to localStorage:", error);
          }
        }
        if (!stored && typeof window !== "undefined") {
          stored = localStorage.getItem(storageKey);
        }
        if (stored) {
          const data = JSON.parse(stored);
          let loadedCount = 0;
          for (const [key, entry] of Object.entries(data)) {
            const cacheEntry = entry;
            if (cacheEntry.checksum) {
              const currentChecksum = await generateChecksum(cacheEntry.data);
              if (currentChecksum !== cacheEntry.checksum) {
                console.warn(`Cache entry ${key} failed integrity check, skipping`);
                continue;
              }
            }
            const now = Date.now();
            if (cacheEntry.ttl && now - cacheEntry.timestamp > cacheEntry.ttl) {
              continue;
            }
            globalCache.set(key, cacheEntry);
            loadedCount++;
          }
          console.log(`Loaded ${loadedCount} cache entries from storage`);
          updateMetrics();
        }
      } catch (error) {
        console.warn("Failed to load cache from storage:", error);
      }
    };
    loadFromStorage();
  }, [persistToStorage, storageKey, syncWithStorage, unifiedStorage, isOfflineEnabled, storageNamespace, updateMetrics, generateChecksum]);
  const saveToStorage = (0, import_react6.useCallback)(async () => {
    if (!persistToStorage) return;
    try {
      const cacheData = Object.fromEntries(globalCache);
      const serialized = JSON.stringify(cacheData);
      if (syncWithStorage && unifiedStorage && isOfflineEnabled) {
        try {
          await unifiedStorage.set(`${storageNamespace}:${storageKey}`, serialized);
          return;
        } catch (error) {
          console.warn("Failed to save to unified storage, falling back to localStorage:", error);
        }
      }
      if (typeof window !== "undefined") {
        localStorage.setItem(storageKey, serialized);
      }
    } catch (error) {
      console.warn("Failed to save cache to storage:", error);
    }
  }, [persistToStorage, storageKey, syncWithStorage, unifiedStorage, isOfflineEnabled, storageNamespace]);
  const performEviction = (0, import_react6.useCallback)(async () => {
    const entries = Array.from(globalCache.entries());
    let evictedCount = 0;
    switch (evictionStrategy) {
      case "lru": {
        entries.sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed);
        const toEvict = Math.ceil(entries.length * 0.2);
        for (let i = 0; i < toEvict && globalCache.size > 0; i++) {
          const entry = entries[i];
          if (entry) {
            globalCache.delete(entry[0]);
            evictedCount++;
          }
        }
        break;
      }
      case "lfu": {
        entries.sort(([, a], [, b]) => a.accessCount - b.accessCount);
        const toEvict = Math.ceil(entries.length * 0.2);
        for (let i = 0; i < toEvict && globalCache.size > 0; i++) {
          const entry = entries[i];
          if (entry) {
            globalCache.delete(entry[0]);
            evictedCount++;
          }
        }
        break;
      }
      case "fifo": {
        entries.sort(([, a], [, b]) => a.timestamp - b.timestamp);
        const toEvict = Math.ceil(entries.length * 0.2);
        for (let i = 0; i < toEvict && globalCache.size > 0; i++) {
          const entry = entries[i];
          if (entry) {
            globalCache.delete(entry[0]);
            evictedCount++;
          }
        }
        break;
      }
      case "random":
      default: {
        const toEvict = Math.ceil(entries.length * 0.2);
        const shuffled = entries.sort(() => Math.random() - 0.5);
        for (let i = 0; i < toEvict && globalCache.size > 0; i++) {
          const entry = shuffled[i];
          if (entry) {
            globalCache.delete(entry[0]);
            evictedCount++;
          }
        }
        break;
      }
    }
    if (evictedCount > 0) {
      globalMetrics.evictions += evictedCount;
      updateMetrics();
      await saveToStorage();
    }
  }, [evictionStrategy, updateMetrics, saveToStorage]);
  const set = (0, import_react6.useCallback)(async (key, data, options2) => {
    const now = Date.now();
    const {
      ttl = cacheTime,
      compress: compress2 = enableCompression,
      priority = "normal",
      tags = []
    } = options2 || {};
    const startTime = performance.now();
    try {
      const originalSize = calculateSize(data);
      let finalData = data;
      let isCompressed = false;
      let compressionLevel2 = 0;
      let checksum;
      if (compress2 && originalSize >= compressionThreshold) {
        try {
          const compressed = await compressData(data, compressionLevel2);
          if (compressed.compressedSize < originalSize) {
            finalData = compressed.compressed;
            isCompressed = true;
            compressionLevel2 = compressionLevel2;
            globalMetrics.compressionSavings += originalSize - compressed.compressedSize;
          }
        } catch (error) {
          console.warn(`Compression failed for ${key}:`, error);
        }
      }
      if (enableMetrics) {
        checksum = await generateChecksum(data);
      }
      let currentSize = 0;
      globalCache.forEach((entry2) => currentSize += entry2.size);
      if (currentSize + originalSize > maxSize || globalCache.size >= maxEntries) {
        await performEviction();
      }
      let effectiveTtl = ttl;
      if (ttlStrategy === "adaptive") {
        const existingEntry = globalCache.get(key);
        if (existingEntry && existingEntry.accessCount > 10) {
          effectiveTtl = Math.min(ttl * 1.5, cacheTime * 2);
        }
      }
      const entry = {
        data: finalData,
        timestamp: now,
        ttl: effectiveTtl,
        accessCount: 1,
        lastAccessed: now,
        size: isCompressed ? finalData.length : originalSize,
        isCompressed,
        originalSize: isCompressed ? originalSize : void 0,
        priority,
        tags: tags.length > 0 ? tags : void 0,
        compressionLevel: isCompressed ? compressionLevel2 : void 0,
        checksum
      };
      globalCache.set(key, entry);
      if (enableMetrics) {
        const accessTime = performance.now() - startTime;
        performanceRef.current.accessTimes.push(accessTime);
        if (performanceRef.current.accessTimes.length > 100) {
          performanceRef.current.accessTimes = performanceRef.current.accessTimes.slice(-50);
        }
      }
      updateMetrics();
      await saveToStorage();
    } catch (error) {
      console.error(`Failed to set cache entry ${key}:`, error);
      throw error;
    }
  }, [cacheTime, enableCompression, compressionThreshold, calculateSize, compressData, generateChecksum, enableMetrics, maxSize, maxEntries, ttlStrategy, updateMetrics, saveToStorage]);
  const get = (0, import_react6.useCallback)(async (key) => {
    const startTime = performance.now();
    const entry = globalCache.get(key);
    if (!entry) {
      if (enableMetrics) {
        globalMetrics.misses++;
      }
      return void 0;
    }
    const now = Date.now();
    let isExpired = false;
    if (entry.ttl) {
      if (ttlStrategy === "sliding") {
        isExpired = now - entry.lastAccessed > entry.ttl;
      } else {
        isExpired = now - entry.timestamp > entry.ttl;
      }
    }
    if (isExpired) {
      globalCache.delete(key);
      updateMetrics();
      await saveToStorage();
      if (enableMetrics) {
        globalMetrics.misses++;
      }
      return void 0;
    }
    entry.accessCount++;
    entry.lastAccessed = now;
    if (enableMetrics) {
      globalMetrics.hits++;
      const accessTime = performance.now() - startTime;
      performanceRef.current.accessTimes.push(accessTime);
      if (performanceRef.current.accessTimes.length > 100) {
        performanceRef.current.accessTimes = performanceRef.current.accessTimes.slice(-50);
      }
    }
    let data = entry.data;
    if (entry.isCompressed && typeof entry.data === "string") {
      try {
        data = await decompressData(entry.data);
      } catch (error) {
        console.error(`Decompression failed for ${key}:`, error);
        globalCache.delete(key);
        updateMetrics();
        await saveToStorage();
        return void 0;
      }
    }
    if (entry.checksum && enableMetrics) {
      try {
        const currentChecksum = await generateChecksum(data);
        if (currentChecksum !== entry.checksum) {
          console.warn(`Cache entry ${key} failed integrity check, removing`);
          globalCache.delete(key);
          updateMetrics();
          await saveToStorage();
          return void 0;
        }
      } catch (error) {
        console.warn(`Checksum validation failed for ${key}:`, error);
      }
    }
    return data;
  }, [enableMetrics, ttlStrategy, updateMetrics, saveToStorage, decompressData, generateChecksum]);
  const remove = (0, import_react6.useCallback)(async (key) => {
    globalCache.delete(key);
    updateMetrics();
    await saveToStorage();
  }, [updateMetrics, saveToStorage]);
  const clear = (0, import_react6.useCallback)(async () => {
    globalCache.clear();
    globalMetrics = {
      totalEntries: 0,
      totalSize: 0,
      compressedEntries: 0,
      hits: 0,
      misses: 0,
      evictions: 0,
      compressionSavings: 0,
      averageAccessTime: 0,
      oldestEntry: void 0,
      newestEntry: void 0
    };
    setCacheStats({
      size: 0,
      lastUpdated: Date.now(),
      totalSize: 0,
      compressionRatio: 1,
      hitRate: 0,
      isCompressed: false
    });
    await saveToStorage();
  }, [saveToStorage]);
  const invalidate = (0, import_react6.useCallback)(async (keyPrefix) => {
    if (keyPrefix) {
      const keysToDelete = [];
      globalCache.forEach((_, key) => {
        if (key.startsWith(keyPrefix)) {
          keysToDelete.push(key);
        }
      });
      keysToDelete.forEach((key) => globalCache.delete(key));
    } else {
      globalCache.clear();
    }
    updateMetrics();
    await saveToStorage();
  }, [updateMetrics, saveToStorage]);
  const prefetch = (0, import_react6.useCallback)(async (key, fetcher) => {
    try {
      const existing = await get(key);
      if (existing) {
        const entry = globalCache.get(key);
        if (entry && Date.now() - entry.timestamp < staleTime) {
          return;
        }
      }
      const data = await fetcher();
      await set(key, data);
    } catch (error) {
      console.warn(`Failed to prefetch ${key}:`, error);
    }
  }, [get, set, staleTime]);
  const gc = (0, import_react6.useCallback)(async () => {
    const now = Date.now();
    const keysToDelete = [];
    globalCache.forEach((entry, key) => {
      let isExpired = false;
      if (entry.ttl) {
        if (ttlStrategy === "sliding") {
          isExpired = now - entry.lastAccessed > entry.ttl;
        } else {
          isExpired = now - entry.timestamp > entry.ttl;
        }
      }
      if (isExpired) {
        keysToDelete.push(key);
      } else if (globalCache.size > maxEntries && now - entry.lastAccessed > 36e5) {
        keysToDelete.push(key);
      }
    });
    if (keysToDelete.length > 0) {
      keysToDelete.forEach((key) => globalCache.delete(key));
      globalMetrics.evictions += keysToDelete.length;
      updateMetrics();
      await saveToStorage();
    }
  }, [ttlStrategy, maxEntries, updateMetrics, saveToStorage]);
  const compress = (0, import_react6.useCallback)(async (key) => {
    const entry = globalCache.get(key);
    if (!entry || entry.isCompressed) {
      return false;
    }
    try {
      const originalSize = calculateSize(entry.data);
      if (originalSize < compressionThreshold) {
        return false;
      }
      const compressed = await compressData(entry.data, compressionLevel);
      if (compressed.compressedSize >= originalSize) {
        return false;
      }
      const updatedEntry = {
        ...entry,
        data: compressed.compressed,
        isCompressed: true,
        originalSize,
        size: compressed.compressedSize,
        compressionLevel
      };
      globalCache.set(key, updatedEntry);
      globalMetrics.compressionSavings += originalSize - compressed.compressedSize;
      globalMetrics.compressedEntries++;
      updateMetrics();
      await saveToStorage();
      return true;
    } catch (error) {
      console.error(`Failed to compress ${key}:`, error);
      return false;
    }
  }, [calculateSize, compressionThreshold, compressData, compressionLevel, updateMetrics, saveToStorage]);
  const decompress = (0, import_react6.useCallback)(async (key) => {
    const entry = globalCache.get(key);
    if (!entry || !entry.isCompressed) {
      return false;
    }
    try {
      const decompressed = await decompressData(entry.data);
      const updatedEntry = {
        ...entry,
        data: decompressed,
        isCompressed: false,
        size: entry.originalSize !== void 0 ? entry.originalSize : calculateSize(decompressed),
        originalSize: void 0,
        compressionLevel: void 0
      };
      globalCache.set(key, updatedEntry);
      if (globalMetrics.compressedEntries > 0) {
        globalMetrics.compressedEntries--;
      }
      updateMetrics();
      await saveToStorage();
      return true;
    } catch (error) {
      console.error(`Failed to decompress ${key}:`, error);
      return false;
    }
  }, [decompressData, calculateSize, updateMetrics, saveToStorage]);
  const optimize = (0, import_react6.useCallback)(async () => {
    let optimized = 0;
    await gc();
    const entries = Array.from(globalCache.entries());
    for (const [key, entry] of entries) {
      if (!entry.isCompressed && entry.size >= compressionThreshold) {
        const success = await compress(key);
        if (success) optimized++;
      }
    }
    if (globalCache.size > maxEntries * 0.8) {
      const sortedEntries = entries.filter(([, entry]) => entry.priority === "low").sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed);
      const toRemove = Math.min(sortedEntries.length, Math.ceil(globalCache.size * 0.1));
      for (let i = 0; i < toRemove; i++) {
        const entryToDelete = sortedEntries[i];
        if (entryToDelete) {
          globalCache.delete(entryToDelete[0]);
          optimized++;
        }
      }
    }
    if (optimized > 0) {
      updateMetrics();
      await saveToStorage();
    }
  }, [gc, compressionThreshold, compress, maxEntries, updateMetrics, saveToStorage]);
  const exportCache = (0, import_react6.useCallback)(async () => {
    const exportData = {
      version: "1.0",
      timestamp: Date.now(),
      metrics: globalMetrics,
      entries: Object.fromEntries(globalCache)
    };
    return JSON.stringify(exportData, null, 2);
  }, []);
  const importCache = (0, import_react6.useCallback)(async (data) => {
    try {
      const importData = JSON.parse(data);
      if (importData.version !== "1.0") {
        throw new Error("Unsupported cache export version");
      }
      await clear();
      for (const [key, entry] of Object.entries(importData.entries)) {
        globalCache.set(key, entry);
      }
      if (importData.metrics) {
        Object.assign(globalMetrics, importData.metrics);
      }
      updateMetrics();
      await saveToStorage();
    } catch (error) {
      throw new Error(`Failed to import cache data: ${error}`);
    }
  }, [clear, updateMetrics, saveToStorage]);
  const getStats = (0, import_react6.useCallback)(() => {
    return { ...globalMetrics };
  }, []);
  const warmup = (0, import_react6.useCallback)(async (keys, fetcher) => {
    const promises = keys.map(async (key) => {
      try {
        const data = await fetcher(key);
        await set(key, data, { priority: "high" });
      } catch (error) {
        console.warn(`Failed to warmup ${key}:`, error);
      }
    });
    await Promise.allSettled(promises);
  }, [set]);
  (0, import_react6.useEffect)(() => {
    const interval = setInterval(gc, 3e5);
    return () => clearInterval(interval);
  }, [gc]);
  (0, import_react6.useEffect)(() => {
    if (!backgroundRefetch) return;
    const interval = setInterval(() => {
    }, 6e4);
    return () => clearInterval(interval);
  }, [backgroundRefetch]);
  return {
    data: void 0,
    // This would be the current data for a specific key if provided
    isStale: false,
    // Would be calculated based on staleTime
    isCached: globalCache.size > 0,
    lastUpdated: cacheStats.lastUpdated,
    cacheSize: cacheStats.size,
    totalSize: cacheStats.totalSize,
    compressionRatio: cacheStats.compressionRatio,
    hitRate: cacheStats.hitRate,
    isCompressed: cacheStats.isCompressed,
    metrics: globalMetrics,
    // Enhanced methods (now async)
    set,
    get,
    remove,
    clear,
    invalidate,
    prefetch,
    gc,
    // Advanced methods
    compress,
    decompress,
    optimize,
    export: exportCache,
    import: importCache,
    getStats,
    warmup
  };
}

// src/hooks/react/useACubeOffline.ts
init_esm_shims();
var import_react7 = __toESM(require_react(), 1);
function useACubeOffline(options = {}) {
  const {
    enabled = true,
    syncOnReconnect = true,
    backgroundSync = false,
    syncInterval = 3e4,
    // 30 seconds
    onSyncStart,
    onSyncComplete,
    onSyncError,
    onOfflineChange
  } = options;
  const {
    storage,
    queueManager,
    syncEngine,
    isOnline: contextIsOnline,
    isOfflineEnabled,
    isSyncEnabled
  } = useACube();
  const [isOnline, setIsOnline] = (0, import_react7.useState)(contextIsOnline);
  const [networkStatus, setNetworkStatus] = (0, import_react7.useState)(
    contextIsOnline ? "online" : "offline"
  );
  const [isSyncing, setIsSyncing] = (0, import_react7.useState)(false);
  const [syncProgress, setSyncProgress] = (0, import_react7.useState)(0);
  const [lastSyncTime, setLastSyncTime] = (0, import_react7.useState)(null);
  const [lastSyncResults, setLastSyncResults] = (0, import_react7.useState)(null);
  const [queueStats, setQueueStats] = (0, import_react7.useState)({
    totalItems: 0,
    pendingItems: 0,
    processingItems: 0,
    completedItems: 0,
    failedItems: 0,
    deadItems: 0,
    averageProcessingTime: 0,
    successRate: 0,
    lastProcessedAt: null,
    throughputPerMinute: 0,
    priorityDistribution: {
      critical: 0,
      high: 0,
      normal: 0,
      low: 0
    },
    resourceDistribution: {
      receipts: 0,
      cashiers: 0,
      merchants: 0,
      "cash-registers": 0,
      "point-of-sales": 0,
      pems: 0
    }
  });
  const [storageStatus, setStorageStatus] = (0, import_react7.useState)({
    queuedOperations: 0,
    cachedEntries: 0,
    offlineEntries: 0,
    pendingSyncOperations: 0
  });
  const syncIntervalRef = (0, import_react7.useRef)(void 0);
  const lastNetworkStatusRef = (0, import_react7.useRef)(contextIsOnline);
  (0, import_react7.useEffect)(() => {
    const newStatus = contextIsOnline;
    setIsOnline(newStatus);
    if (lastNetworkStatusRef.current !== newStatus) {
      setNetworkStatus(newStatus ? "online" : "offline");
      if (!lastNetworkStatusRef.current && newStatus && syncOnReconnect) {
        setNetworkStatus("reconnecting");
        sync().finally(() => {
          setNetworkStatus("online");
        });
      }
      onOfflineChange?.(!newStatus);
      lastNetworkStatusRef.current = newStatus;
    }
  }, [contextIsOnline, syncOnReconnect, onOfflineChange]);
  const updateStats = (0, import_react7.useCallback)(async () => {
    if (!enabled || !isOfflineEnabled) return;
    try {
      if (queueManager) {
        const stats = queueManager.getStats();
        setQueueStats(stats);
      }
      if (storage) {
        const offlineStatus = {
          queuedOperations: queueStats.totalItems,
          cachedEntries: 0,
          offlineEntries: 0,
          pendingSyncOperations: 0
        };
        try {
          const cacheEntries = await storage.query({ keyPrefix: "api_cache:" });
          offlineStatus.cachedEntries = cacheEntries.length;
        } catch (error) {
          console.warn("Failed to count cache entries:", error);
        }
        try {
          const offlineEntries = await storage.query({ keyPrefix: "offline:" });
          offlineStatus.offlineEntries = offlineEntries.length;
        } catch (error) {
          console.warn("Failed to count offline entries:", error);
        }
        if (syncEngine && isSyncEnabled) {
          const syncStatus = syncEngine.getStatus();
          offlineStatus.pendingSyncOperations = syncStatus.activeSyncs + syncStatus.queuedSyncs;
          offlineStatus.lastSyncTime = syncStatus.lastSync ? new Date(syncStatus.lastSync) : void 0;
          setLastSyncTime(syncStatus.lastSync ? new Date(syncStatus.lastSync) : null);
        }
        setStorageStatus(offlineStatus);
      }
    } catch (error) {
      console.warn("Failed to update offline stats:", error);
    }
  }, [enabled, isOfflineEnabled, queueManager, storage, syncEngine, isSyncEnabled, queueStats.totalItems]);
  (0, import_react7.useEffect)(() => {
    if (!enabled || !backgroundSync || !isOnline) return;
    syncIntervalRef.current = setInterval(() => {
      if (!isSyncing) {
        sync().catch(console.warn);
      }
    }, syncInterval);
    return () => {
      if (syncIntervalRef.current) {
        clearInterval(syncIntervalRef.current);
      }
    };
  }, [enabled, backgroundSync, isOnline, isSyncing, syncInterval]);
  (0, import_react7.useEffect)(() => {
    updateStats();
    const statsInterval = setInterval(updateStats, 5e3);
    return () => clearInterval(statsInterval);
  }, [updateStats]);
  const sync = (0, import_react7.useCallback)(async () => {
    if (!enabled || !isOfflineEnabled || isSyncing) {
      return { successful: 0, failed: 0, conflicts: 0, duration: 0 };
    }
    const startTime = Date.now();
    setIsSyncing(true);
    setSyncProgress(0);
    onSyncStart?.();
    try {
      const results = {
        successful: 0,
        failed: 0,
        conflicts: 0,
        duration: 0
      };
      if (queueManager) {
        setSyncProgress(25);
        try {
          await queueManager.processAll();
          const newStats = queueManager.getStats();
          results.successful += queueStats.totalItems - newStats.totalItems;
          results.failed += newStats.failedItems;
        } catch (error) {
          console.warn("Queue sync failed:", error);
          results.failed += queueStats.totalItems;
        }
      }
      if (syncEngine && isSyncEnabled) {
        setSyncProgress(75);
        try {
          const syncResult = await syncEngine.executeSync({
            operation: "full",
            direction: "bidirectional",
            strategy: "immediate"
          });
          results.successful += syncResult.statistics.recordsSynced;
          results.conflicts += syncResult.statistics.conflictsDetected;
          if (syncResult.errors.length > 0) {
            results.failed += syncResult.errors.length;
          }
        } catch (error) {
          console.warn("Sync engine failed:", error);
          results.failed += 1;
        }
      }
      setSyncProgress(100);
      results.duration = Date.now() - startTime;
      setLastSyncTime(/* @__PURE__ */ new Date());
      setLastSyncResults(results);
      await updateStats();
      onSyncComplete?.(results);
      return results;
    } catch (error) {
      const errorMessage = error instanceof Error ? error : new Error("Sync failed");
      onSyncError?.(errorMessage);
      throw errorMessage;
    } finally {
      setIsSyncing(false);
      setSyncProgress(0);
    }
  }, [enabled, isOfflineEnabled, isSyncing, queueManager, syncEngine, isSyncEnabled, queueStats.totalItems, updateStats, onSyncStart, onSyncComplete, onSyncError]);
  const getQueuedOperations = (0, import_react7.useCallback)(() => {
    if (!queueManager) return [];
    try {
      return queueManager.getQueueItems();
    } catch (error) {
      console.warn("Failed to get queued operations:", error);
      return [];
    }
  }, [queueManager]);
  const clearQueue = (0, import_react7.useCallback)(async () => {
    if (!queueManager) return;
    try {
      await queueManager.clear();
      await updateStats();
    } catch (error) {
      console.error("Failed to clear queue:", error);
      throw error;
    }
  }, [queueManager, updateStats]);
  const clearCache = (0, import_react7.useCallback)(async () => {
    if (!storage) return;
    try {
      const cacheEntries = await storage.query({ keyPrefix: "api_cache:" });
      for (const entry of cacheEntries) {
        await storage.delete(entry.key);
      }
      await updateStats();
    } catch (error) {
      console.error("Failed to clear cache:", error);
      throw error;
    }
  }, [storage, updateStats]);
  const getQueuedOperation = (0, import_react7.useCallback)((id) => {
    if (!queueManager) return void 0;
    try {
      const items = queueManager.getQueueItems();
      return items.find((item) => item.id === id);
    } catch (error) {
      console.warn("Failed to get queued operation:", error);
      return void 0;
    }
  }, [queueManager]);
  const forceSync = (0, import_react7.useCallback)(async (queueId) => {
    if (!queueManager) return;
    try {
      if (queueId) {
        const item = getQueuedOperation(queueId);
        if (item) {
          await queueManager.processItem(item);
        }
      } else {
        await queueManager.processAll();
      }
      await updateStats();
    } catch (error) {
      console.error("Failed to force sync:", error);
      throw error;
    }
  }, [queueManager, getQueuedOperation, updateStats]);
  const enableOfflineMode = (0, import_react7.useCallback)(async () => {
    try {
      if (storage) {
        await storage.initialize?.();
      }
      if (queueManager) {
        await queueManager.initialize?.();
      }
      await updateStats();
    } catch (error) {
      console.error("Failed to enable offline mode:", error);
      throw error;
    }
  }, [storage, queueManager, updateStats]);
  const disableOfflineMode = (0, import_react7.useCallback)(() => {
    if (syncIntervalRef.current) {
      clearInterval(syncIntervalRef.current);
    }
  }, []);
  const exportOfflineData = (0, import_react7.useCallback)(async () => {
    if (!storage) throw new Error("Storage not available");
    try {
      const offlineEntries = await storage.query({ keyPrefix: "offline:" });
      const cacheEntries = await storage.query({ keyPrefix: "api_cache:" });
      const queueItems = queueManager ? queueManager.getQueueItems() : [];
      const exportData = {
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        version: "2.0.0",
        offline: offlineEntries,
        cache: cacheEntries,
        queue: queueItems,
        stats: storageStatus
      };
      return JSON.stringify(exportData, null, 2);
    } catch (error) {
      console.error("Failed to export offline data:", error);
      throw error;
    }
  }, [storage, queueManager, storageStatus]);
  const importOfflineData = (0, import_react7.useCallback)(async (data) => {
    if (!storage) throw new Error("Storage not available");
    try {
      const importData = JSON.parse(data);
      for (const entry of importData.offline || []) {
        await storage.set(entry.key, entry.value);
      }
      for (const entry of importData.cache || []) {
        if (entry.value?.expiresAt && new Date(entry.value.expiresAt) > /* @__PURE__ */ new Date()) {
          await storage.set(entry.key, entry.value);
        }
      }
      if (queueManager && importData.queue) {
        for (const item of importData.queue) {
          await queueManager.add(item);
        }
      }
      await updateStats();
    } catch (error) {
      console.error("Failed to import offline data:", error);
      throw error;
    }
  }, [storage, queueManager, updateStats]);
  const getOfflineReport = (0, import_react7.useCallback)(async () => {
    await updateStats();
    return storageStatus;
  }, [updateStats, storageStatus]);
  return {
    // Network state
    isOnline,
    isOffline: !isOnline,
    networkStatus,
    // Queue state
    queueStats,
    queuedOperations: getQueuedOperations(),
    // Sync state
    isSyncing,
    syncProgress,
    lastSyncTime,
    lastSyncResults,
    // Storage state
    storageStatus,
    // Actions
    sync,
    clearQueue,
    clearCache,
    getQueuedOperation,
    forceSync,
    enableOfflineMode,
    disableOfflineMode,
    // Advanced features
    exportOfflineData,
    importOfflineData,
    getOfflineReport
  };
}

// src/hooks/react/auth-provider.tsx
init_esm_shims();
var import_react8 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function authReducer(state, action) {
  switch (action.type) {
    case "AUTH_LOADING":
      return {
        ...state,
        isLoading: action.payload,
        error: action.payload ? null : state.error
        // Clear error when starting new operation
      };
    case "AUTH_SUCCESS":
      return {
        ...state,
        isAuthenticated: true,
        isLoading: false,
        user: action.payload.user,
        accessToken: action.payload.accessToken,
        refreshToken: action.payload.refreshToken,
        expiresAt: action.payload.expiresAt,
        error: null
      };
    case "AUTH_ERROR":
      return {
        ...state,
        isAuthenticated: false,
        isLoading: false,
        user: null,
        accessToken: null,
        refreshToken: null,
        expiresAt: null,
        error: action.payload
      };
    case "AUTH_LOGOUT":
      return {
        ...state,
        isAuthenticated: false,
        isLoading: false,
        user: null,
        accessToken: null,
        refreshToken: null,
        expiresAt: null,
        error: null
      };
    case "AUTH_REFRESH":
      return {
        ...state,
        accessToken: action.payload.accessToken,
        refreshToken: action.payload.refreshToken,
        expiresAt: action.payload.expiresAt,
        error: null
      };
    case "AUTH_CLEAR_ERROR":
      return {
        ...state,
        error: null
      };
    case "AUTH_UPDATE_USER":
      return {
        ...state,
        user: action.payload
      };
    default:
      return state;
  }
}
var initialAuthState = {
  isAuthenticated: false,
  isLoading: false,
  user: null,
  accessToken: null,
  refreshToken: null,
  expiresAt: null,
  error: null
};
var AuthContext = (0, import_react8.createContext)(null);
function AuthProvider({
  children,
  sdk,
  autoInitialize = true,
  onAuthError,
  onAuthSuccess,
  onLogout
}) {
  const [state, dispatch] = (0, import_react8.useReducer)(authReducer, initialAuthState);
  const sdkRef = (0, import_react8.useRef)(sdk);
  (0, import_react8.useEffect)(() => {
    sdkRef.current = sdk;
  }, [sdk]);
  const initializeAuth = (0, import_react8.useCallback)(async () => {
    try {
      const authState = sdkRef.current.getAuthState();
      if (authState?.isAuthenticated && authState.user) {
        dispatch({
          type: "AUTH_SUCCESS",
          payload: {
            user: authState.user,
            accessToken: authState.accessToken || "",
            refreshToken: authState.refreshToken || "",
            expiresAt: authState.expiresAt || 0
          }
        });
      }
    } catch (error) {
      console.error("Failed to initialize auth state:", error);
    }
  }, []);
  (0, import_react8.useEffect)(() => {
    const currentSdk = sdkRef.current;
    const handleAuthSuccess = (event) => {
      const { user } = event.data;
      if (user) {
        const authState = currentSdk.getAuthState();
        dispatch({
          type: "AUTH_SUCCESS",
          payload: {
            user,
            accessToken: authState?.accessToken || "",
            refreshToken: authState?.refreshToken || "",
            expiresAt: authState?.expiresAt || 0
          }
        });
        onAuthSuccess?.(user);
      }
    };
    const handleAuthError = (event) => {
      const error = {
        name: "AuthError",
        type: event.data.errorCode || "UNKNOWN_ERROR",
        message: event.data.errorMessage || "Authentication failed",
        timestamp: Date.now(),
        recoverable: event.data.retry || false
      };
      dispatch({ type: "AUTH_ERROR", payload: error });
      onAuthError?.(error);
    };
    const handleAuthLogout = (event) => {
      dispatch({ type: "AUTH_LOGOUT" });
      onLogout?.(event.data.reason);
    };
    const handleTokenRefresh = () => {
      const authState = currentSdk.getAuthState();
      if (authState?.accessToken) {
        dispatch({
          type: "AUTH_REFRESH",
          payload: {
            accessToken: authState.accessToken,
            refreshToken: authState.refreshToken || "",
            expiresAt: authState.expiresAt || 0
          }
        });
      }
    };
    currentSdk.on("auth.success", handleAuthSuccess);
    currentSdk.on("auth.error", handleAuthError);
    currentSdk.on("auth.logout", handleAuthLogout);
    currentSdk.on("auth.refreshed", handleTokenRefresh);
    return () => {
      currentSdk.off("auth.success", handleAuthSuccess);
      currentSdk.off("auth.error", handleAuthError);
      currentSdk.off("auth.logout", handleAuthLogout);
      currentSdk.off("auth.refreshed", handleTokenRefresh);
    };
  }, [onAuthError, onAuthSuccess, onLogout]);
  (0, import_react8.useEffect)(() => {
    if (autoInitialize) {
      initializeAuth();
    }
  }, [autoInitialize, initializeAuth]);
  const login = (0, import_react8.useCallback)(async (credentials) => {
    dispatch({ type: "AUTH_LOADING", payload: true });
    try {
      const user = await sdkRef.current.login(credentials);
      return user;
    } catch (error) {
      const authError = {
        name: "AuthError",
        type: error instanceof Error && "type" in error ? error.type : "UNKNOWN_ERROR",
        message: error instanceof Error ? error.message : "Login failed",
        timestamp: Date.now(),
        recoverable: false
      };
      dispatch({ type: "AUTH_ERROR", payload: authError });
      throw error;
    } finally {
      dispatch({ type: "AUTH_LOADING", payload: false });
    }
  }, []);
  const logout = (0, import_react8.useCallback)(async (options) => {
    dispatch({ type: "AUTH_LOADING", payload: true });
    try {
      await sdkRef.current.logout(options);
    } catch (error) {
      console.error("Logout error:", error);
      dispatch({ type: "AUTH_LOGOUT" });
    } finally {
      dispatch({ type: "AUTH_LOADING", payload: false });
    }
  }, []);
  const refreshSession = (0, import_react8.useCallback)(async () => {
    try {
      const authService = sdkRef.current.authService;
      await authService.refreshSession();
    } catch (error) {
      const authError = {
        name: "AuthError",
        type: "SESSION_EXPIRED",
        message: "Failed to refresh session",
        timestamp: Date.now(),
        recoverable: false
      };
      dispatch({ type: "AUTH_ERROR", payload: authError });
      throw error;
    }
  }, []);
  const clearError = (0, import_react8.useCallback)(() => {
    dispatch({ type: "AUTH_CLEAR_ERROR" });
  }, []);
  const hasRole2 = (0, import_react8.useCallback)((role) => {
    return sdkRef.current.hasRole(role);
  }, []);
  const hasAnyRole2 = (0, import_react8.useCallback)((roles) => {
    return sdkRef.current.hasAnyRole(roles);
  }, []);
  const getEffectiveRoles2 = (0, import_react8.useCallback)(() => {
    return sdkRef.current.getEffectiveRoles();
  }, []);
  const getPrimaryRole2 = (0, import_react8.useCallback)(() => {
    return sdkRef.current.getPrimaryRole();
  }, []);
  const getSimpleRole = (0, import_react8.useCallback)(() => {
    return sdkRef.current.getSimpleRole();
  }, []);
  const switchRole = (0, import_react8.useCallback)(async (targetRole, context) => {
    try {
      const success = await sdkRef.current.switchRole(targetRole, context);
      if (success) {
        const updatedUser = sdkRef.current.getCurrentUser();
        if (updatedUser) {
          dispatch({ type: "AUTH_UPDATE_USER", payload: updatedUser });
        }
      }
      return success;
    } catch (error) {
      console.error("Role switch failed:", error);
      return false;
    }
  }, []);
  const checkPermission = (0, import_react8.useCallback)(async (permission) => {
    return sdkRef.current.authService.checkPermission(permission);
  }, []);
  const getSessionInfo = (0, import_react8.useCallback)(async () => {
    return sdkRef.current.authService.getSessionInfo();
  }, []);
  const contextValue = {
    // State
    state,
    user: state.user,
    isAuthenticated: state.isAuthenticated,
    isLoading: state.isLoading,
    error: state.error,
    // Actions
    login,
    logout,
    refreshSession,
    clearError,
    // Role Management
    hasRole: hasRole2,
    hasAnyRole: hasAnyRole2,
    getEffectiveRoles: getEffectiveRoles2,
    getPrimaryRole: getPrimaryRole2,
    getSimpleRole,
    switchRole,
    // Permissions
    checkPermission,
    // Session Management
    getSessionInfo
  };
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(AuthContext.Provider, { value: contextValue, children });
}
function useAuthContext() {
  const context = (0, import_react8.useContext)(AuthContext);
  if (!context) {
    throw new Error("useAuthContext must be used within an AuthProvider");
  }
  return context;
}
function useAuthAvailable() {
  return (0, import_react8.useContext)(AuthContext) !== null;
}

// src/hooks/react/use-auth.ts
init_esm_shims();
var import_react9 = __toESM(require_react(), 1);
function useAuth() {
  const context = useAuthContext();
  return {
    // State
    user: context.user,
    isAuthenticated: context.isAuthenticated,
    isLoading: context.isLoading,
    error: context.error,
    // Actions
    login: context.login,
    logout: context.logout,
    refreshSession: context.refreshSession,
    clearError: context.clearError,
    // Role Management
    hasRole: context.hasRole,
    hasAnyRole: context.hasAnyRole,
    getEffectiveRoles: context.getEffectiveRoles,
    getPrimaryRole: context.getPrimaryRole,
    getSimpleRole: context.getSimpleRole,
    switchRole: context.switchRole,
    // Permissions
    checkPermission: context.checkPermission,
    // Session
    getSessionInfo: context.getSessionInfo
  };
}
function useLogin() {
  const { login: contextLogin, isLoading, error, clearError } = useAuthContext();
  const [loginError, setLoginError] = (0, import_react9.useState)(null);
  const login = (0, import_react9.useCallback)(async (credentials) => {
    try {
      setLoginError(null);
      const user = await contextLogin(credentials);
      return user;
    } catch (error2) {
      const authError = error2;
      setLoginError(authError);
      throw error2;
    }
  }, [contextLogin]);
  const clearLoginError = (0, import_react9.useCallback)(() => {
    setLoginError(null);
    clearError();
  }, [clearError]);
  return {
    login,
    isLogging: isLoading,
    loginError: loginError || error,
    clearLoginError
  };
}
function useLogout() {
  const { logout: contextLogout, isLoading } = useAuthContext();
  const [isLoggingOut, setIsLoggingOut] = (0, import_react9.useState)(false);
  const logout = (0, import_react9.useCallback)(async (options) => {
    try {
      setIsLoggingOut(true);
      await contextLogout(options);
    } finally {
      setIsLoggingOut(false);
    }
  }, [contextLogout]);
  return {
    logout,
    isLoggingOut: isLoggingOut || isLoading
  };
}
function useUser() {
  const { user, isAuthenticated } = useAuthContext();
  return {
    user,
    isAuthenticated,
    userId: user?.id,
    userEmail: user?.email,
    userName: user?.name,
    userRoles: user?.roles || [],
    userPermissions: user?.permissions || [],
    lastLogin: user?.last_login,
    sessionId: user?.session_id
  };
}
function useRoles() {
  const {
    hasRole: hasRole2,
    hasAnyRole: hasAnyRole2,
    getEffectiveRoles: getEffectiveRoles2,
    getPrimaryRole: getPrimaryRole2,
    getSimpleRole,
    switchRole,
    user
  } = useAuthContext();
  const [isSwitchingRole, setIsSwitchingRole] = (0, import_react9.useState)(false);
  const switchToRole = (0, import_react9.useCallback)(async (targetRole, context) => {
    try {
      setIsSwitchingRole(true);
      return await switchRole(targetRole, context);
    } finally {
      setIsSwitchingRole(false);
    }
  }, [switchRole]);
  const currentRoles = user?.roles || [];
  const effectiveRoles = getEffectiveRoles2();
  const primaryRole = getPrimaryRole2();
  const simpleRole = getSimpleRole();
  return {
    currentRoles,
    effectiveRoles,
    primaryRole,
    simpleRole,
    hasRole: hasRole2,
    hasAnyRole: hasAnyRole2,
    switchRole: switchToRole,
    isSwitchingRole
  };
}
function usePermissions() {
  const { checkPermission } = useAuthContext();
  const [permissionCache, setPermissionCache] = (0, import_react9.useState)(/* @__PURE__ */ new Map());
  const [checkingPermissions, setCheckingPermissions] = (0, import_react9.useState)(/* @__PURE__ */ new Set());
  const checkPermissionWithCache = (0, import_react9.useCallback)(async (permission, useCache = true) => {
    const cacheKey = `${permission.resource}:${permission.action}:${JSON.stringify(permission.context || {})}`;
    if (useCache && permissionCache.has(cacheKey)) {
      return permissionCache.get(cacheKey);
    }
    if (checkingPermissions.has(cacheKey)) {
      return new Promise((resolve) => {
        const checkCache = () => {
          if (permissionCache.has(cacheKey)) {
            resolve(permissionCache.get(cacheKey));
          } else {
            setTimeout(checkCache, 50);
          }
        };
        checkCache();
      });
    }
    try {
      setCheckingPermissions((prev) => new Set(prev).add(cacheKey));
      const result = await checkPermission(permission);
      if (useCache) {
        setPermissionCache((prev) => new Map(prev).set(cacheKey, result));
      }
      return result;
    } finally {
      setCheckingPermissions((prev) => {
        const newSet = new Set(prev);
        newSet.delete(cacheKey);
        return newSet;
      });
    }
  }, [checkPermission, permissionCache, checkingPermissions]);
  const clearPermissionCache = (0, import_react9.useCallback)(() => {
    setPermissionCache(/* @__PURE__ */ new Map());
  }, []);
  const isCheckingPermission = (0, import_react9.useCallback)((permission) => {
    const cacheKey = `${permission.resource}:${permission.action}:${JSON.stringify(permission.context || {})}`;
    return checkingPermissions.has(cacheKey);
  }, [checkingPermissions]);
  return {
    checkPermission: checkPermissionWithCache,
    clearPermissionCache,
    isCheckingPermission
  };
}
function useSession() {
  const { getSessionInfo, refreshSession, isAuthenticated } = useAuthContext();
  const [sessionInfo, setSessionInfo] = (0, import_react9.useState)(null);
  const [isRefreshing, setIsRefreshing] = (0, import_react9.useState)(false);
  const [sessionError, setSessionError] = (0, import_react9.useState)(null);
  const loadSessionInfo = (0, import_react9.useCallback)(async () => {
    if (!isAuthenticated) {
      setSessionInfo(null);
      return;
    }
    try {
      const info = await getSessionInfo();
      setSessionInfo(info);
      setSessionError(null);
    } catch (error) {
      setSessionError(error instanceof Error ? error.message : "Failed to load session info");
    }
  }, [getSessionInfo, isAuthenticated]);
  const refresh = (0, import_react9.useCallback)(async () => {
    try {
      setIsRefreshing(true);
      setSessionError(null);
      await refreshSession();
      await loadSessionInfo();
    } catch (error) {
      setSessionError(error instanceof Error ? error.message : "Failed to refresh session");
      throw error;
    } finally {
      setIsRefreshing(false);
    }
  }, [refreshSession, loadSessionInfo]);
  (0, import_react9.useEffect)(() => {
    loadSessionInfo();
  }, [loadSessionInfo]);
  (0, import_react9.useEffect)(() => {
    if (!sessionInfo?.expiresAt || !isAuthenticated) return;
    const expiresAt = sessionInfo.expiresAt.getTime();
    const now = Date.now();
    const timeUntilExpiry = expiresAt - now;
    const refreshBuffer = 5 * 60 * 1e3;
    if (timeUntilExpiry > refreshBuffer) {
      const refreshTimeout = setTimeout(() => {
        refresh().catch((error) => {
          console.error("Auto-refresh failed:", error);
        });
      }, timeUntilExpiry - refreshBuffer);
      return () => clearTimeout(refreshTimeout);
    }
    return void 0;
  }, [sessionInfo, isAuthenticated, refresh]);
  return {
    sessionInfo,
    isRefreshing,
    sessionError,
    refreshSession: refresh,
    reloadSessionInfo: loadSessionInfo,
    isSessionExpired: sessionInfo ? sessionInfo.expiresAt.getTime() < Date.now() : false,
    timeUntilExpiry: sessionInfo ? Math.max(0, sessionInfo.expiresAt.getTime() - Date.now()) : 0
  };
}
function useRequireAuth(redirectTo) {
  const { isAuthenticated, isLoading } = useAuthContext();
  (0, import_react9.useEffect)(() => {
    if (!isLoading && !isAuthenticated) {
      if (redirectTo && typeof window !== "undefined") {
        window.location.href = redirectTo;
      } else {
        throw new Error("Authentication required");
      }
    }
  }, [isAuthenticated, isLoading, redirectTo]);
  return { isAuthenticated, isLoading };
}
function useRequireRole(requiredRole, fallbackComponent) {
  const { hasRole: hasRole2, hasAnyRole: hasAnyRole2, isAuthenticated, isLoading } = useAuthContext();
  const hasRequiredRole2 = Array.isArray(requiredRole) ? hasAnyRole2(requiredRole) : hasRole2(requiredRole);
  (0, import_react9.useEffect)(() => {
    if (!isLoading && isAuthenticated && !hasRequiredRole2) {
      if (!fallbackComponent) {
        throw new Error(`Required role not found: ${Array.isArray(requiredRole) ? requiredRole.join(", ") : requiredRole}`);
      }
    }
  }, [hasRequiredRole2, isAuthenticated, isLoading, requiredRole, fallbackComponent]);
  return {
    hasRequiredRole: hasRequiredRole2,
    isAuthenticated,
    isLoading,
    canAccess: isAuthenticated && hasRequiredRole2
  };
}

// src/hooks/react/auth-components.tsx
init_esm_shims();
var import_react10 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
function LoginForm({
  onSuccess,
  onError,
  className = "",
  autoComplete = true,
  showRememberMe = false,
  allowRoleSelection = false,
  availableRoles = []
}) {
  const { login, isLogging, loginError, clearLoginError } = useLogin();
  const [credentials, setCredentials] = (0, import_react10.useState)({
    username: "",
    password: ""
  });
  const [rememberMe, setRememberMe] = (0, import_react10.useState)(false);
  const handleSubmit = (0, import_react10.useCallback)(async (e) => {
    e.preventDefault();
    clearLoginError();
    try {
      await login({
        ...credentials,
        ...rememberMe && { scope: "remember_me" }
      });
      onSuccess?.();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Login failed";
      onError?.(errorMessage);
    }
  }, [credentials, rememberMe, login, onSuccess, onError, clearLoginError]);
  const handleInputChange = (0, import_react10.useCallback)((field, value) => {
    setCredentials((prev) => ({ ...prev, [field]: value }));
    if (loginError) {
      clearLoginError();
    }
  }, [loginError, clearLoginError]);
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("form", { onSubmit: handleSubmit, className, children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "auth-form-group", children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("label", { htmlFor: "username", children: "Email or Username" }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        "input",
        {
          id: "username",
          type: "email",
          value: credentials.username,
          onChange: (e) => handleInputChange("username", e.target.value),
          required: true,
          autoComplete: autoComplete ? "username" : "off",
          disabled: isLogging,
          placeholder: "Enter your email"
        }
      )
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "auth-form-group", children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("label", { htmlFor: "password", children: "Password" }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        "input",
        {
          id: "password",
          type: "password",
          value: credentials.password,
          onChange: (e) => handleInputChange("password", e.target.value),
          required: true,
          autoComplete: autoComplete ? "current-password" : "off",
          disabled: isLogging,
          placeholder: "Enter your password"
        }
      )
    ] }),
    allowRoleSelection && availableRoles.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "auth-form-group", children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("label", { htmlFor: "preferred-role", children: "Preferred Role" }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(
        "select",
        {
          id: "preferred-role",
          value: credentials.preferred_role || "",
          onChange: (e) => handleInputChange("preferred_role", e.target.value),
          disabled: isLogging,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("option", { value: "", children: "Auto-detect role" }),
            availableRoles.map((role) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("option", { value: role, children: role.replace("ROLE_", "").toLowerCase().replace("_", " ") }, role))
          ]
        }
      )
    ] }),
    showRememberMe && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "auth-form-group", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("label", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        "input",
        {
          type: "checkbox",
          checked: rememberMe,
          onChange: (e) => setRememberMe(e.target.checked),
          disabled: isLogging
        }
      ),
      "Remember me"
    ] }) }),
    loginError && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "auth-error", role: "alert", children: loginError.message }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      "button",
      {
        type: "submit",
        disabled: isLogging || !credentials.username || !credentials.password,
        className: "auth-submit-button",
        children: isLogging ? "Signing in..." : "Sign In"
      }
    )
  ] });
}
function UserProfile({
  showRoles = true,
  showSession = true,
  showPermissions = false,
  className = ""
}) {
  const { user, isAuthenticated } = useAuth();
  const { logout, isLoggingOut } = useLogout();
  const { primaryRole, simpleRole, effectiveRoles } = useRoles();
  if (!isAuthenticated || !user) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: `auth-user-profile ${className}`, children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "auth-user-info", children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("h3", { children: user.name || user.email }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("p", { className: "auth-user-email", children: user.email }),
      user.last_login && /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("p", { className: "auth-last-login", children: [
        "Last login: ",
        user.last_login.toLocaleString()
      ] })
    ] }),
    showRoles && /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "auth-user-roles", children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("h4", { children: "Current Role" }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("p", { className: "auth-primary-role", children: [
        primaryRole?.replace("ROLE_", "").toLowerCase().replace("_", " ") || "Unknown",
        /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("span", { className: "auth-simple-role", children: [
          "(",
          simpleRole,
          ")"
        ] })
      ] }),
      effectiveRoles.length > 1 && /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("details", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("summary", { children: "All Available Roles" }),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("ul", { children: effectiveRoles.map((role) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("li", { children: role.replace("ROLE_", "").toLowerCase().replace("_", " ") }, role)) })
      ] })
    ] }),
    showSession && user.session_id && /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "auth-session-info", children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("h4", { children: "Session" }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("p", { className: "auth-session-id", children: [
        "ID: ",
        user.session_id
      ] })
    ] }),
    showPermissions && user.permissions.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "auth-user-permissions", children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("h4", { children: "Permissions" }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("ul", { children: user.permissions.map((permission) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("li", { children: permission }, permission)) })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "auth-user-actions", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      "button",
      {
        onClick: () => logout(),
        disabled: isLoggingOut,
        className: "auth-logout-button",
        children: isLoggingOut ? "Signing out..." : "Sign Out"
      }
    ) })
  ] });
}
function RoleSwitcher({
  availableRoles = [],
  onRoleSwitch,
  className = ""
}) {
  const { switchRole, isSwitchingRole, primaryRole, effectiveRoles } = useRoles();
  const handleRoleSwitch = (0, import_react10.useCallback)(async (targetRole) => {
    try {
      const success = await switchRole(targetRole);
      if (success) {
        onRoleSwitch?.(targetRole);
      }
    } catch (error) {
      console.error("Role switch failed:", error);
    }
  }, [switchRole, onRoleSwitch]);
  const switchableRoles = availableRoles.length > 0 ? availableRoles.filter((role) => effectiveRoles.includes(role)) : effectiveRoles;
  if (switchableRoles.length <= 1) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: `auth-role-switcher ${className}`, children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("label", { htmlFor: "role-select", children: "Switch Role:" }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      "select",
      {
        id: "role-select",
        value: primaryRole || "",
        onChange: (e) => handleRoleSwitch(e.target.value),
        disabled: isSwitchingRole,
        children: switchableRoles.map((role) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("option", { value: role, children: role.replace("ROLE_", "").toLowerCase().replace("_", " ") }, role))
      }
    )
  ] });
}
function AuthStatus({
  showLoginPrompt = true,
  loginPromptText = "Please sign in to continue",
  className = ""
}) {
  const { isAuthenticated, isLoading, error, user } = useAuth();
  if (isLoading) {
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: `auth-status auth-loading ${className}`, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("p", { children: "Loading..." }) });
  }
  if (error) {
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: `auth-status auth-error ${className}`, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("p", { children: [
      "Authentication error: ",
      error.message
    ] }) });
  }
  if (!isAuthenticated) {
    return showLoginPrompt ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: `auth-status auth-unauthenticated ${className}`, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("p", { children: loginPromptText }) }) : null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: `auth-status auth-authenticated ${className}`, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("p", { children: [
    "Signed in as ",
    user?.name || user?.email
  ] }) });
}
function ProtectedRoute({
  children,
  requiredRole,
  fallback: FallbackComponent,
  redirectTo,
  className = ""
}) {
  const { isAuthenticated, isLoading } = useAuth();
  const roleResult = requiredRole ? useRequireRole(requiredRole, FallbackComponent) : null;
  if (isLoading) {
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: `auth-protected-loading ${className}`, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("p", { children: "Loading..." }) });
  }
  if (!isAuthenticated) {
    if (redirectTo && typeof window !== "undefined") {
      window.location.href = redirectTo;
      return null;
    }
    return FallbackComponent ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(FallbackComponent, {}) : /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: `auth-protected-unauthorized ${className}`, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("p", { children: "Authentication required" }) });
  }
  if (requiredRole && roleResult && !roleResult.canAccess) {
    return FallbackComponent ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(FallbackComponent, {}) : /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: `auth-protected-forbidden ${className}`, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("p", { children: "Insufficient permissions" }) });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children });
}
function PermissionGate({
  children,
  resource,
  action,
  context,
  fallback: FallbackComponent,
  showLoading = true
}) {
  const [hasPermission, setHasPermission] = (0, import_react10.useState)(null);
  const { checkPermission } = useAuth();
  import_react10.default.useEffect(() => {
    const permissionCheck = {
      resource,
      action,
      ...context && { context }
    };
    checkPermission(permissionCheck).then((result) => setHasPermission(result.granted)).catch(() => setHasPermission(false));
  }, [checkPermission, resource, action, context]);
  if (hasPermission === null) {
    return showLoading ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "auth-permission-loading", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("p", { children: "Checking permissions..." }) }) : null;
  }
  if (!hasPermission) {
    return FallbackComponent ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(FallbackComponent, {}) : /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "auth-permission-denied", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("p", { children: "Permission denied" }) });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children });
}

// src/compliance/index.ts
init_esm_shims();

// src/compliance/gdpr-compliance.ts
init_esm_shims();
var GDPRComplianceManager = class {
  config;
  dataSubjects = /* @__PURE__ */ new Map();
  consentRecords = /* @__PURE__ */ new Map();
  processingRecords = [];
  exportRequests = /* @__PURE__ */ new Map();
  erasureRequests = /* @__PURE__ */ new Map();
  violations = [];
  constructor(config) {
    this.config = {
      enabled: true,
      dataRetention: {
        defaultPeriod: 365 * 24 * 60 * 60 * 1e3,
        // 1 year
        categories: {
          "user_profile": 2 * 365 * 24 * 60 * 60 * 1e3,
          // 2 years
          "transaction_data": 7 * 365 * 24 * 60 * 60 * 1e3,
          // 7 years
          "analytics_data": 26 * 30 * 24 * 60 * 60 * 1e3,
          // 26 months
          "marketing_data": 365 * 24 * 60 * 60 * 1e3
          // 1 year
        }
      },
      consent: {
        required: true,
        granular: true,
        withdrawalEnabled: true,
        consentVersion: "1.0.0"
      },
      dataMinimization: {
        enabled: true,
        allowedFields: {
          "user_registration": ["email", "name", "company"],
          "transaction_processing": ["amount", "currency", "timestamp"],
          "analytics": ["user_id", "event_type", "timestamp"]
        }
      },
      rightToErasure: {
        enabled: true,
        gracePeriod: 30 * 24 * 60 * 60 * 1e3,
        // 30 days
        cascadeDeletion: true
      },
      dataPortability: {
        enabled: true,
        formats: ["json", "csv"],
        includeMetadata: true
      },
      anonymization: {
        enabled: true,
        techniques: ["pseudonymization", "aggregation"],
        retainStructure: true
      },
      ...config
    };
    if (this.config.enabled) {
      this.initializeRetentionScheduler();
    }
  }
  /**
   * Register a new data subject
   */
  async registerDataSubject(subjectId, email, initialConsent) {
    if (!this.config.enabled) return;
    const dataSubject = {
      id: subjectId,
      ...email && { email },
      createdAt: Date.now(),
      lastActivity: Date.now(),
      consentRecords: [],
      dataCategories: [],
      retentionOverrides: {},
      anonymizationStatus: "none"
    };
    this.dataSubjects.set(subjectId, dataSubject);
    if (initialConsent) {
      await this.recordConsent(subjectId, {
        purpose: initialConsent.purpose || "service_provision",
        dataTypes: initialConsent.dataTypes || ["basic_profile"],
        consentGiven: true,
        source: "explicit",
        ...initialConsent
      });
    }
    this.recordProcessingActivity({
      subjectId,
      dataType: "basic_profile",
      purpose: "user_registration",
      lawfulBasis: initialConsent ? "consent" : "contract",
      processingActivity: "data_subject_registration",
      dataLocation: "internal_database",
      retentionPeriod: this.config.dataRetention.categories["user_profile"] || this.config.dataRetention.defaultPeriod,
      thirdPartySharing: false,
      encryptionUsed: true,
      metadata: { email: !!email }
    });
  }
  /**
   * Record consent for data processing
   */
  async recordConsent(subjectId, consent) {
    if (!this.config.enabled) return "";
    const consentId = this.generateConsentId();
    const now = Date.now();
    const consentRecord = {
      id: consentId,
      subjectId,
      consentVersion: this.config.consent.consentVersion,
      timestamp: now,
      source: "explicit",
      metadata: {},
      ...consent
    };
    if (!consentRecord.expiresAt && consent.purpose === "marketing") {
      consentRecord.expiresAt = now + 365 * 24 * 60 * 60 * 1e3;
    }
    this.consentRecords.set(consentId, consentRecord);
    const dataSubject = this.dataSubjects.get(subjectId);
    if (dataSubject) {
      dataSubject.consentRecords.push(consentRecord);
      dataSubject.lastActivity = now;
      for (const dataType of consent.dataTypes) {
        if (!dataSubject.dataCategories.includes(dataType)) {
          dataSubject.dataCategories.push(dataType);
        }
      }
    }
    this.recordProcessingActivity({
      subjectId,
      dataType: "consent_record",
      purpose: "consent_management",
      lawfulBasis: "legal_obligation",
      processingActivity: "consent_recording",
      dataLocation: "internal_database",
      retentionPeriod: this.config.dataRetention.defaultPeriod,
      thirdPartySharing: false,
      encryptionUsed: true,
      metadata: { consentId, purpose: consent.purpose }
    });
    return consentId;
  }
  /**
   * Withdraw consent
   */
  async withdrawConsent(subjectId, consentId, reason) {
    if (!this.config.enabled || !this.config.consent.withdrawalEnabled) return;
    const consentRecord = this.consentRecords.get(consentId);
    if (!consentRecord || consentRecord.subjectId !== subjectId) {
      throw new Error("Consent record not found or access denied");
    }
    consentRecord.withdrawnAt = Date.now();
    if (reason) {
      consentRecord.withdrawalReason = reason;
    }
    consentRecord.consentGiven = false;
    this.recordProcessingActivity({
      subjectId,
      dataType: "consent_record",
      purpose: "consent_management",
      lawfulBasis: "legal_obligation",
      processingActivity: "consent_withdrawal",
      dataLocation: "internal_database",
      retentionPeriod: this.config.dataRetention.defaultPeriod,
      thirdPartySharing: false,
      encryptionUsed: true,
      metadata: { consentId, reason }
    });
    await this.checkDataRetentionAfterConsentWithdrawal(subjectId);
  }
  /**
   * Check if processing is lawful for a data subject
   */
  isProcessingLawful(subjectId, purpose, dataTypes) {
    if (!this.config.enabled) return { lawful: true, basis: "not_applicable", warnings: [] };
    const dataSubject = this.dataSubjects.get(subjectId);
    if (!dataSubject) {
      return { lawful: false, basis: "no_subject", warnings: ["Data subject not registered"] };
    }
    const warnings = [];
    let hasValidConsent = false;
    let lawfulBasis = "legitimate_interests";
    const relevantConsents = dataSubject.consentRecords.filter(
      (consent) => consent.purpose === purpose && consent.consentGiven && !consent.withdrawnAt && (!consent.expiresAt || consent.expiresAt > Date.now()) && dataTypes.every((type) => consent.dataTypes.includes(type))
    );
    if (relevantConsents.length > 0) {
      hasValidConsent = true;
      lawfulBasis = "consent";
    }
    if (this.config.dataMinimization.enabled) {
      const allowedFields = this.config.dataMinimization.allowedFields[purpose] || [];
      const excessiveFields = dataTypes.filter((type) => !allowedFields.includes(type));
      if (excessiveFields.length > 0) {
        warnings.push(`Excessive data types for purpose ${purpose}: ${excessiveFields.join(", ")}`);
      }
    }
    const legitimateInterestPurposes = ["fraud_prevention", "security", "service_provision"];
    if (!hasValidConsent && legitimateInterestPurposes.includes(purpose)) {
      lawfulBasis = "legitimate_interests";
    }
    const legalObligationPurposes = ["tax_compliance", "anti_money_laundering", "data_retention"];
    if (legalObligationPurposes.includes(purpose)) {
      lawfulBasis = "legal_obligation";
    }
    const lawful = hasValidConsent || legitimateInterestPurposes.includes(purpose) || legalObligationPurposes.includes(purpose);
    return { lawful, basis: lawfulBasis, warnings };
  }
  /**
   * Record data processing activity
   */
  recordProcessingActivity(activity) {
    if (!this.config.enabled) return;
    const record = {
      id: this.generateProcessingId(),
      timestamp: Date.now(),
      ...activity
    };
    this.processingRecords.push(record);
    if (this.processingRecords.length > 1e4) {
      this.processingRecords = this.processingRecords.slice(-1e4);
    }
    const dataSubject = this.dataSubjects.get(activity.subjectId);
    if (dataSubject) {
      dataSubject.lastActivity = Date.now();
    }
  }
  /**
   * Handle data export request (Right to Data Portability)
   */
  async requestDataExport(subjectId, options) {
    if (!this.config.enabled || !this.config.dataPortability.enabled) {
      throw new Error("Data portability not enabled");
    }
    const requestId = this.generateRequestId();
    const exportRequest = {
      id: requestId,
      subjectId,
      requestedAt: Date.now(),
      status: "pending",
      format: options?.format || "json",
      includeMetadata: options?.includeMetadata ?? this.config.dataPortability.includeMetadata,
      ...options?.dataTypes && { dataTypes: options.dataTypes }
    };
    this.exportRequests.set(requestId, exportRequest);
    setTimeout(() => this.processDataExport(requestId), 1e3);
    this.recordProcessingActivity({
      subjectId,
      dataType: "export_request",
      purpose: "data_portability",
      lawfulBasis: "legal_obligation",
      processingActivity: "data_export_request",
      dataLocation: "internal_database",
      retentionPeriod: 30 * 24 * 60 * 60 * 1e3,
      // 30 days
      thirdPartySharing: false,
      encryptionUsed: true,
      metadata: { requestId, format: exportRequest.format }
    });
    return requestId;
  }
  /**
   * Handle data erasure request (Right to be Forgotten)
   */
  async requestDataErasure(subjectId, reason, options) {
    if (!this.config.enabled || !this.config.rightToErasure.enabled) {
      throw new Error("Right to erasure not enabled");
    }
    const requestId = this.generateRequestId();
    const now = Date.now();
    const scheduledAt = options?.immediateErasure ? now : now + this.config.rightToErasure.gracePeriod;
    const erasureRequest = {
      id: requestId,
      subjectId,
      requestedAt: now,
      scheduledAt,
      status: "pending",
      reason,
      cascadeDelete: options?.cascadeDelete ?? this.config.rightToErasure.cascadeDeletion,
      ...options?.dataTypes && { dataTypes: options.dataTypes },
      verificationRequired: !options?.immediateErasure,
      metadata: {}
    };
    this.erasureRequests.set(requestId, erasureRequest);
    setTimeout(() => this.processDataErasure(requestId), scheduledAt - now);
    this.recordProcessingActivity({
      subjectId,
      dataType: "erasure_request",
      purpose: "data_erasure",
      lawfulBasis: "legal_obligation",
      processingActivity: "data_erasure_request",
      dataLocation: "internal_database",
      retentionPeriod: 30 * 24 * 60 * 60 * 1e3,
      // 30 days
      thirdPartySharing: false,
      encryptionUsed: true,
      metadata: { requestId, reason, scheduledAt }
    });
    return requestId;
  }
  /**
   * Generate GDPR compliance report
   */
  generateComplianceReport(timeRangeMs = 30 * 24 * 60 * 60 * 1e3) {
    const now = Date.now();
    const start = now - timeRangeMs;
    const periodProcessingRecords = this.processingRecords.filter(
      (record) => record.timestamp >= start
    );
    const periodConsents = Array.from(this.consentRecords.values()).filter(
      (consent) => consent.timestamp >= start
    );
    const periodExportRequests = Array.from(this.exportRequests.values()).filter(
      (request) => request.requestedAt >= start
    );
    const periodErasureRequests = Array.from(this.erasureRequests.values()).filter(
      (request) => request.requestedAt >= start
    );
    const totalConsents = periodConsents.length;
    const activeConsents = periodConsents.filter(
      (c) => c.consentGiven && !c.withdrawnAt && (!c.expiresAt || c.expiresAt > now)
    ).length;
    const withdrawnConsents = periodConsents.filter((c) => c.withdrawnAt).length;
    const consentCompliance = totalConsents > 0 ? activeConsents / totalConsents * 100 : 100;
    const retentionCompliance = this.calculateRetentionCompliance();
    const dataMinimizationCompliance = this.calculateDataMinimizationCompliance();
    const securityCompliance = this.calculateSecurityCompliance(periodProcessingRecords);
    return {
      generatedAt: now,
      period: { start, end: now },
      summary: {
        totalSubjects: this.dataSubjects.size,
        activeConsents,
        withdrawnConsents,
        dataExportRequests: periodExportRequests.length,
        erasureRequests: periodErasureRequests.length,
        dataProcessingActivities: periodProcessingRecords.length
      },
      compliance: {
        consentCompliance,
        retentionCompliance,
        dataMinimizationCompliance,
        securityCompliance
      },
      violations: this.violations.filter((v) => v.detectedAt >= start),
      recommendations: this.generateRecommendations()
    };
  }
  /**
   * Anonymize data for a subject
   */
  async anonymizeDataSubject(subjectId) {
    if (!this.config.enabled || !this.config.anonymization.enabled) return;
    const dataSubject = this.dataSubjects.get(subjectId);
    if (!dataSubject) return;
    if (this.config.anonymization.techniques.includes("pseudonymization")) {
      if (dataSubject.email) {
        const pseudonymizedEmail = this.pseudonymizeEmail(dataSubject.email);
        if (pseudonymizedEmail) {
          dataSubject.email = pseudonymizedEmail;
        }
      }
      dataSubject.anonymizationStatus = "pseudonymized";
    }
    if (this.config.anonymization.techniques.includes("aggregation")) {
      this.aggregateProcessingRecords(subjectId);
    }
    if (this.config.anonymization.techniques.includes("suppression")) {
      delete dataSubject.email;
      dataSubject.anonymizationStatus = "anonymized";
    }
    this.recordProcessingActivity({
      subjectId,
      dataType: "anonymization_record",
      purpose: "data_anonymization",
      lawfulBasis: "legal_obligation",
      processingActivity: "data_anonymization",
      dataLocation: "internal_database",
      retentionPeriod: this.config.dataRetention.defaultPeriod,
      thirdPartySharing: false,
      encryptionUsed: true,
      metadata: { techniques: this.config.anonymization.techniques }
    });
  }
  async processDataExport(requestId) {
    const exportRequest = this.exportRequests.get(requestId);
    if (!exportRequest) return;
    try {
      exportRequest.status = "processing";
      const dataSubject = this.dataSubjects.get(exportRequest.subjectId);
      if (!dataSubject) {
        exportRequest.status = "failed";
        return;
      }
      const exportData = {
        subject: {
          id: dataSubject.id,
          email: dataSubject.email,
          createdAt: dataSubject.createdAt,
          lastActivity: dataSubject.lastActivity,
          dataCategories: dataSubject.dataCategories
        },
        consents: dataSubject.consentRecords,
        processingActivities: this.processingRecords.filter(
          (record) => record.subjectId === exportRequest.subjectId
        )
      };
      if (exportRequest.includeMetadata) {
        exportData.metadata = {
          exportedAt: Date.now(),
          exportFormat: exportRequest.format,
          gdprVersion: "2018",
          retentionPolicies: this.config.dataRetention
        };
      }
      let exportContent;
      switch (exportRequest.format) {
        case "json":
          exportContent = JSON.stringify(exportData, null, 2);
          break;
        case "csv":
          exportContent = this.convertToCSV(exportData);
          break;
        case "xml":
          exportContent = this.convertToXML(exportData);
          break;
        default:
          throw new Error(`Unsupported format: ${exportRequest.format}`);
      }
      exportRequest.exportUrl = `data:text/plain;base64,${btoa(exportContent)}`;
      exportRequest.status = "completed";
      exportRequest.completedAt = Date.now();
      exportRequest.expiresAt = Date.now() + 7 * 24 * 60 * 60 * 1e3;
    } catch (error) {
      exportRequest.status = "failed";
      console.error(`Data export failed for request ${requestId}:`, error);
    }
  }
  async processDataErasure(requestId) {
    const erasureRequest = this.erasureRequests.get(requestId);
    if (!erasureRequest) return;
    try {
      erasureRequest.status = "processing";
      const dataSubject = this.dataSubjects.get(erasureRequest.subjectId);
      if (!dataSubject) {
        erasureRequest.status = "failed";
        return;
      }
      dataSubject.anonymizationStatus = "deleted";
      if (erasureRequest.cascadeDelete) {
        this.processingRecords = this.processingRecords.filter(
          (record) => record.subjectId !== erasureRequest.subjectId
        );
      } else {
        await this.anonymizeDataSubject(erasureRequest.subjectId);
      }
      erasureRequest.status = "completed";
      erasureRequest.completedAt = Date.now();
    } catch (error) {
      erasureRequest.status = "failed";
      console.error(`Data erasure failed for request ${requestId}:`, error);
    }
  }
  initializeRetentionScheduler() {
    setInterval(() => {
      this.enforceDataRetention();
    }, 24 * 60 * 60 * 1e3);
    setTimeout(() => this.enforceDataRetention(), 5e3);
  }
  enforceDataRetention() {
    const now = Date.now();
    for (const [subjectId, dataSubject] of this.dataSubjects.entries()) {
      for (const category of dataSubject.dataCategories) {
        const retentionPeriod = dataSubject.retentionOverrides[category] || this.config.dataRetention.categories[category] || this.config.dataRetention.defaultPeriod;
        if (now - dataSubject.createdAt > retentionPeriod) {
          this.scheduleDataSubjectDeletion(subjectId, category);
        }
      }
    }
    const maxAge = Math.max(...Object.values(this.config.dataRetention.categories));
    this.processingRecords = this.processingRecords.filter(
      (record) => now - record.timestamp <= maxAge
    );
  }
  scheduleDataSubjectDeletion(subjectId, category) {
    console.log(`Scheduling deletion for subject ${subjectId}, category ${category}`);
  }
  async checkDataRetentionAfterConsentWithdrawal(subjectId) {
    const dataSubject = this.dataSubjects.get(subjectId);
    if (!dataSubject) return;
    const activeConsents = dataSubject.consentRecords.filter(
      (consent) => consent.consentGiven && !consent.withdrawnAt
    );
    if (activeConsents.length === 0) {
      const legitimateInterestData = this.processingRecords.filter(
        (record) => record.subjectId === subjectId && record.lawfulBasis === "legitimate_interests"
      );
      if (legitimateInterestData.length === 0) {
        await this.requestDataErasure(subjectId, "consent_withdrawn", { immediateErasure: false });
      }
    }
  }
  calculateRetentionCompliance() {
    const now = Date.now();
    let compliantSubjects = 0;
    let totalSubjects = 0;
    for (const [_subjectId, dataSubject] of this.dataSubjects.entries()) {
      totalSubjects++;
      let subjectCompliant = true;
      for (const category of dataSubject.dataCategories) {
        const retentionPeriod = this.config.dataRetention.categories[category] || this.config.dataRetention.defaultPeriod;
        if (now - dataSubject.createdAt > retentionPeriod) {
          subjectCompliant = false;
          break;
        }
      }
      if (subjectCompliant) {
        compliantSubjects++;
      }
    }
    return totalSubjects > 0 ? compliantSubjects / totalSubjects * 100 : 100;
  }
  calculateDataMinimizationCompliance() {
    if (!this.config.dataMinimization.enabled) return 100;
    const recentRecords = this.processingRecords.filter(
      (record) => Date.now() - record.timestamp <= 30 * 24 * 60 * 60 * 1e3
      // Last 30 days
    );
    let compliantRecords = 0;
    let totalRecords = recentRecords.length;
    for (const record of recentRecords) {
      const allowedFields = this.config.dataMinimization.allowedFields[record.purpose] || [];
      if (allowedFields.length === 0 || allowedFields.includes(record.dataType)) {
        compliantRecords++;
      }
    }
    return totalRecords > 0 ? compliantRecords / totalRecords * 100 : 100;
  }
  calculateSecurityCompliance(records) {
    const encryptedRecords = records.filter((record) => record.encryptionUsed);
    return records.length > 0 ? encryptedRecords.length / records.length * 100 : 100;
  }
  generateRecommendations() {
    const recommendations = [];
    const expiringConsents = Array.from(this.consentRecords.values()).filter(
      (consent) => consent.expiresAt && consent.expiresAt - Date.now() <= 30 * 24 * 60 * 60 * 1e3
      // 30 days
    );
    if (expiringConsents.length > 0) {
      recommendations.push(`${expiringConsents.length} consents are expiring within 30 days`);
    }
    if (this.config.dataMinimization.enabled) {
      const dataMinimizationScore = this.calculateDataMinimizationCompliance();
      if (dataMinimizationScore < 95) {
        recommendations.push("Review data collection practices to improve data minimization compliance");
      }
    }
    const retentionScore = this.calculateRetentionCompliance();
    if (retentionScore < 95) {
      recommendations.push("Review and update data retention policies");
    }
    return recommendations;
  }
  pseudonymizeEmail(email) {
    if (!email) return void 0;
    const emailParts = email.split("@");
    if (emailParts.length !== 2) return void 0;
    const [local, domain] = emailParts;
    if (!local || !domain) return void 0;
    const hash = btoa(local).substring(0, 8);
    return `user_${hash}@${domain}`;
  }
  aggregateProcessingRecords(subjectId) {
    const subjectRecords = this.processingRecords.filter(
      (record) => record.subjectId === subjectId
    );
    const aggregated = subjectRecords.reduce((acc, record) => {
      const key = record.purpose;
      if (!acc[key]) {
        acc[key] = {
          count: 0,
          dataTypes: /* @__PURE__ */ new Set(),
          firstActivity: record.timestamp,
          lastActivity: record.timestamp
        };
      }
      acc[key].count++;
      acc[key].dataTypes.add(record.dataType);
      acc[key].lastActivity = Math.max(acc[key].lastActivity, record.timestamp);
      return acc;
    }, {});
    this.processingRecords = this.processingRecords.filter(
      (record) => record.subjectId !== subjectId
    );
    for (const [purpose, stats] of Object.entries(aggregated)) {
      this.processingRecords.push({
        id: this.generateProcessingId(),
        subjectId: `anonymized_${btoa(subjectId).substring(0, 8)}`,
        dataType: "aggregated",
        purpose,
        lawfulBasis: "legitimate_interests",
        processingActivity: "aggregated_analytics",
        timestamp: stats.lastActivity,
        dataLocation: "internal_database",
        retentionPeriod: this.config.dataRetention.defaultPeriod,
        thirdPartySharing: false,
        encryptionUsed: true,
        metadata: {
          aggregated: true,
          count: stats.count,
          dataTypes: Array.from(stats.dataTypes),
          period: {
            start: stats.firstActivity,
            end: stats.lastActivity
          }
        }
      });
    }
  }
  convertToCSV(data) {
    const lines = [];
    lines.push("Type,ID,Timestamp,Data");
    lines.push(`Subject,${data.subject.id},${data.subject.createdAt},${JSON.stringify(data.subject).replace(/,/g, ";")}`);
    for (const consent of data.consents) {
      lines.push(`Consent,${consent.id},${consent.timestamp},${JSON.stringify(consent).replace(/,/g, ";")}`);
    }
    return lines.join("\n");
  }
  convertToXML(data) {
    let xml = '<?xml version="1.0" encoding="UTF-8"?>\n<gdpr-export>\n';
    xml += "  <subject>\n";
    xml += `    <id>${data.subject.id}</id>
`;
    xml += `    <email>${data.subject.email || ""}</email>
`;
    xml += `    <created-at>${data.subject.createdAt}</created-at>
`;
    xml += "  </subject>\n";
    xml += "  <consents>\n";
    for (const consent of data.consents) {
      xml += "    <consent>\n";
      xml += `      <id>${consent.id}</id>
`;
      xml += `      <purpose>${consent.purpose}</purpose>
`;
      xml += `      <given>${consent.consentGiven}</given>
`;
      xml += "    </consent>\n";
    }
    xml += "  </consents>\n";
    xml += "</gdpr-export>";
    return xml;
  }
  generateConsentId() {
    return `consent_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
  generateProcessingId() {
    return `proc_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
  generateRequestId() {
    return `req_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
};

// src/compliance/fiscal-audit.ts
init_esm_shims();
var FiscalAuditManager = class {
  config;
  documents = /* @__PURE__ */ new Map();
  periods = /* @__PURE__ */ new Map();
  violations = [];
  sequenceCounters = /* @__PURE__ */ new Map();
  // type -> last sequence number
  auditChain = [];
  // Hash chain for immutability
  reports = /* @__PURE__ */ new Map();
  constructor(config) {
    this.config = {
      enabled: true,
      taxRegion: "IT",
      retentionPeriod: 10 * 365 * 24 * 60 * 60 * 1e3,
      // 10 years
      digitalSignature: {
        required: true,
        algorithm: "ECDSA",
        certificateValidation: true
      },
      receiptSequencing: {
        enforceSequential: true,
        allowGaps: false,
        maxGapSize: 0
      },
      auditTrail: {
        immutable: true,
        hashChaining: true,
        timestamping: true
      },
      compliance: {
        agenziaEntrate: true,
        vatCompliance: true,
        antiMoneyLaundering: true
      },
      ...config
    };
    if (this.config.enabled) {
      this.initializeFiscalSystem();
    }
  }
  /**
   * Create a fiscal document (receipt, invoice, etc.)
   */
  async createFiscalDocument(type, merchantInfo, items, paymentMethod, customerInfo, metadata) {
    if (!this.config.enabled) {
      throw new Error("Fiscal audit system is disabled");
    }
    const documentId = this.generateDocumentId();
    const timestamp = Date.now();
    const fiscalYear = new Date(timestamp).getFullYear();
    const sequenceKey = `${type}_${fiscalYear}`;
    const sequenceNumber = this.getNextSequenceNumber(sequenceKey);
    if (this.config.receiptSequencing.enforceSequential) {
      await this.validateSequence(type, sequenceNumber, fiscalYear);
    }
    const { amount, vat } = this.calculateAmounts(items);
    if (this.config.compliance.vatCompliance) {
      this.validateVATCompliance(items, vat);
    }
    const document2 = {
      id: documentId,
      type,
      sequenceNumber,
      fiscalYear,
      documentNumber: this.generateDocumentNumber(type, sequenceNumber, fiscalYear),
      timestamp,
      amount,
      merchant: merchantInfo,
      ...customerInfo && { customer: customerInfo },
      items,
      vat,
      paymentMethod,
      hash: "",
      // Will be calculated
      previousHash: this.getLastDocumentHash() || "",
      auditTrail: [],
      compliance: {
        agenziaEntrateCompliant: false,
        vatCompliant: false,
        fiscallyValid: false,
        warnings: []
      },
      metadata: metadata || {}
    };
    document2.hash = await this.calculateDocumentHash(document2);
    if (this.config.auditTrail.hashChaining) {
      this.auditChain.push(document2.hash);
    }
    const auditEntry = {
      id: this.generateAuditId(),
      timestamp,
      action: "created",
      userId: metadata?.operator_id || "system",
      details: {
        type,
        amount: amount.total,
        sequenceNumber,
        itemCount: items.length
      },
      hash: await this.calculateAuditHash(documentId, "created", timestamp)
    };
    document2.auditTrail.push(auditEntry);
    if (this.config.digitalSignature.required) {
      document2.digitalSignature = await this.signDocument(document2);
    }
    document2.compliance = await this.validateCompliance(document2);
    this.documents.set(documentId, document2);
    await this.updateFiscalPeriod(document2);
    await this.checkForViolations(document2);
    return documentId;
  }
  /**
   * Void a fiscal document
   */
  async voidFiscalDocument(documentId, reason, userId) {
    const document2 = this.documents.get(documentId);
    if (!document2) {
      throw new Error(`Document not found: ${documentId}`);
    }
    const voidDeadline = document2.timestamp + 24 * 60 * 60 * 1e3;
    if (Date.now() > voidDeadline && this.config.taxRegion === "IT") {
      throw new Error("Document cannot be voided after 24 hours (Italian fiscal law)");
    }
    const auditEntry = {
      id: this.generateAuditId(),
      timestamp: Date.now(),
      action: "voided",
      userId,
      details: {
        reason,
        originalAmount: document2.amount.total,
        voidedAt: Date.now()
      },
      hash: await this.calculateAuditHash(documentId, "voided", Date.now())
    };
    document2.auditTrail.push(auditEntry);
    document2.hash = await this.calculateDocumentHash(document2);
    await this.updateFiscalPeriod(document2);
  }
  /**
   * Generate fiscal period report
   */
  async generateFiscalReport(type, year, month, quarter) {
    const periodKey = this.generatePeriodKey(year, month, quarter);
    const period = this.periods.get(periodKey);
    if (!period) {
      throw new Error(`Fiscal period not found: ${periodKey}`);
    }
    const reportId = this.generateReportId();
    const timestamp = Date.now();
    let reportData;
    switch (type) {
      case "vat_summary":
        reportData = await this.generateVATSummary(period);
        break;
      case "sales_summary":
        reportData = await this.generateSalesSummary(period);
        break;
      case "audit_trail":
        reportData = await this.generateAuditTrailReport(period);
        break;
      case "compliance_check":
        reportData = await this.generateComplianceReport(period);
        break;
      default:
        throw new Error(`Unsupported report type: ${type}`);
    }
    const report = {
      id: reportId,
      type,
      period,
      generatedAt: timestamp,
      generatedBy: "system",
      data: reportData,
      hash: "",
      // Will be calculated
      format: "json",
      compliance: {
        agenziaEntrateFormat: this.config.compliance.agenziaEntrate,
        digitallyValid: false,
        complete: true
      }
    };
    report.hash = await this.calculateReportHash(report);
    if (this.config.digitalSignature.required) {
      report.signature = await this.signReport(report);
      report.compliance.digitallyValid = true;
    }
    this.reports.set(reportId, report);
    return reportId;
  }
  /**
   * Validate fiscal document integrity
   */
  async validateDocumentIntegrity(documentId) {
    const document2 = this.documents.get(documentId);
    if (!document2) {
      return {
        isValid: false,
        issues: ["Document not found"],
        hashChainValid: false,
        signatureValid: false
      };
    }
    const issues = [];
    const calculatedHash = await this.calculateDocumentHash(document2);
    const hashValid = calculatedHash === document2.hash;
    if (!hashValid) {
      issues.push("Document hash mismatch");
    }
    let hashChainValid = true;
    if (this.config.auditTrail.hashChaining && document2.previousHash) {
      const previousDocument = this.findDocumentByHash(document2.previousHash);
      if (!previousDocument) {
        hashChainValid = false;
        issues.push("Previous document not found in chain");
      }
    }
    let signatureValid = true;
    if (this.config.digitalSignature.required && document2.digitalSignature) {
      signatureValid = await this.verifyDocumentSignature(document2);
      if (!signatureValid) {
        issues.push("Digital signature invalid");
      }
    }
    for (const entry of document2.auditTrail) {
      const auditHash = await this.calculateAuditHash(
        documentId,
        entry.action,
        entry.timestamp
      );
      if (auditHash !== entry.hash) {
        issues.push(`Audit entry ${entry.id} hash mismatch`);
      }
    }
    return {
      isValid: issues.length === 0,
      issues,
      hashChainValid,
      signatureValid
    };
  }
  /**
   * Get fiscal compliance status
   */
  getFiscalComplianceStatus() {
    const documents = Array.from(this.documents.values());
    const periods = Array.from(this.periods.values());
    const compliantDocs = documents.filter((d) => d.compliance.fiscallyValid);
    const warningDocs = documents.filter((d) => d.compliance.warnings.length > 0);
    const violationDocs = documents.filter((d) => !d.compliance.fiscallyValid);
    const openPeriods = periods.filter((p) => p.status === "open").length;
    const closedPeriods = periods.filter((p) => p.status === "closed").length;
    const transmittedPeriods = periods.filter((p) => p.status === "transmitted").length;
    const criticalViolations = this.violations.filter((v) => v.severity === "critical").length;
    const unresolvedViolations = this.violations.filter((v) => !v.resolvedAt).length;
    const now = Date.now();
    const sixMonthsFromNow = now + 6 * 30 * 24 * 60 * 60 * 1e3;
    const retentionDeadline = now - this.config.retentionPeriod;
    const expiringSoon = documents.filter(
      (d) => d.timestamp + this.config.retentionPeriod > now && d.timestamp + this.config.retentionPeriod <= sixMonthsFromNow
    ).length;
    const expired = documents.filter(
      (d) => d.timestamp < retentionDeadline
    ).length;
    let overall = "compliant";
    if (criticalViolations > 0 || violationDocs.length > 0) {
      overall = "violations";
    } else if (warningDocs.length > 0) {
      overall = "warnings";
    }
    return {
      overall,
      documents: {
        total: documents.length,
        compliant: compliantDocs.length,
        withWarnings: warningDocs.length,
        withViolations: violationDocs.length
      },
      periods: {
        open: openPeriods,
        closed: closedPeriods,
        transmitted: transmittedPeriods
      },
      violations: {
        total: this.violations.length,
        critical: criticalViolations,
        unresolved: unresolvedViolations
      },
      retention: {
        totalDocuments: documents.length,
        expiringSoon,
        expired
      }
    };
  }
  /**
   * Export fiscal data for tax authorities
   */
  async exportFiscalData(year, format = "xml") {
    const yearDocuments = Array.from(this.documents.values()).filter((doc) => doc.fiscalYear === year);
    const exportData = {
      metadata: {
        exportedAt: Date.now(),
        taxYear: year,
        totalDocuments: yearDocuments.length,
        software: "A-Cube eReceipt SDK",
        version: "2.0.0"
      },
      merchant: yearDocuments[0]?.merchant || {},
      documents: yearDocuments.map((doc) => ({
        id: doc.id,
        type: doc.type,
        documentNumber: doc.documentNumber,
        timestamp: doc.timestamp,
        amount: doc.amount,
        vat: doc.vat,
        hash: doc.hash,
        digitalSignature: doc.digitalSignature
      })),
      summary: {
        totalAmount: yearDocuments.reduce((sum, doc) => sum + doc.amount.total, 0),
        totalVAT: yearDocuments.reduce((sum, doc) => sum + doc.amount.vat, 0),
        documentsByType: this.groupDocumentsByType(yearDocuments)
      },
      compliance: {
        agenziaEntrateCompliant: this.config.compliance.agenziaEntrate,
        retentionCompliant: true,
        digitallyValid: yearDocuments.every((doc) => doc.digitalSignature)
      }
    };
    if (format === "xml") {
      return this.convertToAgenziaEntrateXML(exportData);
    } else {
      return JSON.stringify(exportData, null, 2);
    }
  }
  initializeFiscalSystem() {
    const now = /* @__PURE__ */ new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth() + 1;
    this.ensureFiscalPeriod(currentYear, currentMonth);
    setInterval(() => {
      this.performPeriodicComplianceCheck();
    }, 24 * 60 * 60 * 1e3);
  }
  getNextSequenceNumber(sequenceKey) {
    const current = this.sequenceCounters.get(sequenceKey) || 0;
    const next = current + 1;
    this.sequenceCounters.set(sequenceKey, next);
    return next;
  }
  async validateSequence(type, sequenceNumber, fiscalYear) {
    if (!this.config.receiptSequencing.enforceSequential) return;
    const sequenceKey = `${type}_${fiscalYear}`;
    const expectedNumber = (this.sequenceCounters.get(sequenceKey) || 0) + 1;
    if (sequenceNumber !== expectedNumber) {
      if (!this.config.receiptSequencing.allowGaps) {
        throw new Error(`Sequence violation: expected ${expectedNumber}, got ${sequenceNumber}`);
      }
      const gap = Math.abs(sequenceNumber - expectedNumber);
      if (gap > this.config.receiptSequencing.maxGapSize) {
        throw new Error(`Sequence gap too large: ${gap} > ${this.config.receiptSequencing.maxGapSize}`);
      }
      this.recordViolation({
        type: "sequence_gap",
        severity: "warning",
        description: `Sequence gap detected: expected ${expectedNumber}, got ${sequenceNumber}`,
        metadata: { type, fiscalYear, expectedNumber, actualNumber: sequenceNumber }
      });
    }
  }
  calculateAmounts(items) {
    let netTotal = 0;
    let vatTotal = 0;
    const vatBreakdown = /* @__PURE__ */ new Map();
    for (const item of items) {
      const itemNet = item.quantity * item.unitPrice;
      const itemVat = itemNet * (item.vatRate / 100);
      netTotal += itemNet;
      vatTotal += itemVat;
      const existing = vatBreakdown.get(item.vatRate) || { net: 0, vat: 0 };
      existing.net += itemNet;
      existing.vat += itemVat;
      vatBreakdown.set(item.vatRate, existing);
    }
    const vat = Array.from(vatBreakdown.entries()).map(([rate, amounts]) => ({
      rate,
      netAmount: amounts.net,
      vatAmount: amounts.vat,
      totalAmount: amounts.net + amounts.vat,
      category: this.getVATCategory(rate)
    }));
    return {
      amount: {
        net: netTotal,
        vat: vatTotal,
        total: netTotal + vatTotal,
        currency: "EUR"
      },
      vat
    };
  }
  getVATCategory(rate) {
    if (rate === 0) return "zero";
    if (rate === 22) return "standard";
    if (rate === 10 || rate === 4) return "reduced";
    return "standard";
  }
  validateVATCompliance(items, _vat) {
    const validRates = [0, 4, 5, 10, 22];
    for (const item of items) {
      if (!validRates.includes(item.vatRate)) {
        this.recordViolation({
          type: "invalid_vat",
          severity: "error",
          description: `Invalid VAT rate: ${item.vatRate}% (item: ${item.description})`,
          metadata: { itemId: item.id, vatRate: item.vatRate }
        });
      }
    }
  }
  async calculateDocumentHash(document2) {
    const hashData = {
      id: document2.id,
      type: document2.type,
      sequenceNumber: document2.sequenceNumber,
      timestamp: document2.timestamp,
      amount: document2.amount,
      merchant: document2.merchant,
      items: document2.items,
      previousHash: document2.previousHash
    };
    const encoder = new TextEncoder();
    const data = encoder.encode(JSON.stringify(hashData));
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  async calculateAuditHash(documentId, action, timestamp) {
    const hashData = `${documentId}:${action}:${timestamp}`;
    const encoder = new TextEncoder();
    const data = encoder.encode(hashData);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  async calculateReportHash(report) {
    const hashData = {
      id: report.id,
      type: report.type,
      period: report.period,
      generatedAt: report.generatedAt,
      data: report.data
    };
    const encoder = new TextEncoder();
    const data = encoder.encode(JSON.stringify(hashData));
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  getLastDocumentHash() {
    return this.auditChain[this.auditChain.length - 1];
  }
  findDocumentByHash(hash) {
    return Array.from(this.documents.values()).find((doc) => doc.hash === hash);
  }
  async signDocument(document2) {
    const documentHash = await this.calculateDocumentHash(document2);
    return `signature_${documentHash.substring(0, 16)}`;
  }
  async signReport(report) {
    const reportHash = await this.calculateReportHash(report);
    return `signature_${reportHash.substring(0, 16)}`;
  }
  async verifyDocumentSignature(document2) {
    if (!document2.digitalSignature) return false;
    const documentHash = await this.calculateDocumentHash(document2);
    const expectedSignature = `signature_${documentHash.substring(0, 16)}`;
    return document2.digitalSignature === expectedSignature;
  }
  async validateCompliance(document2) {
    const warnings = [];
    let agenziaEntrateCompliant = true;
    let vatCompliant = true;
    let fiscallyValid = true;
    if (this.config.compliance.agenziaEntrate) {
      if (!document2.merchant.vatNumber || !document2.merchant.fiscalCode) {
        warnings.push("Missing merchant VAT number or fiscal code");
        agenziaEntrateCompliant = false;
      }
      if (!document2.digitalSignature && this.config.digitalSignature.required) {
        warnings.push("Missing digital signature");
        agenziaEntrateCompliant = false;
      }
    }
    if (this.config.compliance.vatCompliance) {
      const totalVAT = document2.vat.reduce((sum, v) => sum + v.vatAmount, 0);
      if (Math.abs(totalVAT - document2.amount.vat) > 0.01) {
        warnings.push("VAT calculation mismatch");
        vatCompliant = false;
      }
    }
    fiscallyValid = agenziaEntrateCompliant && vatCompliant;
    return {
      agenziaEntrateCompliant,
      vatCompliant,
      fiscallyValid,
      warnings
    };
  }
  generateDocumentNumber(type, sequenceNumber, fiscalYear) {
    const typePrefix = {
      receipt: "RC",
      invoice: "FT",
      credit_note: "NC",
      fiscal_report: "RF"
    }[type] || "DOC";
    return `${typePrefix}${fiscalYear}${String(sequenceNumber).padStart(6, "0")}`;
  }
  ensureFiscalPeriod(year, month, quarter) {
    const periodKey = this.generatePeriodKey(year, month, quarter);
    if (!this.periods.has(periodKey)) {
      const startDate = month ? new Date(year, month - 1, 1).getTime() : new Date(year, 0, 1).getTime();
      const endDate = month ? new Date(year, month, 0).getTime() : new Date(year + 1, 0, 0).getTime();
      const period = {
        year,
        ...month !== void 0 && { month },
        ...quarter !== void 0 && { quarter },
        startDate,
        endDate,
        status: "open",
        documents: [],
        summary: {
          totalDocuments: 0,
          totalAmount: 0,
          totalVAT: 0,
          byType: {},
          byVATRate: {}
        }
      };
      this.periods.set(periodKey, period);
    }
  }
  async updateFiscalPeriod(document2) {
    const date = new Date(document2.timestamp);
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    this.ensureFiscalPeriod(year, month);
    const periodKey = this.generatePeriodKey(year, month);
    const period = this.periods.get(periodKey);
    if (!period.documents.includes(document2.id)) {
      period.documents.push(document2.id);
      period.summary.totalDocuments++;
      period.summary.totalAmount += document2.amount.total;
      period.summary.totalVAT += document2.amount.vat;
      period.summary.byType[document2.type] = (period.summary.byType[document2.type] || 0) + 1;
      for (const vat of document2.vat) {
        const rateKey = `${vat.rate}%`;
        period.summary.byVATRate[rateKey] = (period.summary.byVATRate[rateKey] || 0) + vat.vatAmount;
      }
    }
  }
  async checkForViolations(document2) {
    if (this.config.digitalSignature.required && !document2.digitalSignature) {
      this.recordViolation({
        type: "missing_signature",
        severity: "critical",
        documentId: document2.id,
        description: "Document missing required digital signature",
        metadata: { documentType: document2.type }
      });
    }
    if (!document2.compliance.vatCompliant) {
      this.recordViolation({
        type: "invalid_vat",
        severity: "error",
        documentId: document2.id,
        description: "VAT calculation errors detected",
        metadata: { warnings: document2.compliance.warnings }
      });
    }
  }
  recordViolation(violation) {
    const fullViolation = {
      id: this.generateViolationId(),
      detectedAt: Date.now(),
      automaticResolution: false,
      ...violation
    };
    this.violations.push(fullViolation);
  }
  async generateVATSummary(period) {
    const documents = period.documents.map((id) => this.documents.get(id)).filter(Boolean);
    const vatSummary = documents.reduce((summary, doc) => {
      for (const vat of doc.vat) {
        const key = `${vat.rate}%`;
        if (!summary[key]) {
          summary[key] = { netAmount: 0, vatAmount: 0, totalAmount: 0 };
        }
        summary[key].netAmount += vat.netAmount;
        summary[key].vatAmount += vat.vatAmount;
        summary[key].totalAmount += vat.totalAmount;
      }
      return summary;
    }, {});
    return {
      period: `${period.year}-${period.month?.toString().padStart(2, "0") || "YEAR"}`,
      vatSummary,
      totalNet: Object.values(vatSummary).reduce((sum, v) => sum + v.netAmount, 0),
      totalVAT: Object.values(vatSummary).reduce((sum, v) => sum + v.vatAmount, 0),
      totalGross: Object.values(vatSummary).reduce((sum, v) => sum + v.totalAmount, 0)
    };
  }
  async generateSalesSummary(period) {
    return {
      period: `${period.year}-${period.month?.toString().padStart(2, "0") || "YEAR"}`,
      summary: period.summary,
      documents: period.documents.length
    };
  }
  async generateAuditTrailReport(period) {
    const documents = period.documents.map((id) => this.documents.get(id)).filter(Boolean);
    const auditEntries = documents.flatMap(
      (doc) => doc.auditTrail.map((entry) => ({
        documentId: doc.id,
        documentNumber: doc.documentNumber,
        ...entry
      }))
    );
    return {
      period: `${period.year}-${period.month?.toString().padStart(2, "0") || "YEAR"}`,
      auditEntries,
      totalEntries: auditEntries.length
    };
  }
  async generateComplianceReport(period) {
    const documents = period.documents.map((id) => this.documents.get(id)).filter(Boolean);
    const compliantDocs = documents.filter((doc) => doc.compliance.fiscallyValid);
    const nonCompliantDocs = documents.filter((doc) => !doc.compliance.fiscallyValid);
    return {
      period: `${period.year}-${period.month?.toString().padStart(2, "0") || "YEAR"}`,
      complianceRate: documents.length > 0 ? compliantDocs.length / documents.length * 100 : 100,
      totalDocuments: documents.length,
      compliantDocuments: compliantDocs.length,
      nonCompliantDocuments: nonCompliantDocs.length,
      violations: this.violations.filter(
        (v) => v.documentId && period.documents.includes(v.documentId)
      )
    };
  }
  performPeriodicComplianceCheck() {
    const now = Date.now();
    const warningPeriod = 6 * 30 * 24 * 60 * 60 * 1e3;
    for (const document2 of this.documents.values()) {
      const retentionDeadline = document2.timestamp + this.config.retentionPeriod;
      if (retentionDeadline - now <= warningPeriod && retentionDeadline > now) {
        this.recordViolation({
          type: "retention_violation",
          severity: "warning",
          documentId: document2.id,
          description: `Document approaching retention deadline`,
          metadata: {
            retentionDeadline,
            daysRemaining: Math.floor((retentionDeadline - now) / (24 * 60 * 60 * 1e3))
          }
        });
      }
    }
  }
  convertToAgenziaEntrateXML(data) {
    let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
    xml += '<DatiFattura versione="1.0">\n';
    xml += "  <DatiGenerali>\n";
    xml += `    <AnnoFiscale>${data.metadata.taxYear}</AnnoFiscale>
`;
    xml += `    <NumeroDocumenti>${data.metadata.totalDocuments}</NumeroDocumenti>
`;
    xml += "  </DatiGenerali>\n";
    xml += "  <Documenti>\n";
    for (const doc of data.documents) {
      xml += "    <Documento>\n";
      xml += `      <ID>${doc.id}</ID>
`;
      xml += `      <Numero>${doc.documentNumber}</Numero>
`;
      xml += `      <Data>${new Date(doc.timestamp).toISOString().split("T")[0]}</Data>
`;
      xml += `      <Importo>${doc.amount.total}</Importo>
`;
      xml += `      <IVA>${doc.amount.vat}</IVA>
`;
      xml += "    </Documento>\n";
    }
    xml += "  </Documenti>\n";
    xml += "</DatiFattura>";
    return xml;
  }
  groupDocumentsByType(documents) {
    return documents.reduce((acc, doc) => {
      acc[doc.type] = (acc[doc.type] || 0) + 1;
      return acc;
    }, {});
  }
  generatePeriodKey(year, month, quarter) {
    if (month) return `${year}-${month.toString().padStart(2, "0")}`;
    if (quarter) return `${year}-Q${quarter}`;
    return `${year}`;
  }
  generateDocumentId() {
    return `doc_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
  generateAuditId() {
    return `audit_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
  generateReportId() {
    return `report_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
  generateViolationId() {
    return `violation_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
};

// src/compliance/index.ts
init_access_control();

// src/plugins/index.ts
init_esm_shims();

// src/plugins/core/index.ts
init_esm_shims();

// src/plugins/core/plugin-manager.ts
init_esm_shims();
init_eventemitter3();
var PluginManager = class extends import_index.default {
  plugins = /* @__PURE__ */ new Map();
  middleware = [];
  sdk;
  globalConfig = /* @__PURE__ */ new Map();
  globalCache = /* @__PURE__ */ new Map();
  constructor(sdk) {
    super();
    this.sdk = sdk;
  }
  /**
   * Register a plugin with the SDK
   */
  async register(plugin) {
    const { name, version } = plugin.manifest;
    this.validatePlugin(plugin);
    if (this.plugins.has(name)) {
      throw new PluginManagerError(`Plugin '${name}' is already registered`);
    }
    await this.validateDependencies(plugin);
    const context = this.createPluginContext(plugin);
    const registration = {
      plugin,
      context,
      isActive: false,
      loadedAt: /* @__PURE__ */ new Date(),
      errors: []
    };
    try {
      if (plugin.onInit) {
        await plugin.onInit(context);
      }
      registration.isActive = true;
      this.plugins.set(name, registration);
      this.registerMiddleware(plugin, context);
      this.emit("plugin:registered", { name, version });
      console.info(`Plugin '${name}@${version}' registered successfully`);
    } catch (error) {
      const pluginError = {
        message: error instanceof Error ? error.message : String(error),
        ...error instanceof Error && error.stack && { stack: error.stack },
        timestamp: /* @__PURE__ */ new Date(),
        phase: "init"
      };
      registration.errors.push(pluginError);
      this.plugins.set(name, registration);
      this.emit("plugin:error", { name, error: pluginError });
      throw new PluginManagerError(`Failed to initialize plugin '${name}': ${pluginError.message}`);
    }
  }
  /**
   * Unregister a plugin
   */
  async unregister(name) {
    const registration = this.plugins.get(name);
    if (!registration) {
      throw new PluginManagerError(`Plugin '${name}' is not registered`);
    }
    try {
      if (registration.plugin.onDestroy) {
        await registration.plugin.onDestroy(registration.context);
      }
      this.middleware = this.middleware.filter((m) => m.pluginName !== name);
      this.plugins.delete(name);
      this.emit("plugin:unregistered", { name });
      console.info(`Plugin '${name}' unregistered successfully`);
    } catch (error) {
      const pluginError = {
        message: error instanceof Error ? error.message : String(error),
        ...error instanceof Error && error.stack && { stack: error.stack },
        timestamp: /* @__PURE__ */ new Date(),
        phase: "destroy"
      };
      registration.errors.push(pluginError);
      this.emit("plugin:error", { name, error: pluginError });
      throw new PluginManagerError(`Failed to destroy plugin '${name}': ${pluginError.message}`);
    }
  }
  /**
   * Get information about registered plugins
   */
  getRegisteredPlugins() {
    return Array.from(this.plugins.values()).map((reg) => ({
      name: reg.plugin.manifest.name,
      version: reg.plugin.manifest.version,
      isActive: reg.isActive,
      loadedAt: reg.loadedAt,
      errors: reg.errors
    }));
  }
  /**
   * Check if plugin is registered
   */
  isRegistered(name) {
    return this.plugins.has(name);
  }
  /**
   * Get plugin by name
   */
  getPlugin(name) {
    return this.plugins.get(name)?.plugin;
  }
  /**
   * Execute middleware hooks
   */
  async executeBeforeRequestHooks(options) {
    let modifiedOptions = options;
    for (const middleware of this.middleware) {
      if (middleware.beforeRequest) {
        try {
          modifiedOptions = await middleware.beforeRequest(middleware.context, modifiedOptions) || modifiedOptions;
        } catch (error) {
          this.handleMiddlewareError(middleware.pluginName, "beforeRequest", error);
        }
      }
    }
    return modifiedOptions;
  }
  async executeAfterResponseHooks(response) {
    let modifiedResponse = response;
    for (const middleware of this.middleware) {
      if (middleware.afterResponse) {
        try {
          modifiedResponse = await middleware.afterResponse(middleware.context, modifiedResponse) || modifiedResponse;
        } catch (error) {
          this.handleMiddlewareError(middleware.pluginName, "afterResponse", error);
        }
      }
    }
    return modifiedResponse;
  }
  async executeErrorHooks(error) {
    let modifiedError = error;
    for (const middleware of this.middleware) {
      if (middleware.onError) {
        try {
          const result = await middleware.onError(middleware.context, modifiedError);
          if (result instanceof Error) {
            modifiedError = result;
          }
        } catch (hookError) {
          this.handleMiddlewareError(middleware.pluginName, "onError", hookError);
        }
      }
    }
    return modifiedError;
  }
  /**
   * Cleanup all plugins
   */
  async destroy() {
    const pluginNames = Array.from(this.plugins.keys());
    for (const name of pluginNames) {
      try {
        await this.unregister(name);
      } catch (error) {
        console.error(`Failed to unregister plugin '${name}' during cleanup:`, error);
      }
    }
    this.removeAllListeners();
  }
  validatePlugin(plugin) {
    const { name, version } = plugin.manifest;
    if (!name || typeof name !== "string") {
      throw new PluginManagerError("Plugin manifest must have a valid name");
    }
    if (!version || typeof version !== "string") {
      throw new PluginManagerError("Plugin manifest must have a valid version");
    }
    if (!/^[a-z0-9-_]+$/i.test(name)) {
      throw new PluginManagerError("Plugin name can only contain letters, numbers, hyphens, and underscores");
    }
  }
  async validateDependencies(plugin) {
    const { dependencies = [], peerDependencies = [] } = plugin.manifest;
    for (const dep of dependencies) {
      if (!this.isRegistered(dep)) {
        throw new PluginManagerError(`Plugin dependency '${dep}' is not registered`);
      }
    }
    for (const peerDep of peerDependencies) {
      if (!this.isRegistered(peerDep)) {
        console.warn(`Plugin peer dependency '${peerDep}' is not registered`);
      }
    }
  }
  createPluginContext(plugin) {
    const pluginName = plugin.manifest.name;
    const permissions = plugin.manifest.permissions || [];
    return {
      sdk: this.sdk,
      logger: this.createPluginLogger(pluginName),
      storage: this.createPluginStorage(pluginName, permissions),
      events: this.createPluginEventEmitter(pluginName, permissions),
      config: this.createPluginConfig(pluginName, permissions),
      cache: this.createPluginCache(pluginName, permissions),
      http: this.createPluginHttpClient(permissions)
    };
  }
  createPluginLogger(pluginName) {
    return {
      debug: (message, meta) => console.debug(`[${pluginName}] ${message}`, meta),
      info: (message, meta) => console.info(`[${pluginName}] ${message}`, meta),
      warn: (message, meta) => console.warn(`[${pluginName}] ${message}`, meta),
      error: (message, meta) => console.error(`[${pluginName}] ${message}`, meta)
    };
  }
  createPluginStorage(pluginName, permissions) {
    const canRead = permissions.includes("storage:read");
    const canWrite = permissions.includes("storage:write");
    const storageKey = `plugin:${pluginName}`;
    return {
      get: (key) => {
        if (!canRead) throw new PluginManagerError("Plugin does not have storage:read permission");
        const data = localStorage.getItem(`${storageKey}:${key}`);
        return data ? JSON.parse(data) : void 0;
      },
      set: (key, value) => {
        if (!canWrite) throw new PluginManagerError("Plugin does not have storage:write permission");
        localStorage.setItem(`${storageKey}:${key}`, JSON.stringify(value));
      },
      delete: (key) => {
        if (!canWrite) throw new PluginManagerError("Plugin does not have storage:write permission");
        localStorage.removeItem(`${storageKey}:${key}`);
      },
      clear: () => {
        if (!canWrite) throw new PluginManagerError("Plugin does not have storage:write permission");
        const keys = Object.keys(localStorage).filter((k) => k.startsWith(`${storageKey}:`));
        keys.forEach((k) => localStorage.removeItem(k));
      },
      keys: () => {
        if (!canRead) throw new PluginManagerError("Plugin does not have storage:read permission");
        return Object.keys(localStorage).filter((k) => k.startsWith(`${storageKey}:`)).map((k) => k.replace(`${storageKey}:`, ""));
      }
    };
  }
  createPluginEventEmitter(pluginName, permissions) {
    const canListen = permissions.includes("events:listen");
    const canEmit = permissions.includes("events:emit");
    return {
      on: (event, listener) => {
        if (!canListen) throw new PluginManagerError("Plugin does not have events:listen permission");
        this.on(`plugin:${pluginName}:${event}`, listener);
      },
      off: (event, listener) => {
        if (!canListen) throw new PluginManagerError("Plugin does not have events:listen permission");
        this.off(`plugin:${pluginName}:${event}`, listener);
      },
      emit: (event, ...args) => {
        if (!canEmit) throw new PluginManagerError("Plugin does not have events:emit permission");
        return this.emit(`plugin:${pluginName}:${event}`, ...args);
      }
    };
  }
  createPluginConfig(pluginName, permissions) {
    const canRead = permissions.includes("config:read");
    const canWrite = permissions.includes("config:write");
    return {
      get: (key) => {
        if (!canRead) throw new PluginManagerError("Plugin does not have config:read permission");
        return this.globalConfig.get(`${pluginName}:${key}`);
      },
      set: (key, value) => {
        if (!canWrite) throw new PluginManagerError("Plugin does not have config:write permission");
        this.globalConfig.set(`${pluginName}:${key}`, value);
      },
      has: (key) => {
        if (!canRead) throw new PluginManagerError("Plugin does not have config:read permission");
        return this.globalConfig.has(`${pluginName}:${key}`);
      }
    };
  }
  createPluginCache(pluginName, permissions) {
    const canRead = permissions.includes("cache:read");
    const canWrite = permissions.includes("cache:write");
    return {
      get: (key) => {
        if (!canRead) throw new PluginManagerError("Plugin does not have cache:read permission");
        const entry = this.globalCache.get(`${pluginName}:${key}`);
        if (!entry) return void 0;
        if (entry.expires && Date.now() > entry.expires) {
          this.globalCache.delete(`${pluginName}:${key}`);
          return void 0;
        }
        return entry.value;
      },
      set: (key, value, ttl) => {
        if (!canWrite) throw new PluginManagerError("Plugin does not have cache:write permission");
        const expires = ttl ? Date.now() + ttl : void 0;
        this.globalCache.set(`${pluginName}:${key}`, { value, ...expires && { expires } });
      },
      delete: (key) => {
        if (!canWrite) throw new PluginManagerError("Plugin does not have cache:write permission");
        this.globalCache.delete(`${pluginName}:${key}`);
      },
      clear: () => {
        if (!canWrite) throw new PluginManagerError("Plugin does not have cache:write permission");
        const keys = Array.from(this.globalCache.keys()).filter((k) => k.startsWith(`${pluginName}:`));
        keys.forEach((k) => this.globalCache.delete(k));
      }
    };
  }
  createPluginHttpClient(permissions) {
    const canRead = permissions.includes("http:read");
    const canWrite = permissions.includes("http:write");
    const httpClient = this.sdk.getClients().api;
    return {
      request: async (options) => {
        const isReadOperation = options.method === "GET";
        const isWriteOperation = ["POST", "PUT", "PATCH", "DELETE"].includes(options.method);
        if (isReadOperation && !canRead) {
          throw new PluginManagerError("Plugin does not have http:read permission");
        }
        if (isWriteOperation && !canWrite) {
          throw new PluginManagerError("Plugin does not have http:write permission");
        }
        return httpClient.request(options);
      },
      get: async (url, options) => {
        if (!canRead) throw new PluginManagerError("Plugin does not have http:read permission");
        return httpClient.get(url, options);
      },
      post: async (url, data, options) => {
        if (!canWrite) throw new PluginManagerError("Plugin does not have http:write permission");
        return httpClient.post(url, data, options);
      }
    };
  }
  registerMiddleware(plugin, context) {
    const middleware = {
      pluginName: plugin.manifest.name,
      context,
      ...plugin.beforeRequest && { beforeRequest: plugin.beforeRequest },
      ...plugin.afterResponse && { afterResponse: plugin.afterResponse },
      ...plugin.onError && { onError: plugin.onError }
    };
    this.middleware.push(middleware);
  }
  handleMiddlewareError(pluginName, phase, error) {
    const registration = this.plugins.get(pluginName);
    if (registration) {
      const pluginError = {
        message: error instanceof Error ? error.message : String(error),
        ...error instanceof Error && error.stack && { stack: error.stack },
        timestamp: /* @__PURE__ */ new Date(),
        phase: "runtime"
      };
      registration.errors.push(pluginError);
      this.emit("plugin:error", { name: pluginName, error: pluginError });
    }
    console.error(`Plugin '${pluginName}' error in ${phase}:`, error);
  }
};
var PluginManagerError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "PluginManagerError";
  }
};

// src/plugins/core/base-plugin.ts
init_esm_shims();
var BasePlugin = class {
  context;
  /**
   * Initialize the plugin with context
   */
  async onInit(context) {
    this.context = context;
    this.log("info", "Plugin initialized");
    await this.initialize(context);
  }
  /**
   * Cleanup plugin resources
   */
  async onDestroy(context) {
    this.log("info", "Plugin destroying");
    await this.cleanup(context);
    delete this.context;
  }
  /**
   * Handle configuration changes
   */
  async onConfigChange(context, key, value) {
    this.log("debug", `Config changed: ${key}`, { value });
    await this.handleConfigChange(context, key, value);
  }
  /**
   * Process requests before they are sent
   */
  async beforeRequest(context, options) {
    this.log("debug", `Processing request: ${options.method} ${options.url}`);
    return await this.processRequest(context, options) || options;
  }
  /**
   * Process responses after they are received
   */
  async afterResponse(context, response) {
    this.log("debug", `Processing response: ${response.status}`);
    return await this.processResponse(context, response) || response;
  }
  /**
   * Handle errors
   */
  async onError(context, error) {
    this.log("error", "Handling error", { error: error.message });
    return await this.handleError(context, error) || error;
  }
  // Optional hooks for subclasses to override
  /**
   * Handle configuration changes (optional)
   */
  async handleConfigChange(_context, _key, _value) {
  }
  /**
   * Process outgoing requests (optional)
   */
  async processRequest(_context, options) {
    return options;
  }
  /**
   * Process incoming responses (optional)
   */
  async processResponse(_context, response) {
    return response;
  }
  /**
   * Handle errors (optional)
   */
  async handleError(_context, error) {
    return error;
  }
  // Utility methods
  /**
   * Ensure plugin has required permissions
   */
  requirePermissions(...permissions) {
    const pluginPermissions = this.manifest.permissions || [];
    for (const permission of permissions) {
      if (!pluginPermissions.includes(permission)) {
        throw new Error(`Plugin '${this.manifest.name}' requires permission: ${permission}`);
      }
    }
  }
  /**
   * Check if plugin has permission
   */
  hasPermission(permission) {
    return (this.manifest.permissions || []).includes(permission);
  }
  /**
   * Log messages with plugin context
   */
  log(level, message, meta) {
    if (this.context) {
      this.context.logger[level](message, meta);
    } else {
      console[level](`[${this.manifest.name}] ${message}`, meta);
    }
  }
  /**
   * Get configuration value
   */
  getConfig(key) {
    this.requirePermissions("config:read");
    return this.context?.config.get(key);
  }
  /**
   * Set configuration value
   */
  setConfig(key, value) {
    this.requirePermissions("config:write");
    this.context?.config.set(key, value);
  }
  /**
   * Get from cache
   */
  getFromCache(key) {
    this.requirePermissions("cache:read");
    return this.context?.cache.get(key);
  }
  /**
   * Set in cache
   */
  setInCache(key, value, ttl) {
    this.requirePermissions("cache:write");
    this.context?.cache.set(key, value, ttl);
  }
  /**
   * Get from storage
   */
  getFromStorage(key) {
    this.requirePermissions("storage:read");
    return this.context?.storage.get(key);
  }
  /**
   * Set in storage
   */
  setInStorage(key, value) {
    this.requirePermissions("storage:write");
    this.context?.storage.set(key, value);
  }
  /**
   * Emit event
   */
  emitEvent(event, ...args) {
    this.requirePermissions("events:emit");
    return this.context?.events.emit(event, ...args) || false;
  }
  /**
   * Listen to event
   */
  onEvent(event, listener) {
    this.requirePermissions("events:listen");
    this.context?.events.on(event, listener);
  }
  /**
   * Make HTTP request
   */
  async makeRequest(options) {
    const isReadOperation = options.method === "GET";
    this.requirePermissions(isReadOperation ? "http:read" : "http:write");
    if (!this.context) {
      throw new Error("Plugin context not available");
    }
    return this.context.http.request(options);
  }
  /**
   * Get SDK instance
   */
  get sdk() {
    if (!this.context) {
      throw new Error("Plugin context not available");
    }
    return this.context.sdk;
  }
  /**
   * Validate plugin manifest
   */
  static validateManifest(manifest) {
    if (!manifest.name || typeof manifest.name !== "string") {
      throw new Error("Plugin manifest must have a valid name");
    }
    if (!manifest.version || typeof manifest.version !== "string") {
      throw new Error("Plugin manifest must have a valid version");
    }
    const semverRegex = /^(\d+)\.(\d+)\.(\d+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?$/;
    if (!semverRegex.test(manifest.version)) {
      throw new Error("Plugin version must follow semantic versioning (e.g., 1.0.0)");
    }
    if (manifest.permissions) {
      const validPermissions = [
        "http:read",
        "http:write",
        "storage:read",
        "storage:write",
        "events:emit",
        "events:listen",
        "cache:read",
        "cache:write",
        "config:read",
        "config:write"
      ];
      for (const permission of manifest.permissions) {
        if (!validPermissions.includes(permission)) {
          throw new Error(`Invalid permission: ${permission}`);
        }
      }
    }
  }
};

// src/plugins/builtin/index.ts
init_esm_shims();

// src/plugins/builtin/analytics-plugin.ts
init_esm_shims();
var AnalyticsPlugin = class extends BasePlugin {
  manifest = {
    name: "analytics",
    version: "1.0.0",
    description: "Track API usage, performance metrics, and user behavior",
    author: "A-Cube Team",
    permissions: [
      "http:read",
      "storage:read",
      "storage:write",
      "cache:read",
      "cache:write",
      "events:emit",
      "config:read",
      "config:write"
    ]
  };
  sessionId = "";
  requestMetrics = /* @__PURE__ */ new Map();
  eventQueue = [];
  performanceMetrics = [];
  flushInterval;
  async initialize(context) {
    this.sessionId = this.generateSessionId();
    const config = this.getConfig("settings") || {
      enabled: true,
      batchSize: 50,
      flushInterval: 3e4,
      // 30 seconds
      trackUserActions: true,
      trackPerformance: true
    };
    if (!config.enabled) {
      this.log("info", "Analytics disabled by configuration");
      return;
    }
    this.flushInterval = setInterval(() => {
      this.flushEvents();
    }, config.flushInterval);
    this.trackEvent("session_start", {
      sdk_version: "2.0.0",
      environment: context.sdk.getConfig().environment,
      timestamp: Date.now()
    });
    this.log("info", "Analytics plugin initialized", { sessionId: this.sessionId });
  }
  async cleanup(_context) {
    await this.flushEvents();
    if (this.flushInterval) {
      clearInterval(this.flushInterval);
    }
    const sessionParts = this.sessionId.split("_");
    const sessionStart = sessionParts[1] ? parseInt(sessionParts[1]) : Date.now();
    this.trackEvent("session_end", {
      duration: Date.now() - sessionStart,
      total_requests: this.performanceMetrics.length
    });
    await this.flushEvents();
    this.log("info", "Analytics plugin cleaned up");
  }
  async processRequest(_context, options) {
    const config = this.getConfig("settings");
    if (!config?.trackPerformance) return options;
    const requestId = `req_${Date.now()}_${Math.random().toString(36).substring(2)}`;
    this.requestMetrics.set(requestId, {
      startTime: Date.now(),
      options: { ...options }
    });
    options.metadata = {
      ...options.metadata,
      analyticsRequestId: requestId
    };
    this.trackEvent("api_call_start", {
      method: options.method,
      url: this.sanitizeUrl(options.url),
      request_id: requestId
    });
    return options;
  }
  async processResponse(_context, response) {
    const config = this.getConfig("settings");
    if (!config?.trackPerformance) return response;
    const requestId = response.requestId;
    const requestData = this.requestMetrics.get(requestId);
    if (requestData) {
      const duration = response.duration;
      const success = response.status >= 200 && response.status < 400;
      const metric = {
        operation: `${requestData.options.method} ${this.sanitizeUrl(requestData.options.url)}`,
        duration,
        timestamp: Date.now(),
        success,
        metadata: {
          status: response.status,
          method: requestData.options.method
        }
      };
      this.performanceMetrics.push(metric);
      this.requestMetrics.delete(requestId);
      this.trackEvent("api_call_complete", {
        method: requestData.options.method,
        url: this.sanitizeUrl(requestData.options.url),
        status: response.status,
        duration,
        success,
        request_id: requestId
      });
      this.updateCachedStats(metric);
    }
    return response;
  }
  async handleError(_context, error) {
    this.trackEvent("api_error", {
      error_type: error.constructor.name,
      error_message: error.message,
      timestamp: Date.now()
    });
    return error;
  }
  /**
   * Track custom event
   */
  trackEvent(event, properties = {}, userId) {
    const analyticsEvent = {
      event,
      timestamp: Date.now(),
      properties,
      ...userId && { userId },
      sessionId: this.sessionId
    };
    this.eventQueue.push(analyticsEvent);
    const config = this.getConfig("settings");
    if (this.eventQueue.length >= (config?.batchSize || 50)) {
      this.flushEvents();
    }
    this.log("debug", `Tracked event: ${event}`, properties);
  }
  /**
   * Get usage statistics
   */
  getUsageStats(timeRangeMs = 36e5) {
    const now = Date.now();
    const startTime = now - timeRangeMs;
    const relevantMetrics = this.performanceMetrics.filter(
      (m) => m.timestamp >= startTime
    );
    const totalRequests = relevantMetrics.length;
    const successfulRequests = relevantMetrics.filter((m) => m.success).length;
    const failedRequests = totalRequests - successfulRequests;
    const averageResponseTime = totalRequests > 0 ? relevantMetrics.reduce((sum, m) => sum + m.duration, 0) / totalRequests : 0;
    const endpointCounts = relevantMetrics.reduce((acc, m) => {
      const endpoint = m.operation;
      acc[endpoint] = (acc[endpoint] || 0) + 1;
      return acc;
    }, {});
    const topEndpoints = Object.entries(endpointCounts).sort(([, a], [, b]) => b - a).slice(0, 10).map(([endpoint, count]) => ({ endpoint, count }));
    const errorDistribution = relevantMetrics.filter((m) => !m.success).reduce((acc, m) => {
      const errorCode = m.errorCode || "unknown";
      acc[errorCode] = (acc[errorCode] || 0) + 1;
      return acc;
    }, {});
    return {
      totalRequests,
      successfulRequests,
      failedRequests,
      averageResponseTime,
      topEndpoints,
      errorDistribution,
      timeRange: { start: startTime, end: now }
    };
  }
  /**
   * Get performance metrics
   */
  getPerformanceMetrics(limit = 100) {
    return this.performanceMetrics.slice(-limit).sort((a, b) => b.timestamp - a.timestamp);
  }
  /**
   * Clear all stored data
   */
  clearData() {
    this.eventQueue = [];
    this.performanceMetrics = [];
    this.requestMetrics.clear();
    const keys = this.context?.storage.keys() || [];
    keys.forEach((key) => {
      if (key.startsWith("analytics_")) {
        this.context?.storage.delete(key);
      }
    });
    this.log("info", "Analytics data cleared");
  }
  async flushEvents() {
    if (this.eventQueue.length === 0) return;
    const events = [...this.eventQueue];
    this.eventQueue = [];
    try {
      const storageKey = `analytics_events_${Date.now()}`;
      this.setInStorage(storageKey, events);
      this.emitEvent("analytics_batch", { events, sessionId: this.sessionId });
      const config = this.getConfig("settings");
      if (config?.endpoint) {
        try {
          await this.makeRequest({
            method: "POST",
            url: config.endpoint,
            data: { events, sessionId: this.sessionId }
          });
        } catch (error) {
          this.log("warn", "Failed to send analytics to external endpoint", { error });
          this.eventQueue.unshift(...events);
        }
      }
      this.log("debug", `Flushed ${events.length} analytics events`);
    } catch (error) {
      this.log("error", "Failed to flush analytics events", { error });
      this.eventQueue.unshift(...events);
    }
  }
  updateCachedStats(metric) {
    try {
      const cached = this.getFromCache("usage_stats") || {
        totalRequests: 0,
        successfulRequests: 0,
        failedRequests: 0,
        averageResponseTime: 0,
        topEndpoints: [],
        errorDistribution: {},
        timeRange: { start: Date.now(), end: Date.now() }
      };
      cached.totalRequests++;
      if (metric.success) {
        cached.successfulRequests++;
      } else {
        cached.failedRequests++;
      }
      cached.averageResponseTime = (cached.averageResponseTime * (cached.totalRequests - 1) + metric.duration) / cached.totalRequests;
      cached.timeRange.end = Date.now();
      this.setInCache("usage_stats", cached, 3e5);
    } catch (error) {
      this.log("warn", "Failed to update cached stats", { error });
    }
  }
  generateSessionId() {
    return `session_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
  sanitizeUrl(url) {
    try {
      const urlObj = new URL(url, "https://example.com");
      urlObj.searchParams.delete("api_key");
      urlObj.searchParams.delete("token");
      urlObj.searchParams.delete("authorization");
      return urlObj.pathname + (urlObj.search || "");
    } catch {
      return url;
    }
  }
};

// src/plugins/builtin/audit-plugin.ts
init_esm_shims();
var AuditPlugin = class extends BasePlugin {
  manifest = {
    name: "audit",
    version: "1.0.0",
    description: "Comprehensive audit logging and compliance for A-Cube SDK",
    author: "A-Cube Team",
    permissions: [
      "http:read",
      "storage:read",
      "storage:write",
      "cache:read",
      "cache:write",
      "events:emit",
      "config:read",
      "config:write"
    ]
  };
  events = [];
  sessionId = "";
  currentUser;
  suspiciousActivity = /* @__PURE__ */ new Map();
  isEnabled = true;
  maxEvents = 1e4;
  retentionPeriods = {
    low: 30,
    // 30 days
    medium: 90,
    // 90 days
    high: 365,
    // 1 year
    critical: 2555
    // 7 years (Italian fiscal requirement)
  };
  async initialize(_context) {
    const config = this.getConfig("settings") || {
      enabled: true,
      maxEvents: 1e4,
      retentionPeriods: this.retentionPeriods,
      complianceMode: "standard",
      realTimeAlerts: true,
      dataPrivacy: true
    };
    this.isEnabled = config.enabled;
    this.maxEvents = config.maxEvents;
    this.retentionPeriods = { ...this.retentionPeriods, ...config.retentionPeriods };
    if (!this.isEnabled) {
      this.log("info", "Audit plugin disabled by configuration");
      return;
    }
    this.sessionId = this.generateSessionId();
    await this.loadPersistedEvents();
    setInterval(() => {
      this.cleanupExpiredEvents();
    }, 36e5);
    if (config.realTimeAlerts) {
      this.setupRealTimeMonitoring();
    }
    this.recordAuditEvent({
      type: "config",
      action: "audit_plugin_initialized",
      resource: { type: "plugin", id: "audit" },
      outcome: "success",
      details: {
        config: {
          maxEvents: this.maxEvents,
          complianceMode: config.complianceMode,
          realTimeAlerts: config.realTimeAlerts
        }
      },
      risk: "low",
      compliance: { gdpr: false, fiscal: false, internal: true }
    });
    this.log("info", "Audit plugin initialized", {
      sessionId: this.sessionId,
      maxEvents: this.maxEvents,
      complianceMode: config.complianceMode
    });
  }
  async cleanup(_context) {
    await this.persistEvents();
    const report = this.generateComplianceReport(864e5);
    this.emitEvent("compliance_report", report);
    this.recordAuditEvent({
      type: "config",
      action: "audit_plugin_shutdown",
      resource: { type: "plugin", id: "audit" },
      outcome: "success",
      details: {
        totalEvents: this.events.length,
        sessionDuration: Date.now() - (parseInt(this.sessionId.split("_")[1] || "0") || Date.now())
      },
      risk: "low",
      compliance: { gdpr: false, fiscal: false, internal: true }
    });
    this.log("info", "Audit plugin cleaned up");
  }
  async processRequest(_context, options) {
    if (!this.isEnabled) return options;
    const authorization = options.headers?.["Authorization"] || options.headers?.["authorization"];
    const userId = this.extractUserIdFromAuth(authorization);
    this.recordAuditEvent({
      type: "request",
      action: `${options.method.toLowerCase()}_request`,
      resource: {
        type: "api_endpoint",
        path: this.sanitizePath(options.url)
      },
      outcome: "success",
      // Will be updated in response handler
      details: {
        method: options.method,
        url: this.sanitizeUrl(options.url),
        headers: this.sanitizeHeaders(options.headers),
        bodySize: options.data ? this.calculateSize(options.data) : 0,
        userAgent: options.headers?.["User-Agent"]
      },
      risk: this.assessRequestRisk(options),
      compliance: this.assessRequestCompliance(options)
    }, userId);
    options.headers = {
      ...options.headers,
      "X-Audit-Correlation-ID": this.generateCorrelationId()
    };
    return options;
  }
  async processResponse(_context, response) {
    if (!this.isEnabled) return response;
    const correlationId = response.headers?.["x-audit-correlation-id"];
    const responseConfig = response.config;
    const userId = this.extractUserIdFromAuth(responseConfig?.headers?.["Authorization"]);
    this.recordAuditEvent({
      type: "response",
      action: `${responseConfig?.method?.toLowerCase() || "unknown"}_response`,
      resource: {
        type: "api_endpoint",
        path: this.sanitizePath(responseConfig?.url || "")
      },
      outcome: response.status >= 200 && response.status < 400 ? "success" : "failure",
      details: {
        status: response.status,
        statusText: response.statusText,
        duration: response.duration,
        responseSize: this.calculateSize(response.data),
        fromCache: "fromCache" in response ? response.fromCache : false,
        correlationId
      },
      risk: this.assessResponseRisk(response),
      compliance: this.assessResponseCompliance(response)
    }, userId);
    if (response.status >= 400) {
      this.checkSuspiciousActivity(userId, response);
    }
    return response;
  }
  async handleError(_context, error) {
    if (!this.isEnabled) return error;
    this.recordAuditEvent({
      type: "error",
      action: "request_error",
      resource: {
        type: "api_endpoint",
        path: this.sanitizePath(error.config?.url || "")
      },
      outcome: "failure",
      details: {
        error: error.name,
        message: error.message,
        code: error.code,
        status: error.status,
        stack: error.stack
      },
      risk: this.assessErrorRisk(error),
      compliance: { gdpr: false, fiscal: false, internal: true }
    });
    return error;
  }
  /**
   * Record custom audit event
   */
  recordAuditEvent(event, userId) {
    const auditEvent = {
      id: this.generateEventId(),
      timestamp: Date.now(),
      actor: {
        ...userId && { userId },
        sessionId: this.sessionId,
        ...(() => {
          const ipAddress = this.getCurrentIpAddress();
          const userAgent = this.getCurrentUserAgent();
          return {
            ...ipAddress && { ipAddress },
            ...userAgent && { userAgent }
          };
        })()
      },
      retention: this.retentionPeriods[event.risk],
      ...event
    };
    this.events.push(auditEvent);
    if (this.events.length > this.maxEvents) {
      this.events = this.events.slice(-this.maxEvents);
    }
    this.emitEvent("audit_event", auditEvent);
    this.checkComplianceViolations(auditEvent);
    this.log("debug", `Audit event recorded: ${event.action}`, {
      type: event.type,
      risk: event.risk,
      outcome: event.outcome
    });
  }
  /**
   * Set current user context
   */
  setUserContext(userId, role) {
    const previousUser = this.currentUser;
    this.currentUser = { id: userId, role };
    this.recordAuditEvent({
      type: "auth",
      action: "user_context_changed",
      resource: { type: "user_session", id: userId },
      outcome: "success",
      details: {
        previousUser: previousUser?.id,
        newUser: userId,
        role
      },
      risk: "medium",
      compliance: { gdpr: true, fiscal: false, internal: true }
    });
    this.log("info", "User context set", { userId, role });
  }
  /**
   * Get audit events with filtering
   */
  getAuditEvents(filter) {
    let filteredEvents = [...this.events];
    if (filter) {
      if (filter.type) {
        filteredEvents = filteredEvents.filter((e) => filter.type.includes(e.type));
      }
      if (filter.action) {
        filteredEvents = filteredEvents.filter(
          (e) => filter.action.some((action) => e.action.includes(action))
        );
      }
      if (filter.outcome) {
        filteredEvents = filteredEvents.filter((e) => filter.outcome.includes(e.outcome));
      }
      if (filter.risk) {
        filteredEvents = filteredEvents.filter((e) => filter.risk.includes(e.risk));
      }
      if (filter.timeRange) {
        filteredEvents = filteredEvents.filter(
          (e) => e.timestamp >= filter.timeRange.start && e.timestamp <= filter.timeRange.end
        );
      }
      if (filter.userId) {
        filteredEvents = filteredEvents.filter((e) => e.actor.userId === filter.userId);
      }
      if (filter.resource) {
        filteredEvents = filteredEvents.filter(
          (e) => e.resource.type.includes(filter.resource) || e.resource.path?.includes(filter.resource)
        );
      }
      if (filter.compliance) {
        filteredEvents = filteredEvents.filter(
          (e) => filter.compliance.some((comp) => e.compliance[comp])
        );
      }
    }
    return filteredEvents.sort((a, b) => b.timestamp - a.timestamp);
  }
  /**
   * Generate compliance report
   */
  generateComplianceReport(timeRangeMs = 864e5) {
    const now = Date.now();
    const start = now - timeRangeMs;
    const periodEvents = this.getAuditEvents({
      timeRange: { start, end: now }
    });
    const events = {
      total: periodEvents.length,
      byType: this.groupBy(periodEvents, "type"),
      byRisk: this.groupBy(periodEvents, "risk"),
      byOutcome: this.groupBy(periodEvents, "outcome")
    };
    const gdprEvents = periodEvents.filter((e) => e.compliance.gdpr);
    const gdpr = {
      dataAccess: gdprEvents.filter((e) => e.action.includes("read") || e.action.includes("get")).length,
      dataModification: gdprEvents.filter((e) => e.action.includes("update") || e.action.includes("patch")).length,
      dataExport: gdprEvents.filter((e) => e.action.includes("export")).length,
      dataDelete: gdprEvents.filter((e) => e.action.includes("delete")).length
    };
    const fiscalEvents = periodEvents.filter((e) => e.compliance.fiscal);
    const fiscal = {
      receiptCreation: fiscalEvents.filter((e) => e.action.includes("create_receipt")).length,
      receiptVoid: fiscalEvents.filter((e) => e.action.includes("void_receipt")).length,
      receiptModification: fiscalEvents.filter((e) => e.action.includes("modify_receipt")).length,
      fiscalReports: fiscalEvents.filter((e) => e.action.includes("fiscal_report")).length
    };
    const securityEvents = periodEvents.filter((e) => e.type === "security" || e.risk === "critical");
    const security = {
      authFailures: securityEvents.filter((e) => e.action.includes("auth") && e.outcome === "failure").length,
      suspiciousActivity: securityEvents.filter((e) => e.action.includes("suspicious")).length,
      privilegeEscalation: securityEvents.filter((e) => e.action.includes("privilege")).length,
      dataLeaks: securityEvents.filter((e) => e.action.includes("leak") || e.action.includes("breach")).length
    };
    const violations = periodEvents.filter(
      (e) => (e.risk === "high" || e.risk === "critical") && e.outcome === "failure"
    );
    const recommendations = this.generateRecommendations(periodEvents, violations);
    return {
      period: { start, end: now },
      events,
      compliance: { gdpr, fiscal, security },
      violations,
      recommendations
    };
  }
  /**
   * Export audit data for external systems
   */
  exportAuditData(filter) {
    const events = this.getAuditEvents(filter);
    this.recordAuditEvent({
      type: "data",
      action: "audit_data_export",
      resource: { type: "audit_log" },
      outcome: "success",
      details: {
        eventCount: events.length,
        filter,
        exportFormat: "json"
      },
      risk: "medium",
      compliance: { gdpr: true, fiscal: true, internal: true }
    });
    return {
      metadata: {
        exportTime: Date.now(),
        totalEvents: events.length,
        ...filter && { filter }
      },
      events
    };
  }
  /**
   * Clear audit data (with compliance considerations)
   */
  clearAuditData(olderThan, preserveCompliance = true) {
    const cutoff = olderThan ? Date.now() - olderThan : 0;
    const initialCount = this.events.length;
    if (preserveCompliance) {
      this.events = this.events.filter((e) => {
        const retentionEnd = e.timestamp + e.retention * 24 * 60 * 60 * 1e3;
        return Date.now() < retentionEnd || e.timestamp > cutoff;
      });
    } else {
      this.events = this.events.filter((e) => e.timestamp > cutoff);
    }
    const deletedCount = initialCount - this.events.length;
    this.recordAuditEvent({
      type: "data",
      action: "audit_data_cleared",
      resource: { type: "audit_log" },
      outcome: "success",
      details: {
        deletedCount,
        preserveCompliance,
        cutoffTime: cutoff
      },
      risk: "high",
      compliance: { gdpr: true, fiscal: true, internal: true }
    });
    this.log("info", `Cleared ${deletedCount} audit events`, {
      preserveCompliance,
      remaining: this.events.length
    });
    return deletedCount;
  }
  assessRequestRisk(options) {
    if (options.url.includes("/auth") || options.url.includes("/config")) {
      return "high";
    }
    if (["POST", "PUT", "PATCH", "DELETE"].includes(options.method)) {
      return "medium";
    }
    return "low";
  }
  assessResponseRisk(response) {
    if (response.status === 401 || response.status === 403) {
      return "critical";
    }
    if (response.status >= 500) {
      return "high";
    }
    if (response.status >= 400) {
      return "medium";
    }
    return "low";
  }
  assessErrorRisk(error) {
    if (error.message.includes("unauthorized") || error.message.includes("forbidden")) {
      return "critical";
    }
    return "high";
  }
  assessRequestCompliance(options) {
    const path2 = options.url.toLowerCase();
    return {
      gdpr: path2.includes("/user") || path2.includes("/profile") || path2.includes("/data"),
      fiscal: path2.includes("/receipt") || path2.includes("/payment") || path2.includes("/fiscal"),
      internal: true
    };
  }
  assessResponseCompliance(response) {
    const path2 = response.config?.url?.toLowerCase() || "";
    return {
      gdpr: path2.includes("/user") || path2.includes("/profile") || path2.includes("/data"),
      fiscal: path2.includes("/receipt") || path2.includes("/payment") || path2.includes("/fiscal"),
      internal: true
    };
  }
  checkSuspiciousActivity(userId, response) {
    if (!userId) return;
    const key = `${userId}_failures`;
    const failures = this.suspiciousActivity.get(key) || 0;
    const newFailures = failures + 1;
    this.suspiciousActivity.set(key, newFailures);
    if (newFailures >= 5) {
      this.recordAuditEvent({
        type: "security",
        action: "suspicious_activity_detected",
        resource: { type: "user_account", id: userId },
        outcome: "warning",
        details: {
          failureCount: newFailures,
          recentStatus: response?.status,
          pattern: "multiple_auth_failures"
        },
        risk: "critical",
        compliance: { gdpr: true, fiscal: false, internal: true }
      }, userId);
    }
    setTimeout(() => {
      this.suspiciousActivity.delete(key);
    }, 9e5);
  }
  checkComplianceViolations(event) {
    const violations = [];
    if (event.compliance.gdpr && event.type === "request" && !event.actor.userId) {
      violations.push("GDPR: Data access without user identification");
    }
    if (event.compliance.fiscal && this.isOutsideBusinessHours()) {
      violations.push("Fiscal: Operation outside business hours");
    }
    if (event.risk === "critical" && !event.details) {
      violations.push("Security: Critical operation without detailed logging");
    }
    if (violations.length > 0) {
      this.recordAuditEvent({
        type: "security",
        action: "compliance_violation_detected",
        resource: event.resource,
        outcome: "warning",
        details: {
          violations,
          originalEvent: event.id
        },
        risk: "critical",
        compliance: { gdpr: true, fiscal: true, internal: true }
      });
    }
  }
  setupRealTimeMonitoring() {
    this.onEvent("audit_event", (event) => {
      if (event.risk === "critical" || event.outcome === "failure") {
        this.emitEvent("security_alert", {
          type: "real_time_alert",
          event,
          timestamp: Date.now()
        });
      }
    });
  }
  generateRecommendations(events, _violations) {
    const recommendations = [];
    const authFailures = events.filter(
      (e) => e.action.includes("auth") && e.outcome === "failure"
    ).length;
    if (authFailures > 10) {
      recommendations.push("Implement stronger authentication mechanisms (MFA, rate limiting)");
    }
    const gdprEvents = events.filter((e) => e.compliance.gdpr);
    const undocumentedGdprEvents = gdprEvents.filter((e) => !e.details || Object.keys(e.details).length === 0);
    if (undocumentedGdprEvents.length > 0) {
      recommendations.push("Enhance GDPR event documentation and data processing records");
    }
    const slowRequests = events.filter(
      (e) => e.type === "response" && e.details?.duration > 5e3
    ).length;
    if (slowRequests > events.length * 0.1) {
      recommendations.push("Review and optimize slow API endpoints affecting audit performance");
    }
    return recommendations;
  }
  generateSessionId() {
    return `audit_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
  generateEventId() {
    return `evt_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
  generateCorrelationId() {
    return `corr_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
  extractUserIdFromAuth(authorization) {
    if (!authorization) return void 0;
    try {
      const token = authorization.replace("Bearer ", "");
      const payloadPart = token.split(".")[1];
      if (!payloadPart) return void 0;
      const payload = JSON.parse(atob(payloadPart));
      return payload.sub || payload.userId;
    } catch {
      return void 0;
    }
  }
  getCurrentIpAddress() {
    return void 0;
  }
  getCurrentUserAgent() {
    return typeof navigator !== "undefined" ? navigator.userAgent : void 0;
  }
  sanitizePath(url) {
    try {
      const urlObj = new URL(url, "https://example.com");
      return urlObj.pathname;
    } catch {
      return url;
    }
  }
  sanitizeUrl(url) {
    try {
      const urlObj = new URL(url, "https://example.com");
      urlObj.searchParams.delete("api_key");
      urlObj.searchParams.delete("token");
      return urlObj.pathname + (urlObj.search || "");
    } catch {
      return url;
    }
  }
  sanitizeHeaders(headers = {}) {
    const sanitized = { ...headers };
    const sensitiveHeaders = ["authorization", "x-api-key", "cookie"];
    for (const header of sensitiveHeaders) {
      if (sanitized[header]) {
        sanitized[header] = "[REDACTED]";
      }
    }
    return sanitized;
  }
  calculateSize(data) {
    if (!data) return 0;
    try {
      return new Blob([JSON.stringify(data)]).size;
    } catch {
      return 0;
    }
  }
  groupBy(array, key) {
    return array.reduce((acc, item) => {
      const value = String(item[key]);
      acc[value] = (acc[value] || 0) + 1;
      return acc;
    }, {});
  }
  isOutsideBusinessHours() {
    const now = /* @__PURE__ */ new Date();
    const hour = now.getHours();
    const day = now.getDay();
    return hour < 9 || hour >= 17 || day === 0 || day === 6;
  }
  cleanupExpiredEvents() {
    const now = Date.now();
    const initialCount = this.events.length;
    this.events = this.events.filter((event) => {
      const retentionEnd = event.timestamp + event.retention * 24 * 60 * 60 * 1e3;
      return now < retentionEnd;
    });
    const deletedCount = initialCount - this.events.length;
    if (deletedCount > 0) {
      this.log("debug", `Cleaned up ${deletedCount} expired audit events`);
    }
  }
  async loadPersistedEvents() {
    try {
      const persistedEvents = this.getFromStorage("audit_events");
      if (persistedEvents) {
        const now = Date.now();
        this.events = persistedEvents.filter((event) => {
          const retentionEnd = event.timestamp + event.retention * 24 * 60 * 60 * 1e3;
          return now < retentionEnd;
        });
      }
      this.log("debug", "Loaded persisted audit events", {
        events: this.events.length
      });
    } catch (error) {
      this.log("warn", "Failed to load persisted audit events", { error });
    }
  }
  async persistEvents() {
    try {
      this.setInStorage("audit_events", this.events);
      this.log("debug", "Persisted audit events", {
        events: this.events.length
      });
    } catch (error) {
      this.log("warn", "Failed to persist audit events", { error });
    }
  }
};

// src/plugins/builtin/cache-plugin.ts
init_esm_shims();
var CachePlugin = class extends BasePlugin {
  manifest = {
    name: "cache",
    version: "1.0.0",
    description: "Advanced caching strategies for A-Cube SDK",
    author: "A-Cube Team",
    permissions: [
      "http:read",
      "http:write",
      "storage:read",
      "storage:write",
      "cache:read",
      "cache:write",
      "events:emit",
      "config:read",
      "config:write"
    ]
  };
  cache = /* @__PURE__ */ new Map();
  stats = {
    hits: 0,
    misses: 0,
    evictions: 0,
    totalRequests: 0
  };
  config = {
    enabled: true,
    maxSize: 1e3,
    defaultTtl: 3e5,
    strategy: "lru",
    compression: false,
    persistence: false,
    maxMemoryMB: 50,
    warmupUrls: []
  };
  warmupRules = [];
  warmupInterval;
  isEnabled = true;
  async initialize(_context) {
    this.config = this.getConfig("settings") || {
      enabled: true,
      maxSize: 1e3,
      defaultTtl: 3e5,
      // 5 minutes
      strategy: "lru",
      compression: false,
      persistence: true,
      maxMemoryMB: 50,
      warmupUrls: []
    };
    this.isEnabled = this.config.enabled;
    if (!this.isEnabled) {
      this.log("info", "Cache plugin disabled by configuration");
      return;
    }
    if (this.config.persistence) {
      await this.loadPersistedCache();
    }
    this.warmupRules = this.getConfig("warmupRules") || [];
    if (this.warmupRules.length > 0) {
      this.startCacheWarmup();
    }
    setInterval(() => {
      this.cleanupExpiredEntries();
    }, 6e4);
    this.log("info", "Cache plugin initialized", {
      strategy: this.config.strategy,
      maxSize: this.config.maxSize,
      defaultTtl: this.config.defaultTtl,
      persistence: this.config.persistence,
      warmupRules: this.warmupRules.length
    });
  }
  async cleanup(_context) {
    if (this.warmupInterval) {
      clearInterval(this.warmupInterval);
    }
    if (this.config.persistence) {
      await this.persistCache();
    }
    this.emitEvent("cache_stats", this.getCacheStats());
    this.log("info", "Cache plugin cleaned up", {
      finalEntries: this.cache.size,
      hitRate: this.calculateHitRate()
    });
  }
  async processRequest(_context, options) {
    if (!this.isEnabled || !this.shouldCache(options)) {
      return options;
    }
    const cacheKey = this.generateCacheKey(options);
    const cached = this.getCacheEntry(cacheKey);
    if (cached && !this.isExpired(cached)) {
      this.stats.hits++;
      this.stats.totalRequests++;
      cached.hits++;
      cached.lastAccessed = Date.now();
      const cachedResponse = {
        data: cached.data,
        status: 200,
        statusText: "OK",
        headers: cached.metadata?.headers || {},
        duration: 0,
        requestId: `cached_${Date.now()}`
      };
      cachedResponse.config = options;
      cachedResponse.fromCache = true;
      this.emitEvent("cache_hit", { key: cacheKey, data: cached });
      this.log("debug", `Cache HIT: ${cacheKey}`, {
        hits: cached.hits,
        age: Date.now() - cached.timestamp
      });
      options.metadata = {
        ...options.metadata,
        _cachedResponse: cachedResponse,
        _cacheKey: cacheKey
      };
    } else {
      this.stats.misses++;
      this.stats.totalRequests++;
      options.metadata = {
        ...options.metadata,
        _cacheKey: cacheKey,
        _shouldCache: true
      };
      this.log("debug", `Cache MISS: ${cacheKey}`);
    }
    return options;
  }
  async processResponse(_context, response) {
    if (!this.isEnabled) return response;
    const responseConfig = response.config;
    if (responseConfig?.metadata?._cachedResponse) {
      return responseConfig.metadata._cachedResponse;
    }
    if (responseConfig?.metadata?._shouldCache && this.shouldCacheResponse(response)) {
      const cacheKey = responseConfig.metadata._cacheKey;
      const ttl = this.determineTtl(response);
      this.setInCache(cacheKey, response.data, ttl, {
        url: responseConfig?.url,
        method: responseConfig?.method,
        status: response.status,
        headers: response.headers,
        timestamp: Date.now()
      });
      this.log("debug", `Cached response: ${cacheKey}`, {
        ttl,
        size: this.calculateSize(response.data)
      });
    }
    return response;
  }
  /**
   * Manually set cache entry
   */
  setCache(key, data, ttl, tags = []) {
    this.setInCache(key, data, ttl || this.config.defaultTtl, {}, tags);
  }
  /**
   * Get cache entry
   */
  getCache(key) {
    const entry = this.getCacheEntry(key);
    if (entry && !this.isExpired(entry)) {
      entry.hits++;
      entry.lastAccessed = Date.now();
      return entry.data;
    }
    return void 0;
  }
  /**
   * Delete cache entry
   */
  deleteCache(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this.emitEvent("cache_delete", { key });
      this.log("debug", `Cache entry deleted: ${key}`);
    }
    return deleted;
  }
  /**
   * Clear cache by tags
   */
  clearByTags(tags) {
    let cleared = 0;
    for (const [key, entry] of this.cache.entries()) {
      if (tags.some((tag) => entry.tags.includes(tag))) {
        this.cache.delete(key);
        cleared++;
      }
    }
    if (cleared > 0) {
      this.emitEvent("cache_clear", { tags, count: cleared });
      this.log("info", `Cleared ${cleared} cache entries by tags`, { tags });
    }
    return cleared;
  }
  /**
   * Clear all cache
   */
  clearAll() {
    const count = this.cache.size;
    this.cache.clear();
    this.emitEvent("cache_clear_all", { count });
    this.log("info", `Cleared all cache entries`, { count });
  }
  /**
   * Get cache statistics
   */
  getCacheStats() {
    const entries = Array.from(this.cache.values());
    const totalSize = entries.reduce((sum, entry) => sum + this.calculateSize(entry.data), 0);
    const hitRate = this.calculateHitRate();
    const topKeys = entries.sort((a, b) => b.hits - a.hits).slice(0, 10).map((entry) => ({ key: entry.key, hits: entry.hits }));
    const memoryUsage = this.calculateMemoryUsage(totalSize);
    return {
      totalEntries: this.cache.size,
      totalSize,
      hitRate,
      missRate: 1 - hitRate,
      evictionCount: this.stats.evictions,
      topKeys,
      memoryUsage
    };
  }
  /**
   * Warm cache with predefined URLs
   */
  async warmCache(urls = this.config.warmupUrls) {
    if (!this.isEnabled || urls.length === 0) return;
    this.log("info", `Starting cache warmup for ${urls.length} URLs`);
    for (const url of urls) {
      try {
        const options = {
          method: "GET",
          url,
          headers: { "X-Cache-Warmup": "true" }
        };
        await this.makeRequest(options);
        this.log("debug", `Warmed cache for: ${url}`);
      } catch (error) {
        this.log("warn", `Failed to warm cache for: ${url}`, { error });
      }
    }
    this.log("info", "Cache warmup completed");
  }
  /**
   * Set cache warmup rules
   */
  setWarmupRules(rules) {
    this.warmupRules = rules;
    this.setConfig("warmupRules", rules);
    if (this.warmupInterval) {
      clearInterval(this.warmupInterval);
    }
    if (rules.length > 0) {
      this.startCacheWarmup();
    }
    this.log("info", "Cache warmup rules updated", { count: rules.length });
  }
  /**
   * Get cache keys matching pattern
   */
  getKeysByPattern(pattern) {
    const regex = new RegExp(pattern.replace(/\*/g, ".*"));
    return Array.from(this.cache.keys()).filter((key) => regex.test(key));
  }
  /**
   * Get cache entries by tags
   */
  getEntriesByTags(tags) {
    return Array.from(this.cache.values()).filter(
      (entry) => tags.some((tag) => entry.tags.includes(tag))
    );
  }
  setInCache(key, data, ttl, metadata = {}, tags = []) {
    if (this.shouldEvict()) {
      this.evictEntries();
    }
    const entry = {
      key,
      data,
      timestamp: Date.now(),
      ttl,
      hits: 0,
      lastAccessed: Date.now(),
      tags,
      metadata
    };
    this.cache.set(key, entry);
    this.emitEvent("cache_set", { key, ttl, tags });
  }
  /**
   * Get full cache entry object
   */
  getCacheEntry(key) {
    return this.cache.get(key);
  }
  /**
   * Get cached data only (inherited method)
   */
  getFromCache(key) {
    const entry = this.cache.get(key);
    return entry?.data;
  }
  shouldCache(options) {
    if (options.method !== "GET") return false;
    if (options.headers?.["X-No-Cache"] === "true") return false;
    if (options.headers?.["X-Cache-Warmup"] === "true") return false;
    return true;
  }
  shouldCacheResponse(response) {
    if (response.status < 200 || response.status >= 300) return false;
    const cacheControl = response.headers?.["cache-control"];
    if (cacheControl?.includes("no-cache") || cacheControl?.includes("no-store")) {
      return false;
    }
    return true;
  }
  generateCacheKey(options) {
    const url = new URL(options.url, "https://example.com");
    const params = Array.from(url.searchParams.entries()).sort(([a], [b]) => a.localeCompare(b)).map(([key, value]) => `${key}=${value}`).join("&");
    return `${options.method}:${url.pathname}${params ? "?" + params : ""}`;
  }
  determineTtl(response) {
    const cacheControl = response.headers?.["cache-control"];
    if (cacheControl) {
      const maxAgeMatch = cacheControl.match(/max-age=(\d+)/);
      if (maxAgeMatch) {
        const maxAgeValue = maxAgeMatch[1];
        if (maxAgeValue) {
          return parseInt(maxAgeValue) * 1e3;
        }
      }
    }
    const expires = response.headers?.["expires"];
    if (expires) {
      const expiresTime = new Date(expires).getTime();
      const now = Date.now();
      if (expiresTime > now) {
        return expiresTime - now;
      }
    }
    return this.config.defaultTtl;
  }
  isExpired(entry) {
    return Date.now() - entry.timestamp > entry.ttl;
  }
  shouldEvict() {
    return this.cache.size >= this.config.maxSize || this.calculateMemoryUsage().percentage > 90;
  }
  evictEntries() {
    const entriesToEvict = Math.max(1, Math.floor(this.config.maxSize * 0.1));
    const entries = Array.from(this.cache.entries());
    let evicted;
    switch (this.config.strategy) {
      case "lru":
        evicted = entries.sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed).slice(0, entriesToEvict);
        break;
      case "lfu":
        evicted = entries.sort(([, a], [, b]) => a.hits - b.hits).slice(0, entriesToEvict);
        break;
      case "fifo":
      default:
        evicted = entries.sort(([, a], [, b]) => a.timestamp - b.timestamp).slice(0, entriesToEvict);
        break;
    }
    for (const [key] of evicted) {
      this.cache.delete(key);
      this.stats.evictions++;
    }
    this.emitEvent("cache_eviction", {
      strategy: this.config.strategy,
      count: evicted.length
    });
    this.log("debug", `Evicted ${evicted.length} cache entries using ${this.config.strategy} strategy`);
  }
  cleanupExpiredEntries() {
    let cleanedCount = 0;
    for (const [key, entry] of this.cache.entries()) {
      if (this.isExpired(entry)) {
        this.cache.delete(key);
        cleanedCount++;
      }
    }
    if (cleanedCount > 0) {
      this.emitEvent("cache_cleanup", { count: cleanedCount });
      this.log("debug", `Cleaned up ${cleanedCount} expired cache entries`);
    }
  }
  calculateHitRate() {
    return this.stats.totalRequests > 0 ? this.stats.hits / this.stats.totalRequests : 0;
  }
  calculateSize(data) {
    if (!data) return 0;
    try {
      return new Blob([JSON.stringify(data)]).size;
    } catch {
      return 0;
    }
  }
  calculateMemoryUsage(totalSize) {
    const used = totalSize || Array.from(this.cache.values()).reduce((sum, entry) => sum + this.calculateSize(entry.data), 0);
    const available = this.config.maxMemoryMB * 1024 * 1024;
    const percentage = available > 0 ? used / available * 100 : 0;
    return { used, available, percentage };
  }
  startCacheWarmup() {
    this.warmupInterval = setInterval(() => {
      this.executeWarmupRules();
    }, 36e5);
    setTimeout(() => this.executeWarmupRules(), 5e3);
  }
  async executeWarmupRules() {
    const now = /* @__PURE__ */ new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    const dayOfWeek = now.getDay();
    for (const rule of this.warmupRules) {
      if (this.shouldExecuteWarmupRule(rule, currentHour, currentMinute, dayOfWeek)) {
        try {
          const urls = this.getUrlsFromPattern(rule.pattern);
          await this.warmCache(urls);
        } catch (error) {
          this.log("warn", `Failed to execute warmup rule: ${rule.pattern}`, { error });
        }
      }
    }
  }
  shouldExecuteWarmupRule(rule, hour, minute, dayOfWeek) {
    if (rule.conditions) {
      if (rule.conditions.dayOfWeek && !rule.conditions.dayOfWeek.includes(dayOfWeek)) {
        return false;
      }
      if (rule.conditions.timeRange) {
        const startParts = rule.conditions.timeRange.start.split(":").map(Number);
        const endParts = rule.conditions.timeRange.end.split(":").map(Number);
        const [startHour, startMinute] = startParts;
        const [endHour, endMinute] = endParts;
        if (startHour === void 0 || startMinute === void 0 || endHour === void 0 || endMinute === void 0) {
          return false;
        }
        const currentTime = hour * 60 + minute;
        const startTime = startHour * 60 + startMinute;
        const endTime = endHour * 60 + endMinute;
        if (currentTime < startTime || currentTime > endTime) {
          return false;
        }
      }
    }
    return true;
  }
  getUrlsFromPattern(pattern) {
    if (pattern.includes("*")) {
      return this.config.warmupUrls.filter((url) => {
        const regex = new RegExp(pattern.replace(/\*/g, ".*"));
        return regex.test(url);
      });
    }
    return [pattern];
  }
  async loadPersistedCache() {
    try {
      const persistedEntries = this.getFromStorage("cache_entries");
      const persistedStats = this.getFromStorage("cache_stats");
      if (persistedEntries) {
        for (const [key, entry] of persistedEntries) {
          if (!this.isExpired(entry)) {
            this.cache.set(key, entry);
          }
        }
      }
      if (persistedStats) {
        this.stats = { ...this.stats, ...persistedStats };
      }
      this.log("debug", "Loaded persisted cache", {
        entries: this.cache.size,
        hitRate: this.calculateHitRate()
      });
    } catch (error) {
      this.log("warn", "Failed to load persisted cache", { error });
    }
  }
  async persistCache() {
    try {
      const entries = Array.from(this.cache.entries());
      this.setInStorage("cache_entries", entries);
      this.setInStorage("cache_stats", this.stats);
      this.log("debug", "Persisted cache", {
        entries: entries.length,
        hitRate: this.calculateHitRate()
      });
    } catch (error) {
      this.log("warn", "Failed to persist cache", { error });
    }
  }
};

// src/plugins/builtin/debug-plugin.ts
init_esm_shims();
var DebugPlugin = class extends BasePlugin {
  manifest = {
    name: "debug",
    version: "1.0.0",
    description: "Advanced debugging and logging for A-Cube SDK",
    author: "A-Cube Team",
    permissions: [
      "http:read",
      "storage:read",
      "storage:write",
      "cache:read",
      "cache:write",
      "events:emit",
      "config:read",
      "config:write"
    ]
  };
  events = [];
  sessions = /* @__PURE__ */ new Map();
  activeSession;
  requestCorrelations = /* @__PURE__ */ new Map();
  maxEvents = 1e3;
  isEnabled = true;
  async initialize(_context) {
    const config = this.getConfig("settings") || {
      enabled: true,
      maxEvents: 1e3,
      autoSession: true,
      logLevel: "debug",
      persistEvents: false
    };
    this.isEnabled = config.enabled;
    this.maxEvents = config.maxEvents;
    if (!this.isEnabled) {
      this.log("info", "Debug plugin disabled by configuration");
      return;
    }
    if (config.persistEvents) {
      await this.loadPersistedEvents();
    }
    if (config.autoSession) {
      this.startSession("main", { auto: true });
    }
    this.setupGlobalErrorHandler();
    this.log("info", "Debug plugin initialized", {
      maxEvents: this.maxEvents,
      autoSession: config.autoSession,
      logLevel: config.logLevel
    });
  }
  async cleanup(_context) {
    const config = this.getConfig("settings");
    if (config?.persistEvents) {
      await this.persistEvents();
    }
    if (this.activeSession) {
      this.endSession(this.activeSession);
    }
    this.log("info", "Debug plugin cleaned up");
  }
  async processRequest(_context, options) {
    if (!this.isEnabled) return options;
    const correlationId = `req_${Date.now()}_${Math.random().toString(36).substring(2)}`;
    const requestId = `${options.method}_${options.url}_${Date.now()}`;
    this.requestCorrelations.set(requestId, correlationId);
    options.headers = {
      ...options.headers,
      "X-Debug-Correlation-ID": correlationId,
      "X-Debug-Plugin": "enabled"
    };
    this.addEvent({
      id: `${correlationId}_request`,
      timestamp: Date.now(),
      type: "request",
      level: "debug",
      message: `${options.method} ${options.url}`,
      data: {
        method: options.method,
        url: this.sanitizeUrl(options.url),
        headers: this.sanitizeHeaders(options.headers),
        body: this.sanitizeBody(options.data),
        timeout: options.timeout
      },
      correlationId
    });
    options.metadata = {
      ...options.metadata,
      debugCorrelationId: correlationId
    };
    return options;
  }
  async processResponse(_context, response) {
    if (!this.isEnabled) return response;
    const correlationId = response.headers?.["x-debug-correlation-id"] || response.config?.metadata?.debugCorrelationId;
    this.addEvent({
      id: `${correlationId}_response`,
      timestamp: Date.now(),
      type: "response",
      level: response.status >= 400 ? "error" : "debug",
      message: `${response.status} ${response.statusText}`,
      data: {
        status: response.status,
        statusText: response.statusText,
        headers: this.sanitizeHeaders(response.headers),
        data: this.sanitizeResponseBody(response.data),
        duration: response.duration,
        fromCache: "fromCache" in response ? response.fromCache : false
      },
      duration: response.duration,
      correlationId
    });
    return response;
  }
  async handleError(_context, error) {
    if (!this.isEnabled) return error;
    const correlationId = error.correlationId || error.config?.metadata?.debugCorrelationId;
    this.addEvent({
      id: `${correlationId || "unknown"}_error`,
      timestamp: Date.now(),
      type: "error",
      level: "error",
      message: error.message,
      data: {
        name: error.name,
        message: error.message,
        code: error.code,
        status: error.status,
        response: error.response ? {
          status: error.response.status,
          statusText: error.response.statusText,
          data: this.sanitizeResponseBody(error.response.data)
        } : void 0
      },
      ...error.stack && { stackTrace: error.stack },
      ...correlationId && { correlationId }
    });
    return error;
  }
  /**
   * Start a debug session
   */
  startSession(name, metadata = {}) {
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(2)}`;
    const session = {
      id: sessionId,
      name,
      startTime: Date.now(),
      events: [],
      metadata
    };
    this.sessions.set(sessionId, session);
    this.activeSession = sessionId;
    this.addEvent({
      id: `${sessionId}_start`,
      timestamp: Date.now(),
      type: "log",
      level: "info",
      message: `Debug session started: ${name}`,
      data: { sessionId, metadata }
    });
    this.log("info", `Debug session started: ${name}`, { sessionId, metadata });
    return sessionId;
  }
  /**
   * End a debug session
   */
  endSession(sessionId) {
    const session = this.sessions.get(sessionId);
    if (!session) {
      this.log("warn", `Session not found: ${sessionId}`);
      return void 0;
    }
    session.endTime = Date.now();
    session.events = this.events.filter(
      (e) => e.timestamp >= session.startTime && (!session.endTime || e.timestamp <= session.endTime)
    );
    this.addEvent({
      id: `${sessionId}_end`,
      timestamp: Date.now(),
      type: "log",
      level: "info",
      message: `Debug session ended: ${session.name}`,
      data: {
        sessionId,
        duration: session.endTime - session.startTime,
        eventCount: session.events.length
      }
    });
    if (this.activeSession === sessionId) {
      delete this.activeSession;
    }
    this.log("info", `Debug session ended: ${session.name}`, {
      sessionId,
      duration: session.endTime - session.startTime,
      eventCount: session.events.length
    });
    return session;
  }
  /**
   * Add custom debug event
   */
  addDebugLog(level, message, data) {
    this.addEvent({
      id: `log_${Date.now()}_${Math.random().toString(36).substring(2)}`,
      timestamp: Date.now(),
      type: "log",
      level,
      message,
      data,
      ...this.activeSession && { correlationId: this.activeSession }
    });
  }
  /**
   * Get debug events with optional filtering
   */
  getEvents(filter) {
    let filteredEvents = [...this.events];
    if (filter) {
      if (filter.level) {
        filteredEvents = filteredEvents.filter((e) => filter.level.includes(e.level));
      }
      if (filter.type) {
        filteredEvents = filteredEvents.filter((e) => filter.type.includes(e.type));
      }
      if (filter.timeRange) {
        filteredEvents = filteredEvents.filter(
          (e) => e.timestamp >= filter.timeRange.start && e.timestamp <= filter.timeRange.end
        );
      }
      if (filter.keyword) {
        const keyword = filter.keyword.toLowerCase();
        filteredEvents = filteredEvents.filter(
          (e) => e.message.toLowerCase().includes(keyword) || JSON.stringify(e.data || {}).toLowerCase().includes(keyword)
        );
      }
      if (filter.correlationId) {
        filteredEvents = filteredEvents.filter((e) => e.correlationId === filter.correlationId);
      }
    }
    return filteredEvents.sort((a, b) => b.timestamp - a.timestamp);
  }
  /**
   * Get debug session
   */
  getSession(sessionId) {
    return this.sessions.get(sessionId);
  }
  /**
   * Get all sessions
   */
  getSessions() {
    return Array.from(this.sessions.values());
  }
  /**
   * Export debug data
   */
  exportDebugData(sessionId) {
    const session = sessionId ? this.sessions.get(sessionId) : void 0;
    const events = sessionId && session ? session.events : this.events;
    return { ...session && { session }, events };
  }
  /**
   * Clear debug data
   */
  clearDebugData(sessionId) {
    if (sessionId) {
      const session = this.sessions.get(sessionId);
      if (session) {
        this.events = this.events.filter(
          (e) => !(e.timestamp >= session.startTime && (!session.endTime || e.timestamp <= session.endTime))
        );
        this.sessions.delete(sessionId);
      }
    } else {
      this.events = [];
      this.sessions.clear();
      delete this.activeSession;
    }
    this.log("info", "Debug data cleared", { sessionId: sessionId || "all" });
  }
  /**
   * Get debug statistics
   */
  getDebugStats() {
    const eventsByType = this.events.reduce((acc, e) => {
      acc[e.type] = (acc[e.type] || 0) + 1;
      return acc;
    }, {});
    const eventsByLevel = this.events.reduce((acc, e) => {
      acc[e.level] = (acc[e.level] || 0) + 1;
      return acc;
    }, {});
    const requestEvents = this.events.filter((e) => e.type === "response" && e.duration);
    const averageRequestDuration = requestEvents.length > 0 ? requestEvents.reduce((sum, e) => sum + (e.duration || 0), 0) / requestEvents.length : 0;
    const errorEvents = this.events.filter((e) => e.level === "error").length;
    const errorRate = this.events.length > 0 ? errorEvents / this.events.length : 0;
    const activeSessions = Array.from(this.sessions.values()).filter((s) => !s.endTime).length;
    return {
      totalEvents: this.events.length,
      eventsByType,
      eventsByLevel,
      activeSessions,
      averageRequestDuration,
      errorRate
    };
  }
  addEvent(event) {
    this.events.push(event);
    if (this.events.length > this.maxEvents) {
      this.events = this.events.slice(-this.maxEvents);
    }
    this.emitEvent("debug_event", event);
    if (this.activeSession) {
      const session = this.sessions.get(this.activeSession);
      if (session && !session.endTime) {
        session.events.push(event);
      }
    }
  }
  sanitizeUrl(url) {
    try {
      const urlObj = new URL(url, "https://example.com");
      urlObj.searchParams.delete("api_key");
      urlObj.searchParams.delete("token");
      urlObj.searchParams.delete("password");
      return urlObj.pathname + (urlObj.search || "");
    } catch {
      return url;
    }
  }
  sanitizeHeaders(headers = {}) {
    const sanitized = { ...headers };
    const sensitiveHeaders = ["authorization", "x-api-key", "cookie", "set-cookie"];
    for (const header of sensitiveHeaders) {
      if (sanitized[header]) {
        sanitized[header] = "[REDACTED]";
      }
      if (sanitized[header.toLowerCase()]) {
        sanitized[header.toLowerCase()] = "[REDACTED]";
      }
    }
    return sanitized;
  }
  sanitizeBody(body) {
    if (!body) return body;
    if (typeof body === "string") {
      try {
        const parsed = JSON.parse(body);
        return this.sanitizeObject(parsed);
      } catch {
        return "[BINARY_DATA]";
      }
    }
    return this.sanitizeObject(body);
  }
  sanitizeResponseBody(body) {
    if (!body) return body;
    const bodyStr = JSON.stringify(body);
    if (bodyStr.length > 1e4) {
      return "[LARGE_RESPONSE_TRUNCATED]";
    }
    return this.sanitizeObject(body);
  }
  sanitizeObject(obj) {
    if (obj === null || typeof obj !== "object") return obj;
    if (Array.isArray(obj)) {
      return obj.map((item) => this.sanitizeObject(item));
    }
    const sanitized = {};
    const sensitiveKeys = ["password", "token", "secret", "key", "authorization", "credential"];
    for (const [key, value] of Object.entries(obj)) {
      const keyLower = key.toLowerCase();
      if (sensitiveKeys.some((sensitive) => keyLower.includes(sensitive))) {
        sanitized[key] = "[REDACTED]";
      } else {
        sanitized[key] = this.sanitizeObject(value);
      }
    }
    return sanitized;
  }
  setupGlobalErrorHandler() {
    if (typeof window !== "undefined") {
      window.addEventListener("error", (event) => {
        this.addEvent({
          id: `global_error_${Date.now()}`,
          timestamp: Date.now(),
          type: "error",
          level: "error",
          message: `Global error: ${event.message}`,
          data: {
            filename: event.filename,
            lineno: event.lineno,
            colno: event.colno,
            error: event.error?.message
          },
          stackTrace: event.error?.stack
        });
      });
      window.addEventListener("unhandledrejection", (event) => {
        this.addEvent({
          id: `unhandled_rejection_${Date.now()}`,
          timestamp: Date.now(),
          type: "error",
          level: "error",
          message: `Unhandled promise rejection: ${event.reason}`,
          data: {
            reason: event.reason
          }
        });
      });
    }
  }
  async loadPersistedEvents() {
    try {
      const persistedEvents = this.getFromStorage("events");
      const persistedSessions = this.getFromStorage("sessions");
      if (persistedEvents) {
        this.events = persistedEvents.slice(-this.maxEvents);
      }
      if (persistedSessions) {
        for (const session of persistedSessions) {
          this.sessions.set(session.id, session);
        }
      }
      this.log("debug", "Loaded persisted debug data", {
        events: this.events.length,
        sessions: this.sessions.size
      });
    } catch (error) {
      this.log("warn", "Failed to load persisted debug data", { error });
    }
  }
  async persistEvents() {
    try {
      this.setInStorage("events", this.events);
      this.setInStorage("sessions", Array.from(this.sessions.values()));
      this.log("debug", "Persisted debug data", {
        events: this.events.length,
        sessions: this.sessions.size
      });
    } catch (error) {
      this.log("warn", "Failed to persist debug data", { error });
    }
  }
};

// src/plugins/builtin/performance-plugin.ts
init_esm_shims();
var PerformancePlugin = class extends BasePlugin {
  manifest = {
    name: "performance",
    version: "1.0.0",
    description: "Monitor and optimize A-Cube SDK performance",
    author: "A-Cube Team",
    permissions: [
      "http:read",
      "storage:read",
      "storage:write",
      "cache:read",
      "cache:write",
      "events:emit",
      "config:read",
      "config:write"
    ]
  };
  metrics = [];
  alerts = [];
  budgets = [];
  requestStartTimes = /* @__PURE__ */ new Map();
  memoryMonitor;
  isEnabled = true;
  maxMetrics = 5e3;
  async initialize(_context) {
    const config = this.getConfig("settings") || {
      enabled: true,
      maxMetrics: 5e3,
      budgets: this.getDefaultBudgets(),
      memoryMonitoring: true,
      alertThresholds: {
        slowRequest: 5e3,
        // 5 seconds
        highMemory: 100 * 1024 * 1024,
        // 100MB
        errorRate: 0.05
        // 5%
      }
    };
    this.isEnabled = config.enabled;
    this.maxMetrics = config.maxMetrics;
    this.budgets = config.budgets;
    if (!this.isEnabled) {
      this.log("info", "Performance plugin disabled by configuration");
      return;
    }
    if (config.memoryMonitoring) {
      this.startMemoryMonitoring();
    }
    await this.loadPersistedMetrics();
    if (this.context?.sdk) {
      const sdk = this.context.sdk;
      this.recordMetric({
        id: `plugin_init_${Date.now()}`,
        timestamp: Date.now(),
        type: "custom",
        name: "performance_plugin_initialization",
        value: 0,
        // Plugin initialization complete
        unit: "ms",
        category: "computation",
        metadata: {
          environment: sdk.getConfig()?.environment || "unknown",
          version: "2.0.0"
        }
      });
    }
    this.log("info", "Performance plugin initialized", {
      budgets: this.budgets.length,
      memoryMonitoring: config.memoryMonitoring
    });
  }
  async cleanup(_context) {
    if (this.memoryMonitor) {
      clearInterval(this.memoryMonitor);
    }
    await this.persistMetrics();
    const report = this.generateReport(36e5);
    this.emitEvent("performance_report", report);
    this.log("info", "Performance plugin cleaned up");
  }
  async processRequest(_context, options) {
    if (!this.isEnabled) return options;
    const requestId = `${options.method}_${options.url}_${Date.now()}`;
    this.requestStartTimes.set(requestId, performance.now());
    options.headers = {
      ...options.headers,
      "X-Performance-Tracking": "enabled",
      "X-Request-Start": Date.now().toString()
    };
    if (options.data) {
      const bodySize = this.calculateSize(options.data);
      this.recordMetric({
        id: `request_size_${Date.now()}`,
        timestamp: Date.now(),
        type: "request",
        name: "request_size",
        value: bodySize,
        unit: "bytes",
        category: "network",
        metadata: {
          method: options.method,
          url: this.sanitizeUrl(options.url)
        }
      });
    }
    return options;
  }
  async processResponse(_context, response) {
    if (!this.isEnabled) return response;
    const requestId = Object.keys(Object.fromEntries(this.requestStartTimes)).find((key) => key.includes(response.config?.url || ""));
    if (requestId) {
      const startTime = this.requestStartTimes.get(requestId);
      if (startTime) {
        const duration = performance.now() - startTime;
        this.requestStartTimes.delete(requestId);
        this.recordMetric({
          id: `request_duration_${Date.now()}`,
          timestamp: Date.now(),
          type: "request",
          name: "request_duration",
          value: duration,
          unit: "ms",
          category: "network",
          metadata: {
            method: response.config?.method,
            url: this.sanitizeUrl(response.config?.url || ""),
            status: response.status,
            fromCache: response.fromCache
          },
          tags: [
            response.status >= 400 ? "error" : "success",
            response.fromCache ? "cached" : "fresh"
          ]
        });
        this.checkBudgets("request_duration", duration, "ms");
        const responseSize = this.calculateSize(response.data);
        this.recordMetric({
          id: `response_size_${Date.now()}`,
          timestamp: Date.now(),
          type: "request",
          name: "response_size",
          value: responseSize,
          unit: "bytes",
          category: "network",
          metadata: {
            method: response.config?.method,
            url: this.sanitizeUrl(response.config?.url || ""),
            status: response.status
          }
        });
      }
    }
    return response;
  }
  async handleError(_context, error) {
    if (!this.isEnabled) return error;
    this.recordMetric({
      id: `error_${Date.now()}`,
      timestamp: Date.now(),
      type: "custom",
      name: "request_error",
      value: 1,
      unit: "count",
      category: "network",
      metadata: {
        error: error.name,
        message: error.message,
        status: error.status
      },
      tags: ["error"]
    });
    return error;
  }
  /**
   * Record a custom performance metric
   */
  recordMetric(metric) {
    const fullMetric = {
      id: metric.id || `custom_${Date.now()}_${Math.random().toString(36).substring(2)}`,
      timestamp: metric.timestamp || Date.now(),
      ...metric
    };
    this.metrics.push(fullMetric);
    if (this.metrics.length > this.maxMetrics) {
      this.metrics = this.metrics.slice(-this.maxMetrics);
    }
    this.checkBudgets(fullMetric.name, fullMetric.value, fullMetric.unit);
    this.emitEvent("performance_metric", fullMetric);
    this.log("debug", `Recorded metric: ${fullMetric.name}`, fullMetric);
  }
  /**
   * Set performance budgets
   */
  setBudgets(budgets) {
    this.budgets = budgets;
    this.setConfig("budgets", budgets);
    this.log("info", "Performance budgets updated", { count: budgets.length });
  }
  /**
   * Get performance metrics with optional filtering
   */
  getMetrics(filter) {
    let filteredMetrics = [...this.metrics];
    if (filter) {
      if (filter.type) {
        filteredMetrics = filteredMetrics.filter((m) => filter.type.includes(m.type));
      }
      if (filter.category) {
        filteredMetrics = filteredMetrics.filter((m) => filter.category.includes(m.category));
      }
      if (filter.timeRange) {
        filteredMetrics = filteredMetrics.filter(
          (m) => m.timestamp >= filter.timeRange.start && m.timestamp <= filter.timeRange.end
        );
      }
      if (filter.name) {
        filteredMetrics = filteredMetrics.filter((m) => m.name.includes(filter.name));
      }
      if (filter.tags) {
        filteredMetrics = filteredMetrics.filter(
          (m) => filter.tags.some((tag) => m.tags?.includes(tag))
        );
      }
    }
    return filteredMetrics.sort((a, b) => b.timestamp - a.timestamp);
  }
  /**
   * Get performance alerts
   */
  getAlerts(level) {
    let alerts = [...this.alerts];
    if (level) {
      alerts = alerts.filter((a) => a.level === level);
    }
    return alerts.sort((a, b) => b.timestamp - a.timestamp);
  }
  /**
   * Generate performance report
   */
  generateReport(timeRangeMs = 36e5) {
    const now = Date.now();
    const start = now - timeRangeMs;
    const periodMetrics = this.getMetrics({
      timeRange: { start, end: now }
    });
    const requestMetrics = periodMetrics.filter((m) => m.name === "request_duration");
    const requestDurations = requestMetrics.map((m) => m.value).sort((a, b) => a - b);
    const requests = {
      total: requestMetrics.length,
      average: requestDurations.length > 0 ? requestDurations.reduce((a, b) => a + b, 0) / requestDurations.length : 0,
      p50: this.percentile(requestDurations, 50),
      p95: this.percentile(requestDurations, 95),
      p99: this.percentile(requestDurations, 99),
      slowest: requestMetrics.sort((a, b) => b.value - a.value).slice(0, 5)
    };
    const memoryMetrics = periodMetrics.filter((m) => m.name === "memory_usage");
    const memoryValues = memoryMetrics.map((m) => m.value);
    const memory = {
      peak: memoryValues.length > 0 ? Math.max(...memoryValues) : 0,
      average: memoryValues.length > 0 ? memoryValues.reduce((a, b) => a + b, 0) / memoryValues.length : 0,
      trend: this.calculateTrend(memoryValues)
    };
    const recentAlerts = this.alerts.filter((a) => a.timestamp >= start);
    const budgets = {
      passed: this.budgets.length - recentAlerts.filter((a) => a.level === "warning" || a.level === "critical").length,
      warnings: recentAlerts.filter((a) => a.level === "warning").length,
      critical: recentAlerts.filter((a) => a.level === "critical").length
    };
    const recommendations = this.generateRecommendations(periodMetrics, recentAlerts);
    return {
      period: { start, end: now },
      metrics: { requests, memory, budgets },
      alerts: recentAlerts,
      recommendations
    };
  }
  /**
   * Clear performance data
   */
  clearData(olderThan) {
    if (olderThan) {
      const cutoff = Date.now() - olderThan;
      this.metrics = this.metrics.filter((m) => m.timestamp > cutoff);
      this.alerts = this.alerts.filter((a) => a.timestamp > cutoff);
    } else {
      this.metrics = [];
      this.alerts = [];
    }
    this.log("info", "Performance data cleared", { olderThan });
  }
  /**
   * Get current performance summary
   */
  getPerformanceSummary() {
    const recentMetrics = this.getMetrics({
      timeRange: { start: Date.now() - 3e5, end: Date.now() }
      // Last 5 minutes
    });
    const requestMetrics = recentMetrics.filter((m) => m.name === "request_duration");
    const errorMetrics = recentMetrics.filter((m) => m.tags?.includes("error"));
    const memoryMetrics = recentMetrics.filter((m) => m.name === "memory_usage");
    const averageRequestTime = requestMetrics.length > 0 ? requestMetrics.reduce((sum, m) => sum + m.value, 0) / requestMetrics.length : 0;
    const errorRate = recentMetrics.length > 0 ? errorMetrics.length / recentMetrics.length : 0;
    const memoryUsage = memoryMetrics.length > 0 ? memoryMetrics[memoryMetrics.length - 1]?.value || 0 : 0;
    return {
      totalMetrics: this.metrics.length,
      activeAlerts: this.alerts.filter((a) => a.timestamp > Date.now() - 36e5).length,
      averageRequestTime,
      errorRate,
      memoryUsage
    };
  }
  checkBudgets(metricName, value, unit) {
    const budget = this.budgets.find((b) => b.metric === metricName && b.unit === unit);
    if (!budget) return;
    let alertLevel = null;
    let threshold = 0;
    if (value >= budget.critical) {
      alertLevel = "critical";
      threshold = budget.critical;
    } else if (value >= budget.warning) {
      alertLevel = "warning";
      threshold = budget.warning;
    }
    if (alertLevel) {
      const alert2 = {
        id: `alert_${Date.now()}_${Math.random().toString(36).substring(2)}`,
        timestamp: Date.now(),
        level: alertLevel,
        metric: metricName,
        threshold,
        actualValue: value,
        message: `${metricName} exceeded ${alertLevel} threshold: ${value}${unit} > ${threshold}${unit}`,
        recommendation: this.getBudgetRecommendation(metricName, budget.category)
      };
      this.alerts.push(alert2);
      this.emitEvent("performance_alert", alert2);
      this.log(alertLevel === "critical" ? "error" : "warn", alert2.message, alert2);
    }
  }
  startMemoryMonitoring() {
    if (typeof window !== "undefined" && "performance" in window && "memory" in performance) {
      this.memoryMonitor = setInterval(() => {
        const memory = performance.memory;
        if (memory) {
          this.recordMetric({
            type: "memory",
            name: "memory_usage",
            value: memory.usedJSHeapSize,
            unit: "bytes",
            category: "memory",
            metadata: {
              totalJSHeapSize: memory.totalJSHeapSize,
              jsHeapSizeLimit: memory.jsHeapSizeLimit
            }
          });
        }
      }, 5e3);
    }
  }
  getDefaultBudgets() {
    return [
      { metric: "request_duration", warning: 1e3, critical: 3e3, unit: "ms", category: "network" },
      { metric: "response_size", warning: 1024 * 1024, critical: 5 * 1024 * 1024, unit: "bytes", category: "network" },
      { metric: "memory_usage", warning: 50 * 1024 * 1024, critical: 100 * 1024 * 1024, unit: "bytes", category: "memory" }
    ];
  }
  calculateSize(data) {
    if (!data) return 0;
    if (typeof data === "string") {
      return new Blob([data]).size;
    }
    try {
      return new Blob([JSON.stringify(data)]).size;
    } catch {
      return 0;
    }
  }
  sanitizeUrl(url) {
    try {
      const urlObj = new URL(url, "https://example.com");
      urlObj.searchParams.delete("api_key");
      urlObj.searchParams.delete("token");
      return urlObj.pathname;
    } catch {
      return url;
    }
  }
  percentile(values, p) {
    if (values.length === 0) return 0;
    const index = Math.ceil(values.length * p / 100) - 1;
    return values[Math.max(0, index)] || 0;
  }
  calculateTrend(values) {
    if (values.length < 2) return "stable";
    const first = values.slice(0, Math.ceil(values.length / 3));
    const last = values.slice(-Math.ceil(values.length / 3));
    const firstAvg = first.reduce((a, b) => a + b, 0) / first.length;
    const lastAvg = last.reduce((a, b) => a + b, 0) / last.length;
    const change = (lastAvg - firstAvg) / firstAvg;
    if (change > 0.1) return "increasing";
    if (change < -0.1) return "decreasing";
    return "stable";
  }
  generateRecommendations(metrics, alerts) {
    const recommendations = [];
    const slowRequests = metrics.filter((m) => m.name === "request_duration" && m.value > 2e3);
    if (slowRequests.length > 0) {
      recommendations.push("Consider implementing request caching for slow endpoints");
      recommendations.push("Review API payload sizes and optimize data transfer");
    }
    const memoryAlerts = alerts.filter((a) => a.metric === "memory_usage");
    if (memoryAlerts.length > 0) {
      recommendations.push("Monitor for memory leaks and optimize object lifecycle");
      recommendations.push("Consider implementing pagination for large datasets");
    }
    const errorMetrics = metrics.filter((m) => m.tags?.includes("error"));
    if (errorMetrics.length > metrics.length * 0.05) {
      recommendations.push("Implement retry logic for failed requests");
      recommendations.push("Review error handling and add circuit breakers");
    }
    return recommendations;
  }
  getBudgetRecommendation(metric, category) {
    const recommendations = {
      network: {
        request_duration: "Consider implementing caching, optimizing API calls, or adding request deduplication",
        response_size: "Implement response compression, reduce payload size, or use pagination"
      },
      memory: {
        memory_usage: "Review object lifecycle, implement garbage collection optimization, or reduce memory footprint"
      },
      computation: {
        default: "Optimize algorithms, reduce computational complexity, or implement background processing"
      }
    };
    return recommendations[category]?.[metric] || recommendations[category]?.default || "Review and optimize this metric";
  }
  async loadPersistedMetrics() {
    try {
      const persistedMetrics = this.getFromStorage("metrics");
      const persistedAlerts = this.getFromStorage("alerts");
      if (persistedMetrics) {
        this.metrics = persistedMetrics.slice(-this.maxMetrics);
      }
      if (persistedAlerts) {
        this.alerts = persistedAlerts;
      }
      this.log("debug", "Loaded persisted performance data", {
        metrics: this.metrics.length,
        alerts: this.alerts.length
      });
    } catch (error) {
      this.log("warn", "Failed to load persisted performance data", { error });
    }
  }
  async persistMetrics() {
    try {
      this.setInStorage("metrics", this.metrics);
      this.setInStorage("alerts", this.alerts);
      this.log("debug", "Persisted performance data", {
        metrics: this.metrics.length,
        alerts: this.alerts.length
      });
    } catch (error) {
      this.log("warn", "Failed to persist performance data", { error });
    }
  }
};

// src/quality/index.ts
init_esm_shims();

// src/quality/pre-commit.ts
init_esm_shims();
var PreCommitManager = class {
  config;
  hooks = /* @__PURE__ */ new Map();
  cache = /* @__PURE__ */ new Map();
  constructor(config) {
    this.config = {
      enabled: true,
      failFast: false,
      parallel: true,
      timeoutMs: 3e5,
      // 5 minutes
      checks: {
        lint: { enabled: true, severity: "error", autofix: true, timeout: 6e4 },
        format: { enabled: true, severity: "warning", autofix: true, timeout: 3e4 },
        typecheck: { enabled: true, severity: "error", autofix: false, timeout: 12e4 },
        test: { enabled: true, severity: "error", autofix: false, timeout: 18e4 },
        security: { enabled: true, severity: "error", autofix: false, timeout: 9e4 },
        dependencies: { enabled: true, severity: "warning", autofix: false, timeout: 6e4 },
        commitMessage: { enabled: true, severity: "warning", autofix: false, timeout: 5e3 },
        fileSize: { enabled: true, severity: "warning", autofix: false, timeout: 1e4 }
      },
      notifications: {},
      ...config
    };
    this.initializeDefaultHooks();
  }
  /**
   * Register custom quality hook
   */
  registerHook(name, hook) {
    this.hooks.set(name, hook);
  }
  /**
   * Run all pre-commit checks
   */
  async runPreCommitChecks(stagedFiles) {
    if (!this.config.enabled) {
      return {
        isValid: true,
        score: 100,
        issues: [],
        suggestions: [],
        bypassable: false
      };
    }
    const startTime = Date.now();
    const results = [];
    const enabledChecks = Object.entries(this.config.checks).filter(([_, config]) => config.enabled).map(([name, config]) => ({ name, config }));
    try {
      if (this.config.parallel && !this.config.failFast) {
        const promises = enabledChecks.map(
          ({ name, config }) => this.runQualityCheck(name, config, stagedFiles)
        );
        const checkResults = await Promise.allSettled(promises);
        checkResults.forEach((result, index) => {
          if (result.status === "fulfilled") {
            results.push(result.value);
          } else {
            results.push({
              check: enabledChecks[index]?.name || "unknown",
              status: "fail",
              duration: 0,
              details: {
                filesChecked: 0,
                issues: [{
                  file: "system",
                  rule: "execution_error",
                  severity: "error",
                  message: result.reason?.message || "Check execution failed",
                  fixable: false,
                  category: "lint"
                }],
                autoFixed: 0,
                warnings: []
              }
            });
          }
        });
      } else {
        for (const { name, config } of enabledChecks) {
          const result = await this.runQualityCheck(name, config, stagedFiles);
          results.push(result);
          if (this.config.failFast && result.status === "fail" && config.severity === "error") {
            break;
          }
        }
      }
      const validation = this.calculateCommitValidation(results);
      this.cacheResults(results);
      if (!validation.isValid || validation.issues.length > 0) {
        await this.sendNotifications(validation, results);
      }
      this.logQualitySummary(results, Date.now() - startTime);
      return validation;
    } catch (error) {
      return {
        isValid: false,
        score: 0,
        issues: [{
          file: "system",
          rule: "pre_commit_error",
          severity: "error",
          message: error instanceof Error ? error.message : "Unknown error",
          fixable: false,
          category: "lint"
        }],
        suggestions: ["Check pre-commit configuration", "Verify tool availability"],
        bypassable: false
      };
    }
  }
  /**
   * Auto-fix issues where possible
   */
  async autoFixIssues(stagedFiles) {
    let totalFixed = 0;
    const remainingIssues = [];
    for (const [checkName, config] of Object.entries(this.config.checks)) {
      if (!config.enabled || !config.autofix) continue;
      const hook = this.hooks.get(checkName);
      if (!hook?.autofix) continue;
      try {
        const result = await hook.autofix(stagedFiles, config);
        totalFixed += result.fixed;
        remainingIssues.push(...result.remaining);
      } catch (error) {
        console.warn(`Auto-fix failed for ${checkName}:`, error);
      }
    }
    return { fixed: totalFixed, remaining: remainingIssues };
  }
  /**
   * Validate commit message format
   */
  validateCommitMessage(message) {
    const issues = [];
    const patterns = {
      conventional: /^(feat|fix|docs|style|refactor|test|chore|ci|perf|build|revert)(\(.+\))?: .{1,50}/,
      length: /^.{1,72}$/,
      capitalization: /^[A-Z]/
    };
    if (!patterns.conventional.test(message)) {
      issues.push({
        file: "commit-message",
        rule: "conventional-commits",
        severity: "warning",
        message: "Commit message should follow conventional commits format",
        fixable: false,
        category: "style"
      });
    }
    const firstLine = message.split("\n")[0] || "";
    if (!patterns.length.test(firstLine)) {
      issues.push({
        file: "commit-message",
        rule: "message-length",
        severity: "warning",
        message: "Commit message first line should be 1-72 characters",
        fixable: false,
        category: "style"
      });
    }
    return {
      check: "commitMessage",
      status: issues.length === 0 ? "pass" : "warning",
      duration: 0,
      details: {
        filesChecked: 1,
        issues,
        autoFixed: 0,
        warnings: []
      }
    };
  }
  /**
   * Check file sizes
   */
  async checkFileSizes(files) {
    const issues = [];
    const maxSizes = {
      ".js": 100 * 1024,
      // 100KB
      ".ts": 100 * 1024,
      // 100KB
      ".tsx": 100 * 1024,
      // 100KB
      ".jsx": 100 * 1024,
      // 100KB
      ".json": 10 * 1024,
      // 10KB
      ".md": 50 * 1024
      // 50KB
    };
    for (const file of files) {
      try {
        const fs = await import("fs");
        const stats = await fs.promises.stat(file);
        const ext = file.substring(file.lastIndexOf("."));
        const maxSize = maxSizes[ext];
        if (maxSize && stats.size > maxSize) {
          issues.push({
            file,
            rule: "file-size",
            severity: "warning",
            message: `File size ${Math.round(stats.size / 1024)}KB exceeds limit ${Math.round(maxSize / 1024)}KB`,
            fixable: false,
            category: "style"
          });
        }
      } catch (error) {
      }
    }
    return {
      check: "fileSize",
      status: issues.length === 0 ? "pass" : "warning",
      duration: 0,
      details: {
        filesChecked: files.length,
        issues,
        autoFixed: 0,
        warnings: []
      }
    };
  }
  /**
   * Generate quality report
   */
  generateQualityReport(results) {
    const passed = results.filter((r) => r.status === "pass").length;
    const failed = results.filter((r) => r.status === "fail").length;
    const warnings = results.filter((r) => r.status === "warning").length;
    const score = Math.round(passed / results.length * 100);
    const recommendations = [];
    if (failed > 0) {
      recommendations.push("Fix critical issues before committing");
    }
    if (warnings > 0) {
      recommendations.push("Consider addressing warnings to improve code quality");
    }
    const securityIssues = results.some(
      (r) => r.details.issues.some((i) => i.category === "security")
    );
    if (securityIssues) {
      recommendations.push("Review and fix security vulnerabilities immediately");
    }
    return {
      summary: {
        totalChecks: results.length,
        passed,
        failed,
        warnings,
        score
      },
      details: results,
      recommendations
    };
  }
  async runQualityCheck(name, config, files) {
    const startTime = Date.now();
    const hook = this.hooks.get(name);
    if (!hook) {
      return {
        check: name,
        status: "skipped",
        duration: 0,
        details: {
          filesChecked: 0,
          issues: [],
          autoFixed: 0,
          warnings: [`No hook registered for ${name}`]
        }
      };
    }
    try {
      const result = await Promise.race([
        hook.execute(files, config),
        new Promise(
          (_, reject) => setTimeout(() => reject(new Error("Timeout")), config.timeout)
        )
      ]);
      result.duration = Date.now() - startTime;
      return result;
    } catch (error) {
      return {
        check: name,
        status: "fail",
        duration: Date.now() - startTime,
        details: {
          filesChecked: files.length,
          issues: [{
            file: "system",
            rule: "execution_error",
            severity: "error",
            message: error instanceof Error ? error.message : "Unknown error",
            fixable: false,
            category: "lint"
          }],
          autoFixed: 0,
          warnings: []
        }
      };
    }
  }
  calculateCommitValidation(results) {
    const issues = [];
    const suggestions = [];
    let score = 100;
    let hasErrors = false;
    for (const result of results) {
      issues.push(...result.details.issues);
      if (result.status === "fail") {
        const errorIssues = result.details.issues.filter((i) => i.severity === "error");
        if (errorIssues.length > 0) {
          hasErrors = true;
          score -= errorIssues.length * 10;
        }
      }
      if (result.status === "warning") {
        score -= result.details.issues.length * 2;
      }
    }
    score = Math.max(0, score);
    if (hasErrors) {
      suggestions.push("Fix all error-level issues before committing");
    }
    if (issues.some((i) => i.fixable)) {
      suggestions.push("Run auto-fix to resolve fixable issues");
    }
    return {
      isValid: !hasErrors,
      score,
      issues,
      suggestions,
      bypassable: !hasErrors && issues.every((i) => i.severity !== "error")
    };
  }
  cacheResults(results) {
    const cacheKey = `quality_${Date.now()}`;
    this.cache.set(cacheKey, {
      check: "summary",
      status: results.every((r) => r.status === "pass") ? "pass" : "fail",
      duration: results.reduce((sum, r) => sum + r.duration, 0),
      details: {
        filesChecked: Math.max(...results.map((r) => r.details.filesChecked)),
        issues: results.flatMap((r) => r.details.issues),
        autoFixed: results.reduce((sum, r) => sum + r.details.autoFixed, 0),
        warnings: results.flatMap((r) => r.details.warnings)
      }
    });
    if (this.cache.size > 10) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== void 0) {
        this.cache.delete(firstKey);
      }
    }
  }
  async sendNotifications(validation, results) {
    if (!validation.isValid && this.config.notifications.slack) {
      const message = this.formatSlackMessage(validation, results);
      await this.sendSlackNotification(message);
    }
  }
  formatSlackMessage(validation, _results) {
    const errorCount = validation.issues.filter((i) => i.severity === "error").length;
    const warningCount = validation.issues.filter((i) => i.severity === "warning").length;
    return `\u{1F6A8} Pre-commit Quality Check Failed
Score: ${validation.score}/100
Errors: ${errorCount}
Warnings: ${warningCount}
Status: ${validation.isValid ? "\u2705 Passed" : "\u274C Failed"}`;
  }
  async sendSlackNotification(message) {
    console.log("Slack notification:", message);
  }
  logQualitySummary(results, duration) {
    console.log("\n\u{1F4CA} Quality Check Summary");
    console.log("\u2500".repeat(50));
    for (const result of results) {
      const icon = result.status === "pass" ? "\u2705" : result.status === "fail" ? "\u274C" : result.status === "warning" ? "\u26A0\uFE0F" : "\u23ED\uFE0F";
      console.log(`${icon} ${result.check}: ${result.status} (${result.duration}ms)`);
      if (result.details.issues.length > 0) {
        result.details.issues.forEach((issue) => {
          console.log(`   \u2514\u2500 ${issue.file}: ${issue.message}`);
        });
      }
    }
    console.log("\u2500".repeat(50));
    console.log(`Total duration: ${duration}ms`);
  }
  initializeDefaultHooks() {
    this.hooks.set("lint", {
      execute: async (files, _config) => ({
        check: "lint",
        status: "pass",
        duration: 0,
        details: { filesChecked: files.length, issues: [], autoFixed: 0, warnings: [] }
      }),
      autofix: async (_files, _config) => ({ fixed: 0, remaining: [] })
    });
    this.hooks.set("format", {
      execute: async (files, _config) => ({
        check: "format",
        status: "pass",
        duration: 0,
        details: { filesChecked: files.length, issues: [], autoFixed: 0, warnings: [] }
      }),
      autofix: async (_files, _config) => ({ fixed: 0, remaining: [] })
    });
    this.hooks.set("typecheck", {
      execute: async (files, _config) => ({
        check: "typecheck",
        status: "pass",
        duration: 0,
        details: { filesChecked: files.length, issues: [], autoFixed: 0, warnings: [] }
      })
    });
    this.hooks.set("test", {
      execute: async (files, _config) => ({
        check: "test",
        status: "pass",
        duration: 0,
        details: { filesChecked: files.length, issues: [], autoFixed: 0, warnings: [] }
      })
    });
    this.hooks.set("security", {
      execute: async (files, _config) => ({
        check: "security",
        status: "pass",
        duration: 0,
        details: { filesChecked: files.length, issues: [], autoFixed: 0, warnings: [] }
      })
    });
    this.hooks.set("dependencies", {
      execute: async (files, _config) => ({
        check: "dependencies",
        status: "pass",
        duration: 0,
        details: { filesChecked: files.length, issues: [], autoFixed: 0, warnings: [] }
      })
    });
  }
};

// src/quality/ci-cd.ts
init_esm_shims();
var CICDManager = class {
  config;
  runs = /* @__PURE__ */ new Map();
  deployments = /* @__PURE__ */ new Map();
  constructor(config) {
    this.config = {
      enabled: true,
      provider: "github",
      environment: "development",
      pipelines: {
        build: this.getDefaultBuildPipeline(),
        test: this.getDefaultTestPipeline(),
        security: this.getDefaultSecurityPipeline(),
        deploy: this.getDefaultDeployPipeline(),
        release: this.getDefaultReleasePipeline()
      },
      notifications: {},
      artifacts: {
        retention: 30,
        storage: "local",
        encryption: true
      },
      ...config
    };
  }
  /**
   * Trigger pipeline execution
   */
  async triggerPipeline(type, context) {
    if (!this.config.enabled) {
      throw new Error("CI/CD is disabled");
    }
    const pipeline = this.config.pipelines[type];
    if (!pipeline.enabled) {
      throw new Error(`Pipeline ${type} is disabled`);
    }
    if (!this.evaluateConditions(pipeline.conditions || [], context)) {
      throw new Error(`Pipeline conditions not met for ${type}`);
    }
    const runId = this.generateRunId();
    const run = {
      id: runId,
      pipelineType: type,
      status: "pending",
      trigger: context.trigger,
      branch: context.branch,
      commit: context.commit,
      startedAt: Date.now(),
      steps: pipeline.steps.map((step) => ({
        name: step.name,
        status: "pending",
        startedAt: 0,
        retryCount: 0
      })),
      artifacts: [],
      metrics: this.initializeMetrics()
    };
    this.runs.set(runId, run);
    this.executePipeline(runId, pipeline).catch((error) => {
      console.error(`Pipeline ${runId} failed:`, error);
      run.status = "failure";
      run.completedAt = Date.now();
    });
    return runId;
  }
  /**
   * Get pipeline run status
   */
  getPipelineRun(runId) {
    return this.runs.get(runId);
  }
  /**
   * List pipeline runs with filtering
   */
  listPipelineRuns(filter) {
    let runs = Array.from(this.runs.values());
    if (filter) {
      if (filter.type) {
        runs = runs.filter((r) => r.pipelineType === filter.type);
      }
      if (filter.status) {
        runs = runs.filter((r) => r.status === filter.status);
      }
      if (filter.branch) {
        runs = runs.filter((r) => r.branch === filter.branch);
      }
      if (filter.since) {
        runs = runs.filter((r) => r.startedAt >= filter.since);
      }
    }
    runs.sort((a, b) => b.startedAt - a.startedAt);
    if (filter?.limit) {
      runs = runs.slice(0, filter.limit);
    }
    return runs;
  }
  /**
   * Cancel running pipeline
   */
  async cancelPipeline(runId) {
    const run = this.runs.get(runId);
    if (!run) {
      throw new Error(`Pipeline run ${runId} not found`);
    }
    if (run.status !== "running") {
      throw new Error(`Pipeline ${runId} is not running`);
    }
    run.status = "cancelled";
    run.completedAt = Date.now();
    run.duration = run.completedAt - run.startedAt;
    await this.sendNotification("pipeline_cancelled", run);
  }
  /**
   * Deploy to environment
   */
  async deployToEnvironment(environment, deploymentConfig, artifacts) {
    const deploymentId = this.generateRunId();
    try {
      await this.validateDeployment(deploymentConfig);
      await this.executeDeploymentStrategy(deploymentConfig, artifacts);
      await this.runHealthChecks(deploymentConfig);
      this.deployments.set(deploymentId, deploymentConfig);
      await this.sendNotification("deployment_success", {
        deploymentId,
        environment,
        strategy: deploymentConfig.strategy
      });
      return deploymentId;
    } catch (error) {
      await this.sendNotification("deployment_failure", {
        deploymentId,
        environment,
        error: error instanceof Error ? error.message : "Unknown error"
      });
      throw error;
    }
  }
  /**
   * Generate CI/CD workflow files
   */
  generateWorkflowFiles() {
    const workflows = {};
    switch (this.config.provider) {
      case "github":
        workflows[".github/workflows/ci.yml"] = this.generateGitHubWorkflow();
        workflows[".github/workflows/release.yml"] = this.generateGitHubReleaseWorkflow();
        break;
      case "gitlab":
        workflows[".gitlab-ci.yml"] = this.generateGitLabWorkflow();
        break;
      case "azure":
        workflows["azure-pipelines.yml"] = this.generateAzureWorkflow();
        break;
    }
    return workflows;
  }
  /**
   * Get pipeline metrics and analytics
   */
  getPipelineMetrics(timeRange = 30 * 24 * 60 * 60 * 1e3) {
    const cutoff = Date.now() - timeRange;
    const recentRuns = Array.from(this.runs.values()).filter((r) => r.startedAt >= cutoff);
    const totalRuns = recentRuns.length;
    const successfulRuns = recentRuns.filter((r) => r.status === "success").length;
    const successRate = totalRuns > 0 ? successfulRuns / totalRuns * 100 : 0;
    const completedRuns = recentRuns.filter((r) => r.duration);
    const averageDuration = completedRuns.length > 0 ? completedRuns.reduce((sum, r) => sum + (r.duration || 0), 0) / completedRuns.length : 0;
    const failureReasons = {};
    recentRuns.filter((r) => r.status === "failure").forEach((r) => {
      const reason = this.extractFailureReason(r);
      failureReasons[reason] = (failureReasons[reason] || 0) + 1;
    });
    return {
      summary: {
        totalRuns,
        successRate,
        averageDuration,
        failureReasons
      },
      trends: {
        buildTimes: this.generateBuildTimeTrend(recentRuns),
        successRates: this.generateSuccessRateTrend(recentRuns),
        deploymentFrequency: this.generateDeploymentFrequency(recentRuns)
      },
      quality: {
        testCoverage: this.calculateAverageMetric(recentRuns, "testCoverage"),
        codeQuality: this.calculateAverageMetric(recentRuns, "codeQuality"),
        securityScore: this.calculateAverageMetric(recentRuns, "securityScore")
      }
    };
  }
  async executePipeline(runId, pipeline) {
    const run = this.runs.get(runId);
    run.status = "running";
    await this.sendNotification("pipeline_started", run);
    try {
      if (pipeline.parallel) {
        await Promise.all(
          pipeline.steps.map(
            (step, index) => this.executeStep(run, step, index)
          )
        );
      } else {
        for (let i = 0; i < pipeline.steps.length; i++) {
          const step = pipeline.steps[i];
          if (step) {
            await this.executeStep(run, step, i);
          }
          const stepResult = run.steps[i];
          if (stepResult?.status === "failure" && !step?.continueOnError) {
            throw new Error(`Step ${stepResult.name} failed`);
          }
        }
      }
      run.status = "success";
      await this.sendNotification("pipeline_success", run);
    } catch (error) {
      run.status = "failure";
      await this.sendNotification("pipeline_failure", run);
      throw error;
    } finally {
      run.completedAt = Date.now();
      run.duration = run.completedAt - run.startedAt;
    }
  }
  async executeStep(run, step, index) {
    const stepResult = run.steps[index];
    if (!stepResult) {
      throw new Error(`Step result not found at index ${index}`);
    }
    stepResult.status = "running";
    stepResult.startedAt = Date.now();
    let retries = 0;
    while (retries <= step.retries) {
      try {
        switch (step.type) {
          case "command":
            await this.executeCommand(step.command, step.environment);
            break;
          case "script":
            await this.executeScript(step.script, step.environment);
            break;
          case "docker":
            await this.executeDocker(step.dockerfile, step.environment);
            break;
          default:
            throw new Error(`Unsupported step type: ${step.type}`);
        }
        stepResult.status = "success";
        stepResult.exitCode = 0;
        break;
      } catch (error) {
        retries++;
        stepResult.retryCount = retries;
        stepResult.error = error instanceof Error ? error.message : "Unknown error";
        if (retries > step.retries) {
          stepResult.status = "failure";
          stepResult.exitCode = 1;
          break;
        }
      }
    }
    stepResult.completedAt = Date.now();
    stepResult.duration = stepResult.completedAt - stepResult.startedAt;
  }
  async executeCommand(command, env) {
    console.log(`Executing command: ${command}`, env ? `with env: ${Object.keys(env).length} vars` : "");
    await new Promise((resolve) => setTimeout(resolve, 1e3));
  }
  async executeScript(script, env) {
    console.log(`Executing script: ${script}`, env ? `with env: ${Object.keys(env).length} vars` : "");
    await new Promise((resolve) => setTimeout(resolve, 2e3));
  }
  async executeDocker(dockerfile, env) {
    console.log(`Building docker image from: ${dockerfile}`, env ? `with env: ${Object.keys(env).length} vars` : "");
    await new Promise((resolve) => setTimeout(resolve, 5e3));
  }
  evaluateConditions(conditions, context) {
    return conditions.every((condition) => {
      switch (condition.type) {
        case "branch":
          return new RegExp(condition.pattern).test(context.branch);
        case "tag":
          return new RegExp(condition.pattern).test(context.commit);
        default:
          return true;
      }
    });
  }
  async validateDeployment(config) {
    if (config.replicas < 1) {
      throw new Error("Deployment must have at least 1 replica");
    }
    if (config.healthChecks.enabled && !config.healthChecks.path) {
      throw new Error("Health check path is required when health checks are enabled");
    }
  }
  async executeDeploymentStrategy(config, artifacts) {
    switch (config.strategy) {
      case "rolling":
        await this.executeRollingDeployment(config, artifacts);
        break;
      case "blue_green":
        await this.executeBlueGreenDeployment(config, artifacts);
        break;
      case "canary":
        await this.executeCanaryDeployment(config, artifacts);
        break;
      default:
        throw new Error(`Unsupported deployment strategy: ${config.strategy}`);
    }
  }
  async executeRollingDeployment(config, artifacts) {
    console.log(`Executing rolling deployment for ${config.environment} with ${artifacts.length} artifacts...`);
    await new Promise((resolve) => setTimeout(resolve, 3e3));
  }
  async executeBlueGreenDeployment(config, artifacts) {
    console.log(`Executing blue-green deployment for ${config.environment} with ${artifacts.length} artifacts...`);
    await new Promise((resolve) => setTimeout(resolve, 5e3));
  }
  async executeCanaryDeployment(config, artifacts) {
    console.log(`Executing canary deployment for ${config.environment} with ${artifacts.length} artifacts...`);
    await new Promise((resolve) => setTimeout(resolve, 4e3));
  }
  async runHealthChecks(config) {
    if (!config.healthChecks.enabled) return;
    console.log(`Running health checks on ${config.healthChecks.path}...`);
    await new Promise((resolve) => setTimeout(resolve, 2e3));
  }
  async sendNotification(type, data) {
    console.log(`Notification [${type}]:`, data);
  }
  generateGitHubWorkflow() {
    return `name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]
    
    steps:
    - uses: actions/checkout@v4
    - name: Use Node.js \${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: \${{ matrix.node-version }}
        cache: 'npm'
    
    - run: npm ci
    - run: npm run build
    - run: npm run lint
    - run: npm run test
    - run: npm run typecheck
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      if: matrix.node-version == '20.x'`;
  }
  generateGitHubReleaseWorkflow() {
    return `name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        registry-url: 'https://registry.npmjs.org'
    
    - run: npm ci
    - run: npm run build
    - run: npm run test
    - run: npm publish
      env:
        NODE_AUTH_TOKEN: \${{ secrets.NPM_TOKEN }}`;
  }
  generateGitLabWorkflow() {
    return `stages:
  - test
  - build
  - deploy

variables:
  NODE_VERSION: "20.x"

cache:
  paths:
    - node_modules/

test:
  stage: test
  image: node:\${NODE_VERSION}
  script:
    - npm ci
    - npm run lint
    - npm run test
    - npm run typecheck
  coverage: '/Lines\\s*:\\s*(\\d+\\.?\\d*)%/'

build:
  stage: build
  image: node:\${NODE_VERSION}
  script:
    - npm ci
    - npm run build
  artifacts:
    paths:
      - dist/`;
  }
  generateAzureWorkflow() {
    return `trigger:
- main
- develop

pool:
  vmImage: 'ubuntu-latest'

variables:
  nodeVersion: '20.x'

steps:
- task: NodeTool@0
  inputs:
    versionSpec: '$(nodeVersion)'
  displayName: 'Install Node.js'

- script: |
    npm ci
    npm run build
    npm run lint
    npm run test
  displayName: 'Build and Test'`;
  }
  getDefaultBuildPipeline() {
    return {
      enabled: true,
      trigger: "push",
      timeout: 30,
      retries: 1,
      parallel: false,
      steps: [
        {
          name: "Install Dependencies",
          type: "command",
          command: "npm ci",
          continueOnError: false,
          timeout: 10,
          retries: 2
        },
        {
          name: "Build",
          type: "command",
          command: "npm run build",
          continueOnError: false,
          timeout: 15,
          retries: 1
        }
      ]
    };
  }
  getDefaultTestPipeline() {
    return {
      enabled: true,
      trigger: "push",
      timeout: 20,
      retries: 1,
      parallel: true,
      steps: [
        {
          name: "Lint",
          type: "command",
          command: "npm run lint",
          continueOnError: false,
          timeout: 5,
          retries: 0
        },
        {
          name: "Type Check",
          type: "command",
          command: "npm run typecheck",
          continueOnError: false,
          timeout: 10,
          retries: 0
        },
        {
          name: "Unit Tests",
          type: "command",
          command: "npm run test",
          continueOnError: false,
          timeout: 15,
          retries: 1
        }
      ]
    };
  }
  getDefaultSecurityPipeline() {
    return {
      enabled: true,
      trigger: "push",
      timeout: 15,
      retries: 0,
      parallel: true,
      steps: [
        {
          name: "Security Audit",
          type: "command",
          command: "npm audit",
          continueOnError: true,
          timeout: 5,
          retries: 0
        },
        {
          name: "Dependency Check",
          type: "command",
          command: "npm run security:check",
          continueOnError: true,
          timeout: 10,
          retries: 0
        }
      ]
    };
  }
  getDefaultDeployPipeline() {
    return {
      enabled: false,
      trigger: "manual",
      timeout: 60,
      retries: 0,
      parallel: false,
      steps: [
        {
          name: "Deploy to Staging",
          type: "deploy",
          continueOnError: false,
          timeout: 30,
          retries: 1
        }
      ]
    };
  }
  getDefaultReleasePipeline() {
    return {
      enabled: false,
      trigger: "manual",
      timeout: 30,
      retries: 0,
      parallel: false,
      steps: [
        {
          name: "Create Release",
          type: "command",
          command: "npm run release",
          continueOnError: false,
          timeout: 20,
          retries: 0
        }
      ]
    };
  }
  initializeMetrics() {
    return {
      buildTime: 0,
      testCoverage: 0,
      codeQuality: 0,
      securityScore: 0,
      bundleSize: 0,
      performance: {
        loadTime: 0,
        memoryUsage: 0,
        cpuUsage: 0
      }
    };
  }
  generateRunId() {
    return `run_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
  extractFailureReason(run) {
    const failedStep = run.steps.find((s) => s.status === "failure");
    return failedStep?.error || "Unknown failure";
  }
  generateBuildTimeTrend(runs) {
    return runs.filter((r) => r.duration).map((r) => ({ date: r.startedAt, duration: r.duration })).sort((a, b) => a.date - b.date);
  }
  generateSuccessRateTrend(runs) {
    const grouped = /* @__PURE__ */ new Map();
    runs.forEach((r) => {
      const day = new Date(r.startedAt).toDateString();
      const stats = grouped.get(day) || { total: 0, success: 0 };
      stats.total++;
      if (r.status === "success") stats.success++;
      grouped.set(day, stats);
    });
    return Array.from(grouped.entries()).map(([day, stats]) => ({
      date: new Date(day).getTime(),
      rate: stats.success / stats.total * 100
    }));
  }
  generateDeploymentFrequency(runs) {
    const deployments = runs.filter((r) => r.pipelineType === "deploy");
    const grouped = /* @__PURE__ */ new Map();
    deployments.forEach((r) => {
      const day = new Date(r.startedAt).toDateString();
      grouped.set(day, (grouped.get(day) || 0) + 1);
    });
    return Array.from(grouped.entries()).map(([day, count]) => ({
      date: new Date(day).getTime(),
      count
    }));
  }
  calculateAverageMetric(runs, metric) {
    const values = runs.map((r) => r.metrics[metric]).filter((v) => typeof v === "number" && v > 0);
    return values.length > 0 ? values.reduce((sum, v) => sum + v, 0) / values.length : 0;
  }
};

// src/quality/dependency-management.ts
init_esm_shims();
var DependencyManager = class {
  config;
  // private _dependencies = new Map<string, DependencyInfo>();
  vulnerabilities = /* @__PURE__ */ new Map();
  updatePlans = /* @__PURE__ */ new Map();
  scanHistory = [];
  constructor(config) {
    this.config = {
      enabled: true,
      scanSchedule: "0 2 * * 1",
      // Weekly on Monday at 2 AM
      autoUpdate: {
        enabled: false,
        policy: "patch",
        excludePatterns: [],
        requireApproval: true
      },
      security: {
        scanVulnerabilities: true,
        allowedSeverities: ["low", "moderate"],
        autoFixSecurityIssues: false,
        reportingThreshold: "moderate"
      },
      license: {
        scanLicenses: true,
        allowedLicenses: ["MIT", "Apache-2.0", "BSD-3-Clause", "ISC"],
        blockedLicenses: ["GPL-3.0", "AGPL-3.0"],
        requireApproval: ["LGPL-2.1", "MPL-2.0"]
      },
      monitoring: {
        trackUsage: true,
        detectUnused: true,
        bundleSizeTracking: true,
        performanceImpact: true
      },
      ...config
    };
  }
  /**
   * Scan all dependencies for updates, vulnerabilities, and compliance
   */
  async scanDependencies() {
    if (!this.config.enabled) {
      throw new Error("Dependency management is disabled");
    }
    const startTime = Date.now();
    console.log("\u{1F50D} Starting dependency scan...");
    try {
      const packageInfo = await this.loadPackageInfo();
      const updateInfo = await this.scanForUpdates(packageInfo);
      const vulnerabilityInfo = await this.scanVulnerabilities(packageInfo);
      const licenseInfo = await this.scanLicenses(packageInfo);
      const usageInfo = await this.analyzeUsage(packageInfo);
      const recommendations = await this.generateRecommendations(
        updateInfo,
        vulnerabilityInfo,
        licenseInfo,
        usageInfo
      );
      const report = {
        timestamp: Date.now(),
        summary: {
          total: packageInfo.length,
          outdated: updateInfo.filter((d) => d.updates.current !== d.updates.latest).length,
          vulnerable: vulnerabilityInfo.filter((d) => d.security.vulnerabilities.length > 0).length,
          unused: usageInfo.filter((d) => !d.usage.imported).length,
          licenseIssues: licenseInfo.filter((d) => this.hasLicenseIssue(d)).length
        },
        dependencies: this.mergeDependencyInfo(packageInfo, updateInfo, vulnerabilityInfo, licenseInfo, usageInfo),
        vulnerabilities: Array.from(this.vulnerabilities.values()),
        recommendations,
        metrics: await this.calculateMetrics()
      };
      this.scanHistory.push(report);
      if (this.scanHistory.length > 10) {
        this.scanHistory = this.scanHistory.slice(-10);
      }
      console.log(`\u2705 Dependency scan completed in ${Date.now() - startTime}ms`);
      this.logScanSummary(report);
      return report;
    } catch (error) {
      console.error("\u274C Dependency scan failed:", error);
      throw error;
    }
  }
  /**
   * Create update plan for dependencies
   */
  async createUpdatePlan(packages, strategy = "incremental") {
    const report = await this.scanDependencies();
    const outdatedDeps = report.dependencies.filter(
      (d) => d.updates.current !== d.updates.latest && (!packages || packages.includes(d.name))
    );
    const updates = outdatedDeps.map((dep) => ({
      package: dep.name,
      from: dep.updates.current,
      to: dep.updates.latest,
      type: dep.updates.type,
      breaking: dep.updates.breaking,
      reason: this.getUpdateReason(dep)
    }));
    const plan = {
      id: this.generatePlanId(),
      createdAt: Date.now(),
      updates,
      strategy,
      testingRequired: updates.some((u) => u.type === "major" || u.breaking),
      approvalRequired: this.config.autoUpdate.requireApproval || updates.some((u) => u.breaking),
      estimatedRisk: this.calculatePlanRisk(updates)
    };
    this.updatePlans.set(plan.id, plan);
    return plan.id;
  }
  /**
   * Execute update plan
   */
  async executeUpdatePlan(planId) {
    const plan = this.updatePlans.get(planId);
    if (!plan) {
      throw new Error(`Update plan ${planId} not found`);
    }
    const updated = [];
    const failed = [];
    for (const update of plan.updates) {
      try {
        await this.updatePackage(update.package, update.to);
        updated.push(update.package);
        console.log(`\u2705 Updated ${update.package} from ${update.from} to ${update.to}`);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        failed.push({ package: update.package, error: errorMessage });
        console.error(`\u274C Failed to update ${update.package}:`, errorMessage);
      }
    }
    return {
      success: failed.length === 0,
      updated,
      failed
    };
  }
  /**
   * Fix security vulnerabilities
   */
  async fixSecurityVulnerabilities(autoApprove = false) {
    const report = await this.scanDependencies();
    const vulnerableDeps = report.dependencies.filter(
      (d) => d.security.vulnerabilities.length > 0
    );
    const fixed = [];
    const failed = [];
    const requiresManualReview = [];
    for (const dep of vulnerableDeps) {
      const criticalVulns = dep.security.vulnerabilities.filter((v) => v.severity === "critical");
      const canAutoFix = this.config.security.autoFixSecurityIssues || autoApprove;
      if (criticalVulns.length > 0 && !canAutoFix) {
        requiresManualReview.push(dep.name);
        continue;
      }
      try {
        const patchedVersion = this.findPatchedVersion(dep);
        if (patchedVersion) {
          await this.updatePackage(dep.name, patchedVersion);
          fixed.push(dep.name);
        } else {
          requiresManualReview.push(dep.name);
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        failed.push({ package: dep.name, error: errorMessage });
      }
    }
    return { fixed, failed, requiresManualReview };
  }
  /**
   * Remove unused dependencies
   */
  async removeUnusedDependencies() {
    const report = await this.scanDependencies();
    const unusedDeps = report.dependencies.filter(
      (d) => !d.usage.imported && d.type === "dependency"
    );
    const removed = [];
    const kept = [];
    for (const dep of unusedDeps) {
      if (this.shouldKeepPackage(dep)) {
        kept.push({
          package: dep.name,
          reason: this.getKeepReason(dep)
        });
        continue;
      }
      try {
        await this.removePackage(dep.name);
        removed.push(dep.name);
        console.log(`\u{1F5D1}\uFE0F Removed unused dependency: ${dep.name}`);
      } catch (error) {
        console.error(`\u274C Failed to remove ${dep.name}:`, error);
      }
    }
    return { removed, kept };
  }
  /**
   * Get dependency metrics and trends
   */
  getDependencyMetrics() {
    const latest = this.scanHistory[this.scanHistory.length - 1];
    return {
      current: latest?.metrics || {
        bundleSize: 0,
        loadTime: 0,
        securityScore: 100,
        licenseCompliance: 100
      },
      trends: {
        bundleSize: this.scanHistory.map((r) => ({
          date: r.timestamp,
          size: r.metrics.bundleSize
        })),
        vulnerabilities: this.scanHistory.map((r) => ({
          date: r.timestamp,
          count: r.summary.vulnerable
        })),
        outdated: this.scanHistory.map((r) => ({
          date: r.timestamp,
          count: r.summary.outdated
        }))
      }
    };
  }
  async loadPackageInfo() {
    return [
      {
        name: "react",
        version: "18.2.0",
        type: "dependency",
        license: "MIT",
        size: { bundled: 42e3, unpacked: 12e4 },
        usage: { imported: true, lastUsed: Date.now(), importCount: 5, files: ["src/index.ts"] },
        security: { vulnerabilities: [], riskScore: 0, lastScanned: Date.now() },
        updates: { current: "18.2.0", latest: "18.2.0", wanted: "18.2.0", type: "patch", breaking: false }
      },
      {
        name: "lodash",
        version: "4.17.20",
        type: "dependency",
        license: "MIT",
        size: { bundled: 7e4, unpacked: 28e4 },
        usage: { imported: false, lastUsed: 0, importCount: 0, files: [] },
        security: { vulnerabilities: [], riskScore: 0, lastScanned: Date.now() },
        updates: { current: "4.17.20", latest: "4.17.21", wanted: "4.17.21", type: "patch", breaking: false }
      }
    ];
  }
  async scanForUpdates(dependencies) {
    return dependencies.map((dep) => ({
      ...dep,
      updates: {
        ...dep.updates,
        // Simulate some outdated packages
        latest: dep.name === "lodash" ? "4.17.21" : dep.updates.latest
      }
    }));
  }
  async scanVulnerabilities(dependencies) {
    return dependencies;
  }
  async scanLicenses(dependencies) {
    return dependencies;
  }
  async analyzeUsage(dependencies) {
    return dependencies;
  }
  async generateRecommendations(..._dependencyArrays) {
    const recommendations = [];
    recommendations.push({
      type: "remove",
      package: "lodash",
      reason: "Package is not imported in any source files",
      impact: "low",
      breaking: false,
      effort: "low",
      benefits: ["Reduce bundle size", "Remove security surface"],
      risks: ["May be used dynamically"]
    });
    return recommendations;
  }
  mergeDependencyInfo(...arrays) {
    return arrays[0] || [];
  }
  async calculateMetrics() {
    return {
      bundleSize: 512e3,
      // 512KB
      loadTime: 250,
      // 250ms
      securityScore: 95,
      licenseCompliance: 100
    };
  }
  hasLicenseIssue(dep) {
    return this.config.license.blockedLicenses.includes(dep.license) || this.config.license.requireApproval.includes(dep.license);
  }
  getUpdateReason(dep) {
    if (dep.security.vulnerabilities.length > 0) {
      return "Security vulnerability fix";
    }
    if (dep.updates.type === "patch") {
      return "Bug fixes and improvements";
    }
    if (dep.updates.type === "minor") {
      return "New features and improvements";
    }
    return "Major version update";
  }
  calculatePlanRisk(updates) {
    const hasBreaking = updates.some((u) => u.breaking);
    const hasMajor = updates.some((u) => u.type === "major");
    if (hasBreaking || hasMajor) return "high";
    if (updates.some((u) => u.type === "minor")) return "medium";
    return "low";
  }
  async updatePackage(name, version) {
    console.log(`Updating ${name} to ${version}...`);
    await new Promise((resolve) => setTimeout(resolve, 1e3));
  }
  async removePackage(name) {
    console.log(`Removing ${name}...`);
    await new Promise((resolve) => setTimeout(resolve, 500));
  }
  findPatchedVersion(dep) {
    return dep.updates.latest;
  }
  shouldKeepPackage(dep) {
    const keepPatterns = ["@types/", "eslint-", "babel-", "webpack-"];
    return keepPatterns.some((pattern) => dep.name.includes(pattern));
  }
  getKeepReason(dep) {
    if (dep.name.startsWith("@types/")) return "TypeScript type definitions";
    if (dep.name.includes("eslint")) return "ESLint configuration";
    if (dep.name.includes("babel")) return "Babel configuration";
    if (dep.name.includes("webpack")) return "Webpack configuration";
    return "Build tool dependency";
  }
  generatePlanId() {
    return `plan_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
  logScanSummary(report) {
    console.log("\n\u{1F4CA} Dependency Scan Summary");
    console.log("\u2500".repeat(40));
    console.log(`Total dependencies: ${report.summary.total}`);
    console.log(`Outdated: ${report.summary.outdated}`);
    console.log(`Vulnerable: ${report.summary.vulnerable}`);
    console.log(`Unused: ${report.summary.unused}`);
    console.log(`License issues: ${report.summary.licenseIssues}`);
    console.log(`Security score: ${report.metrics.securityScore}/100`);
    console.log(`Bundle size: ${Math.round(report.metrics.bundleSize / 1024)}KB`);
    console.log("\u2500".repeat(40));
  }
};

// src/quality/index.ts
var QualityManager = class {
  preCommit;
  cicd;
  dependencies;
  constructor(config) {
    this.preCommit = new PreCommitManager(config?.preCommit);
    this.cicd = new CICDManager(config?.cicd);
    this.dependencies = new DependencyManager(config?.dependencies);
  }
  /**
   * Get pre-commit manager
   */
  getPreCommit() {
    return this.preCommit;
  }
  /**
   * Get CI/CD manager
   */
  getCICD() {
    return this.cicd;
  }
  /**
   * Get dependency manager
   */
  getDependencies() {
    return this.dependencies;
  }
  /**
   * Initialize quality automation with default configurations
   */
  async initialize() {
    const workflowFiles = this.cicd.generateWorkflowFiles();
    await this.dependencies.scanDependencies();
    return {
      preCommitEnabled: true,
      cicdEnabled: true,
      dependenciesEnabled: true,
      workflowFiles
    };
  }
  /**
   * Run complete quality check for commit
   */
  async runQualityCheck(stagedFiles, commitMessage) {
    const recommendations = [];
    const validation = await this.preCommit.runPreCommitChecks(stagedFiles);
    const commitValidation = this.preCommit.validateCommitMessage(commitMessage);
    if (commitValidation.status !== "pass") {
      validation.issues.push(...commitValidation.details.issues);
    }
    let dependencyReport;
    const packageFilesChanged = stagedFiles.some(
      (file) => file.includes("package.json") || file.includes("package-lock.json") || file.includes("yarn.lock")
    );
    if (packageFilesChanged) {
      dependencyReport = await this.dependencies.scanDependencies();
      if (dependencyReport.summary.vulnerable > 0) {
        recommendations.push("Fix security vulnerabilities before committing");
      }
      if (dependencyReport.summary.outdated > 5) {
        recommendations.push("Consider updating outdated dependencies");
      }
    }
    if (!validation.isValid) {
      recommendations.push("Fix all quality issues before committing");
    }
    if (validation.issues.some((i) => i.fixable)) {
      recommendations.push("Run auto-fix to resolve fixable issues");
    }
    return {
      validation,
      ...dependencyReport && { dependencyReport },
      recommendations
    };
  }
  /**
   * Execute full CI/CD pipeline
   */
  async runFullPipeline(context) {
    const results = {};
    try {
      results.buildRun = await this.cicd.triggerPipeline("build", context);
      results.testRun = await this.cicd.triggerPipeline("test", context);
      results.securityRun = await this.cicd.triggerPipeline("security", context);
      if (context.branch === "main" || context.branch === "master") {
        results.deployRun = await this.cicd.triggerPipeline("deploy", context);
      }
      return results;
    } catch (error) {
      console.error("Pipeline execution failed:", error);
      throw error;
    }
  }
  /**
   * Perform automated maintenance
   */
  async performMaintenance() {
    console.log("\u{1F9F9} Starting automated maintenance...");
    const planId = await this.dependencies.createUpdatePlan(void 0, "incremental");
    const dependencyUpdates = await this.dependencies.executeUpdatePlan(planId);
    const securityFixes = await this.dependencies.fixSecurityVulnerabilities();
    const cleanup = await this.dependencies.removeUnusedDependencies();
    console.log("\u2705 Automated maintenance completed");
    return {
      dependencyUpdates: { planId, ...dependencyUpdates },
      securityFixes,
      cleanup
    };
  }
  /**
   * Generate comprehensive quality report
   */
  async generateQualityReport() {
    const dependencyMetrics = this.dependencies.getDependencyMetrics();
    const cicdMetrics = this.cicd.getPipelineMetrics();
    const dependencyReport = await this.dependencies.scanDependencies();
    const qualityScore = this.calculateQualityScore(cicdMetrics, dependencyReport);
    const securityScore = dependencyMetrics.current.securityScore;
    const maintenanceScore = this.calculateMaintenanceScore(dependencyReport);
    const recommendations = this.generateQualityRecommendations(
      qualityScore,
      securityScore,
      maintenanceScore,
      dependencyReport
    );
    return {
      overview: {
        qualityScore,
        securityScore,
        maintenanceScore,
        recommendations
      },
      preCommit: {
        checksEnabled: 8,
        // Number of enabled checks
        averageRunTime: 3e4
        // 30 seconds
      },
      cicd: {
        pipelineRuns: cicdMetrics.summary.totalRuns,
        successRate: cicdMetrics.summary.successRate,
        averageBuildTime: cicdMetrics.summary.averageDuration,
        deploymentFrequency: cicdMetrics.trends.deploymentFrequency.length
      },
      dependencies: {
        total: dependencyReport.summary.total,
        outdated: dependencyReport.summary.outdated,
        vulnerable: dependencyReport.summary.vulnerable,
        unused: dependencyReport.summary.unused,
        bundleSize: dependencyReport.metrics.bundleSize
      },
      trends: {
        qualityTrend: this.calculateTrend(cicdMetrics.trends.successRates),
        securityTrend: this.calculateTrend(dependencyMetrics.trends.vulnerabilities, true),
        performanceTrend: this.calculateTrend(dependencyMetrics.trends.bundleSize, true)
      }
    };
  }
  /**
   * Setup development environment with quality tools
   */
  async setupDevelopmentEnvironment() {
    const configFiles = {
      ".husky/pre-commit": this.generatePreCommitHook(),
      ".eslintrc.js": this.generateESLintConfig(),
      ".prettierrc": this.generatePrettierConfig(),
      "jest.config.js": this.generateJestConfig(),
      ".gitignore": this.generateGitIgnore(),
      "commitlint.config.js": this.generateCommitLintConfig()
    };
    const scripts = {
      "lint": "eslint src --ext .ts,.tsx,.js,.jsx",
      "lint:fix": "eslint src --ext .ts,.tsx,.js,.jsx --fix",
      "format": 'prettier --write "src/**/*.{ts,tsx,js,jsx,json,md}"',
      "typecheck": "tsc --noEmit",
      "test": "jest",
      "test:coverage": "jest --coverage",
      "test:watch": "jest --watch",
      "quality:check": "npm run lint && npm run typecheck && npm run test",
      "deps:audit": "npm audit",
      "deps:update": "npm update",
      "deps:outdated": "npm outdated"
    };
    const devDependencies = [
      "@typescript-eslint/eslint-plugin",
      "@typescript-eslint/parser",
      "eslint",
      "eslint-config-prettier",
      "eslint-plugin-prettier",
      "prettier",
      "husky",
      "lint-staged",
      "@commitlint/cli",
      "@commitlint/config-conventional",
      "jest",
      "@types/jest",
      "ts-jest"
    ];
    return { configFiles, scripts, devDependencies };
  }
  calculateQualityScore(cicdMetrics, dependencyReport) {
    const cicdScore = cicdMetrics.summary.successRate;
    const dependencyScore = Math.max(0, 100 - dependencyReport.summary.outdated * 2);
    const securityScore = dependencyReport.metrics.securityScore;
    return Math.round((cicdScore + dependencyScore + securityScore) / 3);
  }
  calculateMaintenanceScore(report) {
    const outdatedPenalty = report.summary.outdated * 3;
    const unusedPenalty = report.summary.unused * 2;
    const vulnerabilityPenalty = report.summary.vulnerable * 5;
    return Math.max(0, 100 - outdatedPenalty - unusedPenalty - vulnerabilityPenalty);
  }
  generateQualityRecommendations(qualityScore, securityScore, maintenanceScore, dependencyReport) {
    const recommendations = [];
    if (qualityScore < 80) {
      recommendations.push("Improve CI/CD pipeline success rate");
    }
    if (securityScore < 90) {
      recommendations.push("Address security vulnerabilities immediately");
    }
    if (maintenanceScore < 70) {
      recommendations.push("Update outdated dependencies and remove unused packages");
    }
    if (dependencyReport.summary.vulnerable > 0) {
      recommendations.push("Run automated security fixes");
    }
    if (dependencyReport.summary.unused > 5) {
      recommendations.push("Clean up unused dependencies");
    }
    if (dependencyReport.metrics.bundleSize > 1024 * 1024) {
      recommendations.push("Optimize bundle size and consider code splitting");
    }
    return recommendations;
  }
  calculateTrend(data, inverse = false) {
    if (data.length < 2) return "stable";
    const recent = data.slice(-3);
    const values = recent.map((d) => Object.values(d).find((v) => typeof v === "number" && v !== d.date));
    const trend = (values[values.length - 1] || 0) - (values[0] || 0);
    const threshold = 5;
    if (Math.abs(trend) < threshold) return "stable";
    const isImproving = inverse ? trend < 0 : trend > 0;
    return isImproving ? "improving" : "declining";
  }
  generatePreCommitHook() {
    return `#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

echo "\u{1F50D} Running pre-commit quality checks..."
npm run quality:check`;
  }
  generateESLintConfig() {
    return `module.exports = {
  parser: '@typescript-eslint/parser',
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
    'prettier',
  ],
  plugins: ['@typescript-eslint', 'prettier'],
  rules: {
    'prettier/prettier': 'error',
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
  },
  env: {
    node: true,
    es2021: true,
  },
};`;
  }
  generatePrettierConfig() {
    return JSON.stringify({
      semi: true,
      trailingComma: "es5",
      singleQuote: true,
      printWidth: 100,
      tabWidth: 2
    }, null, 2);
  }
  generateJestConfig() {
    return `module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
};`;
  }
  generateGitIgnore() {
    return `# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build outputs
dist/
build/
*.tsbuildinfo

# Environment files
.env
.env.local
.env.production

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Test coverage
coverage/

# Logs
logs/
*.log`;
  }
  generateCommitLintConfig() {
    return `module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [2, 'always', [
      'feat', 'fix', 'docs', 'style', 'refactor',
      'test', 'chore', 'ci', 'perf', 'build', 'revert'
    ]],
    'subject-max-length': [2, 'always', 72],
  },
};`;
  }
};

// src/pwa/index.ts
init_esm_shims();
init_pwa_manager();
init_manifest_generator();

// src/pwa/background-sync.ts
init_esm_shims();
init_eventemitter3();
init_unified_storage();
init_storage_factory();

// src/pwa/offline-integration.ts
init_esm_shims();
init_eventemitter3();
var DEFAULT_CONFIG17 = {
  enableMigration: true,
  receiptSync: {
    batchSize: 20,
    prioritizeLottery: true,
    fiscalTimeout: 72 * 60 * 60 * 1e3
    // 72 hours
  },
  conflictResolution: {
    preserveFiscalData: true,
    autoResolveDuplicates: true
  }
};

// src/pwa/index.ts
init_push_notifications();
init_app_installer();
init_pwa_manager();
init_manifest_generator();
init_app_installer();
var PWAUtils = {
  /**
   * Check if the app is running in standalone mode (installed as PWA)
   */
  isStandalone() {
    if (typeof window === "undefined") return false;
    return window.matchMedia("(display-mode: standalone)").matches || window.matchMedia("(display-mode: fullscreen)").matches || window.navigator.standalone === true;
  },
  /**
   * Check if PWA features are supported
   */
  isPWASupported() {
    if (typeof window === "undefined") return false;
    return "serviceWorker" in navigator && "caches" in window && "fetch" in window;
  },
  /**
   * Check if background sync is supported
   */
  isBackgroundSyncSupported() {
    if (typeof window === "undefined") return false;
    return "serviceWorker" in navigator && "sync" in window.ServiceWorkerRegistration.prototype;
  },
  /**
   * Check if push notifications are supported
   */
  isPushNotificationSupported() {
    if (typeof window === "undefined") return false;
    return "serviceWorker" in navigator && "PushManager" in window && "Notification" in window;
  },
  /**
   * Check if periodic background sync is supported
   */
  isPeriodicSyncSupported() {
    if (typeof window === "undefined") return false;
    return "serviceWorker" in navigator && "periodicSync" in window.ServiceWorkerRegistration.prototype;
  },
  /**
   * Get display mode
   */
  getDisplayMode() {
    if (typeof window === "undefined") return "browser";
    if (window.matchMedia("(display-mode: fullscreen)").matches) {
      return "fullscreen";
    }
    if (window.matchMedia("(display-mode: standalone)").matches) {
      return "standalone";
    }
    if (window.matchMedia("(display-mode: minimal-ui)").matches) {
      return "minimal-ui";
    }
    return "browser";
  },
  /**
   * Get network status
   */
  getNetworkStatus() {
    if (typeof navigator === "undefined") {
      return { online: true };
    }
    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    return {
      online: navigator.onLine,
      effectiveType: connection?.effectiveType,
      downlink: connection?.downlink,
      rtt: connection?.rtt
    };
  },
  /**
   * Estimate cache storage quota
   */
  async getStorageEstimate() {
    if (typeof navigator === "undefined" || !("storage" in navigator)) {
      return {};
    }
    try {
      const estimate = await navigator.storage.estimate();
      const quota = estimate.quota || 0;
      const usage = estimate.usage || 0;
      const usagePercentage = quota > 0 ? Math.round(usage / quota * 100) : 0;
      return {
        quota,
        usage,
        usagePercentage
      };
    } catch (error) {
      console.warn("Failed to get storage estimate:", error);
      return {};
    }
  },
  /**
   * Convert bytes to human readable format
   */
  formatBytes(bytes, decimals = 2) {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i];
  },
  /**
   * Create a debounced function
   */
  debounce(func, wait, immediate = false) {
    let timeout = null;
    return function executedFunction(...args) {
      const later = () => {
        timeout = null;
        if (!immediate) func(...args);
      };
      const callNow = immediate && !timeout;
      if (timeout) clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func(...args);
    };
  }
};
var PWA_CONSTANTS = {
  // Cache names
  STATIC_CACHE_PREFIX: "acube-static-",
  API_CACHE_PREFIX: "acube-api-",
  RUNTIME_CACHE_PREFIX: "acube-runtime-",
  // Default cache durations (in milliseconds)
  DEFAULT_API_CACHE_DURATION: 5 * 60 * 1e3,
  // 5 minutes
  DEFAULT_STATIC_CACHE_DURATION: 24 * 60 * 60 * 1e3,
  // 24 hours
  DEFAULT_RUNTIME_CACHE_DURATION: 60 * 60 * 1e3,
  // 1 hour
  // Offline queue settings
  DEFAULT_QUEUE_NAME: "acube-offline-queue",
  DEFAULT_MAX_QUEUE_SIZE: 1e3,
  DEFAULT_MAX_RETENTION_TIME: 7 * 24 * 60 * 60 * 1e3,
  // 7 days
  // Background sync settings
  DEFAULT_MIN_SYNC_INTERVAL: 15 * 60 * 1e3,
  // 15 minutes
  // Manifest defaults
  DEFAULT_THEME_COLOR: "#1976d2",
  DEFAULT_BACKGROUND_COLOR: "#ffffff",
  DEFAULT_DISPLAY_MODE: "standalone",
  DEFAULT_ORIENTATION: "portrait",
  // Service worker events
  SW_EVENTS: {
    REGISTERED: "sw:registered",
    UPDATED: "sw:updated",
    ERROR: "sw:error",
    INSTALL_AVAILABLE: "install:available",
    INSTALL_COMPLETED: "install:completed",
    CACHE_UPDATED: "cache:updated",
    OFFLINE_QUEUED: "offline:queued",
    OFFLINE_SYNCED: "offline:synced",
    PUSH_RECEIVED: "push:received",
    SYNC_COMPLETED: "sync:completed"
  },
  // Italian e-receipt specific categories
  ERECEIPT_CATEGORIES: [
    "business",
    "finance",
    "productivity",
    "utilities"
  ],
  // Recommended icon sizes for PWA
  RECOMMENDED_ICON_SIZES: [
    "72x72",
    "96x96",
    "128x128",
    "144x144",
    "152x152",
    "192x192",
    "384x384",
    "512x512"
  ],
  // Maskable icon sizes
  MASKABLE_ICON_SIZES: [
    "192x192",
    "512x512"
  ]
};

// src/index.ts
init_errors();
function initializeSandboxSDK(config = {}) {
  return createACubeSDK({
    environment: "sandbox",
    ...config
  });
}
function initializeProductionSDK(config = {}) {
  return createACubeSDK({
    environment: "production",
    ...config
  });
}
function initializeDevelopmentSDK(config = {}) {
  return createACubeSDK({
    environment: "development",
    ...config
  });
}
var SDK_VERSION = "2.0.0";
var API_VERSION = "1.0.0";
var src_default = ACubeSDK;
export {
  ACubeProvider,
  ACubeSDK,
  ACubeSDKError,
  AGGRESSIVE_RETRY_CONFIG,
  API_VERSION,
  AUTH_HTTP_CONFIG,
  AccessControlManager,
  AnalyticsPlugin,
  AuditPlugin,
  AuthProvider,
  AuthStatus,
  AuthenticationError,
  AuthenticationMiddleware,
  AuthorizationError,
  BaseOpenAPIResource,
  BatchProcessor,
  CONSERVATIVE_RETRY_CONFIG,
  CachePlugin,
  CashRegisterEndpoints,
  CashRegistersResource as CashRegisters,
  CashRegistersResource,
  CashierEndpoints,
  CashiersResource as Cashiers,
  CashiersResource,
  CircuitBreaker,
  CircuitBreakerError,
  ConfigurationError,
  ConflictResolverManager,
  ContentTypeMiddleware,
  DEFAULT_HTTP_CONFIG,
  DEFAULT_RETRY_CONFIG,
  DEFAULT_SDK_CONFIG,
  DebugPlugin,
  DependencyManager,
  EnterpriseQueueManager,
  FiscalAuditManager,
  FiscalError,
  GDPRComplianceManager,
  HttpClient,
  IndexedDBAdapter,
  LocalStorageAdapter,
  LoggingMiddleware,
  LoginForm,
  ManifestGenerator,
  MerchantEndpoints,
  MerchantsResource as Merchants,
  MerchantsResource,
  MiddlewareStack,
  NetworkError,
  NotFoundError,
  PEMEndpoints,
  PEMsResource as PEMs,
  PEMsResource,
  PWAManager,
  PWAUtils,
  PWA_CONSTANTS,
  PerformanceMiddleware,
  PerformancePlugin,
  PermissionGate,
  PluginManager,
  PointOfSalesResource as PointOfSales,
  PointOfSalesEndpoints,
  PointOfSalesResource,
  PriorityQueue,
  ProtectedRoute,
  QualityManager,
  QueueAnalytics,
  RateLimitError,
  RateLimitingMiddleware,
  ReceiptEndpoints,
  ReceiptsResource as Receipts,
  ReceiptsResource,
  RequestIdMiddleware,
  RetryHandler,
  RetryManager,
  RoleSwitcher,
  SDK_VERSION,
  STORAGE_NAMESPACES,
  StorageCapacityError,
  StorageConnectionError,
  StorageEncryptionError,
  StorageEncryptionService,
  StorageError,
  StorageFactory,
  StorageTransactionError,
  UserAgentMiddleware,
  UserProfile,
  ValidationError,
  createACubeSDK,
  createAmount,
  createCashRegisterId,
  createCashierId,
  createCompatibilityStorage,
  createDocumentNumber,
  createEncryptionService,
  createErrorFromResponse,
  createFiscalId,
  createHighPerformanceStorage,
  createMerchantId,
  createMinimalEncryptionService,
  createPEMId,
  createPointOfSaleId,
  createQuantity,
  createReceiptId,
  createSecureEncryptionService,
  createSecureStorage,
  createSerialNumber,
  createStorage,
  createStorageKey,
  createVATRate,
  src_default as default,
  getEnvironmentInfo,
  getPerformanceTier,
  getPlatform,
  getRecommendedStorageAdapter,
  hasCapability,
  initializeDevelopmentSDK,
  initializeProductionSDK,
  initializeSandboxSDK,
  isAmount,
  isCashierId,
  isFiscalId,
  isMerchantId,
  isPEMId,
  isPointOfSaleId,
  isQuantity,
  isReceiptId,
  isSerialNumber,
  platformDetector,
  storageFactory,
  useACube,
  useACubeCache,
  useACubeMutation,
  useACubeNetworkManager,
  useACubeNetworkStatus,
  useACubeOffline,
  useACubeQuery,
  useACubeQueueManager,
  useACubeSDK2 as useACubeSDK,
  useACubeStorage,
  useACubeSubscription,
  useACubeSyncEngine,
  useAuth,
  useAuthAvailable,
  useAuthContext,
  useEnhancedACubeOffline,
  useLogin,
  useLogout,
  usePermissions,
  useRequireAuth,
  useRequireRole,
  useRoles,
  useSession,
  useUser
};
/*! Bundled license information:

react/cjs/react.production.js:
  (**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.js:
  (**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=index.js.map